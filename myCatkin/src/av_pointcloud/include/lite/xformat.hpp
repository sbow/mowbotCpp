/***********************************************************************************************************
	xformat.hpp
	Copyright Saeed Alaei 2008.
	Version : 1.007
	Generated on: Fri Nov 06 02:03:11 2009

	Warning: This file is generated. If you need to make a change, modify the template.
	To generate the documentation, run Doxygen on this file.

	Permission  is hereby granted, free of charge, to any person or organization
	obtaining a copy of the software and accompanying documentation covered by
	this license (the "Software") to use, reproduce, display, distribute,
	execute, and transmit the Software, and to prepare derivative works of the
	Software, and to permit third-parties to whom the Software is furnished to
	do so, all subject to the following:

	The copyright notices in the Software and this entire statement, including
	the above license grant, this restriction and the following disclaimer,
	must be included in all copies of the Software, in whole or in part, and
	all derivative works of the Software, unless such copies or derivative
	works are solely in the form of machine-executable object code generated by
	a source language processor.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
	SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
	FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
	ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
	DEALINGS IN THE SOFTWARE.
***********************************************************************************************************/
/*!
    \ifnot COMMON
	\mainpage lite xformat

	See \ref xformat.

    \author Saeed Alaei 
    <a href="http://www.google.com/search?hl=en&q=saeed+alaei&btnI=I'm+Feeling+Lucky">(home page)</a>

    \par Copyright
	Permission is hereby granted, free of charge, to any person or organization
	obtaining a copy of the software and accompanying documentation covered by
	this license (the "Software") to use, reproduce, display, distribute,
	execute, and transmit the Software, and to prepare derivative works of the
	Software, and to permit third-parties to whom the Software is furnished to
	do so, all subject to the following:
	
    \par
	The copyright notices in the Software and this entire statement, including
	the above license grant, this restriction and the following disclaimer,
	must be included in all copies of the Software, in whole or in part, and
	all derivative works of the Software, unless such copies or derivative
	works are solely in the form of machine-executable object code generated by
	a source language processor.

	\par
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
	SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
	FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
	ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
	DEALINGS IN THE SOFTWARE.

    \endif
*/

/*! 
	\file xformat.hpp
	\defgroup xformat lite xformat - A C++ printf/scanf style IO library

	This is a header only library that provides functions for prinf/scanf style IO using iostreams. 
	It also provides tool for conversion of values to/from strings.

	\par Rationale
	The following are the design goals for xprintf() / xscanf() :
	- The syntax should be intuitive and should resemble the printf()/scanf() syntax as much as possible
		but without sacrificing usability or performance.
	- The added overhead should be as minimal as possible.
	- The format string should provide the possibility of adding user defined format fields.

	\par Performance
	In order to achieve a good performance the following has been done:
	- The creation/destruction of \c sentry objects are minimized because they usually contain 
		\c lock() / \c unlock() call to ensure thread safety.
	- Retrieving locale and facets from the streams are minimized because the functions that retrieve 
		these objects usually contain \c lock() / \c unlock() calls. To achieve this, the stream locale and 
		all the necessary facets, and locale specific characters are retained in a cache object that is 
		associated with each stream object. The cache object is updated using an stream event handler.
	- There is only one extra virtual function call per each argument. This is to allow for 
		more inlining of function calls.
	- The basic_conversion class maintains an stream object. This avoids repeated construction/destruction 
		of the stream object per each conversion and thus avoids a lot of unnecessary overhead when 
		performing a large number of conversions (e.g., when reading an input file).

	\par Benchmarks
	Using the xprintf() / xscanf() functions are about 5 times faster that using the 
	<a href="http://www.google.com/search?hl=en&q=boost+format&btnI=I'm+Feeling+Lucky">boost::format</a>
	\todo Add detailed benchmark
*/

/*!
	\defgroup xprintf xprintf Family of Functions
	\ingroup xformat
*/

/*!
	\defgroup xscanf xscanf Family of Functions
	\ingroup xformat
*/

/*!
	\defgroup conversion String Conversion
	\ingroup xformat
*/

/*!
	\defgroup exceptions Exceptions
	\ingroup xformat
*/


#ifndef LITE_XFORMAT_HPP
#define LITE_XFORMAT_HPP

#ifdef _MSC_VER
#pragma warning (push)
#pragma warning (disable:4996)
#endif

#ifndef __LINE__ // true when Doxygen is processing the file
#define DOCUMENTATION_ONLY
#endif 

#define LITE_XFORMAT_VERSION 1007

#include <locale>
#include <iostream>
#include <sstream>
#include <stdexcept>
#include <typeinfo>

#ifndef LITE_ASSERT
#define LITE_ASSERT(x) 
#define LITE_ASSERT_LOCAL 1
#endif // LITE_ASSERT

namespace lite
{

class format_error;
class argument_index_error;
class input_mismatch_error;
class conversion_error;

template<
    typename _char_type =char, 
    typename _traits_type =std::char_traits<_char_type>, 
    typename _alloc_type =std::allocator<_char_type> >
class basic_conversion;

/*! \ingroup conversion */
typedef basic_conversion<char> conversion;

/*! \ingroup conversion */
typedef basic_conversion<wchar_t> wconversion;

/***********************************************************************************************************/
/* xprintf family ******************************************************************************************/
/***********************************************************************************************************/

/*!
	\defgroup xprintf xprintf Family of Functions
	\ingroup xformat
	prints the arguments using the specified format string.

	These functions use a printf style format string which can use both Standard and Extended format fields.
	In both cases, each argument is printed by a call to an appropriate overload of xprintf_one() function.

	\par Standard Format Field
	The standard format has the following pattern:

	<b>%[arg_pos$][flags][width][.precision][h|H|l|L|i|I]type</b>

	Each format string may cause certain stream flags to be set or cleared and the precision and/or 
	width variable of the stream to be set. The goal has been to support all features that can
	be easily simulated using the iostream formatting facilities. Features that have no direct equivalent 
	for iostreams are not supported.

	The \b arg_pos is the positional argument specifying the index of the argument to be printed. 
	The first argument (i.e. \a arg1) has index 1. using a positional argument also changes the current 
	argument index so the next argument to be printed by the next format field will be \a arg_pos+1.

	The following \b flags are supported:
		- '-' left align. 
			- clears: \c std::ios_base::adjustfield
			- sets: \c std::ios_base::left
		- ' ' prefix with a blank if positive. 
			- clears: \c std::ios_base::adjustfield
			- sets: \c std::ios_base::internal
		- '+' prefix with a '+' if positive. 
			- sets: \c std::ios_base::showpos
		- '#' show the base for hexadecimal and octal numbers. Can also be used to enable 
			\c showpoint and \c boolalpha.
			- sets: \c std::ios_base::showpoint, \c std::ios_base::showbase, \c std::ios_base::boolalpha
		- '0' is ignored.

	The \b width and \b precision simply sets the stream precision and the field width for 
	the next formatted output of the stream.

	All the type prefixes  (i.e. 'h', 'H', 'l', ...) are ignored.

	The \b type characters simply set/clear some of the stream flags. The actual type of the argument will
	be used by the stream for printing. The following \b type characters are supported:
		- 'c', 'C', 'p', 's', 'S' are ignored.
		- 'd', 'i', 'u' integer numbers will be printed in decimal.
			- clears: \c std::ios_base::basefield
			- sets: \c std::ios_base::dec
		- 'o' integer numbers will be printed in octal.
			- clears: \c std::ios_base::basefield
			- sets: \c std::ios_base::oct
		- 'x' integer numbers will be printed in hexadecimal using lowercase letters.
			- clears: \c std::ios_base::basefield, \c std::ios_base::uppercase
			- sets: \c std::ios_base::hex
		- 'X' integer numbers will be printed in hexadecimal using uppercase letters.
			- clears: \c std::ios_base::basefield
			- sets: \c std::ios_base::hex, \c std::ios_base::uppercase
		- 'e','a' floating point numbers will be printed in scientific format using 'e' letter.
			- clears: \c std::ios_base::floatfield, \c std::ios_base::uppercase
			- sets: \c std::ios_base::scientific
		- 'E','A' floating point numbers will be printed in scientific format using 'E' letter.
			- clears: \c std::ios_base::floatfield
			- sets: \c std::ios_base::scientific, \c std::ios_base::uppercase
		- 'g' floating point numbers will be printed in the shortest of fixed 
			or scientific format using 'e' letter.
			- clears: \c std::ios_base::floatfield, \c std::ios_base::uppercase
		- 'G' floating point numbers will be printed in the shortest of fixed 
			or scientific format using 'E' letter.
			- clears: \c std::ios_base::floatfield, \c std::ios_base::uppercase
		- 'n' is ignored and the corresponding argument is skipped.

	\par Extended Format Field
	In the extended format, a user defined format string is used to format the argument.

	<b>%[arg_pos$]{fmt}</b>

	The format string \a fmt is enclosed in braces and can be any arbitrary string which is balanced with 
	respect to '{' and '}'. This allows for nesting of format fields. 
	The \a fmt is then passed to the appropriate overload of the xprintf_one() function for processing.
	The xprintf_one() will do the actual printing.

	\par Example:
	\code
	xprintf(std::cout, "%.4f %5s %1$f", 34.34, "hello");
	xprintf(std::cout, "%.4s %5d %1$f", 34.34, "hello"); // gives the same result
	
	Date d; // assume that xprintf_one() is defined for the Date class.
	xprintf(std::cout, "The date is : %{%m/%d/%y}, temperature is : %d", d, 80); // uses the extended format
	\endcode

	\remark
	The precision and flags of the stream are saved at the beginning and restored to their initial value
	upon exiting the function even if the function exits due to an exception. Also, the stream flags 
	and precision value are reset to their saved value before processing any of the format fields. 
	However, for standard format fields, the flags are reset to the default stream values.
*/


#ifdef DOCUMENTATION_ONLY
/*!
	\ingroup xprintf
	Prints \a arg1 ... \a argN to output stream \a os using the format string specified by \a format 
	and then return the stream.

	\param os The target output stream
	\param format The format string
	\param argI I-th argument where I is 1,2, ... N
	\return Returns the same output stream \a os
	\throws format_error, argument_index_error
*/
template<
    typename _char_type, 
    typename _traits_type,
    typename _argument1_type,
    ...,
    typename _argumentN_type>
std::basic_ostream<_char_type, _traits_type>& 
xprintf(std::basic_ostream<_char_type, _traits_type>& os, 
        const _char_type* format,
        const _argument1_type& arg1,
		...,
        const _argumentN_type& argN);
#endif // DOCUMENTATION_ONLY

template<
    typename _char_type, 
    typename _traits_type>
std::basic_ostream<_char_type, _traits_type>& 
xprintf(std::basic_ostream<_char_type, _traits_type>& os, 
        const _char_type* format);

template<
    typename _char_type, 
    typename _traits_type, 
    typename _argument1_type>
std::basic_ostream<_char_type, _traits_type>& 
xprintf(std::basic_ostream<_char_type, _traits_type>& os, 
        const _char_type* format, 
        const _argument1_type& arg1);

template<
    typename _char_type, 
    typename _traits_type, 
    typename _argument1_type,
    typename _argument2_type>
std::basic_ostream<_char_type, _traits_type>& 
xprintf(std::basic_ostream<_char_type, _traits_type>& os, 
        const _char_type* format, 
        const _argument1_type& arg1,
        const _argument2_type& arg2);

template<
    typename _char_type, 
    typename _traits_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type>
std::basic_ostream<_char_type, _traits_type>& 
xprintf(std::basic_ostream<_char_type, _traits_type>& os, 
        const _char_type* format, 
        const _argument1_type& arg1,
        const _argument2_type& arg2,
        const _argument3_type& arg3);

template<
    typename _char_type, 
    typename _traits_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type>
std::basic_ostream<_char_type, _traits_type>& 
xprintf(std::basic_ostream<_char_type, _traits_type>& os, 
        const _char_type* format, 
        const _argument1_type& arg1,
        const _argument2_type& arg2,
        const _argument3_type& arg3,
        const _argument4_type& arg4);

template<
    typename _char_type, 
    typename _traits_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type>
std::basic_ostream<_char_type, _traits_type>& 
xprintf(std::basic_ostream<_char_type, _traits_type>& os, 
        const _char_type* format, 
        const _argument1_type& arg1,
        const _argument2_type& arg2,
        const _argument3_type& arg3,
        const _argument4_type& arg4,
        const _argument5_type& arg5);

template<
    typename _char_type, 
    typename _traits_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type,
    typename _argument6_type>
std::basic_ostream<_char_type, _traits_type>& 
xprintf(std::basic_ostream<_char_type, _traits_type>& os, 
        const _char_type* format, 
        const _argument1_type& arg1,
        const _argument2_type& arg2,
        const _argument3_type& arg3,
        const _argument4_type& arg4,
        const _argument5_type& arg5,
        const _argument6_type& arg6);

template<
    typename _char_type, 
    typename _traits_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type,
    typename _argument6_type,
    typename _argument7_type>
std::basic_ostream<_char_type, _traits_type>& 
xprintf(std::basic_ostream<_char_type, _traits_type>& os, 
        const _char_type* format, 
        const _argument1_type& arg1,
        const _argument2_type& arg2,
        const _argument3_type& arg3,
        const _argument4_type& arg4,
        const _argument5_type& arg5,
        const _argument6_type& arg6,
        const _argument7_type& arg7);

template<
    typename _char_type, 
    typename _traits_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type,
    typename _argument6_type,
    typename _argument7_type,
    typename _argument8_type>
std::basic_ostream<_char_type, _traits_type>& 
xprintf(std::basic_ostream<_char_type, _traits_type>& os, 
        const _char_type* format, 
        const _argument1_type& arg1,
        const _argument2_type& arg2,
        const _argument3_type& arg3,
        const _argument4_type& arg4,
        const _argument5_type& arg5,
        const _argument6_type& arg6,
        const _argument7_type& arg7,
        const _argument8_type& arg8);

template<
    typename _char_type, 
    typename _traits_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type,
    typename _argument6_type,
    typename _argument7_type,
    typename _argument8_type,
    typename _argument9_type>
std::basic_ostream<_char_type, _traits_type>& 
xprintf(std::basic_ostream<_char_type, _traits_type>& os, 
        const _char_type* format, 
        const _argument1_type& arg1,
        const _argument2_type& arg2,
        const _argument3_type& arg3,
        const _argument4_type& arg4,
        const _argument5_type& arg5,
        const _argument6_type& arg6,
        const _argument7_type& arg7,
        const _argument8_type& arg8,
        const _argument9_type& arg9);

template<
    typename _char_type, 
    typename _traits_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type,
    typename _argument6_type,
    typename _argument7_type,
    typename _argument8_type,
    typename _argument9_type,
    typename _argument10_type>
std::basic_ostream<_char_type, _traits_type>& 
xprintf(std::basic_ostream<_char_type, _traits_type>& os, 
        const _char_type* format, 
        const _argument1_type& arg1,
        const _argument2_type& arg2,
        const _argument3_type& arg3,
        const _argument4_type& arg4,
        const _argument5_type& arg5,
        const _argument6_type& arg6,
        const _argument7_type& arg7,
        const _argument8_type& arg8,
        const _argument9_type& arg9,
        const _argument10_type& arg10);



#ifdef DOCUMENTATION_ONLY
/*!
	\ingroup xprintf
	Prints \a arg1 ... \a argN to a string using the format string specified by \a format 
	and then return the string.

	\param format The format string
	\param argI I-th argument where I is 1,2, ... N
	\return Returns the resulting string
	\remark Note that this function does not throw any exception. Instead, it silently ignores any error.
		and the printing stops as soon as an error is encountered.
*/
template<
    typename _char_type, 
    typename _traits_type,
    typename _argument1_type,
    ...,
    typename _argumentN_type>
std::basic_string<_char_type> 
xprintf(const _char_type* format,
        const _argument1_type& arg1,
		...,
        const _argumentN_type& argN);
#endif // DOCUMENTATION_ONLY

template<
    typename _char_type>
std::basic_string<_char_type> 
xprintf(const _char_type* format);

template<
    typename _char_type, 
    typename _argument1_type>
std::basic_string<_char_type> 
xprintf(const _char_type* format, 
        const _argument1_type& arg1);

template<
    typename _char_type, 
    typename _argument1_type,
    typename _argument2_type>
std::basic_string<_char_type> 
xprintf(const _char_type* format, 
        const _argument1_type& arg1,
        const _argument2_type& arg2);

template<
    typename _char_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type>
std::basic_string<_char_type> 
xprintf(const _char_type* format, 
        const _argument1_type& arg1,
        const _argument2_type& arg2,
        const _argument3_type& arg3);

template<
    typename _char_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type>
std::basic_string<_char_type> 
xprintf(const _char_type* format, 
        const _argument1_type& arg1,
        const _argument2_type& arg2,
        const _argument3_type& arg3,
        const _argument4_type& arg4);

template<
    typename _char_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type>
std::basic_string<_char_type> 
xprintf(const _char_type* format, 
        const _argument1_type& arg1,
        const _argument2_type& arg2,
        const _argument3_type& arg3,
        const _argument4_type& arg4,
        const _argument5_type& arg5);

template<
    typename _char_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type,
    typename _argument6_type>
std::basic_string<_char_type> 
xprintf(const _char_type* format, 
        const _argument1_type& arg1,
        const _argument2_type& arg2,
        const _argument3_type& arg3,
        const _argument4_type& arg4,
        const _argument5_type& arg5,
        const _argument6_type& arg6);

template<
    typename _char_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type,
    typename _argument6_type,
    typename _argument7_type>
std::basic_string<_char_type> 
xprintf(const _char_type* format, 
        const _argument1_type& arg1,
        const _argument2_type& arg2,
        const _argument3_type& arg3,
        const _argument4_type& arg4,
        const _argument5_type& arg5,
        const _argument6_type& arg6,
        const _argument7_type& arg7);

template<
    typename _char_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type,
    typename _argument6_type,
    typename _argument7_type,
    typename _argument8_type>
std::basic_string<_char_type> 
xprintf(const _char_type* format, 
        const _argument1_type& arg1,
        const _argument2_type& arg2,
        const _argument3_type& arg3,
        const _argument4_type& arg4,
        const _argument5_type& arg5,
        const _argument6_type& arg6,
        const _argument7_type& arg7,
        const _argument8_type& arg8);

template<
    typename _char_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type,
    typename _argument6_type,
    typename _argument7_type,
    typename _argument8_type,
    typename _argument9_type>
std::basic_string<_char_type> 
xprintf(const _char_type* format, 
        const _argument1_type& arg1,
        const _argument2_type& arg2,
        const _argument3_type& arg3,
        const _argument4_type& arg4,
        const _argument5_type& arg5,
        const _argument6_type& arg6,
        const _argument7_type& arg7,
        const _argument8_type& arg8,
        const _argument9_type& arg9);

template<
    typename _char_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type,
    typename _argument6_type,
    typename _argument7_type,
    typename _argument8_type,
    typename _argument9_type,
    typename _argument10_type>
std::basic_string<_char_type> 
xprintf(const _char_type* format, 
        const _argument1_type& arg1,
        const _argument2_type& arg2,
        const _argument3_type& arg3,
        const _argument4_type& arg4,
        const _argument5_type& arg5,
        const _argument6_type& arg6,
        const _argument7_type& arg7,
        const _argument8_type& arg8,
        const _argument9_type& arg9,
        const _argument10_type& arg10);



/*!
	\ingroup xprintf
	Prints the arguments in the range [\a first, \a last) to output stream \a os using 
	the format string specified by the range [\a format_begin, \a format_end) and then return the stream.

	\param os The target output stream
	\param format_begin pointer to the beginning of the format string
	\param format_end pointer to one past the end of the format string
	\param first iterator to the first argument
	\param last iterator to one past the last argument
	\return Returns the same output stream \a os
	\throws format_error, argument_index_error
*/
template<typename _char_type, typename _traits_type, typename _argument_iter_type> 
std::basic_ostream<_char_type, _traits_type>& 
xprintf_range(std::basic_ostream<_char_type, _traits_type>& os, 
              const _char_type* format_begin, 
              const _char_type* format_end, 
              _argument_iter_type first,
              _argument_iter_type last);

/*!
	\ingroup xprintf
	Prints the arguments in the range [\a first, \a last) to output stream \a os using 
	the format string specified by \a format and then return the stream.

	\param os The target output stream
	\param format pointer to the the format string
	\param first iterator to the first argument
	\param last iterator to one past the last argument
	\return Returns the same output stream \a os
	\throws format_error, argument_index_error
*/
template<typename _char_type, typename _traits_type, typename _argument_iter_type> 
std::basic_ostream<_char_type, _traits_type>& 
xprintf_range(std::basic_ostream<_char_type, _traits_type>& os, 
              const _char_type* format, 
              _argument_iter_type first,
              _argument_iter_type last);

/*!
	\ingroup xprintf
	Prints the argument \a argument to output stream \a os using 
	the user defined format string specified by the range [fmt_begin, fmt_end).
	The default implementation of this function ignores the format string and simply uses the 
	&lt;&lt; operator to print \a argument to the output stream. This function can be overloaded to allow
	handling of user defined format strings.
*/
template<typename _char_type, typename _traits_type, typename _argument_type> 
inline std::basic_ostream<_char_type, _traits_type>& 
xprintf_one(std::basic_ostream<_char_type, _traits_type>& os, 
            const _char_type* fmt_begin, 
            const _char_type* fmt_end, 
            const _argument_type& argument);

/***********************************************************************************************************/
/* xscanf family *******************************************************************************************/
/***********************************************************************************************************/

/*!
	\defgroup xscanf xscanf Family of Functions
	\ingroup xformat
	Scans the arguments using the specified format string.

	These functions use a scanf style format string which can be of Standard or Extended form.
	In both cases, each argument is scanned by a call to an appropriate overload of xscanf_one() function.

	The format string uses exactly the same pattern as the format strings used by xprintf(). 
	You can refer to xprintf() for explanation of the format string. Although the format 
	string changes the stream precision and flags the same way that it does for xprintf(), most of these 
	changes have no effect except for a few like 'i','d','o','x', field width, etc.

	Any white space in the format string may match zero or more white space in the input stream. 
	The rest of the characters in the format string, excluding the format fields, 
	should match the same character from the input stream otherwise a ::input_mismatch_error exception 
	will be thrown.
	
	\remark
	For an input stream, the field width specifies the maximum length of the next string to be read. 

	\par Example:
	\code
	int i; float f;
	xscanf(std::cin, "f=%f i=%d", f, i);
	xscanf(std::cin, "f=%s i=%c", f, i); // gives the same result
	
	Date d; // assume that xscanf_one() is defined for the Date class.
	xscanf(std::cin, "The date is : %{%m/%d/%y} ", d); // uses the extended format
	\endcode
*/

#ifdef DOCUMENTATION_ONLY
/*!
	\ingroup xscanf
	Scans \a arg1 ... \a argN from the input stream \a is using the format string specified by \a format 
	and then return the stream. 
	
	This function fails if the input stream does not match the format string.

	\param is The source input stream
	\param format The format string
	\param argI I-th argument where I is 1,2, ... N
	\return Returns the same input stream \a is
	\throws format_error, argument_index_error, input_mismatch_error
*/
template<
    typename _char_type, 
    typename _traits_type,
    typename _argument1_type,
    ...,
    typename _argumentN_type>
std::basic_istream<_char_type, _traits_type>& 
xscanf(std::basic_istream<_char_type, _traits_type>& is, 
        const _char_type* format,
        _argument1_type& arg1,
		...,
        _argumentN_type& argN);
#endif // DOCUMENTATION_ONLY

template<
    typename _char_type, 
    typename _traits_type>
std::basic_istream<_char_type, _traits_type>& 
xscanf(std::basic_istream<_char_type, _traits_type>& is, 
       const _char_type* format);

template<
    typename _char_type, 
    typename _traits_type, 
    typename _argument1_type>
std::basic_istream<_char_type, _traits_type>& 
xscanf(std::basic_istream<_char_type, _traits_type>& is, 
       const _char_type* format, 
       _argument1_type& arg1);

template<
    typename _char_type, 
    typename _traits_type, 
    typename _argument1_type,
    typename _argument2_type>
std::basic_istream<_char_type, _traits_type>& 
xscanf(std::basic_istream<_char_type, _traits_type>& is, 
       const _char_type* format, 
       _argument1_type& arg1,
       _argument2_type& arg2);

template<
    typename _char_type, 
    typename _traits_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type>
std::basic_istream<_char_type, _traits_type>& 
xscanf(std::basic_istream<_char_type, _traits_type>& is, 
       const _char_type* format, 
       _argument1_type& arg1,
       _argument2_type& arg2,
       _argument3_type& arg3);

template<
    typename _char_type, 
    typename _traits_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type>
std::basic_istream<_char_type, _traits_type>& 
xscanf(std::basic_istream<_char_type, _traits_type>& is, 
       const _char_type* format, 
       _argument1_type& arg1,
       _argument2_type& arg2,
       _argument3_type& arg3,
       _argument4_type& arg4);

template<
    typename _char_type, 
    typename _traits_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type>
std::basic_istream<_char_type, _traits_type>& 
xscanf(std::basic_istream<_char_type, _traits_type>& is, 
       const _char_type* format, 
       _argument1_type& arg1,
       _argument2_type& arg2,
       _argument3_type& arg3,
       _argument4_type& arg4,
       _argument5_type& arg5);

template<
    typename _char_type, 
    typename _traits_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type,
    typename _argument6_type>
std::basic_istream<_char_type, _traits_type>& 
xscanf(std::basic_istream<_char_type, _traits_type>& is, 
       const _char_type* format, 
       _argument1_type& arg1,
       _argument2_type& arg2,
       _argument3_type& arg3,
       _argument4_type& arg4,
       _argument5_type& arg5,
       _argument6_type& arg6);

template<
    typename _char_type, 
    typename _traits_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type,
    typename _argument6_type,
    typename _argument7_type>
std::basic_istream<_char_type, _traits_type>& 
xscanf(std::basic_istream<_char_type, _traits_type>& is, 
       const _char_type* format, 
       _argument1_type& arg1,
       _argument2_type& arg2,
       _argument3_type& arg3,
       _argument4_type& arg4,
       _argument5_type& arg5,
       _argument6_type& arg6,
       _argument7_type& arg7);

template<
    typename _char_type, 
    typename _traits_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type,
    typename _argument6_type,
    typename _argument7_type,
    typename _argument8_type>
std::basic_istream<_char_type, _traits_type>& 
xscanf(std::basic_istream<_char_type, _traits_type>& is, 
       const _char_type* format, 
       _argument1_type& arg1,
       _argument2_type& arg2,
       _argument3_type& arg3,
       _argument4_type& arg4,
       _argument5_type& arg5,
       _argument6_type& arg6,
       _argument7_type& arg7,
       _argument8_type& arg8);

template<
    typename _char_type, 
    typename _traits_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type,
    typename _argument6_type,
    typename _argument7_type,
    typename _argument8_type,
    typename _argument9_type>
std::basic_istream<_char_type, _traits_type>& 
xscanf(std::basic_istream<_char_type, _traits_type>& is, 
       const _char_type* format, 
       _argument1_type& arg1,
       _argument2_type& arg2,
       _argument3_type& arg3,
       _argument4_type& arg4,
       _argument5_type& arg5,
       _argument6_type& arg6,
       _argument7_type& arg7,
       _argument8_type& arg8,
       _argument9_type& arg9);

template<
    typename _char_type, 
    typename _traits_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type,
    typename _argument6_type,
    typename _argument7_type,
    typename _argument8_type,
    typename _argument9_type,
    typename _argument10_type>
std::basic_istream<_char_type, _traits_type>& 
xscanf(std::basic_istream<_char_type, _traits_type>& is, 
       const _char_type* format, 
       _argument1_type& arg1,
       _argument2_type& arg2,
       _argument3_type& arg3,
       _argument4_type& arg4,
       _argument5_type& arg5,
       _argument6_type& arg6,
       _argument7_type& arg7,
       _argument8_type& arg8,
       _argument9_type& arg9,
       _argument10_type& arg10);



#ifdef DOCUMENTATION_ONLY
/*!
	\ingroup xscanf
	Scans \a arg1 ... \a argN from the string \a str using the format string specified by \a format 
	and then return the status.
	
	This function fails if the input stream does not match the format string.

	\param str The source string
	\param format The format string
	\param argI I-th argument where I is 1,2, ... N
	\return Returns the status
	\throws format_error, argument_index_error, input_mismatch_error

	\remark To make sure that the \a format string matches the whole string and there are no extra 
	characters at the end of the string, you can add an extra space to the end of the format string. 
	The extra space will eat all the trailing white space and if there are no extra non-white space 
	characters at the end, the return value should be \c std::ios_base::eof_bit .
*/
template<
    typename _char_type, 
    typename _traits_type,
    typename _alloc_type,
    typename _argument1_type,
    ...,
    typename _argumentN_type>
std::ios_base::iostate 
xscanf(const std::basic_string<_char_type, _traits_type, _alloc_type>& str,
        const _char_type* format,
        _argument1_type& arg1,
		...,
        _argumentN_type& argN);
#endif // DOCUMENTATION_ONLY


template<
    typename _char_type,
    typename _traits_type,
    typename _alloc_type>
std::ios_base::iostate 
xscanf(const std::basic_string<_char_type, _traits_type, _alloc_type>& str, 
       const _char_type* format);

template<
    typename _char_type, 
    typename _traits_type,
    typename _alloc_type,
    typename _argument1_type>
std::ios_base::iostate 
xscanf(const std::basic_string<_char_type, _traits_type, _alloc_type>& str,
       const _char_type* format, 
       _argument1_type& arg1);

template<
    typename _char_type, 
    typename _traits_type,
    typename _alloc_type,
    typename _argument1_type,
    typename _argument2_type>
std::ios_base::iostate 
xscanf(const std::basic_string<_char_type, _traits_type, _alloc_type>& str,
       const _char_type* format, 
       _argument1_type& arg1,
       _argument2_type& arg2);

template<
    typename _char_type, 
    typename _traits_type,
    typename _alloc_type,
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type>
std::ios_base::iostate 
xscanf(const std::basic_string<_char_type, _traits_type, _alloc_type>& str,
       const _char_type* format, 
       _argument1_type& arg1,
       _argument2_type& arg2,
       _argument3_type& arg3);

template<
    typename _char_type, 
    typename _traits_type,
    typename _alloc_type,
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type>
std::ios_base::iostate 
xscanf(const std::basic_string<_char_type, _traits_type, _alloc_type>& str,
       const _char_type* format, 
       _argument1_type& arg1,
       _argument2_type& arg2,
       _argument3_type& arg3,
       _argument4_type& arg4);

template<
    typename _char_type, 
    typename _traits_type,
    typename _alloc_type,
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type>
std::ios_base::iostate 
xscanf(const std::basic_string<_char_type, _traits_type, _alloc_type>& str,
       const _char_type* format, 
       _argument1_type& arg1,
       _argument2_type& arg2,
       _argument3_type& arg3,
       _argument4_type& arg4,
       _argument5_type& arg5);

template<
    typename _char_type, 
    typename _traits_type,
    typename _alloc_type,
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type,
    typename _argument6_type>
std::ios_base::iostate 
xscanf(const std::basic_string<_char_type, _traits_type, _alloc_type>& str,
       const _char_type* format, 
       _argument1_type& arg1,
       _argument2_type& arg2,
       _argument3_type& arg3,
       _argument4_type& arg4,
       _argument5_type& arg5,
       _argument6_type& arg6);

template<
    typename _char_type, 
    typename _traits_type,
    typename _alloc_type,
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type,
    typename _argument6_type,
    typename _argument7_type>
std::ios_base::iostate 
xscanf(const std::basic_string<_char_type, _traits_type, _alloc_type>& str,
       const _char_type* format, 
       _argument1_type& arg1,
       _argument2_type& arg2,
       _argument3_type& arg3,
       _argument4_type& arg4,
       _argument5_type& arg5,
       _argument6_type& arg6,
       _argument7_type& arg7);

template<
    typename _char_type, 
    typename _traits_type,
    typename _alloc_type,
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type,
    typename _argument6_type,
    typename _argument7_type,
    typename _argument8_type>
std::ios_base::iostate 
xscanf(const std::basic_string<_char_type, _traits_type, _alloc_type>& str,
       const _char_type* format, 
       _argument1_type& arg1,
       _argument2_type& arg2,
       _argument3_type& arg3,
       _argument4_type& arg4,
       _argument5_type& arg5,
       _argument6_type& arg6,
       _argument7_type& arg7,
       _argument8_type& arg8);

template<
    typename _char_type, 
    typename _traits_type,
    typename _alloc_type,
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type,
    typename _argument6_type,
    typename _argument7_type,
    typename _argument8_type,
    typename _argument9_type>
std::ios_base::iostate 
xscanf(const std::basic_string<_char_type, _traits_type, _alloc_type>& str,
       const _char_type* format, 
       _argument1_type& arg1,
       _argument2_type& arg2,
       _argument3_type& arg3,
       _argument4_type& arg4,
       _argument5_type& arg5,
       _argument6_type& arg6,
       _argument7_type& arg7,
       _argument8_type& arg8,
       _argument9_type& arg9);

template<
    typename _char_type, 
    typename _traits_type,
    typename _alloc_type,
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type,
    typename _argument6_type,
    typename _argument7_type,
    typename _argument8_type,
    typename _argument9_type,
    typename _argument10_type>
std::ios_base::iostate 
xscanf(const std::basic_string<_char_type, _traits_type, _alloc_type>& str,
       const _char_type* format, 
       _argument1_type& arg1,
       _argument2_type& arg2,
       _argument3_type& arg3,
       _argument4_type& arg4,
       _argument5_type& arg5,
       _argument6_type& arg6,
       _argument7_type& arg7,
       _argument8_type& arg8,
       _argument9_type& arg9,
       _argument10_type& arg10);


/*!
	\ingroup xscanf
	Scans the arguments in the range [\a arg1, \a argN) from the input stream \a is using the 
	format string specified by the range [\a format_begin, \a format_end) and then return the stream. 
	
	This function fails if the input stream does not match the format string.

	\param is The source input stream
	\param format_begin Pointer to the beginning of the format string
	\param format_end Pointer to the end of the format string
	\param first The iterator pointing to the beginning of the range of arguments
	\param last The iterator pointing to one past the last argument in the range of arguments
	\return Returns the same input stream \a is
	\throws format_error, argument_index_error, input_mismatch_error
*/

template<typename _char_type, typename _traits_type, typename _argument_iter_type> 
std::basic_istream<_char_type, _traits_type>& 
xscanf_range(std::basic_istream<_char_type, _traits_type>& is, 
             const _char_type* format_begin, 
             const _char_type* format_end, 
             _argument_iter_type first,
             _argument_iter_type last);

/*!
	\ingroup xscanf
	Scans the arguments in the range [\a arg1, \a argN) from the input stream \a is using the 
	format string specified by \a format and then return the stream. 
	
	This function fails if the input stream does not match the format string.

	\param is The source input stream
	\param format The format string
	\param first The iterator pointing to the beginning of the range of arguments
	\param last The iterator pointing to one past the last argument in the range of arguments
	\return Returns the same input stream \a is
	\throws format_error, argument_index_error, input_mismatch_error
*/

template<typename _char_type, typename _traits_type, typename _argument_iter_type> 
std::basic_istream<_char_type, _traits_type>& 
xscanf_range(std::basic_istream<_char_type, _traits_type>& is, 
             const _char_type* format, 
             _argument_iter_type first,
             _argument_iter_type last);

/*!
	\ingroup xscanf
	Scans the argument \a argument from the input stream \a is using 
	the user defined format string specified by the range [fmt_begin, fmt_end).
	The default implementation of this function ignores the format string and simply uses the 
	&gt;&gt; operator to read \a argument from the input stream. This function can be overloaded to allow
	handling of user defined format strings.
*/
template<typename _char_type, typename _traits_type, typename _argument_type> 
inline std::basic_istream<_char_type, _traits_type>& 
xscanf_one(std::basic_istream<_char_type, _traits_type>& is, 
           const _char_type* fmt_begin, 
           const _char_type* fmt_end, 
           _argument_type& argument);

/***********************************************************************************************************/
/* detail **************************************************************************************************/
/***********************************************************************************************************/

namespace detail
{

struct format_char_info;

template<typename _char_type, typename _traits_type> 
class xprintf_argument_wrapper_base;

template<typename _char_type, typename _traits_type, typename _argument_type> 
class xprintf_argument_wrapper;

template<typename _char_type, typename _traits_type> 
class xscanf_argument_wrapper_base;

template<typename _char_type, typename _traits_type, typename _argument_type> 
class xscanf_argument_wrapper;

template<typename _char_type, typename _traits_type> 
class xformat_cache;

template<typename _char_type> 
inline char do_narrow(const _char_type& ch, const std::ctype<_char_type>& conv)
{ return conv.narrow(ch, '\0'); }

inline char do_narrow(const char ch, const std::ctype<char>&)
{ return ch; }

template<typename _char_type> 
inline const _char_type* 
read_number(const _char_type* format_begin, 
            const _char_type* format_end, 
            int& num,
            const std::ctype<_char_type>& conv);

} // namespace detail

/***********************************************************************************************************/
/* format_error ********************************************************************************************/
/***********************************************************************************************************/

/*! 
	\ingroup exceptions
	An error in the format string 
*/
class format_error
    : public std::invalid_argument
{
public:
    format_error(const std::string& msg ="")
        : std::invalid_argument(msg) 
    {}

    ~format_error() throw() {}
};

/***********************************************************************************************************/
/* argument_index_error ************************************************************************************/
/***********************************************************************************************************/

/*! 
	\ingroup exceptions
	An invalid position argument in a format field of a format string 
*/
class argument_index_error
    : public std::out_of_range
{
public:
    argument_index_error(const std::string& msg ="")
        : std::out_of_range(msg) 
    {}

    ~argument_index_error() throw() {}
};

/***********************************************************************************************************/
/* input_mismatch_error ******************************************************************************************/
/***********************************************************************************************************/

/*! 
	\ingroup exceptions
	A mismatch between the format string and the input 
*/
class input_mismatch_error
    : public std::runtime_error
{
public:
    input_mismatch_error(const std::string& msg ="")
        : std::runtime_error(msg) 
    {}

    ~input_mismatch_error() throw() {}
};

/***********************************************************************************************************/
/* conversion_error ****************************************************************************************/
/***********************************************************************************************************/

/*! 
	\ingroup exceptions
	A conversion error 
*/
class conversion_error
    : public std::bad_cast
{
public:
    conversion_error(const char* msg)
        : m_msg(msg) 
    {}

    const char* what() const throw() 
    { return m_msg.c_str(); }

    ~conversion_error() throw() {}

private:
    std::string m_msg;
};

/***********************************************************************************************************/
/* basic_conversion **********************************************************************************************/
/***********************************************************************************************************/

/*!
	\ingroup conversion
	This class encapsulates a stringstream that is used for converting value types to/from string. 
*/
template<
    typename _char_type, 
    typename _traits_type,
    typename _alloc_type>
class basic_conversion
{
public:
    typedef _char_type char_type;
    typedef _traits_type traits_type;
    typedef _alloc_type allocator_type;
    typedef std::basic_string<_char_type, _traits_type, _alloc_type> string_type;
    typedef std::basic_stringstream<_char_type, _traits_type, _alloc_type> stream_type;
    
	/*! the conversion setting can be modified by directly accessing the stream object */
    stream_type stream; 

    basic_conversion()
        : m_cache(stream)
    {
        cache_type::get(stream, &m_cache);
    }

	/*! 
		Convert \a value to string and store it in \a str. Throw an exception on error if \a raise is true.
		Otherwise return false on error and true otherwise.
	*/
    template<typename _value_type>
    bool to_str(const _value_type& value, string_type& str, bool raise=true)
    {
        stream.str("");
        stream.clear();
        stream << value;
        if (stream.good()) {
            str = stream.str();
            return true;
        }
        else 
            if (raise)
                throw conversion_error("basic_conversion to string failed!");
            else
                return false;
    }

	/*! Convert \a value to string and return it. Throws an exception on error. */
    template<typename _value_type>
    string_type to_str(const _value_type& value)
    {
        stream.str("");
        stream.clear();
        stream << value;
        if (stream.good() && stream >> std::ws)
            return stream.str();
        else
            throw conversion_error("basic_conversion to string failed!");
    }

	/*! 
		Convert the string in \a str to a \a _value_type and store it in \a value.
		Throw an exception on error if \a raise is true. Otherwise return false on error and true otherwise.
	*/
    template<typename _value_type>
    bool from_str(const string_type& str, _value_type& value, bool raise=true)
    {
        stream.str(str);
        stream.clear();
        stream >> value;
        if (stream.rdstate() == std::ios_base::eofbit) 
            return true;
        else {
            if (stream.good()) {
                const std::ctype<_char_type>& conv = *m_cache.conv;
                
                typename traits_type::int_type meta = stream.rdbuf()->sgetc();

				for (; ; meta = stream.rdbuf()->snextc())
                    if (traits_type::eq_int_type(traits_type::eof(), meta)) {
                        stream.setstate(std::ios_base::eofbit);
                        break;
                    }
                    else if (!conv.is(std::ctype_base::space, traits_type::to_char_type(meta)))
                        break;	
                if (stream.rdstate() == std::ios_base::eofbit)
                    return true;
            }
            if (raise)
                throw conversion_error("basic_conversion from string failed!");
            else
                return false;
        }
    }

	/*! Convert the string in \a str to a \a _value_type and return it. Throw an exception on error. */
    template<typename _value_type>
    _value_type from_str(const string_type& str)
    {
        _value_type value;

        from_str(str, value, true);
        return value;
    }

private:
    typedef detail::xformat_cache<_char_type, _traits_type> cache_type;
    cache_type m_cache;
};

/***********************************************************************************************************/
/* xformat_cache *******************************************************************************************/
/***********************************************************************************************************/

template<typename _char_type, typename _traits_type> 
class detail::xformat_cache
{
public:
    typedef _char_type char_type;
    typedef _traits_type traits_type;

    enum cache_type {c_null=0, c_static, c_dynamic};

    std::locale loc;
    const std::ctype<_char_type>* conv;
    char_type ch_perc, ch_dollar, ch_lb, ch_rb;
    
    static xformat_cache* get(std::ios_base& stream, xformat_cache* ext_cache=0)
    {
        static int x_index = std::ios_base::xalloc();

        void*& pw = stream.pword(x_index);

        if (pw)
            return static_cast<xformat_cache*>(pw);

        long& iw = stream.iword(x_index);

        if (iw == c_null)
            stream.register_callback(&xformat_cache::ios_event_handler, x_index);

        xformat_cache* cache =0;

        if (ext_cache) {
            cache = ext_cache;
            iw = c_static;
        }
        else {
            cache = new xformat_cache(stream);
            iw = c_dynamic;
        }
            
        pw = static_cast<void*>(cache);
        return cache;
    }

    xformat_cache()
    {
        conv = 0;
        ch_perc = ch_dollar = ch_lb = ch_rb = char_type();
    }

    explicit xformat_cache(const std::ios_base& stream)
    {
        conv = 0;
        update(stream);
    }

protected:
    void update(const std::ios_base& stream)
    {
        loc = stream.getloc();
        conv = &std::use_facet<std::ctype<_char_type> > (loc);
        ch_perc = conv->widen('%');
        ch_dollar = conv->widen('$');
        ch_lb = conv->widen('{');
        ch_rb = conv->widen('}');
    }

private:
    static void ios_event_handler(std::ios_base::event ev, std::ios_base& stream, int x_index)
    {
        void*& pw = stream.pword(x_index);

        switch (ev) 
        {
        case std::ios_base::copyfmt_event:
        case std::ios_base::imbue_event:
            if (pw)
                static_cast<xformat_cache*>(pw)->update(stream);
            break;
        case std::ios_base::erase_event:
            if (pw && stream.iword(x_index) == c_dynamic) {
                delete static_cast<xformat_cache*>(pw);
                pw = 0;
            }
            break;
        default:;
        }
    }
};

/***********************************************************************************************************/
/* char_info_record ****************************************************************************************/
/***********************************************************************************************************/

struct detail::format_char_info 
{
public:
    enum char_fmt_type {c_invalid =0, c_flags, c_prefix, c_type, c_special_type};

    std::ios_base::fmtflags cflags; // flags to clear
    std::ios_base::fmtflags sflags; // flags to set
    char_fmt_type type;

    static const format_char_info* get_defaults()
    {
        static format_char_info records[255];
        static bool init = false;

        if (!init) {
            records[int('-')].cflags = std::ios_base::adjustfield;
            records[int('-')].sflags = std::ios_base::left;
            records[int('-')].type = c_flags;
            records[int('+')].sflags = std::ios_base::showpos;
            records[int('+')].type = c_flags;
            records[int(' ')].cflags = std::ios_base::adjustfield;
            records[int(' ')].sflags = std::ios_base::internal;
            records[int(' ')].type = c_flags;
            records[int('#')].sflags = std::ios_base::showpoint 
                | std::ios_base::showbase | std::ios_base::boolalpha;
            records[int('#')].type = c_flags;
            records[int('0')].type = c_flags;
            records[int('c')].type = c_type;
            records[int('C')].type = c_type;
            records[int('d')].cflags = std::ios_base::basefield;
            records[int('d')].sflags = std::ios_base::dec;
            records[int('d')].type = c_type;
            records[int('i')].cflags = std::ios_base::basefield;
            records[int('i')].sflags = std::ios_base::dec;
            records[int('i')].type = c_type;
            records[int('o')].cflags = std::ios_base::basefield;
            records[int('o')].sflags = std::ios_base::oct;
            records[int('o')].type = c_type;
            records[int('u')].cflags = std::ios_base::basefield;
            records[int('u')].sflags = std::ios_base::dec;
            records[int('u')].type = c_type;
            records[int('x')].cflags = std::ios_base::basefield | std::ios_base::uppercase;
            records[int('x')].sflags = std::ios_base::hex;
            records[int('x')].type = c_type;
            records[int('X')].cflags = std::ios_base::basefield;
            records[int('X')].sflags = std::ios_base::hex | std::ios_base::uppercase;
            records[int('X')].type = c_type;
            records[int('e')].cflags = std::ios_base::floatfield | std::ios_base::uppercase;
            records[int('e')].sflags = std::ios_base::scientific;
            records[int('e')].type = c_type;
            records[int('E')].cflags = std::ios_base::floatfield;
            records[int('E')].sflags = std::ios_base::scientific | std::ios_base::uppercase;
            records[int('E')].type = c_type;
            records[int('f')].cflags = std::ios_base::floatfield;
            records[int('f')].sflags = std::ios_base::fixed;
            records[int('f')].type = c_type;
            records[int('g')].cflags = std::ios_base::floatfield | std::ios_base::uppercase;
            records[int('g')].type = c_type;
            records[int('G')].cflags = std::ios_base::floatfield;
            records[int('G')].sflags = std::ios_base::uppercase;
            records[int('G')].type = c_type;
            records[int('a')].cflags = std::ios_base::floatfield | std::ios_base::uppercase;
            records[int('a')].sflags = std::ios_base::scientific;
            records[int('a')].type = c_type;
            records[int('A')].cflags = std::ios_base::floatfield;
            records[int('A')].sflags = std::ios_base::scientific | std::ios_base::uppercase;
            records[int('A')].type = c_type;
            records[int('n')].type = c_special_type;
            records[int('p')].type = c_type;
            records[int('s')].type = c_type;
            records[int('S')].type = c_type;
            records[int('l')].type = c_prefix;
            records[int('L')].type = c_prefix;
            records[int('i')].type = c_prefix;
            records[int('I')].type = c_prefix;
            records[int('h')].type = c_prefix;
            records[int('H')].type = c_prefix;

            init = true;
        }
        return records;
    }
}; 

/***********************************************************************************************************/
/* xprintf_argument_wrapper_base ***************************************************************************/
/***********************************************************************************************************/

template<typename _char_type, typename _traits_type> 
class detail::xprintf_argument_wrapper_base
{
public:
    typedef _char_type char_type;
    typedef _traits_type traits_type;
    typedef std::basic_ostream<_char_type, _traits_type> ostream_type;
    
    virtual ostream_type& 
        do_print(ostream_type& os, const char_type* fmt_begin, const char_type* fmt_end) const =0;

protected:
    virtual ~xprintf_argument_wrapper_base() {}
};

/***********************************************************************************************************/
/* xprintf_argument_wrapper ********************************************************************************/
/***********************************************************************************************************/

template<typename _char_type, typename _traits_type, typename _argument_type> 
class detail::xprintf_argument_wrapper
    : public xprintf_argument_wrapper_base<_char_type, _traits_type>
{
public:
    typedef _char_type char_type;
    typedef _traits_type traits_type;
    typedef _argument_type argument_type;
    typedef std::basic_ostream<_char_type, _traits_type> ostream_type;

    xprintf_argument_wrapper(const _argument_type& arg) : argument(arg) {}

    ostream_type& do_print(ostream_type& os, const char_type* fmt_begin, const char_type* fmt_end) const
    {
        return xprintf_one(os, fmt_begin, fmt_end, argument);
    }

    const argument_type& argument;

private:
    xprintf_argument_wrapper& operator=(const xprintf_argument_wrapper&);
};

/***********************************************************************************************************/
/* xscanf_argument_wrapper_base ****************************************************************************/
/***********************************************************************************************************/

template<typename _char_type, typename _traits_type> 
class detail::xscanf_argument_wrapper_base
{
public:
    typedef _char_type char_type;
    typedef _traits_type traits_type;
    typedef std::basic_istream<_char_type, _traits_type> istream_type;
    
    virtual istream_type& 
        do_scan(istream_type& is, const char_type* fmt_begin, const char_type* fmt_end) const =0;

protected:
    virtual ~xscanf_argument_wrapper_base() {}
};

/***********************************************************************************************************/
/* xscanf_argument_wrapper *********************************************************************************/
/***********************************************************************************************************/

template<typename _char_type, typename _traits_type, typename _argument_type> 
class detail::xscanf_argument_wrapper
    : public xscanf_argument_wrapper_base<_char_type, _traits_type>
{
public:
    typedef _char_type char_type;
    typedef _traits_type traits_type;
    typedef _argument_type argument_type;
    typedef std::basic_istream<_char_type, _traits_type> istream_type;

    xscanf_argument_wrapper(_argument_type& arg) : argument(arg) {}

    istream_type& do_scan(istream_type& is, const char_type* fmt_begin, const char_type* fmt_end) const
    {
        return xscanf_one(is, fmt_begin, fmt_end, argument);
    }

    argument_type& argument;

private:
    xscanf_argument_wrapper& operator=(const xscanf_argument_wrapper&);
};

/***********************************************************************************************************/
/* read_number *********************************************************************************************/
/***********************************************************************************************************/

template<typename _char_type> 
inline const _char_type* 
detail::read_number(const _char_type* format_begin, 
                    const _char_type* format_end, 
                    int& num,
                    const std::ctype<_char_type>& conv)
{
    num = 0;

    for (const _char_type* cur=format_begin; cur<format_end; ++cur) {
        char ch = detail::do_narrow(*cur, conv);

        //? make this portable to non-ASCII
        if (ch >= '0' && ch <= '9')
            num = num*10+(ch-'0'); 
        else
            return cur;
    }

    return format_end;
}

/***********************************************************************************************************/
/* xprintf_one *********************************************************************************************/
/***********************************************************************************************************/

template<typename _char_type, typename _traits_type> 
std::basic_ostream<_char_type, _traits_type>& 
xprintf_one(std::basic_ostream<_char_type, _traits_type>& os, 
            const _char_type* format_begin, 
            const _char_type* format_end, 
            const detail::xprintf_argument_wrapper_base<_char_type, _traits_type>* argument_wrapper)
{
    return argument_wrapper->do_print(os, format_begin, format_end);
}


template<typename _char_type, typename _traits_type, typename _argument_type> 
std::basic_ostream<_char_type, _traits_type>& 
xprintf_one(std::basic_ostream<_char_type, _traits_type>& os, 
            const _char_type*, 
            const _char_type*, 
            const _argument_type& argument)
{
    return os << argument;
}

/***********************************************************************************************************/
/* xprintf - basic_ostream *********************************************************************************/
/***********************************************************************************************************/

template<typename _char_type, typename _traits_type>
std::basic_ostream<_char_type, _traits_type>& 
xprintf(std::basic_ostream<_char_type, _traits_type>& os, const _char_type* format)
{
    const detail::xprintf_argument_wrapper_base<_char_type, _traits_type>* args = 0;

    return xprintf_range(os, format, format+_traits_type::length(format), &args, &args);
}

template<
    typename _char_type, 
    typename _traits_type, 
    typename _argument1_type>
std::basic_ostream<_char_type, _traits_type>& 
xprintf(std::basic_ostream<_char_type, _traits_type>& os, 
        const _char_type* format, 
        const _argument1_type& arg1)
{
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument1_type> wrp1(arg1);

    const detail::xprintf_argument_wrapper_base<_char_type, _traits_type>* args[] = 
    {&wrp1};

    return xprintf_range(os, format, format+_traits_type::length(format), args, args+1);
}

template<
    typename _char_type, 
    typename _traits_type, 
    typename _argument1_type,
    typename _argument2_type>
std::basic_ostream<_char_type, _traits_type>& 
xprintf(std::basic_ostream<_char_type, _traits_type>& os, 
        const _char_type* format, 
        const _argument1_type& arg1,
        const _argument2_type& arg2)
{
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument1_type> wrp1(arg1);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument2_type> wrp2(arg2);

    const detail::xprintf_argument_wrapper_base<_char_type, _traits_type>* args[] = 
    {&wrp1, &wrp2};

    return xprintf_range(os, format, format+_traits_type::length(format), args, args+2);
}

template<
    typename _char_type, 
    typename _traits_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type>
std::basic_ostream<_char_type, _traits_type>& 
xprintf(std::basic_ostream<_char_type, _traits_type>& os, 
        const _char_type* format, 
        const _argument1_type& arg1,
        const _argument2_type& arg2,
        const _argument3_type& arg3)
{
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument1_type> wrp1(arg1);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument2_type> wrp2(arg2);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument3_type> wrp3(arg3);

    const detail::xprintf_argument_wrapper_base<_char_type, _traits_type>* args[] = 
    {&wrp1, &wrp2, &wrp3};

    return xprintf_range(os, format, format+_traits_type::length(format), args, args+3);
}

template<
    typename _char_type, 
    typename _traits_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type>
std::basic_ostream<_char_type, _traits_type>& 
xprintf(std::basic_ostream<_char_type, _traits_type>& os, 
        const _char_type* format, 
        const _argument1_type& arg1,
        const _argument2_type& arg2,
        const _argument3_type& arg3,
        const _argument4_type& arg4)
{
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument1_type> wrp1(arg1);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument2_type> wrp2(arg2);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument3_type> wrp3(arg3);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument4_type> wrp4(arg4);

    const detail::xprintf_argument_wrapper_base<_char_type, _traits_type>* args[] = 
    {&wrp1, &wrp2, &wrp3, &wrp4};

    return xprintf_range(os, format, format+_traits_type::length(format), args, args+4);
}

template<
    typename _char_type, 
    typename _traits_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type>
std::basic_ostream<_char_type, _traits_type>& 
xprintf(std::basic_ostream<_char_type, _traits_type>& os, 
        const _char_type* format, 
        const _argument1_type& arg1,
        const _argument2_type& arg2,
        const _argument3_type& arg3,
        const _argument4_type& arg4,
        const _argument5_type& arg5)
{
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument1_type> wrp1(arg1);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument2_type> wrp2(arg2);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument3_type> wrp3(arg3);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument4_type> wrp4(arg4);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument5_type> wrp5(arg5);

    const detail::xprintf_argument_wrapper_base<_char_type, _traits_type>* args[] = 
    {&wrp1, &wrp2, &wrp3, &wrp4, &wrp5};

    return xprintf_range(os, format, format+_traits_type::length(format), args, args+5);
}

template<
    typename _char_type, 
    typename _traits_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type,
    typename _argument6_type>
std::basic_ostream<_char_type, _traits_type>& 
xprintf(std::basic_ostream<_char_type, _traits_type>& os, 
        const _char_type* format, 
        const _argument1_type& arg1,
        const _argument2_type& arg2,
        const _argument3_type& arg3,
        const _argument4_type& arg4,
        const _argument5_type& arg5,
        const _argument6_type& arg6)
{
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument1_type> wrp1(arg1);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument2_type> wrp2(arg2);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument3_type> wrp3(arg3);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument4_type> wrp4(arg4);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument5_type> wrp5(arg5);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument6_type> wrp6(arg6);

    const detail::xprintf_argument_wrapper_base<_char_type, _traits_type>* args[] = 
    {&wrp1, &wrp2, &wrp3, &wrp4, &wrp5, &wrp6};

    return xprintf_range(os, format, format+_traits_type::length(format), args, args+6);
}

template<
    typename _char_type, 
    typename _traits_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type,
    typename _argument6_type,
    typename _argument7_type>
std::basic_ostream<_char_type, _traits_type>& 
xprintf(std::basic_ostream<_char_type, _traits_type>& os, 
        const _char_type* format, 
        const _argument1_type& arg1,
        const _argument2_type& arg2,
        const _argument3_type& arg3,
        const _argument4_type& arg4,
        const _argument5_type& arg5,
        const _argument6_type& arg6,
        const _argument7_type& arg7)
{
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument1_type> wrp1(arg1);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument2_type> wrp2(arg2);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument3_type> wrp3(arg3);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument4_type> wrp4(arg4);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument5_type> wrp5(arg5);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument6_type> wrp6(arg6);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument7_type> wrp7(arg7);

    const detail::xprintf_argument_wrapper_base<_char_type, _traits_type>* args[] = 
    {&wrp1, &wrp2, &wrp3, &wrp4, &wrp5, &wrp6, &wrp7};

    return xprintf_range(os, format, format+_traits_type::length(format), args, args+7);
}

template<
    typename _char_type, 
    typename _traits_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type,
    typename _argument6_type,
    typename _argument7_type,
    typename _argument8_type>
std::basic_ostream<_char_type, _traits_type>& 
xprintf(std::basic_ostream<_char_type, _traits_type>& os, 
        const _char_type* format, 
        const _argument1_type& arg1,
        const _argument2_type& arg2,
        const _argument3_type& arg3,
        const _argument4_type& arg4,
        const _argument5_type& arg5,
        const _argument6_type& arg6,
        const _argument7_type& arg7,
        const _argument8_type& arg8)
{
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument1_type> wrp1(arg1);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument2_type> wrp2(arg2);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument3_type> wrp3(arg3);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument4_type> wrp4(arg4);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument5_type> wrp5(arg5);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument6_type> wrp6(arg6);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument7_type> wrp7(arg7);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument8_type> wrp8(arg8);

    const detail::xprintf_argument_wrapper_base<_char_type, _traits_type>* args[] = 
    {&wrp1, &wrp2, &wrp3, &wrp4, &wrp5, &wrp6, &wrp7, &wrp8};

    return xprintf_range(os, format, format+_traits_type::length(format), args, args+8);
}

template<
    typename _char_type, 
    typename _traits_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type,
    typename _argument6_type,
    typename _argument7_type,
    typename _argument8_type,
    typename _argument9_type>
std::basic_ostream<_char_type, _traits_type>& 
xprintf(std::basic_ostream<_char_type, _traits_type>& os, 
        const _char_type* format, 
        const _argument1_type& arg1,
        const _argument2_type& arg2,
        const _argument3_type& arg3,
        const _argument4_type& arg4,
        const _argument5_type& arg5,
        const _argument6_type& arg6,
        const _argument7_type& arg7,
        const _argument8_type& arg8,
        const _argument9_type& arg9)
{
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument1_type> wrp1(arg1);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument2_type> wrp2(arg2);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument3_type> wrp3(arg3);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument4_type> wrp4(arg4);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument5_type> wrp5(arg5);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument6_type> wrp6(arg6);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument7_type> wrp7(arg7);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument8_type> wrp8(arg8);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument9_type> wrp9(arg9);

    const detail::xprintf_argument_wrapper_base<_char_type, _traits_type>* args[] = 
    {&wrp1, &wrp2, &wrp3, &wrp4, &wrp5, &wrp6, &wrp7, &wrp8, &wrp9};

    return xprintf_range(os, format, format+_traits_type::length(format), args, args+9);
}

template<
    typename _char_type, 
    typename _traits_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type,
    typename _argument6_type,
    typename _argument7_type,
    typename _argument8_type,
    typename _argument9_type,
    typename _argument10_type>
std::basic_ostream<_char_type, _traits_type>& 
xprintf(std::basic_ostream<_char_type, _traits_type>& os, 
        const _char_type* format, 
        const _argument1_type& arg1,
        const _argument2_type& arg2,
        const _argument3_type& arg3,
        const _argument4_type& arg4,
        const _argument5_type& arg5,
        const _argument6_type& arg6,
        const _argument7_type& arg7,
        const _argument8_type& arg8,
        const _argument9_type& arg9,
        const _argument10_type& arg10)
{
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument1_type> wrp1(arg1);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument2_type> wrp2(arg2);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument3_type> wrp3(arg3);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument4_type> wrp4(arg4);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument5_type> wrp5(arg5);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument6_type> wrp6(arg6);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument7_type> wrp7(arg7);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument8_type> wrp8(arg8);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument9_type> wrp9(arg9);
    detail::xprintf_argument_wrapper<_char_type, _traits_type, _argument10_type> wrp10(arg10);

    const detail::xprintf_argument_wrapper_base<_char_type, _traits_type>* args[] = 
    {&wrp1, &wrp2, &wrp3, &wrp4, &wrp5, &wrp6, &wrp7, &wrp8, &wrp9, &wrp10};

    return xprintf_range(os, format, format+_traits_type::length(format), args, args+10);
}


/***********************************************************************************************************/
/* xprintf - basic_string **********************************************************************************/
/***********************************************************************************************************/

template<typename _char_type>
std::basic_string<_char_type>
xprintf(const _char_type* format)
{
    typedef std::char_traits<_char_type> traits_type;
    const detail::xprintf_argument_wrapper_base<_char_type, traits_type>* args = 0;

    std::basic_ostringstream<_char_type, traits_type> oss;

    xprintf_range(oss, format, format+traits_type::length(format), &args, &args);
    return oss.str();
}

template<
    typename _char_type, 
    typename _argument1_type>
std::basic_string<_char_type> 
xprintf(const _char_type* format, 
        const _argument1_type& arg1)
{
    typedef std::char_traits<_char_type> traits_type;
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument1_type> wrp1(arg1);

    const detail::xprintf_argument_wrapper_base<_char_type, traits_type>* args[] = 
    {&wrp1};

    std::basic_ostringstream<_char_type, traits_type> oss;

    xprintf_range(oss, format, format+traits_type::length(format), args, args+1);
    return oss.str();
}

template<
    typename _char_type, 
    typename _argument1_type,
    typename _argument2_type>
std::basic_string<_char_type> 
xprintf(const _char_type* format, 
        const _argument1_type& arg1,
        const _argument2_type& arg2)
{
    typedef std::char_traits<_char_type> traits_type;
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument1_type> wrp1(arg1);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument2_type> wrp2(arg2);

    const detail::xprintf_argument_wrapper_base<_char_type, traits_type>* args[] = 
    {&wrp1, &wrp2};

    std::basic_ostringstream<_char_type, traits_type> oss;

    xprintf_range(oss, format, format+traits_type::length(format), args, args+2);
    return oss.str();
}

template<
    typename _char_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type>
std::basic_string<_char_type> 
xprintf(const _char_type* format, 
        const _argument1_type& arg1,
        const _argument2_type& arg2,
        const _argument3_type& arg3)
{
    typedef std::char_traits<_char_type> traits_type;
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument1_type> wrp1(arg1);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument2_type> wrp2(arg2);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument3_type> wrp3(arg3);

    const detail::xprintf_argument_wrapper_base<_char_type, traits_type>* args[] = 
    {&wrp1, &wrp2, &wrp3};

    std::basic_ostringstream<_char_type, traits_type> oss;

    xprintf_range(oss, format, format+traits_type::length(format), args, args+3);
    return oss.str();
}

template<
    typename _char_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type>
std::basic_string<_char_type> 
xprintf(const _char_type* format, 
        const _argument1_type& arg1,
        const _argument2_type& arg2,
        const _argument3_type& arg3,
        const _argument4_type& arg4)
{
    typedef std::char_traits<_char_type> traits_type;
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument1_type> wrp1(arg1);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument2_type> wrp2(arg2);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument3_type> wrp3(arg3);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument4_type> wrp4(arg4);

    const detail::xprintf_argument_wrapper_base<_char_type, traits_type>* args[] = 
    {&wrp1, &wrp2, &wrp3, &wrp4};

    std::basic_ostringstream<_char_type, traits_type> oss;

    xprintf_range(oss, format, format+traits_type::length(format), args, args+4);
    return oss.str();
}

template<
    typename _char_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type>
std::basic_string<_char_type> 
xprintf(const _char_type* format, 
        const _argument1_type& arg1,
        const _argument2_type& arg2,
        const _argument3_type& arg3,
        const _argument4_type& arg4,
        const _argument5_type& arg5)
{
    typedef std::char_traits<_char_type> traits_type;
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument1_type> wrp1(arg1);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument2_type> wrp2(arg2);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument3_type> wrp3(arg3);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument4_type> wrp4(arg4);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument5_type> wrp5(arg5);

    const detail::xprintf_argument_wrapper_base<_char_type, traits_type>* args[] = 
    {&wrp1, &wrp2, &wrp3, &wrp4, &wrp5};

    std::basic_ostringstream<_char_type, traits_type> oss;

    xprintf_range(oss, format, format+traits_type::length(format), args, args+5);
    return oss.str();
}

template<
    typename _char_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type,
    typename _argument6_type>
std::basic_string<_char_type> 
xprintf(const _char_type* format, 
        const _argument1_type& arg1,
        const _argument2_type& arg2,
        const _argument3_type& arg3,
        const _argument4_type& arg4,
        const _argument5_type& arg5,
        const _argument6_type& arg6)
{
    typedef std::char_traits<_char_type> traits_type;
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument1_type> wrp1(arg1);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument2_type> wrp2(arg2);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument3_type> wrp3(arg3);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument4_type> wrp4(arg4);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument5_type> wrp5(arg5);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument6_type> wrp6(arg6);

    const detail::xprintf_argument_wrapper_base<_char_type, traits_type>* args[] = 
    {&wrp1, &wrp2, &wrp3, &wrp4, &wrp5, &wrp6};

    std::basic_ostringstream<_char_type, traits_type> oss;

    xprintf_range(oss, format, format+traits_type::length(format), args, args+6);
    return oss.str();
}

template<
    typename _char_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type,
    typename _argument6_type,
    typename _argument7_type>
std::basic_string<_char_type> 
xprintf(const _char_type* format, 
        const _argument1_type& arg1,
        const _argument2_type& arg2,
        const _argument3_type& arg3,
        const _argument4_type& arg4,
        const _argument5_type& arg5,
        const _argument6_type& arg6,
        const _argument7_type& arg7)
{
    typedef std::char_traits<_char_type> traits_type;
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument1_type> wrp1(arg1);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument2_type> wrp2(arg2);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument3_type> wrp3(arg3);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument4_type> wrp4(arg4);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument5_type> wrp5(arg5);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument6_type> wrp6(arg6);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument7_type> wrp7(arg7);

    const detail::xprintf_argument_wrapper_base<_char_type, traits_type>* args[] = 
    {&wrp1, &wrp2, &wrp3, &wrp4, &wrp5, &wrp6, &wrp7};

    std::basic_ostringstream<_char_type, traits_type> oss;

    xprintf_range(oss, format, format+traits_type::length(format), args, args+7);
    return oss.str();
}

template<
    typename _char_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type,
    typename _argument6_type,
    typename _argument7_type,
    typename _argument8_type>
std::basic_string<_char_type> 
xprintf(const _char_type* format, 
        const _argument1_type& arg1,
        const _argument2_type& arg2,
        const _argument3_type& arg3,
        const _argument4_type& arg4,
        const _argument5_type& arg5,
        const _argument6_type& arg6,
        const _argument7_type& arg7,
        const _argument8_type& arg8)
{
    typedef std::char_traits<_char_type> traits_type;
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument1_type> wrp1(arg1);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument2_type> wrp2(arg2);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument3_type> wrp3(arg3);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument4_type> wrp4(arg4);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument5_type> wrp5(arg5);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument6_type> wrp6(arg6);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument7_type> wrp7(arg7);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument8_type> wrp8(arg8);

    const detail::xprintf_argument_wrapper_base<_char_type, traits_type>* args[] = 
    {&wrp1, &wrp2, &wrp3, &wrp4, &wrp5, &wrp6, &wrp7, &wrp8};

    std::basic_ostringstream<_char_type, traits_type> oss;

    xprintf_range(oss, format, format+traits_type::length(format), args, args+8);
    return oss.str();
}

template<
    typename _char_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type,
    typename _argument6_type,
    typename _argument7_type,
    typename _argument8_type,
    typename _argument9_type>
std::basic_string<_char_type> 
xprintf(const _char_type* format, 
        const _argument1_type& arg1,
        const _argument2_type& arg2,
        const _argument3_type& arg3,
        const _argument4_type& arg4,
        const _argument5_type& arg5,
        const _argument6_type& arg6,
        const _argument7_type& arg7,
        const _argument8_type& arg8,
        const _argument9_type& arg9)
{
    typedef std::char_traits<_char_type> traits_type;
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument1_type> wrp1(arg1);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument2_type> wrp2(arg2);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument3_type> wrp3(arg3);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument4_type> wrp4(arg4);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument5_type> wrp5(arg5);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument6_type> wrp6(arg6);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument7_type> wrp7(arg7);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument8_type> wrp8(arg8);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument9_type> wrp9(arg9);

    const detail::xprintf_argument_wrapper_base<_char_type, traits_type>* args[] = 
    {&wrp1, &wrp2, &wrp3, &wrp4, &wrp5, &wrp6, &wrp7, &wrp8, &wrp9};

    std::basic_ostringstream<_char_type, traits_type> oss;

    xprintf_range(oss, format, format+traits_type::length(format), args, args+9);
    return oss.str();
}

template<
    typename _char_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type,
    typename _argument6_type,
    typename _argument7_type,
    typename _argument8_type,
    typename _argument9_type,
    typename _argument10_type>
std::basic_string<_char_type> 
xprintf(const _char_type* format, 
        const _argument1_type& arg1,
        const _argument2_type& arg2,
        const _argument3_type& arg3,
        const _argument4_type& arg4,
        const _argument5_type& arg5,
        const _argument6_type& arg6,
        const _argument7_type& arg7,
        const _argument8_type& arg8,
        const _argument9_type& arg9,
        const _argument10_type& arg10)
{
    typedef std::char_traits<_char_type> traits_type;
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument1_type> wrp1(arg1);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument2_type> wrp2(arg2);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument3_type> wrp3(arg3);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument4_type> wrp4(arg4);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument5_type> wrp5(arg5);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument6_type> wrp6(arg6);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument7_type> wrp7(arg7);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument8_type> wrp8(arg8);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument9_type> wrp9(arg9);
    detail::xprintf_argument_wrapper<_char_type, traits_type, _argument10_type> wrp10(arg10);

    const detail::xprintf_argument_wrapper_base<_char_type, traits_type>* args[] = 
    {&wrp1, &wrp2, &wrp3, &wrp4, &wrp5, &wrp6, &wrp7, &wrp8, &wrp9, &wrp10};

    std::basic_ostringstream<_char_type, traits_type> oss;

    xprintf_range(oss, format, format+traits_type::length(format), args, args+10);
    return oss.str();
}


/***********************************************************************************************************/
/* xprintf_range *******************************************************************************************/
/***********************************************************************************************************/

template<typename _char_type, typename _traits_type, typename _argument_iter_type> 
std::basic_ostream<_char_type, _traits_type>& 
xprintf_range(std::basic_ostream<_char_type, _traits_type>& os, 
              const _char_type* format, 
              _argument_iter_type arg_begin,
              _argument_iter_type arg_end) 
{
    return xprintf_range(os, format, format+_traits_type::length(format), arg_begin, arg_end);
}


template<typename _char_type, typename _traits_type, typename _argument_iter_type> 
std::basic_ostream<_char_type, _traits_type>& 
xprintf_range(std::basic_ostream<_char_type, _traits_type>& os, 
              const _char_type* format_begin, 
              const _char_type* format_end, 
              _argument_iter_type arg_begin,
              _argument_iter_type arg_end) 
{
    typedef std::basic_ostream<_char_type, _traits_type> ostream_type; 
    typedef std::basic_streambuf<_char_type, _traits_type> streambuf_type;
    typedef detail::xformat_cache<_char_type, _traits_type> cache_type;

    static const detail::format_char_info* ft_info = detail::format_char_info::get_defaults();

    cache_type* cache = cache_type::get(os);
    const std::ctype<_char_type>& conv = *cache->conv; 
    const _char_type ch_perc = cache->ch_perc;
    const _char_type ch_dollar = cache->ch_dollar;
    const _char_type ch_lb = cache->ch_lb;
    const _char_type ch_rb = cache->ch_rb;

    const typename ostream_type::sentry sentry(os); 

    if (!sentry)
        return os;

    std::ios_base::iostate state = std::ios_base::goodbit;
    std::ios_base::fmtflags saved_flags = os.flags();
    std::streamsize saved_precision = os.precision();
    int cur_arg_index = 0;
    const _char_type* cur=format_begin;
    bool in_argument = false;

    try {
        while (cur<format_end) {
            streambuf_type* sb = os.rdbuf();
            int new_arg_index = -1;

            if (!os || !sb) {
                os.flags(saved_flags);
                os.precision(saved_precision);
                return os;
            }

            const _char_type* perc_pos = _traits_type::find(cur, format_end-cur, ch_perc);

            // no other format field in the rest for the format string?
            if (!perc_pos) {
                std::streamsize count = format_end-cur;

                if (sb->sputn(cur, count) != count) {
                    state |= std::ios_base::badbit;
                    break;
                }
                break;
            }

            std::ios_base::fmtflags cur_flags = saved_flags;
            std::streamsize cur_precision = saved_precision;
            std::streamsize cur_width = 0;
            bool has_width = false;

            int num;

            // write up to the current percent sign
            if (perc_pos > cur) {
                std::streamsize count = perc_pos-cur;

                if (sb->sputn(cur, count) != count) {
                    state |= std::ios_base::badbit;
                    break;
                }
            }

            cur = perc_pos+1;

            // if reached end of format string early
            if (cur >= format_end) {
                state |= std::ios_base::failbit;
                if (os.exceptions() & std::ios_base::failbit)
                    throw format_error("xprintf: incomplete field at the end of format string!");
                break;
            }

            // handle the %%
            if (*cur == ch_perc) {
                ++cur;

                if (_traits_type::eq_int_type(_traits_type::eof(), sb->sputc(ch_perc))) {
                    state |= std::ios_base::badbit;
                    break;
                }
                continue;
            }

            // so this must be a formatted field
            cur_arg_index++;

            // read the argument index or field width
            cur = detail::read_number(cur, format_end, num, conv); 

            // if reached end of format string early
            if (cur >= format_end) {
                state |= std::ios_base::failbit;
                if (os.exceptions() & std::ios_base::failbit)
                    throw format_error("xprintf: incomplete field at the end of format string!");
                break;
            }

            // did we read anything for argument index or field width?
            if (cur > perc_pos+1) {
                // handle positional argument
                if (*cur == ch_dollar) {
                    // is argument index out of range?
                    if (num-1 >= arg_end-arg_begin || num == 0) {
                        state |= std::ios_base::failbit;
                        if (os.exceptions() & std::ios_base::failbit)
                            throw argument_index_error("xprintf: argument index out of range");
                        break;
                    }

                    // skip the $
                    ++cur;

                    // if reached end of format string early
                    if (cur >= format_end) {
                        state |= std::ios_base::failbit;
                        if (os.exceptions() & std::ios_base::failbit)
                            throw format_error("xprintf: incomplete field at the end of format string!");
                        break;
                    }

                    new_arg_index = num;
                }
                // so it must be field width
                else {
                    cur_width = num;
                    has_width = true;
                }
            }

            // handle the sub-format  %{...} 
            if (!has_width && *cur == ch_lb) {
                ++cur;

                const _char_type* subfmt_begin = cur;
                int balance = 1;

                for (; cur<format_end; ++cur) {
                    if (*cur == ch_rb)
                        balance--;
                    else if (*cur == ch_lb)
                        balance++;

                    if (balance <= 0)
                        break;
                }

                // if reached end of format string before a matching }
                if (cur >= format_end) {
                    state |= std::ios_base::failbit;
                    if (os.exceptions() & std::ios_base::failbit)
                        throw format_error("xprintf: field subformat not closed with a '}'");
                    break;
                }

                const _char_type* subfmt_end = cur;

                ++cur;

                if (new_arg_index != -1) 
                    cur_arg_index = new_arg_index;

                if (cur_arg_index-1 >= arg_end-arg_begin) {
                    state |= std::ios_base::failbit;
                    if (os.exceptions() & std::ios_base::failbit)
                        throw argument_index_error("xprintf: argument index out of range");
                    break;
                }

                os.flags(cur_flags);
                os.precision(cur_precision);
                os.width(cur_width);
                in_argument = true;
                xprintf_one(os, subfmt_begin, subfmt_end, arg_begin[cur_arg_index-1]);
                in_argument = false;
                if (!os.good())
                    break;
            }
            else {
                char cur_ch =0;

                // reset the flags 
                cur_flags &= ~(std::ios_base::adjustfield | std::ios_base::showpos | std::ios_base::showpoint 
                    | std::ios_base::showbase | std::ios_base::boolalpha);
                cur_flags |= std::ios_base::right;

                // if we haven't read the field width before
                if (!has_width)
                {
                    // read the flags 
                    for (; cur<format_end; ++cur) {
                        cur_ch = detail::do_narrow(*cur, conv);

                        const detail::format_char_info& info = ft_info[(int)cur_ch];

                        if (info.type != detail::format_char_info::c_flags)
                            break;

                        cur_flags &= ~info.cflags;
                        cur_flags |= info.sflags;
                    }

                    // if reached end of format string early
                    if (cur >= format_end) {
                        state |= std::ios_base::failbit;
                        if (os.exceptions() & std::ios_base::failbit)
                            throw format_error("xprintf: incomplete field at the end of format string!");
                        break;
                    }

                    // read the width field
                    if (cur_ch >= '0' && cur_ch <= '9') {
                        cur = detail::read_number(cur, format_end, num, conv);
                        cur_width = num;
                        has_width = true;

                        // if reached end of format string early
                        if (cur >= format_end) {
                            state |= std::ios_base::failbit;
                            if (os.exceptions() & std::ios_base::failbit)
                                throw format_error("xprintf: incomplete field at the end of format string!");
                            break;
                        }
                        cur_ch = detail::do_narrow(*cur, conv);
                    }
                }
                else
                    cur_ch = detail::do_narrow(*cur, conv);

                // read the precision field
                if (cur_ch == '.') {
                    // skip the .
                    ++cur;

                    // if reached end of format string early
                    if (cur >= format_end) {
                        state |= std::ios_base::failbit;
                        if (os.exceptions() & std::ios_base::failbit)
                            throw format_error("xprintf: incomplete field at the end of format string!");
                        break;
                    }

                    cur = detail::read_number(cur, format_end, num, conv);
                    cur_precision = num;

                    // if reached end of format string early
                    if (cur >= format_end) {
                        state |= std::ios_base::failbit;
                        if (os.exceptions() & std::ios_base::failbit)
                            throw format_error("xprintf: incomplete field at the end of format string!");
                        break;
                    }
                    cur_ch = detail::do_narrow(*cur, conv);
                }

                bool complete = false;

                // read the type field with some optional prefixes
                for (; cur<format_end; ++cur) {
                    cur_ch = detail::do_narrow(*cur, conv);

                    const detail::format_char_info& info = ft_info[(int)cur_ch];

                    if (info.type == detail::format_char_info::c_type) {
                        cur_flags &= ~info.cflags;
                        cur_flags |= info.sflags;
                        complete = true;
                        break;
                    }
                    if (info.type == detail::format_char_info::c_prefix) {
                        cur_flags &= ~info.cflags;
                        cur_flags |= info.sflags;
                        continue;
                    }

                    break;
                }

                // if reached end of format string early
                if (cur >= format_end) {
                    state |= std::ios_base::failbit;
                    if (os.exceptions() & std::ios_base::failbit)
                        throw format_error("xprintf: incomplete field at the end of format string!");
                    break;
                }

                // if complete, print the argument according to the format
                if (complete) {
                    ++cur;

                    if (new_arg_index != -1) 
                        cur_arg_index = new_arg_index;

                    if (cur_arg_index-1 >= arg_end-arg_begin) {
                        state |= std::ios_base::failbit;
                        if (os.exceptions() & std::ios_base::failbit)
                            throw argument_index_error("xprintf: argument index out of range");
                        break;
                    }

                    os.flags(cur_flags);
                    os.precision(cur_precision);
                    os.width(cur_width);
                    in_argument = true;
                    xprintf_one(os, perc_pos+1, perc_pos+1, arg_begin[cur_arg_index-1]);
                    in_argument = false;
                    if (!os.good())
                        break;
                    continue;
                }

                // ignore the %n
                if (cur_ch == 'n') {
                    ++cur;
                    continue;
                }

                // if not complete, print the format string up to here verbatim and continue
                state |= std::ios_base::failbit;
                if (os.exceptions() & std::ios_base::failbit)
                    throw format_error("xprintf: unrecognized format field!");
                break;
            }
        }
    }
    catch (...) {
        state |= os.rdstate();
        os.flags(saved_flags);
        os.precision(saved_precision);

        if (state == std::ios_base::goodbit)
            state |= in_argument ? std::ios_base::failbit : std::ios_base::badbit;

        try { os.setstate(state); } catch (...) {}

        if (state & os.exceptions())
            throw;
    }

    os.flags(saved_flags);
    os.precision(saved_precision);
    os.setstate(state);
    return os;
}

/***********************************************************************************************************/
/* xscanf_one **********************************************************************************************/
/***********************************************************************************************************/

template<typename _char_type, typename _traits_type> 
std::basic_istream<_char_type, _traits_type>& 
xscanf_one(std::basic_istream<_char_type, _traits_type>& is, 
           const _char_type* format_begin, 
           const _char_type* format_end, 
           const detail::xscanf_argument_wrapper_base<_char_type, _traits_type>* argument_wrapper)
{
    return argument_wrapper->do_scan(is, format_begin, format_end);
}


template<typename _char_type, typename _traits_type, typename _argument_type> 
std::basic_istream<_char_type, _traits_type>& 
xscanf_one(std::basic_istream<_char_type, _traits_type>& is, 
           const _char_type*, 
           const _char_type*, 
           _argument_type& argument)
{
    return is >> argument;
}

/***********************************************************************************************************/
/* xscanf - basic_istream **********************************************************************************/
/***********************************************************************************************************/

template<typename _char_type, typename _traits_type>
std::basic_istream<_char_type, _traits_type>& 
xscanf(std::basic_istream<_char_type, _traits_type>& is, const _char_type* format)
{
    const detail::xscanf_argument_wrapper_base<_char_type, _traits_type>* args = 0;

    return xscanf_range(is, format, format+_traits_type::length(format), &args, &args);
}

template<
    typename _char_type, 
    typename _traits_type, 
    typename _argument1_type>
std::basic_istream<_char_type, _traits_type>& 
xscanf(std::basic_istream<_char_type, _traits_type>& is, 
       const _char_type* format, 
       _argument1_type& arg1)
{
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument1_type> wrp1(arg1);

    const detail::xscanf_argument_wrapper_base<_char_type, _traits_type>* args[] = 
    {&wrp1};

    return xscanf_range(is, format, format+_traits_type::length(format), args, args+1);
}

template<
    typename _char_type, 
    typename _traits_type, 
    typename _argument1_type,
    typename _argument2_type>
std::basic_istream<_char_type, _traits_type>& 
xscanf(std::basic_istream<_char_type, _traits_type>& is, 
       const _char_type* format, 
       _argument1_type& arg1,
       _argument2_type& arg2)
{
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument1_type> wrp1(arg1);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument2_type> wrp2(arg2);

    const detail::xscanf_argument_wrapper_base<_char_type, _traits_type>* args[] = 
    {&wrp1, &wrp2};

    return xscanf_range(is, format, format+_traits_type::length(format), args, args+2);
}

template<
    typename _char_type, 
    typename _traits_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type>
std::basic_istream<_char_type, _traits_type>& 
xscanf(std::basic_istream<_char_type, _traits_type>& is, 
       const _char_type* format, 
       _argument1_type& arg1,
       _argument2_type& arg2,
       _argument3_type& arg3)
{
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument1_type> wrp1(arg1);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument2_type> wrp2(arg2);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument3_type> wrp3(arg3);

    const detail::xscanf_argument_wrapper_base<_char_type, _traits_type>* args[] = 
    {&wrp1, &wrp2, &wrp3};

    return xscanf_range(is, format, format+_traits_type::length(format), args, args+3);
}

template<
    typename _char_type, 
    typename _traits_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type>
std::basic_istream<_char_type, _traits_type>& 
xscanf(std::basic_istream<_char_type, _traits_type>& is, 
       const _char_type* format, 
       _argument1_type& arg1,
       _argument2_type& arg2,
       _argument3_type& arg3,
       _argument4_type& arg4)
{
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument1_type> wrp1(arg1);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument2_type> wrp2(arg2);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument3_type> wrp3(arg3);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument4_type> wrp4(arg4);

    const detail::xscanf_argument_wrapper_base<_char_type, _traits_type>* args[] = 
    {&wrp1, &wrp2, &wrp3, &wrp4};

    return xscanf_range(is, format, format+_traits_type::length(format), args, args+4);
}

template<
    typename _char_type, 
    typename _traits_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type>
std::basic_istream<_char_type, _traits_type>& 
xscanf(std::basic_istream<_char_type, _traits_type>& is, 
       const _char_type* format, 
       _argument1_type& arg1,
       _argument2_type& arg2,
       _argument3_type& arg3,
       _argument4_type& arg4,
       _argument5_type& arg5)
{
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument1_type> wrp1(arg1);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument2_type> wrp2(arg2);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument3_type> wrp3(arg3);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument4_type> wrp4(arg4);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument5_type> wrp5(arg5);

    const detail::xscanf_argument_wrapper_base<_char_type, _traits_type>* args[] = 
    {&wrp1, &wrp2, &wrp3, &wrp4, &wrp5};

    return xscanf_range(is, format, format+_traits_type::length(format), args, args+5);
}

template<
    typename _char_type, 
    typename _traits_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type,
    typename _argument6_type>
std::basic_istream<_char_type, _traits_type>& 
xscanf(std::basic_istream<_char_type, _traits_type>& is, 
       const _char_type* format, 
       _argument1_type& arg1,
       _argument2_type& arg2,
       _argument3_type& arg3,
       _argument4_type& arg4,
       _argument5_type& arg5,
       _argument6_type& arg6)
{
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument1_type> wrp1(arg1);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument2_type> wrp2(arg2);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument3_type> wrp3(arg3);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument4_type> wrp4(arg4);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument5_type> wrp5(arg5);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument6_type> wrp6(arg6);

    const detail::xscanf_argument_wrapper_base<_char_type, _traits_type>* args[] = 
    {&wrp1, &wrp2, &wrp3, &wrp4, &wrp5, &wrp6};

    return xscanf_range(is, format, format+_traits_type::length(format), args, args+6);
}

template<
    typename _char_type, 
    typename _traits_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type,
    typename _argument6_type,
    typename _argument7_type>
std::basic_istream<_char_type, _traits_type>& 
xscanf(std::basic_istream<_char_type, _traits_type>& is, 
       const _char_type* format, 
       _argument1_type& arg1,
       _argument2_type& arg2,
       _argument3_type& arg3,
       _argument4_type& arg4,
       _argument5_type& arg5,
       _argument6_type& arg6,
       _argument7_type& arg7)
{
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument1_type> wrp1(arg1);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument2_type> wrp2(arg2);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument3_type> wrp3(arg3);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument4_type> wrp4(arg4);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument5_type> wrp5(arg5);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument6_type> wrp6(arg6);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument7_type> wrp7(arg7);

    const detail::xscanf_argument_wrapper_base<_char_type, _traits_type>* args[] = 
    {&wrp1, &wrp2, &wrp3, &wrp4, &wrp5, &wrp6, &wrp7};

    return xscanf_range(is, format, format+_traits_type::length(format), args, args+7);
}

template<
    typename _char_type, 
    typename _traits_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type,
    typename _argument6_type,
    typename _argument7_type,
    typename _argument8_type>
std::basic_istream<_char_type, _traits_type>& 
xscanf(std::basic_istream<_char_type, _traits_type>& is, 
       const _char_type* format, 
       _argument1_type& arg1,
       _argument2_type& arg2,
       _argument3_type& arg3,
       _argument4_type& arg4,
       _argument5_type& arg5,
       _argument6_type& arg6,
       _argument7_type& arg7,
       _argument8_type& arg8)
{
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument1_type> wrp1(arg1);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument2_type> wrp2(arg2);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument3_type> wrp3(arg3);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument4_type> wrp4(arg4);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument5_type> wrp5(arg5);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument6_type> wrp6(arg6);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument7_type> wrp7(arg7);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument8_type> wrp8(arg8);

    const detail::xscanf_argument_wrapper_base<_char_type, _traits_type>* args[] = 
    {&wrp1, &wrp2, &wrp3, &wrp4, &wrp5, &wrp6, &wrp7, &wrp8};

    return xscanf_range(is, format, format+_traits_type::length(format), args, args+8);
}

template<
    typename _char_type, 
    typename _traits_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type,
    typename _argument6_type,
    typename _argument7_type,
    typename _argument8_type,
    typename _argument9_type>
std::basic_istream<_char_type, _traits_type>& 
xscanf(std::basic_istream<_char_type, _traits_type>& is, 
       const _char_type* format, 
       _argument1_type& arg1,
       _argument2_type& arg2,
       _argument3_type& arg3,
       _argument4_type& arg4,
       _argument5_type& arg5,
       _argument6_type& arg6,
       _argument7_type& arg7,
       _argument8_type& arg8,
       _argument9_type& arg9)
{
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument1_type> wrp1(arg1);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument2_type> wrp2(arg2);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument3_type> wrp3(arg3);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument4_type> wrp4(arg4);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument5_type> wrp5(arg5);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument6_type> wrp6(arg6);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument7_type> wrp7(arg7);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument8_type> wrp8(arg8);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument9_type> wrp9(arg9);

    const detail::xscanf_argument_wrapper_base<_char_type, _traits_type>* args[] = 
    {&wrp1, &wrp2, &wrp3, &wrp4, &wrp5, &wrp6, &wrp7, &wrp8, &wrp9};

    return xscanf_range(is, format, format+_traits_type::length(format), args, args+9);
}

template<
    typename _char_type, 
    typename _traits_type, 
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type,
    typename _argument6_type,
    typename _argument7_type,
    typename _argument8_type,
    typename _argument9_type,
    typename _argument10_type>
std::basic_istream<_char_type, _traits_type>& 
xscanf(std::basic_istream<_char_type, _traits_type>& is, 
       const _char_type* format, 
       _argument1_type& arg1,
       _argument2_type& arg2,
       _argument3_type& arg3,
       _argument4_type& arg4,
       _argument5_type& arg5,
       _argument6_type& arg6,
       _argument7_type& arg7,
       _argument8_type& arg8,
       _argument9_type& arg9,
       _argument10_type& arg10)
{
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument1_type> wrp1(arg1);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument2_type> wrp2(arg2);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument3_type> wrp3(arg3);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument4_type> wrp4(arg4);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument5_type> wrp5(arg5);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument6_type> wrp6(arg6);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument7_type> wrp7(arg7);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument8_type> wrp8(arg8);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument9_type> wrp9(arg9);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument10_type> wrp10(arg10);

    const detail::xscanf_argument_wrapper_base<_char_type, _traits_type>* args[] = 
    {&wrp1, &wrp2, &wrp3, &wrp4, &wrp5, &wrp6, &wrp7, &wrp8, &wrp9, &wrp10};

    return xscanf_range(is, format, format+_traits_type::length(format), args, args+10);
}


/***********************************************************************************************************/
/* xscanf - basic_string ***********************************************************************************/
/***********************************************************************************************************/

template<
    typename _char_type, 
    typename _traits_type,
    typename _alloc_type>
std::ios_base::iostate 
xscanf(const std::basic_string<_char_type, _traits_type, _alloc_type>& str, 
       const _char_type* format)
{
    const detail::xscanf_argument_wrapper_base<_char_type, _traits_type>* args = 0;

    std::basic_istringstream<_char_type, _traits_type> iss(str);

    return xscanf_range(iss, format, format+_traits_type::length(format), &args, &args).rdstate();
}

template<
    typename _char_type, 
    typename _traits_type,
    typename _alloc_type,
    typename _argument1_type>
std::ios_base::iostate 
xscanf(const std::basic_string<_char_type, _traits_type, _alloc_type>& str, 
       const _char_type* format, 
       _argument1_type& arg1)
{
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument1_type> wrp1(arg1);

    const detail::xscanf_argument_wrapper_base<_char_type, _traits_type>* args[] = 
    {&wrp1};

    std::basic_istringstream<_char_type, _traits_type> iss(str);

    return xscanf_range(iss, format, format+_traits_type::length(format), args, args+1).rdstate();
}

template<
    typename _char_type, 
    typename _traits_type,
    typename _alloc_type,
    typename _argument1_type,
    typename _argument2_type>
std::ios_base::iostate 
xscanf(const std::basic_string<_char_type, _traits_type, _alloc_type>& str, 
       const _char_type* format, 
       _argument1_type& arg1,
       _argument2_type& arg2)
{
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument1_type> wrp1(arg1);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument2_type> wrp2(arg2);

    const detail::xscanf_argument_wrapper_base<_char_type, _traits_type>* args[] = 
    {&wrp1, &wrp2};

    std::basic_istringstream<_char_type, _traits_type> iss(str);

    return xscanf_range(iss, format, format+_traits_type::length(format), args, args+2).rdstate();
}

template<
    typename _char_type, 
    typename _traits_type,
    typename _alloc_type,
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type>
std::ios_base::iostate 
xscanf(const std::basic_string<_char_type, _traits_type, _alloc_type>& str, 
       const _char_type* format, 
       _argument1_type& arg1,
       _argument2_type& arg2,
       _argument3_type& arg3)
{
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument1_type> wrp1(arg1);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument2_type> wrp2(arg2);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument3_type> wrp3(arg3);

    const detail::xscanf_argument_wrapper_base<_char_type, _traits_type>* args[] = 
    {&wrp1, &wrp2, &wrp3};

    std::basic_istringstream<_char_type, _traits_type> iss(str);

    return xscanf_range(iss, format, format+_traits_type::length(format), args, args+3).rdstate();
}

template<
    typename _char_type, 
    typename _traits_type,
    typename _alloc_type,
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type>
std::ios_base::iostate 
xscanf(const std::basic_string<_char_type, _traits_type, _alloc_type>& str, 
       const _char_type* format, 
       _argument1_type& arg1,
       _argument2_type& arg2,
       _argument3_type& arg3,
       _argument4_type& arg4)
{
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument1_type> wrp1(arg1);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument2_type> wrp2(arg2);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument3_type> wrp3(arg3);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument4_type> wrp4(arg4);

    const detail::xscanf_argument_wrapper_base<_char_type, _traits_type>* args[] = 
    {&wrp1, &wrp2, &wrp3, &wrp4};

    std::basic_istringstream<_char_type, _traits_type> iss(str);

    return xscanf_range(iss, format, format+_traits_type::length(format), args, args+4).rdstate();
}

template<
    typename _char_type, 
    typename _traits_type,
    typename _alloc_type,
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type>
std::ios_base::iostate 
xscanf(const std::basic_string<_char_type, _traits_type, _alloc_type>& str, 
       const _char_type* format, 
       _argument1_type& arg1,
       _argument2_type& arg2,
       _argument3_type& arg3,
       _argument4_type& arg4,
       _argument5_type& arg5)
{
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument1_type> wrp1(arg1);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument2_type> wrp2(arg2);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument3_type> wrp3(arg3);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument4_type> wrp4(arg4);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument5_type> wrp5(arg5);

    const detail::xscanf_argument_wrapper_base<_char_type, _traits_type>* args[] = 
    {&wrp1, &wrp2, &wrp3, &wrp4, &wrp5};

    std::basic_istringstream<_char_type, _traits_type> iss(str);

    return xscanf_range(iss, format, format+_traits_type::length(format), args, args+5).rdstate();
}

template<
    typename _char_type, 
    typename _traits_type,
    typename _alloc_type,
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type,
    typename _argument6_type>
std::ios_base::iostate 
xscanf(const std::basic_string<_char_type, _traits_type, _alloc_type>& str, 
       const _char_type* format, 
       _argument1_type& arg1,
       _argument2_type& arg2,
       _argument3_type& arg3,
       _argument4_type& arg4,
       _argument5_type& arg5,
       _argument6_type& arg6)
{
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument1_type> wrp1(arg1);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument2_type> wrp2(arg2);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument3_type> wrp3(arg3);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument4_type> wrp4(arg4);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument5_type> wrp5(arg5);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument6_type> wrp6(arg6);

    const detail::xscanf_argument_wrapper_base<_char_type, _traits_type>* args[] = 
    {&wrp1, &wrp2, &wrp3, &wrp4, &wrp5, &wrp6};

    std::basic_istringstream<_char_type, _traits_type> iss(str);

    return xscanf_range(iss, format, format+_traits_type::length(format), args, args+6).rdstate();
}

template<
    typename _char_type, 
    typename _traits_type,
    typename _alloc_type,
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type,
    typename _argument6_type,
    typename _argument7_type>
std::ios_base::iostate 
xscanf(const std::basic_string<_char_type, _traits_type, _alloc_type>& str, 
       const _char_type* format, 
       _argument1_type& arg1,
       _argument2_type& arg2,
       _argument3_type& arg3,
       _argument4_type& arg4,
       _argument5_type& arg5,
       _argument6_type& arg6,
       _argument7_type& arg7)
{
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument1_type> wrp1(arg1);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument2_type> wrp2(arg2);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument3_type> wrp3(arg3);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument4_type> wrp4(arg4);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument5_type> wrp5(arg5);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument6_type> wrp6(arg6);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument7_type> wrp7(arg7);

    const detail::xscanf_argument_wrapper_base<_char_type, _traits_type>* args[] = 
    {&wrp1, &wrp2, &wrp3, &wrp4, &wrp5, &wrp6, &wrp7};

    std::basic_istringstream<_char_type, _traits_type> iss(str);

    return xscanf_range(iss, format, format+_traits_type::length(format), args, args+7).rdstate();
}

template<
    typename _char_type, 
    typename _traits_type,
    typename _alloc_type,
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type,
    typename _argument6_type,
    typename _argument7_type,
    typename _argument8_type>
std::ios_base::iostate 
xscanf(const std::basic_string<_char_type, _traits_type, _alloc_type>& str, 
       const _char_type* format, 
       _argument1_type& arg1,
       _argument2_type& arg2,
       _argument3_type& arg3,
       _argument4_type& arg4,
       _argument5_type& arg5,
       _argument6_type& arg6,
       _argument7_type& arg7,
       _argument8_type& arg8)
{
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument1_type> wrp1(arg1);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument2_type> wrp2(arg2);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument3_type> wrp3(arg3);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument4_type> wrp4(arg4);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument5_type> wrp5(arg5);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument6_type> wrp6(arg6);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument7_type> wrp7(arg7);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument8_type> wrp8(arg8);

    const detail::xscanf_argument_wrapper_base<_char_type, _traits_type>* args[] = 
    {&wrp1, &wrp2, &wrp3, &wrp4, &wrp5, &wrp6, &wrp7, &wrp8};

    std::basic_istringstream<_char_type, _traits_type> iss(str);

    return xscanf_range(iss, format, format+_traits_type::length(format), args, args+8).rdstate();
}

template<
    typename _char_type, 
    typename _traits_type,
    typename _alloc_type,
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type,
    typename _argument6_type,
    typename _argument7_type,
    typename _argument8_type,
    typename _argument9_type>
std::ios_base::iostate 
xscanf(const std::basic_string<_char_type, _traits_type, _alloc_type>& str, 
       const _char_type* format, 
       _argument1_type& arg1,
       _argument2_type& arg2,
       _argument3_type& arg3,
       _argument4_type& arg4,
       _argument5_type& arg5,
       _argument6_type& arg6,
       _argument7_type& arg7,
       _argument8_type& arg8,
       _argument9_type& arg9)
{
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument1_type> wrp1(arg1);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument2_type> wrp2(arg2);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument3_type> wrp3(arg3);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument4_type> wrp4(arg4);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument5_type> wrp5(arg5);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument6_type> wrp6(arg6);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument7_type> wrp7(arg7);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument8_type> wrp8(arg8);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument9_type> wrp9(arg9);

    const detail::xscanf_argument_wrapper_base<_char_type, _traits_type>* args[] = 
    {&wrp1, &wrp2, &wrp3, &wrp4, &wrp5, &wrp6, &wrp7, &wrp8, &wrp9};

    std::basic_istringstream<_char_type, _traits_type> iss(str);

    return xscanf_range(iss, format, format+_traits_type::length(format), args, args+9).rdstate();
}

template<
    typename _char_type, 
    typename _traits_type,
    typename _alloc_type,
    typename _argument1_type,
    typename _argument2_type,
    typename _argument3_type,
    typename _argument4_type,
    typename _argument5_type,
    typename _argument6_type,
    typename _argument7_type,
    typename _argument8_type,
    typename _argument9_type,
    typename _argument10_type>
std::ios_base::iostate 
xscanf(const std::basic_string<_char_type, _traits_type, _alloc_type>& str, 
       const _char_type* format, 
       _argument1_type& arg1,
       _argument2_type& arg2,
       _argument3_type& arg3,
       _argument4_type& arg4,
       _argument5_type& arg5,
       _argument6_type& arg6,
       _argument7_type& arg7,
       _argument8_type& arg8,
       _argument9_type& arg9,
       _argument10_type& arg10)
{
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument1_type> wrp1(arg1);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument2_type> wrp2(arg2);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument3_type> wrp3(arg3);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument4_type> wrp4(arg4);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument5_type> wrp5(arg5);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument6_type> wrp6(arg6);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument7_type> wrp7(arg7);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument8_type> wrp8(arg8);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument9_type> wrp9(arg9);
    detail::xscanf_argument_wrapper<_char_type, _traits_type, _argument10_type> wrp10(arg10);

    const detail::xscanf_argument_wrapper_base<_char_type, _traits_type>* args[] = 
    {&wrp1, &wrp2, &wrp3, &wrp4, &wrp5, &wrp6, &wrp7, &wrp8, &wrp9, &wrp10};

    std::basic_istringstream<_char_type, _traits_type> iss(str);

    return xscanf_range(iss, format, format+_traits_type::length(format), args, args+10).rdstate();
}



/***********************************************************************************************************/
/* xscanf_range ********************************************************************************************/
/***********************************************************************************************************/

template<typename _char_type, typename _traits_type, typename _argument_iter_type> 
std::basic_istream<_char_type, _traits_type>& 
xscanf_range(std::basic_istream<_char_type, _traits_type>& is, 
             const _char_type* format, 
             _argument_iter_type arg_begin,
             _argument_iter_type arg_end) 
{
    return xscanf_range(is, format, _traits_type::length(format), arg_begin, arg_end);
}

template<typename _char_type, typename _traits_type, typename _argument_iter_type> 
std::basic_istream<_char_type, _traits_type>& 
xscanf_range(std::basic_istream<_char_type, _traits_type>& is, 
             const _char_type* format_begin, 
             const _char_type* format_end, 
             _argument_iter_type arg_begin,
             _argument_iter_type arg_end)
{
    typedef std::basic_istream<_char_type, _traits_type> istream_type; 
    typedef detail::xformat_cache<_char_type, _traits_type> cache_type;

    static const detail::format_char_info* ft_info = detail::format_char_info::get_defaults();

    cache_type* cache = cache_type::get(is);
    const std::ctype<_char_type>& conv = *cache->conv; 
    const _char_type ch_perc = cache->ch_perc;
    const _char_type ch_dollar = cache->ch_dollar;
    const _char_type ch_lb = cache->ch_lb;
    const _char_type ch_rb = cache->ch_rb;

    const typename istream_type::sentry sentry(is); 

    if (!sentry)
        return is;

    std::ios_base::iostate state = std::ios_base::goodbit;
    std::ios_base::fmtflags saved_flags = is.flags();
    std::streamsize saved_precision = is.precision();
    int cur_arg_index = 0;
    const _char_type* cur=format_begin;
    bool in_argument = false;

    try {
        while (cur<format_end) {
            int new_arg_index = -1;
            const _char_type* perc_pos =0;

            if (!is) {
                is.flags(saved_flags);
                is.precision(saved_precision);
                return is;
            }

            // match every character until the next percent sign
            {
                std::istreambuf_iterator<_char_type, _traits_type> it(is), it_end;

                for (;;) {
                    if (cur >= format_end) {
                        is.flags(saved_flags);
                        is.precision(saved_precision);
                        return is;
                    }

                    // a percent sign?
                    if (*cur == ch_perc) {
                        perc_pos = cur;
                        ++cur;

                        if (cur >= format_end) {
                            state |= std::ios_base::failbit;
                            if (is.exceptions() & std::ios_base::failbit)
                                throw format_error("xscanf: incomplete field at the end of format string!");
                            break;
                        }

                        // if the following is not a percent sign then this is a field type character
                        if (*cur != ch_perc) 
                            break;
                    }

                    if (it == it_end) {
                        state |= std::ios_base::eofbit | std::ios_base::failbit;
                        if (is.exceptions() & std::ios_base::failbit)
                            throw input_mismatch_error("xscanf: input too short for the given format string!");
                        break;
                    }

                    // skip white space
                    if (conv.is(std::ctype_base::space, *cur)) {
                        while (it != it_end && conv.is(std::ctype_base::space, *it))
                            ++it;
                        ++cur;
                    }
                    else {
                        if (*cur != *it) {
                            state |= std::ios_base::failbit;
                            if (is.exceptions() & std::ios_base::failbit)
                                throw input_mismatch_error("xscanf: input not matching the format string!");
                            break;
                        }
                        ++cur;
                        ++it;
                    }
                }
            }

            if (state != std::ios_base::goodbit)
                break;

            std::ios_base::fmtflags cur_flags = saved_flags;
            std::streamsize cur_precision = saved_precision;
            std::streamsize cur_width = 0;
            bool has_width = false;

            int num;

            // so this must be a formatted field
            cur_arg_index++;

            // read the argument index or field width
            cur = detail::read_number(cur, format_end, num, conv); 

            // if reached end of format string early
            if (cur >= format_end) {
                state |= std::ios_base::failbit;
                if (is.exceptions() & std::ios_base::failbit)
                    throw format_error("xscanf: incomplete field at the end of format string!");
                break;
            }

            // did we read anything for argument index or field width?
            if (cur > perc_pos+1) {
                // handle positional argument
                if (*cur == ch_dollar) {
                    // if argument index out of range then just set the failbit and return
                    if (num-1 >= arg_end-arg_begin || num == 0) {
                        state |= std::ios_base::failbit;
                        if (is.exceptions() & std::ios_base::failbit)
                            throw argument_index_error("xscanf: argument index out of range");
                        break;
                    }

                    // skip the $
                    ++cur;

                    // if reached end of format string early
                    if (cur >= format_end) {
                        state |= std::ios_base::failbit;
                        if (is.exceptions() & std::ios_base::failbit)
                            throw format_error("xscanf: incomplete field at the end of format string!");
                        break;
                    }

                    new_arg_index = num;
                }
                // so it must be field width
                else {
                    cur_width = num;
                    has_width = true;
                }
            }

            // handle the sub-format  %{...} 
            if (!has_width && *cur == ch_lb) {
                ++cur;

                const _char_type* subfmt_begin = cur;
                int balance = 1;

                for (; cur<format_end; ++cur) {
                    if (*cur == ch_rb)
                        balance--;
                    else if (*cur == ch_lb)
                        balance++;

                    if (balance <= 0)
                        break;
                }

                // if reached end of format string before a matching }
                if (cur >= format_end) {
                    state |= std::ios_base::failbit;
                    if (is.exceptions() & std::ios_base::failbit)
                        throw format_error("xscanf: field subformat not closed with a '}'");
                    break;
                }

                const _char_type* subfmt_end = cur;

                ++cur;

                if (new_arg_index != -1) 
                    cur_arg_index = new_arg_index;

                if (cur_arg_index-1 >= arg_end-arg_begin) {
                    state |= std::ios_base::failbit;
                    if (is.exceptions() & std::ios_base::failbit)
                        throw argument_index_error("xscanf: argument index out of range");
                    break;
                }

                is.flags(cur_flags);
                is.precision(cur_precision);
                is.width(cur_width);
                in_argument = true;
                xscanf_one(is, subfmt_begin, subfmt_end, arg_begin[cur_arg_index-1]);
                in_argument = false;
                if (!is.good())
                    break;
            }
            else {
                char cur_ch =0;

                // reset the flags 
                cur_flags &= ~(std::ios_base::adjustfield | std::ios_base::showpos | std::ios_base::showpoint 
                    | std::ios_base::showbase | std::ios_base::boolalpha);
                cur_flags |= std::ios_base::right;

                // if we haven't read the field width before
                if (!has_width)
                {
                    cur_ch = detail::do_narrow(*cur, conv);

                    // read the width field
                    if (cur_ch >= '0' && cur_ch <= '9') {
                        cur = detail::read_number(cur, format_end, num, conv);
                        cur_width = num;
                        has_width = true;

                        // if reached end of format string early
                        if (cur >= format_end) {
                            state |= std::ios_base::failbit;
                            if (is.exceptions() & std::ios_base::failbit)
                                throw format_error("xscanf: incomplete field at the end of format string!");
                            break;
                        }
                        cur_ch = detail::do_narrow(*cur, conv);
                    }
                }
                else
                    cur_ch = detail::do_narrow(*cur, conv);

                bool complete = false;

                // read the type field with some optional prefixes
                for (; cur<format_end; ++cur) {
                    cur_ch = detail::do_narrow(*cur, conv);

                    const detail::format_char_info& info = ft_info[(int)cur_ch];

                    if (info.type == detail::format_char_info::c_type) {
                        cur_flags &= ~info.cflags;
                        cur_flags |= info.sflags;
                        complete = true;
                        break;
                    }
                    if (info.type == detail::format_char_info::c_prefix) {
                        cur_flags &= ~info.cflags;
                        cur_flags |= info.sflags;
                        continue;
                    }

                    break;
                }

                // if reached end of format string early
                if (cur >= format_end) {
                    state |= std::ios_base::failbit;
                    if (is.exceptions() & std::ios_base::failbit)
                        throw format_error("xscanf: incomplete field at the end of format string!");
                    break;
                }

                // if complete, scan the argument according to the format
                if (complete) {
                    ++cur;

                    if (new_arg_index != -1) 
                        cur_arg_index = new_arg_index;

                    if (cur_arg_index-1 >= arg_end-arg_begin) {
                        state |= std::ios_base::failbit;
                        if (is.exceptions() & std::ios_base::failbit)
                            throw argument_index_error("xscanf: argument index out of range");
                        break;
                    }

                    is.flags(cur_flags);
                    is.precision(cur_precision);
                    is.width(cur_width);
                    in_argument = true;
                    xscanf_one(is, perc_pos+1, perc_pos+1, arg_begin[cur_arg_index-1]);
                    in_argument = false;
                    if (!is.good())
                        break;
                    continue;
                }

                // ignore the %n
                if (cur_ch == 'n') {
                    ++cur;
                    continue;
                }

                // if not complete, set the failbit and return
                state |= std::ios_base::failbit;
                if (is.exceptions() & std::ios_base::failbit)
                    throw format_error("xscanf: unrecognized format field!");
                break;
            }
        }
    }
    catch (...) {
        state |= is.rdstate();
        is.flags(saved_flags);
        is.precision(saved_precision);

        if (state == std::ios_base::goodbit)
            state |= in_argument ? std::ios_base::failbit : std::ios_base::badbit;

        try { is.setstate(state); } catch (...) {}

        if (state & is.exceptions())
            throw;
    }
    is.flags(saved_flags);
    is.precision(saved_precision);
    is.setstate(state);
    return is;
}


} // namespace lite

#ifdef LITE_ASSERT_LOCAL
#undef LITE_ASSERT 
#undef LITE_ASSERT_LOCAL
#endif // LITE_ASSERT_LOCAL

#ifdef _MSC_VER
#pragma warning (pop)
#endif


#endif // LITE_XFORMAT_HPP
