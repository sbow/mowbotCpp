<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/>
<title>Lite: array.hpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="lite.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.0 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>array.hpp</h1><a href="array_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/***********************************************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment">    array.hpp</span>
<a name="l00003"></a>00003 <span class="comment">    Copyright Saeed Alaei 2007-2009.</span>
<a name="l00004"></a>00004 <span class="comment">    Version : 3.505</span>
<a name="l00005"></a>00005 <span class="comment">    Generated on: Fri Nov 06 02:03:07 2009</span>
<a name="l00006"></a>00006 <span class="comment"></span>
<a name="l00007"></a>00007 <span class="comment">    Warning: This file is generated. If you need to make a change, modify the template.</span>
<a name="l00008"></a>00008 <span class="comment">    To generate the documentation, run Doxygen on this file.</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">    Permission is hereby granted, free of charge, to any person or organization</span>
<a name="l00011"></a>00011 <span class="comment">    obtaining a copy of the software and accompanying documentation covered by</span>
<a name="l00012"></a>00012 <span class="comment">    this license (the &quot;Software&quot;) to use, reproduce, display, distribute,</span>
<a name="l00013"></a>00013 <span class="comment">    execute, and transmit the Software, and to prepare derivative works of the</span>
<a name="l00014"></a>00014 <span class="comment">    Software, and to permit third-parties to whom the Software is furnished to</span>
<a name="l00015"></a>00015 <span class="comment">    do so, all subject to the following:</span>
<a name="l00016"></a>00016 <span class="comment"></span>
<a name="l00017"></a>00017 <span class="comment">    The copyright notices in the Software and this entire statement, including</span>
<a name="l00018"></a>00018 <span class="comment">    the above license grant, this restriction and the following disclaimer,</span>
<a name="l00019"></a>00019 <span class="comment">    must be included in all copies of the Software, in whole or in part, and</span>
<a name="l00020"></a>00020 <span class="comment">    all derivative works of the Software, unless such copies or derivative</span>
<a name="l00021"></a>00021 <span class="comment">    works are solely in the form of machine-executable object code generated by</span>
<a name="l00022"></a>00022 <span class="comment">    a source language processor.</span>
<a name="l00023"></a>00023 <span class="comment"></span>
<a name="l00024"></a>00024 <span class="comment">    THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<a name="l00025"></a>00025 <span class="comment">    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<a name="l00026"></a>00026 <span class="comment">    FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT</span>
<a name="l00027"></a>00027 <span class="comment">    SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE</span>
<a name="l00028"></a>00028 <span class="comment">    FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,</span>
<a name="l00029"></a>00029 <span class="comment">    ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER</span>
<a name="l00030"></a>00030 <span class="comment">    DEALINGS IN THE SOFTWARE.</span>
<a name="l00031"></a>00031 <span class="comment"></span>
<a name="l00032"></a>00032 <span class="comment">    Trivia: </span>
<a name="l00033"></a>00033 <span class="comment">    This whole file was written from scratch from 9/4/2009 to 9/10/2009 excluding the documentation.</span>
<a name="l00034"></a>00034 <span class="comment">***********************************************************************************************************/</span>
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 <span class="comment">/* </span>
<a name="l00037"></a>00037 <span class="comment">FUTURE TODO:</span>
<a name="l00038"></a>00038 <span class="comment">    - (high) add the dimension selection for for_each functions </span>
<a name="l00039"></a>00039 <span class="comment">    - (medium) add resize error checking</span>
<a name="l00040"></a>00040 <span class="comment">    - (very low) add xformat formating</span>
<a name="l00041"></a>00041 <span class="comment">    - (very low) do something about internal_rep with variable length abuse!</span>
<a name="l00042"></a>00042 <span class="comment">    - (very low) elaborate the default_array_traits</span>
<a name="l00043"></a>00043 <span class="comment">    - (very low) add stl style vector operations.</span>
<a name="l00044"></a>00044 <span class="comment">    - (very low) add specialized operations for 0-dimension arrays.</span>
<a name="l00045"></a>00045 <span class="comment">*/</span>
<a name="l00046"></a>00046 
<a name="l01302"></a>01302 <span class="preprocessor">#ifndef LITE_ARRAY_HPP</span>
<a name="l01303"></a>01303 <span class="preprocessor"></span><span class="preprocessor">#define LITE_ARRAY_HPP</span>
<a name="l01304"></a>01304 <span class="preprocessor"></span>
<a name="l01305"></a>01305 <span class="preprocessor">#include &lt;exception&gt;</span>
<a name="l01306"></a>01306 <span class="preprocessor">#include &lt;stdexcept&gt;</span>
<a name="l01307"></a>01307 <span class="preprocessor">#include &lt;iterator&gt;</span>
<a name="l01308"></a>01308 <span class="preprocessor">#include &lt;algorithm&gt;</span>
<a name="l01309"></a>01309 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l01310"></a>01310 <span class="preprocessor">#include &lt;iomanip&gt;</span>
<a name="l01311"></a>01311 <span class="preprocessor">#include &lt;limits&gt;</span>
<a name="l01312"></a>01312 <span class="preprocessor">#include &lt;cmath&gt;</span>
<a name="l01313"></a>01313 <span class="preprocessor">#include &lt;cstdlib&gt;</span>
<a name="l01314"></a>01314 
<a name="l01315"></a>01315 <span class="comment">/***********************************************************************************************************/</span>
<a name="l01316"></a>01316 <span class="comment">/* common configuration ************************************************************************************/</span>
<a name="l01317"></a>01317 <span class="comment">/***********************************************************************************************************/</span>
<a name="l01318"></a>01318 
<a name="l01319"></a>01319 <span class="preprocessor">#ifdef LITE_INLINE</span>
<a name="l01320"></a>01320 <span class="preprocessor"></span><span class="preprocessor">#undef LITE_INLINE</span>
<a name="l01321"></a>01321 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01322"></a>01322 <span class="preprocessor"></span>
<a name="l01327"></a><a class="code" href="group__array__misc.html#ga3f9b4b2d53e8efdb8c5730fc6bdebff9">01327</a> <span class="preprocessor">#define LITE_ARRAY_MAX_DIMS 3</span>
<a name="l01328"></a>01328 <span class="preprocessor"></span>
<a name="l01333"></a><a class="code" href="group__array__misc.html#gac28b5b386cbc363b7bdec213419264b7">01333</a> <span class="preprocessor">#define LITE_ARRAY_MAX_PACKS 4</span>
<a name="l01334"></a>01334 <span class="preprocessor"></span>
<a name="l01347"></a><a class="code" href="group__array__misc.html#gac842ced9d971cf30fd9d7c150ee0791a">01347</a> <span class="preprocessor">#define LITE_ARRAY_MAX_VECTOR_ARGS 5</span>
<a name="l01348"></a>01348 <span class="preprocessor"></span>
<a name="l01356"></a><a class="code" href="group__array__misc.html#gafb2b4f1f3d2e16500ae18f44b398d22b">01356</a> <span class="preprocessor">#define LITE_ARRAY_MAX_ITERATOR_ARGS 3</span>
<a name="l01357"></a>01357 <span class="preprocessor"></span>
<a name="l01364"></a><a class="code" href="group__array__misc.html#ga1a43bfd4a9dbc307c7a9f0585572fb07">01364</a> <span class="preprocessor">#define LITE_ARRAY_MAX_STATIC_UNROLL_LENGTH 5</span>
<a name="l01365"></a>01365 <span class="preprocessor"></span>
<a name="l01374"></a><a class="code" href="group__array__misc.html#gae5ad7fd90e5353ec451612eb5b576e23">01374</a> <span class="preprocessor">#define LITE_ARRAY_MAX_DYNAMIC_UNROLL_DEPTH 4</span>
<a name="l01375"></a>01375 <span class="preprocessor"></span>
<a name="l01380"></a><a class="code" href="group__array__misc.html#gaad574f4ee708348838b8d587c1b06b24">01380</a> <span class="preprocessor">#define LITE_ARRAY_VERSION 3505</span>
<a name="l01381"></a>01381 <span class="preprocessor"></span>
<a name="l01386"></a><a class="code" href="group__array__misc.html#ga7fe993abbd6c910e87802be46911c5a0">01386</a> <span class="preprocessor">#define LITE_ARRAY_VERSION_STR &quot;3.505&quot;</span>
<a name="l01387"></a>01387 <span class="preprocessor"></span>
<a name="l01388"></a>01388 <span class="preprocessor">#define LITE_ARRAY_USE(x) ((void)(x))</span>
<a name="l01389"></a>01389 <span class="preprocessor"></span>
<a name="l01390"></a>01390 <span class="preprocessor">#ifndef __LINE__ // true when Doxygen is processing the file</span>
<a name="l01391"></a>01391 <span class="preprocessor"></span><span class="preprocessor">#define DOCUMENTATION_ONLY</span>
<a name="l01392"></a>01392 <span class="preprocessor"></span><span class="preprocessor">#endif </span>
<a name="l01393"></a>01393 <span class="preprocessor"></span>
<a name="l01394"></a>01394 <span class="comment">/***********************************************************************************************************/</span>
<a name="l01395"></a>01395 <span class="comment">/* MSVC++ configuration ************************************************************************************/</span>
<a name="l01396"></a>01396 <span class="comment">/***********************************************************************************************************/</span>
<a name="l01397"></a>01397 
<a name="l01398"></a>01398 <span class="preprocessor">#ifdef _MSC_VER</span>
<a name="l01399"></a>01399 <span class="preprocessor"></span>
<a name="l01400"></a>01400 <span class="preprocessor">#if _MSC_VER &lt; 1300</span>
<a name="l01401"></a>01401 <span class="preprocessor"></span><span class="preprocessor">#error visual c++ .net 7.1 (2003) or newer is required</span>
<a name="l01402"></a>01402 <span class="preprocessor"></span><span class="preprocessor">#endif // _MSC_VER &lt; 1300 </span>
<a name="l01403"></a>01403 <span class="preprocessor"></span>
<a name="l01404"></a>01404 <span class="preprocessor">#pragma warning(push)</span>
<a name="l01405"></a>01405 <span class="preprocessor"></span><span class="preprocessor">#pragma warning(disable : 4127) // conditional_c expression is constant</span>
<a name="l01406"></a>01406 <span class="preprocessor"></span><span class="preprocessor">#pragma inline_recursion(on)</span>
<a name="l01407"></a>01407 <span class="preprocessor"></span><span class="preprocessor">#pragma inline_depth(200)</span>
<a name="l01408"></a>01408 <span class="preprocessor"></span>
<a name="l01409"></a>01409 <span class="preprocessor">#define LITE_INLINE __forceinline</span>
<a name="l01410"></a>01410 <span class="preprocessor"></span>
<a name="l01411"></a>01411 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l01412"></a>01412 <span class="preprocessor"></span><span class="preprocessor">#pragma message (&quot;lite/array.hpp: Warning! Possible performance penalty due to assertions. Define NDEBUG to disable.&quot;)</span>
<a name="l01413"></a>01413 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01414"></a>01414 <span class="preprocessor"></span>
<a name="l01415"></a>01415 <span class="preprocessor">#endif // _MSC_VER</span>
<a name="l01416"></a>01416 <span class="preprocessor"></span>
<a name="l01417"></a>01417 <span class="comment">/***********************************************************************************************************/</span>
<a name="l01418"></a>01418 <span class="comment">/* GCC configuration ***************************************************************************************/</span>
<a name="l01419"></a>01419 <span class="comment">/***********************************************************************************************************/</span>
<a name="l01420"></a>01420 
<a name="l01421"></a>01421 <span class="preprocessor">#ifdef __GNUC__</span>
<a name="l01422"></a>01422 <span class="preprocessor"></span>
<a name="l01423"></a>01423 <span class="preprocessor">#define LITE_INLINE  inline __attribute__((always_inline))</span>
<a name="l01424"></a>01424 <span class="preprocessor"></span>
<a name="l01425"></a>01425 <span class="preprocessor">#ifndef LITE_ARRAY_NO_HINT</span>
<a name="l01426"></a>01426 <span class="preprocessor"></span><span class="preprocessor">#warning &quot;Use the following compiler switches to get a good performance: -finline-limit=1234567 --param large-function-growth=1234567 --param max-inline-insns-single=1234567&quot;</span>
<a name="l01427"></a>01427 <span class="preprocessor"></span><span class="preprocessor">#warning &quot;Define LITE_ARRAY_NO_HINT to disable the previous warning.&quot;</span>
<a name="l01428"></a>01428 <span class="preprocessor"></span><span class="preprocessor">#endif </span>
<a name="l01429"></a>01429 <span class="preprocessor"></span>
<a name="l01430"></a>01430 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l01431"></a>01431 <span class="preprocessor"></span><span class="preprocessor">#warning &quot;lite/array.hpp: Possible performance penalty due to assertions. Define NDEBUG to disable.&quot;</span>
<a name="l01432"></a>01432 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01433"></a>01433 <span class="preprocessor"></span>
<a name="l01434"></a>01434 <span class="preprocessor">#endif // __GNUC__</span>
<a name="l01435"></a>01435 <span class="preprocessor"></span>
<a name="l01436"></a>01436 <span class="comment">/***********************************************************************************************************/</span>
<a name="l01437"></a>01437 <span class="comment">/* generic configuration ***********************************************************************************/</span>
<a name="l01438"></a>01438 <span class="comment">/***********************************************************************************************************/</span>
<a name="l01439"></a>01439 
<a name="l01440"></a>01440 <span class="preprocessor">#ifndef LITE_INLINE</span>
<a name="l01441"></a>01441 <span class="preprocessor"></span><span class="preprocessor">#define LITE_INLINE inline</span>
<a name="l01442"></a>01442 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01443"></a>01443 <span class="preprocessor"></span>
<a name="l01444"></a>01444 <span class="comment">/***********************************************************************************************************/</span>
<a name="l01445"></a>01445 <span class="comment">/* error checking/debug level ******************************************************************************/</span>
<a name="l01446"></a>01446 <span class="comment">/***********************************************************************************************************/</span>
<a name="l01447"></a>01447 
<a name="l01448"></a>01448 <span class="preprocessor">#ifdef NDEBUG</span>
<a name="l01449"></a>01449 <span class="preprocessor"></span><span class="preprocessor">#define LITE_ARRAY_SIZE_CHECK(size1, size2, msg)</span>
<a name="l01450"></a>01450 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l01451"></a>01451 <span class="preprocessor"></span><span class="preprocessor">#define LITE_ARRAY_SIZE_CHECK(size1, size2, msg) lite_array_size_check(size1, size2, msg)</span>
<a name="l01452"></a>01452 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01453"></a>01453 <span class="preprocessor"></span>
<a name="l01454"></a>01454 <span class="comment">/***********************************************************************************************************/</span>
<a name="l01455"></a>01455 <span class="comment">/* namespace lite ******************************************************************************************/</span>
<a name="l01456"></a>01456 <span class="comment">/***********************************************************************************************************/</span>
<a name="l01457"></a>01457 
<a name="l01459"></a><a class="code" href="namespacelite.html">01459</a> <span class="keyword">namespace </span>lite
<a name="l01460"></a>01460 {
<a name="l01461"></a>01461 
<a name="l01462"></a>01462 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_, type_ value_&gt;
<a name="l01463"></a>01463 <span class="keyword">class </span><a class="code" href="classlite_1_1constant.html" title="This class can be used to encapsulate an element of a lite::pack as a constant element...">constant</a>;
<a name="l01464"></a>01464 
<a name="l01465"></a>01465 <span class="keyword">template</span>&lt;
<a name="l01466"></a>01466     <span class="keyword">typename</span> type0_ = void ,
<a name="l01467"></a>01467     <span class="keyword">typename</span> type1_ = void ,
<a name="l01468"></a>01468     <span class="keyword">typename</span> type2_ = void ,
<a name="l01469"></a>01469     <span class="keyword">typename</span> type3_ = <span class="keywordtype">void</span> 
<a name="l01470"></a>01470     &gt;
<a name="l01471"></a>01471 <span class="keyword">class </span><a class="code" href="classlite_1_1pack.html" title="This is a general tuple class that can pack together elements of different types...">pack</a>;
<a name="l01472"></a>01472 
<a name="l01473"></a>01473 <span class="keyword">template</span>&lt;
<a name="l01474"></a>01474     <span class="keyword">typename</span> pack_type_,
<a name="l01475"></a>01475     <span class="keywordtype">bool</span> keep0_ =<span class="keyword">false</span>,
<a name="l01476"></a>01476     <span class="keywordtype">bool</span> keep1_ =<span class="keyword">false</span>,
<a name="l01477"></a>01477     <span class="keywordtype">bool</span> keep2_ =<span class="keyword">false</span>,
<a name="l01478"></a>01478     <span class="keywordtype">bool</span> keep3_ =<span class="keyword">false</span>
<a name="l01479"></a>01479     &gt;
<a name="l01480"></a>01480 <span class="keyword">class </span><a class="code" href="classlite_1_1sub__pack.html" title="This class can be used to define and extract a subset of element of a pack as another...">sub_pack</a>;
<a name="l01481"></a>01481 
<a name="l01482"></a>01482 <span class="comment">// class s_iterator; // the pack class is used directly instead</span>
<a name="l01483"></a>01483 
<a name="l01484"></a>01484 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _value_type&gt;
<a name="l01485"></a>01485 <span class="keyword">class </span><a class="code" href="classlite_1_1c__iterator.html" title="This class implements an iterator that returns the same value everywhere.">c_iterator</a>; <span class="comment">// const_iterator</span>
<a name="l01486"></a>01486 
<a name="l01487"></a>01487 <span class="keyword">template</span>&lt;
<a name="l01488"></a>01488     <span class="keyword">typename</span> base_iter_type_, 
<a name="l01489"></a>01489     <span class="keyword">typename</span> func_type_, 
<a name="l01490"></a>01490     <span class="keywordtype">bool</span> is_static_ =<span class="keyword">true</span>&gt;
<a name="l01491"></a>01491 <span class="keyword">class </span><a class="code" href="classlite_1_1u__iterator.html" title="This class implements an iterator that returns the result of applying a function...">u_iterator</a>; <span class="comment">// unary iterator</span>
<a name="l01492"></a>01492 
<a name="l01493"></a>01493 <span class="keyword">template</span>&lt;
<a name="l01494"></a>01494     <span class="keyword">typename</span> left_base_iter_type_, 
<a name="l01495"></a>01495     <span class="keyword">typename</span> right_base_iter_type_, 
<a name="l01496"></a>01496     <span class="keyword">typename</span> func_type_, 
<a name="l01497"></a>01497     <span class="keywordtype">bool</span> is_static_=<span class="keyword">true</span>&gt;
<a name="l01498"></a>01498 <span class="keyword">class </span><a class="code" href="classlite_1_1b__iterator.html" title="This class implements an iterator that returns the result of applying a binary function...">b_iterator</a>; <span class="comment">// binary_iterator</span>
<a name="l01499"></a>01499 
<a name="l01500"></a>01500 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> base_iterator_type_=<span class="keywordtype">void</span>&gt;
<a name="l01501"></a>01501 <span class="keyword">struct </span><a class="code" href="structlite_1_1array__signature__traits.html" title="This can be used to extract information from array signatures and get the appropriate...">array_signature_traits</a>;
<a name="l01502"></a>01502 
<a name="l01503"></a>01503 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_&gt;
<a name="l01504"></a>01504 <span class="keyword">class </span><a class="code" href="classlite_1_1reference__rep.html" title="This is a tag type that can be used to specify reference representation for an array...">reference_rep</a>;
<a name="l01505"></a>01505 
<a name="l01506"></a>01506 <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> reversed_&gt;
<a name="l01507"></a>01507 <span class="keyword">class </span><a class="code" href="classlite_1_1internal__rep.html" title="This is a tag type that can be used to specify internal representation for an array...">internal_rep</a>;
<a name="l01508"></a>01508 
<a name="l01509"></a>01509 <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> reversed_, <span class="keywordtype">int</span> <span class="keywordtype">int</span>ernal_buf_size_&gt;
<a name="l01510"></a>01510 <span class="keyword">class </span><a class="code" href="classlite_1_1hybrid__rep.html" title="This is a tag type that can be used to specify hybrid representation for an array...">hybrid_rep</a>;
<a name="l01511"></a>01511 
<a name="l01512"></a>01512 <span class="keyword">struct </span><a class="code" href="structlite_1_1default__array__traits.html" title="This is the default array traits type used by the class lite::array.See Array Traits...">default_array_traits</a>;
<a name="l01513"></a>01513 
<a name="l01514"></a>01514 <span class="keyword">template</span>&lt;
<a name="l01515"></a>01515     <span class="keyword">typename</span> signature_, 
<a name="l01516"></a>01516     <span class="keyword">typename</span> traits_type_ = <a class="code" href="structlite_1_1default__array__traits.html" title="This is the default array traits type used by the class lite::array.See Array Traits...">default_array_traits</a>, 
<a name="l01517"></a>01517     <span class="keyword">typename</span> rep_ = <span class="keyword">typename</span> traits_type_::template representation_type&lt;signature_&gt;::type&gt;
<a name="l01518"></a>01518 <span class="keyword">class </span><a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a>;
<a name="l01519"></a>01519 
<a name="l01520"></a>01520 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_ = default_array_traits&gt;
<a name="l01521"></a>01521 <span class="keyword">struct </span>array_helper;
<a name="l01522"></a>01522 
<a name="l01523"></a>01523 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> trans_type_, <span class="keyword">typename</span> <span class="keywordtype">size_t</span>ype_&gt;
<a name="l01524"></a>01524 <span class="keyword">struct </span><a class="code" href="structlite_1_1size__transformer.html" title="This can be used to apply a transform object of type transform_type_ to a size object...">size_transformer</a>;
<a name="l01525"></a>01525 
<a name="l01526"></a>01526 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> trans_type_, <span class="keyword">typename</span> iter_type_, <span class="keyword">typename</span> <span class="keywordtype">size_t</span>ype_&gt;
<a name="l01527"></a>01527 <span class="keyword">struct </span><a class="code" href="structlite_1_1iterator__transformer.html" title="This can be used to apply a transform object of type transform_type_ to a pair of...">iterator_transformer</a>;
<a name="l01528"></a>01528 
<a name="l01529"></a>01529 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> array_type_, <span class="keyword">typename</span> trans_type_, <span class="keyword">typename</span> enabler_=<span class="keywordtype">void</span>&gt;
<a name="l01530"></a>01530 <span class="keyword">struct </span><a class="code" href="structlite_1_1transform__traits.html" title="This class provides information about applying a transform object to an array object...">transform_traits</a>;
<a name="l01531"></a>01531 
<a name="l01532"></a>01532 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim_&gt;
<a name="l01533"></a><a class="code" href="group__array__transforms.html#gac13d5a020f69071131362062cbb527cb">01533</a> <span class="keyword">class </span><a class="code" href="classlite_1_1plane.html" title="This transform, when applied to an array of dimension N, returns a reference array...">plane</a>;
<a name="l01534"></a>01534 
<a name="l01556"></a>01556 <span class="keyword">typedef</span> <a class="code" href="classlite_1_1plane.html" title="This transform, when applied to an array of dimension N, returns a reference array...">plane&lt;0&gt;</a> <a class="code" href="classlite_1_1plane.html" title="This transform, when applied to an array of dimension N, returns a reference array...">row</a>;
<a name="l01557"></a>01557 
<a name="l01579"></a><a class="code" href="group__array__transforms.html#gadb85ceb967b099b563484f6a96ca911c">01579</a> <span class="keyword">typedef</span> <a class="code" href="classlite_1_1plane.html" title="This transform, when applied to an array of dimension N, returns a reference array...">plane&lt;1&gt;</a> <a class="code" href="classlite_1_1plane.html" title="This transform, when applied to an array of dimension N, returns a reference array...">column</a>;
<a name="l01580"></a>01580 
<a name="l01581"></a>01581 <span class="keyword">class </span><a class="code" href="classlite_1_1diagonal.html" title="This transform returns a 1-D reference array that corresponds to the main diagonal...">diagonal</a>;
<a name="l01582"></a>01582 
<a name="l01583"></a>01583 <span class="keyword">class </span><a class="code" href="classlite_1_1transpose.html" title="This transform returns a reference array that references the original array but its...">transpose</a>;
<a name="l01584"></a>01584 
<a name="l01585"></a>01585 <span class="keyword">template</span>&lt;
<a name="l01586"></a>01586     <span class="keywordtype">int</span> n0_ = -2,
<a name="l01587"></a>01587     <span class="keywordtype">int</span> n1_ = -2,
<a name="l01588"></a>01588     <span class="keywordtype">int</span> n2_ = -2
<a name="l01589"></a>01589     &gt;
<a name="l01590"></a>01590 <span class="keyword">class </span><a class="code" href="classlite_1_1block.html" title="This transform can be used to create a reference array that corresponds to a block...">block</a>;
<a name="l01591"></a>01591 
<a name="l01592"></a>01592 <span class="keyword">class </span><a class="code" href="classlite_1_1array__comparator.html" title="This class defines a function object that can be used to compare two compatible arrays...">array_comparator</a>;
<a name="l01593"></a>01593 
<a name="l01594"></a>01594 <span class="keyword">class </span><a class="code" href="classlite_1_1size__mismatch__error.html" title="A mismatch between the sizes of two arrays in an operation or invalid size for a...">size_mismatch_error</a>;
<a name="l01595"></a>01595 
<a name="l01604"></a><a class="code" href="namespacelite_1_1transforms.html">01604</a> <span class="keyword">namespace </span>transforms 
<a name="l01605"></a>01605 {
<a name="l01606"></a>01606 using ::lite::plane;
<a name="l01607"></a>01607 <a class="code" href="group__array__transforms.html#gac13d5a020f69071131362062cbb527cb" title="This transform, when applied to an array of dimension N, returns a reference array...">using ::lite::row</a>;
<a name="l01608"></a>01608 <a class="code" href="group__array__transforms.html#gadb85ceb967b099b563484f6a96ca911c" title="This transform, when applied to an array of dimension N (N must be at least 2), returns...">using ::lite::column</a>;
<a name="l01609"></a>01609 using ::lite::diagonal;
<a name="l01610"></a>01610 using ::lite::transpose;
<a name="l01611"></a>01611 using ::lite::block;
<a name="l01612"></a>01612 using ::lite::transform_traits;
<a name="l01613"></a>01613 };
<a name="l01614"></a>01614 
<a name="l01615"></a>01615 <span class="comment">/***********************************************************************************************************/</span>
<a name="l01616"></a>01616 <span class="comment">/* implementation helpers **********************************************************************************/</span>
<a name="l01617"></a>01617 <span class="comment">/***********************************************************************************************************/</span>
<a name="l01618"></a>01618 
<a name="l01619"></a>01619 <span class="keyword">namespace </span>detail
<a name="l01620"></a>01620 {
<a name="l01621"></a>01621 
<a name="l01622"></a>01622 <span class="comment">/***********************************************************************************************************/</span>
<a name="l01623"></a>01623 <span class="comment">/* enable_if ***********************************************************************************************/</span>
<a name="l01624"></a>01624 <span class="comment">/***********************************************************************************************************/</span>
<a name="l01625"></a>01625 
<a name="l01626"></a>01626 <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> cond_, <span class="keyword">typename</span> type_ =<span class="keywordtype">void</span>&gt;
<a name="l01627"></a>01627 <span class="keyword">struct </span>enable_if;
<a name="l01628"></a>01628 
<a name="l01629"></a>01629 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_&gt;
<a name="l01630"></a>01630 <span class="keyword">struct </span>enable_if&lt;false, type_&gt;
<a name="l01631"></a>01631 {};
<a name="l01632"></a>01632 
<a name="l01633"></a>01633 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_&gt;
<a name="l01634"></a>01634 <span class="keyword">struct </span>enable_if&lt;true, type_&gt;
<a name="l01635"></a>01635 {
<a name="l01636"></a>01636     <span class="keyword">typedef</span> type_ type;
<a name="l01637"></a>01637 };
<a name="l01638"></a>01638 
<a name="l01639"></a>01639 <span class="comment">/***********************************************************************************************************/</span>
<a name="l01640"></a>01640 <span class="comment">/* type_if *************************************************************************************************/</span>
<a name="l01641"></a>01641 <span class="comment">/***********************************************************************************************************/</span>
<a name="l01642"></a>01642 
<a name="l01643"></a>01643 <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> cond_, <span class="keyword">typename</span> true_type_, <span class="keyword">typename</span> false_type_&gt;
<a name="l01644"></a>01644 <span class="keyword">struct </span>type_if;
<a name="l01645"></a>01645 
<a name="l01646"></a>01646 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> true_type_, <span class="keyword">typename</span> false_type_&gt;
<a name="l01647"></a>01647 <span class="keyword">struct </span>type_if&lt;true, true_type_, false_type_&gt;
<a name="l01648"></a>01648 {
<a name="l01649"></a>01649     <span class="keyword">typedef</span> true_type_ type;
<a name="l01650"></a>01650 };
<a name="l01651"></a>01651 
<a name="l01652"></a>01652 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> true_type_, <span class="keyword">typename</span> false_type_&gt;
<a name="l01653"></a>01653 <span class="keyword">struct </span>type_if&lt;false, true_type_, false_type_&gt;
<a name="l01654"></a>01654 {
<a name="l01655"></a>01655     <span class="keyword">typedef</span> false_type_ type;
<a name="l01656"></a>01656 };
<a name="l01657"></a>01657 
<a name="l01658"></a>01658 <span class="keyword">struct </span>invalid_argument {};
<a name="l01659"></a>01659 
<a name="l01660"></a>01660 <span class="comment">/***********************************************************************************************************/</span>
<a name="l01661"></a>01661 <span class="comment">/* same_type ***********************************************************************************************/</span>
<a name="l01662"></a>01662 <span class="comment">/***********************************************************************************************************/</span>
<a name="l01663"></a>01663 
<a name="l01664"></a>01664 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> left_type_, <span class="keyword">typename</span> right_type_&gt;
<a name="l01665"></a>01665 <span class="keyword">struct </span>same_type
<a name="l01666"></a>01666 {
<a name="l01667"></a>01667     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> result = <span class="keyword">false</span>;
<a name="l01668"></a>01668 };
<a name="l01669"></a>01669 
<a name="l01670"></a>01670 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_&gt;
<a name="l01671"></a>01671 <span class="keyword">struct </span>same_type&lt;type_, type_&gt;
<a name="l01672"></a>01672 {
<a name="l01673"></a>01673     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> result = <span class="keyword">true</span>;
<a name="l01674"></a>01674 };
<a name="l01675"></a>01675 
<a name="l01676"></a>01676 <span class="comment">/***********************************************************************************************************/</span>
<a name="l01677"></a>01677 <span class="comment">/* defined *************************************************************************************************/</span>
<a name="l01678"></a>01678 <span class="comment">/***********************************************************************************************************/</span>
<a name="l01679"></a>01679 
<a name="l01680"></a>01680 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_&gt;
<a name="l01681"></a>01681 <span class="keyword">struct </span>defined
<a name="l01682"></a>01682 {
<a name="l01683"></a>01683     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> value = <span class="keyword">true</span>;
<a name="l01684"></a>01684 };
<a name="l01685"></a>01685 
<a name="l01686"></a>01686 <span class="comment">/***********************************************************************************************************/</span>
<a name="l01687"></a>01687 <span class="comment">/* compile_time_assert **************************************************************************************/</span>
<a name="l01688"></a>01688 <span class="comment">/***********************************************************************************************************/</span>
<a name="l01689"></a>01689 
<a name="l01690"></a>01690 <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> cond_&gt;
<a name="l01691"></a>01691 <span class="keyword">struct </span>compile_time_assert;
<a name="l01692"></a>01692 
<a name="l01693"></a>01693 <span class="keyword">template</span>&lt;&gt;
<a name="l01694"></a>01694 <span class="keyword">struct </span>compile_time_assert&lt;true&gt;
<a name="l01695"></a>01695 {
<a name="l01696"></a>01696     <span class="keyword">typedef</span> <span class="keywordtype">void</span> verified;
<a name="l01697"></a>01697 };
<a name="l01698"></a>01698 
<a name="l01699"></a>01699 <span class="comment">/***********************************************************************************************************/</span>
<a name="l01700"></a>01700 <span class="comment">/* remove **************************************************************************************************/</span>
<a name="l01701"></a>01701 <span class="comment">/***********************************************************************************************************/</span>
<a name="l01702"></a>01702 
<a name="l01703"></a>01703 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_, <span class="keyword">typename</span> stencil_, <span class="keyword">typename</span> other_&gt;
<a name="l01704"></a>01704 <span class="keyword">struct </span>remove_4
<a name="l01705"></a>01705 {
<a name="l01706"></a>01706     <span class="keyword">typedef</span> type_ type;
<a name="l01707"></a>01707     <span class="keyword">typedef</span> other_ other;
<a name="l01708"></a>01708 };
<a name="l01709"></a>01709 
<a name="l01710"></a>01710 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_, <span class="keyword">typename</span> stencil_, <span class="keyword">typename</span> other_&gt;
<a name="l01711"></a>01711 <span class="keyword">struct </span>remove_4&lt;volatile type_, volatile stencil_, other_&gt;
<a name="l01712"></a>01712 {
<a name="l01713"></a>01713     <span class="keyword">typedef</span> type_ type;
<a name="l01714"></a>01714     <span class="keyword">typedef</span> <span class="keyword">volatile</span> other_ other;
<a name="l01715"></a>01715 };
<a name="l01716"></a>01716 
<a name="l01717"></a>01717 <span class="comment">/***********************************************************************************************************/</span>
<a name="l01718"></a>01718 
<a name="l01719"></a>01719 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_, <span class="keyword">typename</span> stencil_, <span class="keyword">typename</span> other_&gt;
<a name="l01720"></a>01720 <span class="keyword">struct </span>remove_3
<a name="l01721"></a>01721 {
<a name="l01722"></a>01722     <span class="keyword">typedef</span> <span class="keyword">typename</span> remove_4&lt;type_, stencil_, other_&gt;::type type;
<a name="l01723"></a>01723     <span class="keyword">typedef</span> <span class="keyword">typename</span> remove_4&lt;type_, stencil_, other_&gt;::other other;
<a name="l01724"></a>01724 };
<a name="l01725"></a>01725 
<a name="l01726"></a>01726 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_, <span class="keyword">typename</span> stencil_, <span class="keyword">typename</span> other_&gt;
<a name="l01727"></a>01727 <span class="keyword">struct </span>remove_3&lt;const type_, const stencil_, other_&gt;
<a name="l01728"></a>01728 {
<a name="l01729"></a>01729     <span class="keyword">typedef</span> <span class="keyword">typename</span> remove_4&lt;type_, stencil_, other_&gt;::type type;
<a name="l01730"></a>01730     <span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keyword">typename</span> remove_4&lt;type_, stencil_, other_&gt;::other other;
<a name="l01731"></a>01731 };
<a name="l01732"></a>01732 
<a name="l01733"></a>01733 <span class="comment">/***********************************************************************************************************/</span>
<a name="l01734"></a>01734 
<a name="l01735"></a>01735 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_, <span class="keyword">typename</span> stencil_, <span class="keyword">typename</span> other_&gt;
<a name="l01736"></a>01736 <span class="keyword">struct </span>remove_2
<a name="l01737"></a>01737 {
<a name="l01738"></a>01738     <span class="keyword">typedef</span> <span class="keyword">typename</span> remove_3&lt;type_, stencil_, other_&gt;::type type;
<a name="l01739"></a>01739     <span class="keyword">typedef</span> <span class="keyword">typename</span> remove_3&lt;type_, stencil_, other_&gt;::other other;
<a name="l01740"></a>01740 };
<a name="l01741"></a>01741 
<a name="l01742"></a>01742 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_, <span class="keyword">typename</span> stencil_, <span class="keyword">typename</span> other_&gt;
<a name="l01743"></a>01743 <span class="keyword">struct </span>remove_2&lt;type_*, stencil_*, other_&gt;
<a name="l01744"></a>01744 {
<a name="l01745"></a>01745     <span class="keyword">typedef</span> <span class="keyword">typename</span> remove_3&lt;type_, stencil_, other_&gt;::type type;
<a name="l01746"></a>01746     <span class="keyword">typedef</span> <span class="keyword">typename</span> remove_3&lt;type_, stencil_, other_&gt;::other* other;
<a name="l01747"></a>01747 };
<a name="l01748"></a>01748 
<a name="l01749"></a>01749 <span class="comment">/***********************************************************************************************************/</span>
<a name="l01750"></a>01750 
<a name="l01751"></a>01751 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_, <span class="keyword">typename</span> stencil_, <span class="keyword">typename</span> other_&gt;
<a name="l01752"></a>01752 <span class="keyword">struct </span>remove_1
<a name="l01753"></a>01753 {
<a name="l01754"></a>01754     <span class="keyword">typedef</span> <span class="keyword">typename</span> remove_2&lt;type_, stencil_, other_&gt;::type type;
<a name="l01755"></a>01755     <span class="keyword">typedef</span> <span class="keyword">typename</span> remove_2&lt;type_, stencil_, other_&gt;::other other;
<a name="l01756"></a>01756 };
<a name="l01757"></a>01757 
<a name="l01758"></a>01758 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_, <span class="keyword">typename</span> stencil_, <span class="keyword">typename</span> other_&gt;
<a name="l01759"></a>01759 <span class="keyword">struct </span>remove_1&lt;type_&amp;, stencil_&amp;, other_&gt;
<a name="l01760"></a>01760 {
<a name="l01761"></a>01761     <span class="keyword">typedef</span> <span class="keyword">typename</span> remove_2&lt;type_, stencil_, other_&gt;::type type;
<a name="l01762"></a>01762     <span class="keyword">typedef</span> <span class="keyword">typename</span> remove_2&lt;type_, stencil_, other_&gt;::other&amp; other;
<a name="l01763"></a>01763 };
<a name="l01764"></a>01764 
<a name="l01765"></a>01765 <span class="comment">/***********************************************************************************************************/</span>
<a name="l01766"></a>01766 
<a name="l01767"></a>01767 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_, <span class="keyword">typename</span> stencil_, <span class="keyword">typename</span> other_=<span class="keywordtype">int</span>&gt;
<a name="l01768"></a>01768 <span class="keyword">struct </span>remove
<a name="l01769"></a>01769 {
<a name="l01770"></a>01770     <span class="keyword">typedef</span> <span class="keyword">typename</span> remove_1&lt;type_, stencil_, other_&gt;::type type;
<a name="l01771"></a>01771     <span class="keyword">typedef</span> <span class="keyword">typename</span> remove_1&lt;type_, stencil_, other_&gt;::other other;
<a name="l01772"></a>01772 };
<a name="l01773"></a>01773 
<a name="l01774"></a>01774 <span class="comment">/***********************************************************************************************************/</span>
<a name="l01775"></a>01775 <span class="comment">/* size_to_signature ***************************************************************************************/</span>
<a name="l01776"></a>01776 <span class="comment">/***********************************************************************************************************/</span>
<a name="l01777"></a>01777 
<a name="l01778"></a>01778 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> dim_type_&gt;
<a name="l01779"></a>01779 <span class="keyword">struct </span>dim_type_to_sig;
<a name="l01780"></a>01780 
<a name="l01781"></a>01781 <span class="keyword">template</span>&lt;&gt;
<a name="l01782"></a>01782 <span class="keyword">struct </span>dim_type_to_sig&lt;int&gt;
<a name="l01783"></a>01783 { <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n = 1; };
<a name="l01784"></a>01784 
<a name="l01785"></a>01785 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> n_&gt;
<a name="l01786"></a>01786 <span class="keyword">struct </span>dim_type_to_sig&lt;constant&lt;int, n_&gt; &gt;
<a name="l01787"></a>01787 { <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n = n_; };
<a name="l01788"></a>01788 
<a name="l01789"></a>01789 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="keywordtype">size_t</span>ype_, <span class="keyword">typename</span> value_type_&gt;
<a name="l01790"></a>01790 <span class="keyword">struct </span>size_to_signature;
<a name="l01791"></a>01791 
<a name="l01792"></a>01792 
<a name="l01793"></a>01793 <span class="keyword">template</span>&lt;
<a name="l01794"></a>01794     <span class="keyword">typename</span> value_type_&gt;
<a name="l01795"></a>01795 <span class="keyword">struct </span>size_to_signature&lt;pack&lt;
<a name="l01796"></a>01796     &gt;,
<a name="l01797"></a>01797     value_type_&gt;
<a name="l01798"></a>01798 {
<a name="l01799"></a>01799     <span class="keyword">typedef</span> value_type_ type
<a name="l01800"></a>01800     ;
<a name="l01801"></a>01801 };
<a name="l01802"></a>01802 
<a name="l01803"></a>01803 <span class="keyword">template</span>&lt;
<a name="l01804"></a>01804     <span class="keyword">typename</span> type0_,
<a name="l01805"></a>01805     <span class="keyword">typename</span> value_type_&gt;
<a name="l01806"></a>01806 <span class="keyword">struct </span>size_to_signature&lt;pack&lt;
<a name="l01807"></a>01807     type0_
<a name="l01808"></a>01808     &gt;,
<a name="l01809"></a>01809     value_type_&gt;
<a name="l01810"></a>01810 {
<a name="l01811"></a>01811     <span class="keyword">typedef</span> value_type_ type
<a name="l01812"></a>01812         [dim_type_to_sig&lt;type0_&gt;::n]
<a name="l01813"></a>01813     ;
<a name="l01814"></a>01814 };
<a name="l01815"></a>01815 
<a name="l01816"></a>01816 <span class="keyword">template</span>&lt;
<a name="l01817"></a>01817     <span class="keyword">typename</span> type0_,
<a name="l01818"></a>01818     <span class="keyword">typename</span> type1_,
<a name="l01819"></a>01819     <span class="keyword">typename</span> value_type_&gt;
<a name="l01820"></a>01820 <span class="keyword">struct </span>size_to_signature&lt;pack&lt;
<a name="l01821"></a>01821     type0_,
<a name="l01822"></a>01822     type1_
<a name="l01823"></a>01823     &gt;,
<a name="l01824"></a>01824     value_type_&gt;
<a name="l01825"></a>01825 {
<a name="l01826"></a>01826     <span class="keyword">typedef</span> value_type_ type
<a name="l01827"></a>01827         [dim_type_to_sig&lt;type0_&gt;::n]
<a name="l01828"></a>01828         [dim_type_to_sig&lt;type1_&gt;::n]
<a name="l01829"></a>01829     ;
<a name="l01830"></a>01830 };
<a name="l01831"></a>01831 
<a name="l01832"></a>01832 <span class="keyword">template</span>&lt;
<a name="l01833"></a>01833     <span class="keyword">typename</span> type0_,
<a name="l01834"></a>01834     <span class="keyword">typename</span> type1_,
<a name="l01835"></a>01835     <span class="keyword">typename</span> type2_,
<a name="l01836"></a>01836     <span class="keyword">typename</span> value_type_&gt;
<a name="l01837"></a>01837 <span class="keyword">struct </span>size_to_signature&lt;pack&lt;
<a name="l01838"></a>01838     type0_,
<a name="l01839"></a>01839     type1_,
<a name="l01840"></a>01840     type2_
<a name="l01841"></a>01841     &gt;,
<a name="l01842"></a>01842     value_type_&gt;
<a name="l01843"></a>01843 {
<a name="l01844"></a>01844     <span class="keyword">typedef</span> value_type_ type
<a name="l01845"></a>01845         [dim_type_to_sig&lt;type0_&gt;::n]
<a name="l01846"></a>01846         [dim_type_to_sig&lt;type1_&gt;::n]
<a name="l01847"></a>01847         [dim_type_to_sig&lt;type2_&gt;::n]
<a name="l01848"></a>01848     ;
<a name="l01849"></a>01849 };
<a name="l01850"></a>01850 
<a name="l01851"></a>01851 } <span class="comment">// namespace detail</span>
<a name="l01852"></a>01852 
<a name="l01853"></a>01853 <span class="comment">/***********************************************************************************************************/</span>
<a name="l01854"></a>01854 <span class="comment">/* size_mismatch_error *************************************************************************************/</span>
<a name="l01855"></a>01855 <span class="comment">/***********************************************************************************************************/</span>
<a name="l01856"></a>01856 
<a name="l01862"></a><a class="code" href="classlite_1_1size__mismatch__error.html">01862</a> <span class="keyword">class </span><a class="code" href="classlite_1_1size__mismatch__error.html" title="A mismatch between the sizes of two arrays in an operation or invalid size for a...">size_mismatch_error</a>
<a name="l01863"></a>01863     : <span class="keyword">public</span> std::runtime_error
<a name="l01864"></a>01864 {
<a name="l01865"></a>01865 <span class="keyword">public</span>:
<a name="l01866"></a>01866     <a class="code" href="classlite_1_1size__mismatch__error.html" title="A mismatch between the sizes of two arrays in an operation or invalid size for a...">size_mismatch_error</a>(<span class="keyword">const</span> std::string&amp; msg =<span class="stringliteral">&quot;&quot;</span>)
<a name="l01867"></a>01867         : std::runtime_error(msg) 
<a name="l01868"></a>01868     {}
<a name="l01869"></a>01869 
<a name="l01870"></a>01870     ~<a class="code" href="classlite_1_1size__mismatch__error.html" title="A mismatch between the sizes of two arrays in an operation or invalid size for a...">size_mismatch_error</a>() <span class="keywordflow">throw</span>() {}
<a name="l01871"></a>01871 };
<a name="l01872"></a>01872 
<a name="l01873"></a>01873 <span class="comment">/***********************************************************************************************************/</span>
<a name="l01874"></a>01874 <span class="comment">/* pack ****************************************************************************************************/</span>
<a name="l01875"></a>01875 <span class="comment">/***********************************************************************************************************/</span>
<a name="l01876"></a>01876 
<a name="l01891"></a>01891 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_, type_ value_&gt;
<a name="l01892"></a><a class="code" href="classlite_1_1constant.html">01892</a> <span class="keyword">class </span><a class="code" href="classlite_1_1constant.html" title="This class can be used to encapsulate an element of a lite::pack as a constant element...">constant</a> 
<a name="l01893"></a>01893 {
<a name="l01894"></a>01894 <span class="keyword">public</span>:
<a name="l01895"></a><a class="code" href="classlite_1_1constant.html#ae4798b866edf46b1375ea0ca55ba87a1">01895</a>     <span class="keyword">typedef</span> type_ type; 
<a name="l01896"></a><a class="code" href="classlite_1_1constant.html#ae6f9209876bd5581484be93946c5a588">01896</a>     <span class="keyword">static</span> <span class="keyword">const</span> type_ value = value_; 
<a name="l01897"></a>01897 };
<a name="l01898"></a>01898 
<a name="l01899"></a>01899 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_, type_ value_&gt;
<a name="l01900"></a>01900 <span class="keyword">const</span> type_ <a class="code" href="classlite_1_1constant.html" title="This class can be used to encapsulate an element of a lite::pack as a constant element...">constant&lt;type_, value_&gt;::value</a>;
<a name="l01901"></a>01901 
<a name="l01902"></a>01902 <span class="preprocessor">#ifdef DOCUMENTATION_ONLY</span>
<a name="l01903"></a>01903 <span class="preprocessor"></span>
<a name="l01982"></a>01982 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type0_ ..., <span class="keyword">typename</span> typeN_&gt;
<a name="l01983"></a><a class="code" href="classlite_1_1pack.html">01983</a> <span class="keyword">class </span><a class="code" href="classlite_1_1pack.html" title="This is a general tuple class that can pack together elements of different types...">pack</a>
<a name="l01984"></a>01984 {
<a name="l01985"></a>01985 <span class="keyword">public</span>:
<a name="l01986"></a><a class="code" href="classlite_1_1pack.html#a51a7c4a42e0f4d2459124f75e359d500">01986</a>     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n = N+1; 
<a name="l01987"></a>01987 
<a name="l01988"></a><a class="code" href="classlite_1_1pack.html#ae7aa729553674e2ed2f753ef1b37cb4f">01988</a>     <span class="keyword">typedef</span> ... typeX; 
<a name="l01989"></a>01989 
<a name="l01990"></a><a class="code" href="classlite_1_1pack.html#aa0433ab3d8fdfd05afe9c65cdd36d1f6">01990</a>     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_constX = ...; 
<a name="l01991"></a>01991 
<a name="l01992"></a><a class="code" href="classlite_1_1pack.html#ab8bc4a09377765105443ecb5ea3e6594">01992</a>     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_all_const = ...; 
<a name="l01993"></a>01993 
<a name="l01994"></a><a class="code" href="classlite_1_1pack.html#a1c23b4564bca33fdee03518e740e0b01">01994</a>     <span class="keyword">static</span> <span class="keyword">const</span> typeX iX = valueX_; 
<a name="l01995"></a>01995     
<a name="l01996"></a><a class="code" href="classlite_1_1pack.html#ac159559e1cf49527ebf2fc074fd121fc">01996</a>     typeX iX; 
<a name="l01997"></a>01997 
<a name="l01999"></a>01999     <a class="code" href="classlite_1_1pack.html" title="This is a general tuple class that can pack together elements of different types...">pack</a>();
<a name="l02000"></a>02000     
<a name="l02002"></a>02002     <a class="code" href="classlite_1_1pack.html" title="This is a general tuple class that can pack together elements of different types...">pack</a>(<span class="keyword">const</span> type0&amp; a0);
<a name="l02003"></a>02003 
<a name="l02005"></a>02005     <a class="code" href="classlite_1_1pack.html" title="This is a general tuple class that can pack together elements of different types...">pack</a>(<span class="keyword">const</span> type0&amp; a0, ... , <span class="keyword">const</span> typeN&amp; aN);
<a name="l02006"></a>02006 
<a name="l02008"></a>02008     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_type0_, ... , <span class="keyword">typename</span> other_typeN_&gt;
<a name="l02009"></a>02009     <a class="code" href="classlite_1_1pack.html" title="This is a general tuple class that can pack together elements of different types...">pack</a>(<span class="keyword">const</span> <a class="code" href="classlite_1_1pack.html" title="This is a general tuple class that can pack together elements of different types...">pack&lt;other_type0_, ... , other_typeN_&gt;</a>&amp; other);
<a name="l02010"></a>02010 
<a name="l02012"></a>02012     <a class="code" href="classlite_1_1pack.html" title="This is a general tuple class that can pack together elements of different types...">pack</a>&amp; 
<a name="l02013"></a>02013     operator= (<span class="keyword">const</span> <a class="code" href="classlite_1_1pack.html" title="This is a general tuple class that can pack together elements of different types...">pack</a>&amp; other);
<a name="l02014"></a>02014 
<a name="l02016"></a>02016     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_type0_, ... , <span class="keyword">typename</span> other_typeN_&gt;
<a name="l02017"></a>02017     <a class="code" href="classlite_1_1pack.html" title="This is a general tuple class that can pack together elements of different types...">pack</a>&amp; 
<a name="l02018"></a>02018     operator= (<span class="keyword">const</span> <a class="code" href="classlite_1_1pack.html" title="This is a general tuple class that can pack together elements of different types...">pack&lt;other_type0_, ... , other_typeN_&gt;</a>&amp; other);
<a name="l02019"></a>02019 
<a name="l02021"></a>02021     <span class="keywordtype">void</span> <span class="keyword">set</span>(<span class="keyword">const</span> type0&amp; a0, ... , <span class="keyword">const</span> typeN&amp; aN);
<a name="l02022"></a>02022 };
<a name="l02023"></a>02023 
<a name="l02024"></a>02024 <span class="preprocessor">#else // DOCUMENTATION_ONLY</span>
<a name="l02025"></a>02025 <span class="preprocessor"></span>
<a name="l02026"></a>02026 <span class="keyword">template</span>&lt;
<a name="l02027"></a>02027     <span class="keyword">typename</span> type0_,
<a name="l02028"></a>02028     <span class="keyword">typename</span> type1_,
<a name="l02029"></a>02029     <span class="keyword">typename</span> type2_,
<a name="l02030"></a>02030     <span class="keyword">typename</span> type3_
<a name="l02031"></a>02031     &gt;
<a name="l02032"></a>02032 <span class="keyword">class </span><a class="code" href="classlite_1_1pack.html" title="This is a general tuple class that can pack together elements of different types...">pack</a>
<a name="l02033"></a>02033 {
<a name="l02034"></a>02034 <span class="keyword">public</span>:
<a name="l02035"></a>02035     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n = 4;
<a name="l02036"></a>02036 
<a name="l02037"></a>02037     <span class="keyword">typedef</span> type0_ type0;
<a name="l02038"></a>02038     <span class="keyword">typedef</span> type1_ type1;
<a name="l02039"></a>02039     <span class="keyword">typedef</span> type2_ type2;
<a name="l02040"></a>02040     <span class="keyword">typedef</span> type3_ type3;
<a name="l02041"></a>02041 
<a name="l02042"></a>02042     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const0 = <span class="keyword">false</span>;
<a name="l02043"></a>02043     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const1 = <span class="keyword">false</span>;
<a name="l02044"></a>02044     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const2 = <span class="keyword">false</span>;
<a name="l02045"></a>02045     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const3 = <span class="keyword">false</span>;
<a name="l02046"></a>02046     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_all_const = <span class="keyword">false</span>;
<a name="l02047"></a>02047     type0 i0;
<a name="l02048"></a>02048     type1 i1;
<a name="l02049"></a>02049     type2 i2;
<a name="l02050"></a>02050     type3 i3;
<a name="l02051"></a>02051 
<a name="l02052"></a>02052     LITE_INLINE <a class="code" href="classlite_1_1pack.html" title="This is a general tuple class that can pack together elements of different types...">pack</a>() 
<a name="l02053"></a>02053         : i0(),i1(),i2(),i3()    {}
<a name="l02054"></a>02054     
<a name="l02055"></a>02055     LITE_INLINE pack(<span class="keyword">const</span> type0&amp; a0)
<a name="l02056"></a>02056         : i0(a0) 
<a name="l02057"></a>02057      {}
<a name="l02058"></a>02058 
<a name="l02059"></a>02059     LITE_INLINE pack(
<a name="l02060"></a>02060         <span class="keyword">const</span> type0&amp; a0,
<a name="l02061"></a>02061         <span class="keyword">const</span> type1&amp; a1,
<a name="l02062"></a>02062         <span class="keyword">const</span> type2&amp; a2,
<a name="l02063"></a>02063         <span class="keyword">const</span> type3&amp; a3
<a name="l02064"></a>02064         ) : i0(a0), i1(a1), i2(a2), i3(a3) {}
<a name="l02065"></a>02065 
<a name="l02066"></a>02066     <span class="keyword">template</span>&lt;
<a name="l02067"></a>02067         <span class="keyword">typename</span> other_type0_ ,
<a name="l02068"></a>02068         <span class="keyword">typename</span> other_type1_ ,
<a name="l02069"></a>02069         <span class="keyword">typename</span> other_type2_ ,
<a name="l02070"></a>02070         <span class="keyword">typename</span> other_type3_ 
<a name="l02071"></a>02071     &gt;
<a name="l02072"></a>02072     LITE_INLINE pack(<span class="keyword">const</span> pack&lt;
<a name="l02073"></a>02073         other_type0_,
<a name="l02074"></a>02074         other_type1_,
<a name="l02075"></a>02075         other_type2_,
<a name="l02076"></a>02076         other_type3_
<a name="l02077"></a>02077         &gt;&amp; other) : i0(other.i0), i1(other.i1), i2(other.i2), i3(other.i3)    {}
<a name="l02078"></a>02078 
<a name="l02079"></a>02079     LITE_INLINE pack&amp; 
<a name="l02080"></a>02080     operator= (<span class="keyword">const</span> pack&amp; other) 
<a name="l02081"></a>02081     {
<a name="l02082"></a>02082         i0 = other.i0;
<a name="l02083"></a>02083         i1 = other.i1;
<a name="l02084"></a>02084         i2 = other.i2;
<a name="l02085"></a>02085         i3 = other.i3;
<a name="l02086"></a>02086         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02087"></a>02087     }
<a name="l02088"></a>02088 
<a name="l02089"></a>02089     <span class="keyword">template</span>&lt;
<a name="l02090"></a>02090         <span class="keyword">typename</span> other_type0_ ,
<a name="l02091"></a>02091         <span class="keyword">typename</span> other_type1_ ,
<a name="l02092"></a>02092         <span class="keyword">typename</span> other_type2_ ,
<a name="l02093"></a>02093         <span class="keyword">typename</span> other_type3_ 
<a name="l02094"></a>02094     &gt;
<a name="l02095"></a>02095     LITE_INLINE pack&amp;  
<a name="l02096"></a>02096     operator=(<span class="keyword">const</span> pack&lt;
<a name="l02097"></a>02097         other_type0_,
<a name="l02098"></a>02098         other_type1_,
<a name="l02099"></a>02099         other_type2_,
<a name="l02100"></a>02100         other_type3_
<a name="l02101"></a>02101         &gt;&amp; other) 
<a name="l02102"></a>02102     {
<a name="l02103"></a>02103         i0 = other.i0;
<a name="l02104"></a>02104         i1 = other.i1;
<a name="l02105"></a>02105         i2 = other.i2;
<a name="l02106"></a>02106         i3 = other.i3;
<a name="l02107"></a>02107         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02108"></a>02108     }
<a name="l02109"></a>02109 
<a name="l02110"></a>02110     LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l02111"></a>02111         <span class="keyword">const</span> type0&amp; a0,
<a name="l02112"></a>02112         <span class="keyword">const</span> type1&amp; a1,
<a name="l02113"></a>02113         <span class="keyword">const</span> type2&amp; a2,
<a name="l02114"></a>02114         <span class="keyword">const</span> type3&amp; a3
<a name="l02115"></a>02115         ) 
<a name="l02116"></a>02116     {
<a name="l02117"></a>02117             i0 = a0;
<a name="l02118"></a>02118             i1 = a1;
<a name="l02119"></a>02119             i2 = a2;
<a name="l02120"></a>02120             i3 = a3;
<a name="l02121"></a>02121     }
<a name="l02122"></a>02122 };
<a name="l02123"></a>02123 
<a name="l02124"></a>02124 
<a name="l02125"></a>02125 <span class="comment">/***********************************************************************************************************/</span>
<a name="l02126"></a>02126 <span class="keyword">template</span>&lt;
<a name="l02127"></a>02127     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l02128"></a>02128     <span class="keyword">typename</span> type1_,
<a name="l02129"></a>02129     <span class="keyword">typename</span> type2_,
<a name="l02130"></a>02130     <span class="keyword">typename</span> type3_
<a name="l02131"></a>02131     &gt;
<a name="l02132"></a>02132 <span class="keyword">class </span>pack&lt;
<a name="l02133"></a>02133     constant&lt;type0_, value0_&gt;,
<a name="l02134"></a>02134     type1_,
<a name="l02135"></a>02135     type2_,
<a name="l02136"></a>02136     type3_
<a name="l02137"></a>02137     &gt;
<a name="l02138"></a>02138 {
<a name="l02139"></a>02139 <span class="keyword">public</span>:
<a name="l02140"></a>02140     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n = 4;
<a name="l02141"></a>02141 
<a name="l02142"></a>02142     <span class="keyword">typedef</span> type0_ type0;
<a name="l02143"></a>02143     <span class="keyword">typedef</span> type1_ type1;
<a name="l02144"></a>02144     <span class="keyword">typedef</span> type2_ type2;
<a name="l02145"></a>02145     <span class="keyword">typedef</span> type3_ type3;
<a name="l02146"></a>02146 
<a name="l02147"></a>02147     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const0 = <span class="keyword">true</span>;
<a name="l02148"></a>02148     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const1 = <span class="keyword">false</span>;
<a name="l02149"></a>02149     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const2 = <span class="keyword">false</span>;
<a name="l02150"></a>02150     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const3 = <span class="keyword">false</span>;
<a name="l02151"></a>02151     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_all_const = <span class="keyword">false</span>;
<a name="l02152"></a>02152     <span class="keyword">static</span> <span class="keyword">const</span> type0 i0 = value0_;
<a name="l02153"></a>02153     type1 i1;
<a name="l02154"></a>02154     type2 i2;
<a name="l02155"></a>02155     type3 i3;
<a name="l02156"></a>02156 
<a name="l02157"></a>02157     LITE_INLINE pack() 
<a name="l02158"></a>02158         : i1(),i2(),i3()    {}
<a name="l02159"></a>02159     
<a name="l02160"></a>02160     LITE_INLINE pack(<span class="keyword">const</span> type0&amp; )
<a name="l02161"></a>02161      {}
<a name="l02162"></a>02162 
<a name="l02163"></a>02163     LITE_INLINE pack(
<a name="l02164"></a>02164         <span class="keyword">const</span> type0&amp; ,
<a name="l02165"></a>02165         <span class="keyword">const</span> type1&amp; a1,
<a name="l02166"></a>02166         <span class="keyword">const</span> type2&amp; a2,
<a name="l02167"></a>02167         <span class="keyword">const</span> type3&amp; a3
<a name="l02168"></a>02168         ) : i1(a1), i2(a2), i3(a3) {}
<a name="l02169"></a>02169 
<a name="l02170"></a>02170     <span class="keyword">template</span>&lt;
<a name="l02171"></a>02171         <span class="keyword">typename</span> other_type0_ ,
<a name="l02172"></a>02172         <span class="keyword">typename</span> other_type1_ ,
<a name="l02173"></a>02173         <span class="keyword">typename</span> other_type2_ ,
<a name="l02174"></a>02174         <span class="keyword">typename</span> other_type3_ 
<a name="l02175"></a>02175     &gt;
<a name="l02176"></a>02176     LITE_INLINE pack(<span class="keyword">const</span> pack&lt;
<a name="l02177"></a>02177         other_type0_,
<a name="l02178"></a>02178         other_type1_,
<a name="l02179"></a>02179         other_type2_,
<a name="l02180"></a>02180         other_type3_
<a name="l02181"></a>02181         &gt;&amp; other) : i1(other.i1), i2(other.i2), i3(other.i3)    {}
<a name="l02182"></a>02182 
<a name="l02183"></a>02183     LITE_INLINE pack&amp; 
<a name="l02184"></a>02184     operator= (<span class="keyword">const</span> pack&amp; other) 
<a name="l02185"></a>02185     {
<a name="l02186"></a>02186         i1 = other.i1;
<a name="l02187"></a>02187         i2 = other.i2;
<a name="l02188"></a>02188         i3 = other.i3;
<a name="l02189"></a>02189         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02190"></a>02190     }
<a name="l02191"></a>02191 
<a name="l02192"></a>02192     <span class="keyword">template</span>&lt;
<a name="l02193"></a>02193         <span class="keyword">typename</span> other_type0_ ,
<a name="l02194"></a>02194         <span class="keyword">typename</span> other_type1_ ,
<a name="l02195"></a>02195         <span class="keyword">typename</span> other_type2_ ,
<a name="l02196"></a>02196         <span class="keyword">typename</span> other_type3_ 
<a name="l02197"></a>02197     &gt;
<a name="l02198"></a>02198     LITE_INLINE pack&amp;  
<a name="l02199"></a>02199     operator=(<span class="keyword">const</span> pack&lt;
<a name="l02200"></a>02200         other_type0_,
<a name="l02201"></a>02201         other_type1_,
<a name="l02202"></a>02202         other_type2_,
<a name="l02203"></a>02203         other_type3_
<a name="l02204"></a>02204         &gt;&amp; other) 
<a name="l02205"></a>02205     {
<a name="l02206"></a>02206         i1 = other.i1;
<a name="l02207"></a>02207         i2 = other.i2;
<a name="l02208"></a>02208         i3 = other.i3;
<a name="l02209"></a>02209         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02210"></a>02210     }
<a name="l02211"></a>02211 
<a name="l02212"></a>02212     LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l02213"></a>02213         <span class="keyword">const</span> type0&amp; ,
<a name="l02214"></a>02214         <span class="keyword">const</span> type1&amp; a1,
<a name="l02215"></a>02215         <span class="keyword">const</span> type2&amp; a2,
<a name="l02216"></a>02216         <span class="keyword">const</span> type3&amp; a3
<a name="l02217"></a>02217         ) 
<a name="l02218"></a>02218     {
<a name="l02219"></a>02219             i1 = a1;
<a name="l02220"></a>02220             i2 = a2;
<a name="l02221"></a>02221             i3 = a3;
<a name="l02222"></a>02222     }
<a name="l02223"></a>02223 };
<a name="l02224"></a>02224 
<a name="l02225"></a>02225 
<a name="l02226"></a>02226 <span class="keyword">template</span>&lt;
<a name="l02227"></a>02227     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l02228"></a>02228     <span class="keyword">typename</span> type1_,
<a name="l02229"></a>02229     <span class="keyword">typename</span> type2_,
<a name="l02230"></a>02230     <span class="keyword">typename</span> type3_
<a name="l02231"></a>02231     &gt;
<a name="l02232"></a>02232 <span class="keyword">const</span> type0_ pack&lt;
<a name="l02233"></a>02233     constant&lt;type0_, value0_&gt;,
<a name="l02234"></a>02234     type1_,
<a name="l02235"></a>02235     type2_,
<a name="l02236"></a>02236     type3_
<a name="l02237"></a>02237     &gt;::i0;
<a name="l02238"></a>02238 
<a name="l02239"></a>02239 <span class="comment">/***********************************************************************************************************/</span>
<a name="l02240"></a>02240 <span class="keyword">template</span>&lt;
<a name="l02241"></a>02241     <span class="keyword">typename</span> type0_,
<a name="l02242"></a>02242     <span class="keyword">typename</span> type1_, type1_ value1_,
<a name="l02243"></a>02243     <span class="keyword">typename</span> type2_,
<a name="l02244"></a>02244     <span class="keyword">typename</span> type3_
<a name="l02245"></a>02245     &gt;
<a name="l02246"></a>02246 <span class="keyword">class </span>pack&lt;
<a name="l02247"></a>02247     type0_,
<a name="l02248"></a>02248     constant&lt;type1_, value1_&gt;,
<a name="l02249"></a>02249     type2_,
<a name="l02250"></a>02250     type3_
<a name="l02251"></a>02251     &gt;
<a name="l02252"></a>02252 {
<a name="l02253"></a>02253 <span class="keyword">public</span>:
<a name="l02254"></a>02254     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n = 4;
<a name="l02255"></a>02255 
<a name="l02256"></a>02256     <span class="keyword">typedef</span> type0_ type0;
<a name="l02257"></a>02257     <span class="keyword">typedef</span> type1_ type1;
<a name="l02258"></a>02258     <span class="keyword">typedef</span> type2_ type2;
<a name="l02259"></a>02259     <span class="keyword">typedef</span> type3_ type3;
<a name="l02260"></a>02260 
<a name="l02261"></a>02261     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const0 = <span class="keyword">false</span>;
<a name="l02262"></a>02262     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const1 = <span class="keyword">true</span>;
<a name="l02263"></a>02263     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const2 = <span class="keyword">false</span>;
<a name="l02264"></a>02264     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const3 = <span class="keyword">false</span>;
<a name="l02265"></a>02265     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_all_const = <span class="keyword">false</span>;
<a name="l02266"></a>02266     type0 i0;
<a name="l02267"></a>02267     <span class="keyword">static</span> <span class="keyword">const</span> type1 i1 = value1_;
<a name="l02268"></a>02268     type2 i2;
<a name="l02269"></a>02269     type3 i3;
<a name="l02270"></a>02270 
<a name="l02271"></a>02271     LITE_INLINE pack() 
<a name="l02272"></a>02272         : i0(),i2(),i3()    {}
<a name="l02273"></a>02273     
<a name="l02274"></a>02274     LITE_INLINE pack(<span class="keyword">const</span> type0&amp; a0)
<a name="l02275"></a>02275         : i0(a0) 
<a name="l02276"></a>02276      {}
<a name="l02277"></a>02277 
<a name="l02278"></a>02278     LITE_INLINE pack(
<a name="l02279"></a>02279         <span class="keyword">const</span> type0&amp; a0,
<a name="l02280"></a>02280         <span class="keyword">const</span> type1&amp; ,
<a name="l02281"></a>02281         <span class="keyword">const</span> type2&amp; a2,
<a name="l02282"></a>02282         <span class="keyword">const</span> type3&amp; a3
<a name="l02283"></a>02283         ) : i0(a0), i2(a2), i3(a3) {}
<a name="l02284"></a>02284 
<a name="l02285"></a>02285     <span class="keyword">template</span>&lt;
<a name="l02286"></a>02286         <span class="keyword">typename</span> other_type0_ ,
<a name="l02287"></a>02287         <span class="keyword">typename</span> other_type1_ ,
<a name="l02288"></a>02288         <span class="keyword">typename</span> other_type2_ ,
<a name="l02289"></a>02289         <span class="keyword">typename</span> other_type3_ 
<a name="l02290"></a>02290     &gt;
<a name="l02291"></a>02291     LITE_INLINE pack(<span class="keyword">const</span> pack&lt;
<a name="l02292"></a>02292         other_type0_,
<a name="l02293"></a>02293         other_type1_,
<a name="l02294"></a>02294         other_type2_,
<a name="l02295"></a>02295         other_type3_
<a name="l02296"></a>02296         &gt;&amp; other) : i0(other.i0), i2(other.i2), i3(other.i3)    {}
<a name="l02297"></a>02297 
<a name="l02298"></a>02298     LITE_INLINE pack&amp; 
<a name="l02299"></a>02299     operator= (<span class="keyword">const</span> pack&amp; other) 
<a name="l02300"></a>02300     {
<a name="l02301"></a>02301         i0 = other.i0;
<a name="l02302"></a>02302         i2 = other.i2;
<a name="l02303"></a>02303         i3 = other.i3;
<a name="l02304"></a>02304         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02305"></a>02305     }
<a name="l02306"></a>02306 
<a name="l02307"></a>02307     <span class="keyword">template</span>&lt;
<a name="l02308"></a>02308         <span class="keyword">typename</span> other_type0_ ,
<a name="l02309"></a>02309         <span class="keyword">typename</span> other_type1_ ,
<a name="l02310"></a>02310         <span class="keyword">typename</span> other_type2_ ,
<a name="l02311"></a>02311         <span class="keyword">typename</span> other_type3_ 
<a name="l02312"></a>02312     &gt;
<a name="l02313"></a>02313     LITE_INLINE pack&amp;  
<a name="l02314"></a>02314     operator=(<span class="keyword">const</span> pack&lt;
<a name="l02315"></a>02315         other_type0_,
<a name="l02316"></a>02316         other_type1_,
<a name="l02317"></a>02317         other_type2_,
<a name="l02318"></a>02318         other_type3_
<a name="l02319"></a>02319         &gt;&amp; other) 
<a name="l02320"></a>02320     {
<a name="l02321"></a>02321         i0 = other.i0;
<a name="l02322"></a>02322         i2 = other.i2;
<a name="l02323"></a>02323         i3 = other.i3;
<a name="l02324"></a>02324         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02325"></a>02325     }
<a name="l02326"></a>02326 
<a name="l02327"></a>02327     LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l02328"></a>02328         <span class="keyword">const</span> type0&amp; a0,
<a name="l02329"></a>02329         <span class="keyword">const</span> type1&amp; ,
<a name="l02330"></a>02330         <span class="keyword">const</span> type2&amp; a2,
<a name="l02331"></a>02331         <span class="keyword">const</span> type3&amp; a3
<a name="l02332"></a>02332         ) 
<a name="l02333"></a>02333     {
<a name="l02334"></a>02334             i0 = a0;
<a name="l02335"></a>02335             i2 = a2;
<a name="l02336"></a>02336             i3 = a3;
<a name="l02337"></a>02337     }
<a name="l02338"></a>02338 };
<a name="l02339"></a>02339 
<a name="l02340"></a>02340 
<a name="l02341"></a>02341 <span class="keyword">template</span>&lt;
<a name="l02342"></a>02342     <span class="keyword">typename</span> type0_,
<a name="l02343"></a>02343     <span class="keyword">typename</span> type1_, type1_ value1_,
<a name="l02344"></a>02344     <span class="keyword">typename</span> type2_,
<a name="l02345"></a>02345     <span class="keyword">typename</span> type3_
<a name="l02346"></a>02346     &gt;
<a name="l02347"></a>02347 <span class="keyword">const</span> type1_ pack&lt;
<a name="l02348"></a>02348     type0_,
<a name="l02349"></a>02349     constant&lt;type1_, value1_&gt;,
<a name="l02350"></a>02350     type2_,
<a name="l02351"></a>02351     type3_
<a name="l02352"></a>02352     &gt;::i1;
<a name="l02353"></a>02353 
<a name="l02354"></a>02354 <span class="comment">/***********************************************************************************************************/</span>
<a name="l02355"></a>02355 <span class="keyword">template</span>&lt;
<a name="l02356"></a>02356     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l02357"></a>02357     <span class="keyword">typename</span> type1_, type1_ value1_,
<a name="l02358"></a>02358     <span class="keyword">typename</span> type2_,
<a name="l02359"></a>02359     <span class="keyword">typename</span> type3_
<a name="l02360"></a>02360     &gt;
<a name="l02361"></a>02361 <span class="keyword">class </span>pack&lt;
<a name="l02362"></a>02362     constant&lt;type0_, value0_&gt;,
<a name="l02363"></a>02363     constant&lt;type1_, value1_&gt;,
<a name="l02364"></a>02364     type2_,
<a name="l02365"></a>02365     type3_
<a name="l02366"></a>02366     &gt;
<a name="l02367"></a>02367 {
<a name="l02368"></a>02368 <span class="keyword">public</span>:
<a name="l02369"></a>02369     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n = 4;
<a name="l02370"></a>02370 
<a name="l02371"></a>02371     <span class="keyword">typedef</span> type0_ type0;
<a name="l02372"></a>02372     <span class="keyword">typedef</span> type1_ type1;
<a name="l02373"></a>02373     <span class="keyword">typedef</span> type2_ type2;
<a name="l02374"></a>02374     <span class="keyword">typedef</span> type3_ type3;
<a name="l02375"></a>02375 
<a name="l02376"></a>02376     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const0 = <span class="keyword">true</span>;
<a name="l02377"></a>02377     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const1 = <span class="keyword">true</span>;
<a name="l02378"></a>02378     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const2 = <span class="keyword">false</span>;
<a name="l02379"></a>02379     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const3 = <span class="keyword">false</span>;
<a name="l02380"></a>02380     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_all_const = <span class="keyword">false</span>;
<a name="l02381"></a>02381     <span class="keyword">static</span> <span class="keyword">const</span> type0 i0 = value0_;
<a name="l02382"></a>02382     <span class="keyword">static</span> <span class="keyword">const</span> type1 i1 = value1_;
<a name="l02383"></a>02383     type2 i2;
<a name="l02384"></a>02384     type3 i3;
<a name="l02385"></a>02385 
<a name="l02386"></a>02386     LITE_INLINE pack() 
<a name="l02387"></a>02387         : i2(),i3()    {}
<a name="l02388"></a>02388     
<a name="l02389"></a>02389     LITE_INLINE pack(<span class="keyword">const</span> type0&amp; )
<a name="l02390"></a>02390      {}
<a name="l02391"></a>02391 
<a name="l02392"></a>02392     LITE_INLINE pack(
<a name="l02393"></a>02393         <span class="keyword">const</span> type0&amp; ,
<a name="l02394"></a>02394         <span class="keyword">const</span> type1&amp; ,
<a name="l02395"></a>02395         <span class="keyword">const</span> type2&amp; a2,
<a name="l02396"></a>02396         <span class="keyword">const</span> type3&amp; a3
<a name="l02397"></a>02397         ) : i2(a2), i3(a3) {}
<a name="l02398"></a>02398 
<a name="l02399"></a>02399     <span class="keyword">template</span>&lt;
<a name="l02400"></a>02400         <span class="keyword">typename</span> other_type0_ ,
<a name="l02401"></a>02401         <span class="keyword">typename</span> other_type1_ ,
<a name="l02402"></a>02402         <span class="keyword">typename</span> other_type2_ ,
<a name="l02403"></a>02403         <span class="keyword">typename</span> other_type3_ 
<a name="l02404"></a>02404     &gt;
<a name="l02405"></a>02405     LITE_INLINE pack(<span class="keyword">const</span> pack&lt;
<a name="l02406"></a>02406         other_type0_,
<a name="l02407"></a>02407         other_type1_,
<a name="l02408"></a>02408         other_type2_,
<a name="l02409"></a>02409         other_type3_
<a name="l02410"></a>02410         &gt;&amp; other) : i2(other.i2), i3(other.i3)    {}
<a name="l02411"></a>02411 
<a name="l02412"></a>02412     LITE_INLINE pack&amp; 
<a name="l02413"></a>02413     operator= (<span class="keyword">const</span> pack&amp; other) 
<a name="l02414"></a>02414     {
<a name="l02415"></a>02415         i2 = other.i2;
<a name="l02416"></a>02416         i3 = other.i3;
<a name="l02417"></a>02417         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02418"></a>02418     }
<a name="l02419"></a>02419 
<a name="l02420"></a>02420     <span class="keyword">template</span>&lt;
<a name="l02421"></a>02421         <span class="keyword">typename</span> other_type0_ ,
<a name="l02422"></a>02422         <span class="keyword">typename</span> other_type1_ ,
<a name="l02423"></a>02423         <span class="keyword">typename</span> other_type2_ ,
<a name="l02424"></a>02424         <span class="keyword">typename</span> other_type3_ 
<a name="l02425"></a>02425     &gt;
<a name="l02426"></a>02426     LITE_INLINE pack&amp;  
<a name="l02427"></a>02427     operator=(<span class="keyword">const</span> pack&lt;
<a name="l02428"></a>02428         other_type0_,
<a name="l02429"></a>02429         other_type1_,
<a name="l02430"></a>02430         other_type2_,
<a name="l02431"></a>02431         other_type3_
<a name="l02432"></a>02432         &gt;&amp; other) 
<a name="l02433"></a>02433     {
<a name="l02434"></a>02434         i2 = other.i2;
<a name="l02435"></a>02435         i3 = other.i3;
<a name="l02436"></a>02436         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02437"></a>02437     }
<a name="l02438"></a>02438 
<a name="l02439"></a>02439     LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l02440"></a>02440         <span class="keyword">const</span> type0&amp; ,
<a name="l02441"></a>02441         <span class="keyword">const</span> type1&amp; ,
<a name="l02442"></a>02442         <span class="keyword">const</span> type2&amp; a2,
<a name="l02443"></a>02443         <span class="keyword">const</span> type3&amp; a3
<a name="l02444"></a>02444         ) 
<a name="l02445"></a>02445     {
<a name="l02446"></a>02446             i2 = a2;
<a name="l02447"></a>02447             i3 = a3;
<a name="l02448"></a>02448     }
<a name="l02449"></a>02449 };
<a name="l02450"></a>02450 
<a name="l02451"></a>02451 
<a name="l02452"></a>02452 <span class="keyword">template</span>&lt;
<a name="l02453"></a>02453     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l02454"></a>02454     <span class="keyword">typename</span> type1_, type1_ value1_,
<a name="l02455"></a>02455     <span class="keyword">typename</span> type2_,
<a name="l02456"></a>02456     <span class="keyword">typename</span> type3_
<a name="l02457"></a>02457     &gt;
<a name="l02458"></a>02458 <span class="keyword">const</span> type0_ pack&lt;
<a name="l02459"></a>02459     constant&lt;type0_, value0_&gt;,
<a name="l02460"></a>02460     constant&lt;type1_, value1_&gt;,
<a name="l02461"></a>02461     type2_,
<a name="l02462"></a>02462     type3_
<a name="l02463"></a>02463     &gt;::i0;
<a name="l02464"></a>02464 
<a name="l02465"></a>02465 <span class="keyword">template</span>&lt;
<a name="l02466"></a>02466     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l02467"></a>02467     <span class="keyword">typename</span> type1_, type1_ value1_,
<a name="l02468"></a>02468     <span class="keyword">typename</span> type2_,
<a name="l02469"></a>02469     <span class="keyword">typename</span> type3_
<a name="l02470"></a>02470     &gt;
<a name="l02471"></a>02471 <span class="keyword">const</span> type1_ pack&lt;
<a name="l02472"></a>02472     constant&lt;type0_, value0_&gt;,
<a name="l02473"></a>02473     constant&lt;type1_, value1_&gt;,
<a name="l02474"></a>02474     type2_,
<a name="l02475"></a>02475     type3_
<a name="l02476"></a>02476     &gt;::i1;
<a name="l02477"></a>02477 
<a name="l02478"></a>02478 <span class="comment">/***********************************************************************************************************/</span>
<a name="l02479"></a>02479 <span class="keyword">template</span>&lt;
<a name="l02480"></a>02480     <span class="keyword">typename</span> type0_,
<a name="l02481"></a>02481     <span class="keyword">typename</span> type1_,
<a name="l02482"></a>02482     <span class="keyword">typename</span> type2_, type2_ value2_,
<a name="l02483"></a>02483     <span class="keyword">typename</span> type3_
<a name="l02484"></a>02484     &gt;
<a name="l02485"></a>02485 <span class="keyword">class </span>pack&lt;
<a name="l02486"></a>02486     type0_,
<a name="l02487"></a>02487     type1_,
<a name="l02488"></a>02488     constant&lt;type2_, value2_&gt;,
<a name="l02489"></a>02489     type3_
<a name="l02490"></a>02490     &gt;
<a name="l02491"></a>02491 {
<a name="l02492"></a>02492 <span class="keyword">public</span>:
<a name="l02493"></a>02493     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n = 4;
<a name="l02494"></a>02494 
<a name="l02495"></a>02495     <span class="keyword">typedef</span> type0_ type0;
<a name="l02496"></a>02496     <span class="keyword">typedef</span> type1_ type1;
<a name="l02497"></a>02497     <span class="keyword">typedef</span> type2_ type2;
<a name="l02498"></a>02498     <span class="keyword">typedef</span> type3_ type3;
<a name="l02499"></a>02499 
<a name="l02500"></a>02500     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const0 = <span class="keyword">false</span>;
<a name="l02501"></a>02501     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const1 = <span class="keyword">false</span>;
<a name="l02502"></a>02502     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const2 = <span class="keyword">true</span>;
<a name="l02503"></a>02503     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const3 = <span class="keyword">false</span>;
<a name="l02504"></a>02504     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_all_const = <span class="keyword">false</span>;
<a name="l02505"></a>02505     type0 i0;
<a name="l02506"></a>02506     type1 i1;
<a name="l02507"></a>02507     <span class="keyword">static</span> <span class="keyword">const</span> type2 i2 = value2_;
<a name="l02508"></a>02508     type3 i3;
<a name="l02509"></a>02509 
<a name="l02510"></a>02510     LITE_INLINE pack() 
<a name="l02511"></a>02511         : i0(),i1(),i3()    {}
<a name="l02512"></a>02512     
<a name="l02513"></a>02513     LITE_INLINE pack(<span class="keyword">const</span> type0&amp; a0)
<a name="l02514"></a>02514         : i0(a0) 
<a name="l02515"></a>02515      {}
<a name="l02516"></a>02516 
<a name="l02517"></a>02517     LITE_INLINE pack(
<a name="l02518"></a>02518         <span class="keyword">const</span> type0&amp; a0,
<a name="l02519"></a>02519         <span class="keyword">const</span> type1&amp; a1,
<a name="l02520"></a>02520         <span class="keyword">const</span> type2&amp; ,
<a name="l02521"></a>02521         <span class="keyword">const</span> type3&amp; a3
<a name="l02522"></a>02522         ) : i0(a0), i1(a1), i3(a3) {}
<a name="l02523"></a>02523 
<a name="l02524"></a>02524     <span class="keyword">template</span>&lt;
<a name="l02525"></a>02525         <span class="keyword">typename</span> other_type0_ ,
<a name="l02526"></a>02526         <span class="keyword">typename</span> other_type1_ ,
<a name="l02527"></a>02527         <span class="keyword">typename</span> other_type2_ ,
<a name="l02528"></a>02528         <span class="keyword">typename</span> other_type3_ 
<a name="l02529"></a>02529     &gt;
<a name="l02530"></a>02530     LITE_INLINE pack(<span class="keyword">const</span> pack&lt;
<a name="l02531"></a>02531         other_type0_,
<a name="l02532"></a>02532         other_type1_,
<a name="l02533"></a>02533         other_type2_,
<a name="l02534"></a>02534         other_type3_
<a name="l02535"></a>02535         &gt;&amp; other) : i0(other.i0), i1(other.i1), i3(other.i3)    {}
<a name="l02536"></a>02536 
<a name="l02537"></a>02537     LITE_INLINE pack&amp; 
<a name="l02538"></a>02538     operator= (<span class="keyword">const</span> pack&amp; other) 
<a name="l02539"></a>02539     {
<a name="l02540"></a>02540         i0 = other.i0;
<a name="l02541"></a>02541         i1 = other.i1;
<a name="l02542"></a>02542         i3 = other.i3;
<a name="l02543"></a>02543         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02544"></a>02544     }
<a name="l02545"></a>02545 
<a name="l02546"></a>02546     <span class="keyword">template</span>&lt;
<a name="l02547"></a>02547         <span class="keyword">typename</span> other_type0_ ,
<a name="l02548"></a>02548         <span class="keyword">typename</span> other_type1_ ,
<a name="l02549"></a>02549         <span class="keyword">typename</span> other_type2_ ,
<a name="l02550"></a>02550         <span class="keyword">typename</span> other_type3_ 
<a name="l02551"></a>02551     &gt;
<a name="l02552"></a>02552     LITE_INLINE pack&amp;  
<a name="l02553"></a>02553     operator=(<span class="keyword">const</span> pack&lt;
<a name="l02554"></a>02554         other_type0_,
<a name="l02555"></a>02555         other_type1_,
<a name="l02556"></a>02556         other_type2_,
<a name="l02557"></a>02557         other_type3_
<a name="l02558"></a>02558         &gt;&amp; other) 
<a name="l02559"></a>02559     {
<a name="l02560"></a>02560         i0 = other.i0;
<a name="l02561"></a>02561         i1 = other.i1;
<a name="l02562"></a>02562         i3 = other.i3;
<a name="l02563"></a>02563         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02564"></a>02564     }
<a name="l02565"></a>02565 
<a name="l02566"></a>02566     LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l02567"></a>02567         <span class="keyword">const</span> type0&amp; a0,
<a name="l02568"></a>02568         <span class="keyword">const</span> type1&amp; a1,
<a name="l02569"></a>02569         <span class="keyword">const</span> type2&amp; ,
<a name="l02570"></a>02570         <span class="keyword">const</span> type3&amp; a3
<a name="l02571"></a>02571         ) 
<a name="l02572"></a>02572     {
<a name="l02573"></a>02573             i0 = a0;
<a name="l02574"></a>02574             i1 = a1;
<a name="l02575"></a>02575             i3 = a3;
<a name="l02576"></a>02576     }
<a name="l02577"></a>02577 };
<a name="l02578"></a>02578 
<a name="l02579"></a>02579 
<a name="l02580"></a>02580 <span class="keyword">template</span>&lt;
<a name="l02581"></a>02581     <span class="keyword">typename</span> type0_,
<a name="l02582"></a>02582     <span class="keyword">typename</span> type1_,
<a name="l02583"></a>02583     <span class="keyword">typename</span> type2_, type2_ value2_,
<a name="l02584"></a>02584     <span class="keyword">typename</span> type3_
<a name="l02585"></a>02585     &gt;
<a name="l02586"></a>02586 <span class="keyword">const</span> type2_ pack&lt;
<a name="l02587"></a>02587     type0_,
<a name="l02588"></a>02588     type1_,
<a name="l02589"></a>02589     constant&lt;type2_, value2_&gt;,
<a name="l02590"></a>02590     type3_
<a name="l02591"></a>02591     &gt;::i2;
<a name="l02592"></a>02592 
<a name="l02593"></a>02593 <span class="comment">/***********************************************************************************************************/</span>
<a name="l02594"></a>02594 <span class="keyword">template</span>&lt;
<a name="l02595"></a>02595     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l02596"></a>02596     <span class="keyword">typename</span> type1_,
<a name="l02597"></a>02597     <span class="keyword">typename</span> type2_, type2_ value2_,
<a name="l02598"></a>02598     <span class="keyword">typename</span> type3_
<a name="l02599"></a>02599     &gt;
<a name="l02600"></a>02600 <span class="keyword">class </span>pack&lt;
<a name="l02601"></a>02601     constant&lt;type0_, value0_&gt;,
<a name="l02602"></a>02602     type1_,
<a name="l02603"></a>02603     constant&lt;type2_, value2_&gt;,
<a name="l02604"></a>02604     type3_
<a name="l02605"></a>02605     &gt;
<a name="l02606"></a>02606 {
<a name="l02607"></a>02607 <span class="keyword">public</span>:
<a name="l02608"></a>02608     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n = 4;
<a name="l02609"></a>02609 
<a name="l02610"></a>02610     <span class="keyword">typedef</span> type0_ type0;
<a name="l02611"></a>02611     <span class="keyword">typedef</span> type1_ type1;
<a name="l02612"></a>02612     <span class="keyword">typedef</span> type2_ type2;
<a name="l02613"></a>02613     <span class="keyword">typedef</span> type3_ type3;
<a name="l02614"></a>02614 
<a name="l02615"></a>02615     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const0 = <span class="keyword">true</span>;
<a name="l02616"></a>02616     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const1 = <span class="keyword">false</span>;
<a name="l02617"></a>02617     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const2 = <span class="keyword">true</span>;
<a name="l02618"></a>02618     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const3 = <span class="keyword">false</span>;
<a name="l02619"></a>02619     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_all_const = <span class="keyword">false</span>;
<a name="l02620"></a>02620     <span class="keyword">static</span> <span class="keyword">const</span> type0 i0 = value0_;
<a name="l02621"></a>02621     type1 i1;
<a name="l02622"></a>02622     <span class="keyword">static</span> <span class="keyword">const</span> type2 i2 = value2_;
<a name="l02623"></a>02623     type3 i3;
<a name="l02624"></a>02624 
<a name="l02625"></a>02625     LITE_INLINE pack() 
<a name="l02626"></a>02626         : i1(),i3()    {}
<a name="l02627"></a>02627     
<a name="l02628"></a>02628     LITE_INLINE pack(<span class="keyword">const</span> type0&amp; )
<a name="l02629"></a>02629      {}
<a name="l02630"></a>02630 
<a name="l02631"></a>02631     LITE_INLINE pack(
<a name="l02632"></a>02632         <span class="keyword">const</span> type0&amp; ,
<a name="l02633"></a>02633         <span class="keyword">const</span> type1&amp; a1,
<a name="l02634"></a>02634         <span class="keyword">const</span> type2&amp; ,
<a name="l02635"></a>02635         <span class="keyword">const</span> type3&amp; a3
<a name="l02636"></a>02636         ) : i1(a1), i3(a3) {}
<a name="l02637"></a>02637 
<a name="l02638"></a>02638     <span class="keyword">template</span>&lt;
<a name="l02639"></a>02639         <span class="keyword">typename</span> other_type0_ ,
<a name="l02640"></a>02640         <span class="keyword">typename</span> other_type1_ ,
<a name="l02641"></a>02641         <span class="keyword">typename</span> other_type2_ ,
<a name="l02642"></a>02642         <span class="keyword">typename</span> other_type3_ 
<a name="l02643"></a>02643     &gt;
<a name="l02644"></a>02644     LITE_INLINE pack(<span class="keyword">const</span> pack&lt;
<a name="l02645"></a>02645         other_type0_,
<a name="l02646"></a>02646         other_type1_,
<a name="l02647"></a>02647         other_type2_,
<a name="l02648"></a>02648         other_type3_
<a name="l02649"></a>02649         &gt;&amp; other) : i1(other.i1), i3(other.i3)    {}
<a name="l02650"></a>02650 
<a name="l02651"></a>02651     LITE_INLINE pack&amp; 
<a name="l02652"></a>02652     operator= (<span class="keyword">const</span> pack&amp; other) 
<a name="l02653"></a>02653     {
<a name="l02654"></a>02654         i1 = other.i1;
<a name="l02655"></a>02655         i3 = other.i3;
<a name="l02656"></a>02656         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02657"></a>02657     }
<a name="l02658"></a>02658 
<a name="l02659"></a>02659     <span class="keyword">template</span>&lt;
<a name="l02660"></a>02660         <span class="keyword">typename</span> other_type0_ ,
<a name="l02661"></a>02661         <span class="keyword">typename</span> other_type1_ ,
<a name="l02662"></a>02662         <span class="keyword">typename</span> other_type2_ ,
<a name="l02663"></a>02663         <span class="keyword">typename</span> other_type3_ 
<a name="l02664"></a>02664     &gt;
<a name="l02665"></a>02665     LITE_INLINE pack&amp;  
<a name="l02666"></a>02666     operator=(<span class="keyword">const</span> pack&lt;
<a name="l02667"></a>02667         other_type0_,
<a name="l02668"></a>02668         other_type1_,
<a name="l02669"></a>02669         other_type2_,
<a name="l02670"></a>02670         other_type3_
<a name="l02671"></a>02671         &gt;&amp; other) 
<a name="l02672"></a>02672     {
<a name="l02673"></a>02673         i1 = other.i1;
<a name="l02674"></a>02674         i3 = other.i3;
<a name="l02675"></a>02675         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02676"></a>02676     }
<a name="l02677"></a>02677 
<a name="l02678"></a>02678     LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l02679"></a>02679         <span class="keyword">const</span> type0&amp; ,
<a name="l02680"></a>02680         <span class="keyword">const</span> type1&amp; a1,
<a name="l02681"></a>02681         <span class="keyword">const</span> type2&amp; ,
<a name="l02682"></a>02682         <span class="keyword">const</span> type3&amp; a3
<a name="l02683"></a>02683         ) 
<a name="l02684"></a>02684     {
<a name="l02685"></a>02685             i1 = a1;
<a name="l02686"></a>02686             i3 = a3;
<a name="l02687"></a>02687     }
<a name="l02688"></a>02688 };
<a name="l02689"></a>02689 
<a name="l02690"></a>02690 
<a name="l02691"></a>02691 <span class="keyword">template</span>&lt;
<a name="l02692"></a>02692     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l02693"></a>02693     <span class="keyword">typename</span> type1_,
<a name="l02694"></a>02694     <span class="keyword">typename</span> type2_, type2_ value2_,
<a name="l02695"></a>02695     <span class="keyword">typename</span> type3_
<a name="l02696"></a>02696     &gt;
<a name="l02697"></a>02697 <span class="keyword">const</span> type0_ pack&lt;
<a name="l02698"></a>02698     constant&lt;type0_, value0_&gt;,
<a name="l02699"></a>02699     type1_,
<a name="l02700"></a>02700     constant&lt;type2_, value2_&gt;,
<a name="l02701"></a>02701     type3_
<a name="l02702"></a>02702     &gt;::i0;
<a name="l02703"></a>02703 
<a name="l02704"></a>02704 <span class="keyword">template</span>&lt;
<a name="l02705"></a>02705     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l02706"></a>02706     <span class="keyword">typename</span> type1_,
<a name="l02707"></a>02707     <span class="keyword">typename</span> type2_, type2_ value2_,
<a name="l02708"></a>02708     <span class="keyword">typename</span> type3_
<a name="l02709"></a>02709     &gt;
<a name="l02710"></a>02710 <span class="keyword">const</span> type2_ pack&lt;
<a name="l02711"></a>02711     constant&lt;type0_, value0_&gt;,
<a name="l02712"></a>02712     type1_,
<a name="l02713"></a>02713     constant&lt;type2_, value2_&gt;,
<a name="l02714"></a>02714     type3_
<a name="l02715"></a>02715     &gt;::i2;
<a name="l02716"></a>02716 
<a name="l02717"></a>02717 <span class="comment">/***********************************************************************************************************/</span>
<a name="l02718"></a>02718 <span class="keyword">template</span>&lt;
<a name="l02719"></a>02719     <span class="keyword">typename</span> type0_,
<a name="l02720"></a>02720     <span class="keyword">typename</span> type1_, type1_ value1_,
<a name="l02721"></a>02721     <span class="keyword">typename</span> type2_, type2_ value2_,
<a name="l02722"></a>02722     <span class="keyword">typename</span> type3_
<a name="l02723"></a>02723     &gt;
<a name="l02724"></a>02724 <span class="keyword">class </span>pack&lt;
<a name="l02725"></a>02725     type0_,
<a name="l02726"></a>02726     constant&lt;type1_, value1_&gt;,
<a name="l02727"></a>02727     constant&lt;type2_, value2_&gt;,
<a name="l02728"></a>02728     type3_
<a name="l02729"></a>02729     &gt;
<a name="l02730"></a>02730 {
<a name="l02731"></a>02731 <span class="keyword">public</span>:
<a name="l02732"></a>02732     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n = 4;
<a name="l02733"></a>02733 
<a name="l02734"></a>02734     <span class="keyword">typedef</span> type0_ type0;
<a name="l02735"></a>02735     <span class="keyword">typedef</span> type1_ type1;
<a name="l02736"></a>02736     <span class="keyword">typedef</span> type2_ type2;
<a name="l02737"></a>02737     <span class="keyword">typedef</span> type3_ type3;
<a name="l02738"></a>02738 
<a name="l02739"></a>02739     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const0 = <span class="keyword">false</span>;
<a name="l02740"></a>02740     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const1 = <span class="keyword">true</span>;
<a name="l02741"></a>02741     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const2 = <span class="keyword">true</span>;
<a name="l02742"></a>02742     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const3 = <span class="keyword">false</span>;
<a name="l02743"></a>02743     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_all_const = <span class="keyword">false</span>;
<a name="l02744"></a>02744     type0 i0;
<a name="l02745"></a>02745     <span class="keyword">static</span> <span class="keyword">const</span> type1 i1 = value1_;
<a name="l02746"></a>02746     <span class="keyword">static</span> <span class="keyword">const</span> type2 i2 = value2_;
<a name="l02747"></a>02747     type3 i3;
<a name="l02748"></a>02748 
<a name="l02749"></a>02749     LITE_INLINE pack() 
<a name="l02750"></a>02750         : i0(),i3()    {}
<a name="l02751"></a>02751     
<a name="l02752"></a>02752     LITE_INLINE pack(<span class="keyword">const</span> type0&amp; a0)
<a name="l02753"></a>02753         : i0(a0) 
<a name="l02754"></a>02754      {}
<a name="l02755"></a>02755 
<a name="l02756"></a>02756     LITE_INLINE pack(
<a name="l02757"></a>02757         <span class="keyword">const</span> type0&amp; a0,
<a name="l02758"></a>02758         <span class="keyword">const</span> type1&amp; ,
<a name="l02759"></a>02759         <span class="keyword">const</span> type2&amp; ,
<a name="l02760"></a>02760         <span class="keyword">const</span> type3&amp; a3
<a name="l02761"></a>02761         ) : i0(a0), i3(a3) {}
<a name="l02762"></a>02762 
<a name="l02763"></a>02763     <span class="keyword">template</span>&lt;
<a name="l02764"></a>02764         <span class="keyword">typename</span> other_type0_ ,
<a name="l02765"></a>02765         <span class="keyword">typename</span> other_type1_ ,
<a name="l02766"></a>02766         <span class="keyword">typename</span> other_type2_ ,
<a name="l02767"></a>02767         <span class="keyword">typename</span> other_type3_ 
<a name="l02768"></a>02768     &gt;
<a name="l02769"></a>02769     LITE_INLINE pack(<span class="keyword">const</span> pack&lt;
<a name="l02770"></a>02770         other_type0_,
<a name="l02771"></a>02771         other_type1_,
<a name="l02772"></a>02772         other_type2_,
<a name="l02773"></a>02773         other_type3_
<a name="l02774"></a>02774         &gt;&amp; other) : i0(other.i0), i3(other.i3)    {}
<a name="l02775"></a>02775 
<a name="l02776"></a>02776     LITE_INLINE pack&amp; 
<a name="l02777"></a>02777     operator= (<span class="keyword">const</span> pack&amp; other) 
<a name="l02778"></a>02778     {
<a name="l02779"></a>02779         i0 = other.i0;
<a name="l02780"></a>02780         i3 = other.i3;
<a name="l02781"></a>02781         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02782"></a>02782     }
<a name="l02783"></a>02783 
<a name="l02784"></a>02784     <span class="keyword">template</span>&lt;
<a name="l02785"></a>02785         <span class="keyword">typename</span> other_type0_ ,
<a name="l02786"></a>02786         <span class="keyword">typename</span> other_type1_ ,
<a name="l02787"></a>02787         <span class="keyword">typename</span> other_type2_ ,
<a name="l02788"></a>02788         <span class="keyword">typename</span> other_type3_ 
<a name="l02789"></a>02789     &gt;
<a name="l02790"></a>02790     LITE_INLINE pack&amp;  
<a name="l02791"></a>02791     operator=(<span class="keyword">const</span> pack&lt;
<a name="l02792"></a>02792         other_type0_,
<a name="l02793"></a>02793         other_type1_,
<a name="l02794"></a>02794         other_type2_,
<a name="l02795"></a>02795         other_type3_
<a name="l02796"></a>02796         &gt;&amp; other) 
<a name="l02797"></a>02797     {
<a name="l02798"></a>02798         i0 = other.i0;
<a name="l02799"></a>02799         i3 = other.i3;
<a name="l02800"></a>02800         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02801"></a>02801     }
<a name="l02802"></a>02802 
<a name="l02803"></a>02803     LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l02804"></a>02804         <span class="keyword">const</span> type0&amp; a0,
<a name="l02805"></a>02805         <span class="keyword">const</span> type1&amp; ,
<a name="l02806"></a>02806         <span class="keyword">const</span> type2&amp; ,
<a name="l02807"></a>02807         <span class="keyword">const</span> type3&amp; a3
<a name="l02808"></a>02808         ) 
<a name="l02809"></a>02809     {
<a name="l02810"></a>02810             i0 = a0;
<a name="l02811"></a>02811             i3 = a3;
<a name="l02812"></a>02812     }
<a name="l02813"></a>02813 };
<a name="l02814"></a>02814 
<a name="l02815"></a>02815 
<a name="l02816"></a>02816 <span class="keyword">template</span>&lt;
<a name="l02817"></a>02817     <span class="keyword">typename</span> type0_,
<a name="l02818"></a>02818     <span class="keyword">typename</span> type1_, type1_ value1_,
<a name="l02819"></a>02819     <span class="keyword">typename</span> type2_, type2_ value2_,
<a name="l02820"></a>02820     <span class="keyword">typename</span> type3_
<a name="l02821"></a>02821     &gt;
<a name="l02822"></a>02822 <span class="keyword">const</span> type1_ pack&lt;
<a name="l02823"></a>02823     type0_,
<a name="l02824"></a>02824     constant&lt;type1_, value1_&gt;,
<a name="l02825"></a>02825     constant&lt;type2_, value2_&gt;,
<a name="l02826"></a>02826     type3_
<a name="l02827"></a>02827     &gt;::i1;
<a name="l02828"></a>02828 
<a name="l02829"></a>02829 <span class="keyword">template</span>&lt;
<a name="l02830"></a>02830     <span class="keyword">typename</span> type0_,
<a name="l02831"></a>02831     <span class="keyword">typename</span> type1_, type1_ value1_,
<a name="l02832"></a>02832     <span class="keyword">typename</span> type2_, type2_ value2_,
<a name="l02833"></a>02833     <span class="keyword">typename</span> type3_
<a name="l02834"></a>02834     &gt;
<a name="l02835"></a>02835 <span class="keyword">const</span> type2_ pack&lt;
<a name="l02836"></a>02836     type0_,
<a name="l02837"></a>02837     constant&lt;type1_, value1_&gt;,
<a name="l02838"></a>02838     constant&lt;type2_, value2_&gt;,
<a name="l02839"></a>02839     type3_
<a name="l02840"></a>02840     &gt;::i2;
<a name="l02841"></a>02841 
<a name="l02842"></a>02842 <span class="comment">/***********************************************************************************************************/</span>
<a name="l02843"></a>02843 <span class="keyword">template</span>&lt;
<a name="l02844"></a>02844     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l02845"></a>02845     <span class="keyword">typename</span> type1_, type1_ value1_,
<a name="l02846"></a>02846     <span class="keyword">typename</span> type2_, type2_ value2_,
<a name="l02847"></a>02847     <span class="keyword">typename</span> type3_
<a name="l02848"></a>02848     &gt;
<a name="l02849"></a>02849 <span class="keyword">class </span>pack&lt;
<a name="l02850"></a>02850     constant&lt;type0_, value0_&gt;,
<a name="l02851"></a>02851     constant&lt;type1_, value1_&gt;,
<a name="l02852"></a>02852     constant&lt;type2_, value2_&gt;,
<a name="l02853"></a>02853     type3_
<a name="l02854"></a>02854     &gt;
<a name="l02855"></a>02855 {
<a name="l02856"></a>02856 <span class="keyword">public</span>:
<a name="l02857"></a>02857     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n = 4;
<a name="l02858"></a>02858 
<a name="l02859"></a>02859     <span class="keyword">typedef</span> type0_ type0;
<a name="l02860"></a>02860     <span class="keyword">typedef</span> type1_ type1;
<a name="l02861"></a>02861     <span class="keyword">typedef</span> type2_ type2;
<a name="l02862"></a>02862     <span class="keyword">typedef</span> type3_ type3;
<a name="l02863"></a>02863 
<a name="l02864"></a>02864     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const0 = <span class="keyword">true</span>;
<a name="l02865"></a>02865     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const1 = <span class="keyword">true</span>;
<a name="l02866"></a>02866     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const2 = <span class="keyword">true</span>;
<a name="l02867"></a>02867     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const3 = <span class="keyword">false</span>;
<a name="l02868"></a>02868     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_all_const = <span class="keyword">false</span>;
<a name="l02869"></a>02869     <span class="keyword">static</span> <span class="keyword">const</span> type0 i0 = value0_;
<a name="l02870"></a>02870     <span class="keyword">static</span> <span class="keyword">const</span> type1 i1 = value1_;
<a name="l02871"></a>02871     <span class="keyword">static</span> <span class="keyword">const</span> type2 i2 = value2_;
<a name="l02872"></a>02872     type3 i3;
<a name="l02873"></a>02873 
<a name="l02874"></a>02874     LITE_INLINE pack() 
<a name="l02875"></a>02875         : i3()    {}
<a name="l02876"></a>02876     
<a name="l02877"></a>02877     LITE_INLINE pack(<span class="keyword">const</span> type0&amp; )
<a name="l02878"></a>02878      {}
<a name="l02879"></a>02879 
<a name="l02880"></a>02880     LITE_INLINE pack(
<a name="l02881"></a>02881         <span class="keyword">const</span> type0&amp; ,
<a name="l02882"></a>02882         <span class="keyword">const</span> type1&amp; ,
<a name="l02883"></a>02883         <span class="keyword">const</span> type2&amp; ,
<a name="l02884"></a>02884         <span class="keyword">const</span> type3&amp; a3
<a name="l02885"></a>02885         ) : i3(a3) {}
<a name="l02886"></a>02886 
<a name="l02887"></a>02887     <span class="keyword">template</span>&lt;
<a name="l02888"></a>02888         <span class="keyword">typename</span> other_type0_ ,
<a name="l02889"></a>02889         <span class="keyword">typename</span> other_type1_ ,
<a name="l02890"></a>02890         <span class="keyword">typename</span> other_type2_ ,
<a name="l02891"></a>02891         <span class="keyword">typename</span> other_type3_ 
<a name="l02892"></a>02892     &gt;
<a name="l02893"></a>02893     LITE_INLINE pack(<span class="keyword">const</span> pack&lt;
<a name="l02894"></a>02894         other_type0_,
<a name="l02895"></a>02895         other_type1_,
<a name="l02896"></a>02896         other_type2_,
<a name="l02897"></a>02897         other_type3_
<a name="l02898"></a>02898         &gt;&amp; other) : i3(other.i3)    {}
<a name="l02899"></a>02899 
<a name="l02900"></a>02900     LITE_INLINE pack&amp; 
<a name="l02901"></a>02901     operator= (<span class="keyword">const</span> pack&amp; other) 
<a name="l02902"></a>02902     {
<a name="l02903"></a>02903         i3 = other.i3;
<a name="l02904"></a>02904         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02905"></a>02905     }
<a name="l02906"></a>02906 
<a name="l02907"></a>02907     <span class="keyword">template</span>&lt;
<a name="l02908"></a>02908         <span class="keyword">typename</span> other_type0_ ,
<a name="l02909"></a>02909         <span class="keyword">typename</span> other_type1_ ,
<a name="l02910"></a>02910         <span class="keyword">typename</span> other_type2_ ,
<a name="l02911"></a>02911         <span class="keyword">typename</span> other_type3_ 
<a name="l02912"></a>02912     &gt;
<a name="l02913"></a>02913     LITE_INLINE pack&amp;  
<a name="l02914"></a>02914     operator=(<span class="keyword">const</span> pack&lt;
<a name="l02915"></a>02915         other_type0_,
<a name="l02916"></a>02916         other_type1_,
<a name="l02917"></a>02917         other_type2_,
<a name="l02918"></a>02918         other_type3_
<a name="l02919"></a>02919         &gt;&amp; other) 
<a name="l02920"></a>02920     {
<a name="l02921"></a>02921         i3 = other.i3;
<a name="l02922"></a>02922         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02923"></a>02923     }
<a name="l02924"></a>02924 
<a name="l02925"></a>02925     LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l02926"></a>02926         <span class="keyword">const</span> type0&amp; ,
<a name="l02927"></a>02927         <span class="keyword">const</span> type1&amp; ,
<a name="l02928"></a>02928         <span class="keyword">const</span> type2&amp; ,
<a name="l02929"></a>02929         <span class="keyword">const</span> type3&amp; a3
<a name="l02930"></a>02930         ) 
<a name="l02931"></a>02931     {
<a name="l02932"></a>02932             i3 = a3;
<a name="l02933"></a>02933     }
<a name="l02934"></a>02934 };
<a name="l02935"></a>02935 
<a name="l02936"></a>02936 
<a name="l02937"></a>02937 <span class="keyword">template</span>&lt;
<a name="l02938"></a>02938     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l02939"></a>02939     <span class="keyword">typename</span> type1_, type1_ value1_,
<a name="l02940"></a>02940     <span class="keyword">typename</span> type2_, type2_ value2_,
<a name="l02941"></a>02941     <span class="keyword">typename</span> type3_
<a name="l02942"></a>02942     &gt;
<a name="l02943"></a>02943 <span class="keyword">const</span> type0_ pack&lt;
<a name="l02944"></a>02944     constant&lt;type0_, value0_&gt;,
<a name="l02945"></a>02945     constant&lt;type1_, value1_&gt;,
<a name="l02946"></a>02946     constant&lt;type2_, value2_&gt;,
<a name="l02947"></a>02947     type3_
<a name="l02948"></a>02948     &gt;::i0;
<a name="l02949"></a>02949 
<a name="l02950"></a>02950 <span class="keyword">template</span>&lt;
<a name="l02951"></a>02951     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l02952"></a>02952     <span class="keyword">typename</span> type1_, type1_ value1_,
<a name="l02953"></a>02953     <span class="keyword">typename</span> type2_, type2_ value2_,
<a name="l02954"></a>02954     <span class="keyword">typename</span> type3_
<a name="l02955"></a>02955     &gt;
<a name="l02956"></a>02956 <span class="keyword">const</span> type1_ pack&lt;
<a name="l02957"></a>02957     constant&lt;type0_, value0_&gt;,
<a name="l02958"></a>02958     constant&lt;type1_, value1_&gt;,
<a name="l02959"></a>02959     constant&lt;type2_, value2_&gt;,
<a name="l02960"></a>02960     type3_
<a name="l02961"></a>02961     &gt;::i1;
<a name="l02962"></a>02962 
<a name="l02963"></a>02963 <span class="keyword">template</span>&lt;
<a name="l02964"></a>02964     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l02965"></a>02965     <span class="keyword">typename</span> type1_, type1_ value1_,
<a name="l02966"></a>02966     <span class="keyword">typename</span> type2_, type2_ value2_,
<a name="l02967"></a>02967     <span class="keyword">typename</span> type3_
<a name="l02968"></a>02968     &gt;
<a name="l02969"></a>02969 <span class="keyword">const</span> type2_ pack&lt;
<a name="l02970"></a>02970     constant&lt;type0_, value0_&gt;,
<a name="l02971"></a>02971     constant&lt;type1_, value1_&gt;,
<a name="l02972"></a>02972     constant&lt;type2_, value2_&gt;,
<a name="l02973"></a>02973     type3_
<a name="l02974"></a>02974     &gt;::i2;
<a name="l02975"></a>02975 
<a name="l02976"></a>02976 <span class="comment">/***********************************************************************************************************/</span>
<a name="l02977"></a>02977 <span class="keyword">template</span>&lt;
<a name="l02978"></a>02978     <span class="keyword">typename</span> type0_,
<a name="l02979"></a>02979     <span class="keyword">typename</span> type1_,
<a name="l02980"></a>02980     <span class="keyword">typename</span> type2_,
<a name="l02981"></a>02981     <span class="keyword">typename</span> type3_, type3_ value3_
<a name="l02982"></a>02982     &gt;
<a name="l02983"></a>02983 <span class="keyword">class </span>pack&lt;
<a name="l02984"></a>02984     type0_,
<a name="l02985"></a>02985     type1_,
<a name="l02986"></a>02986     type2_,
<a name="l02987"></a>02987     constant&lt;type3_, value3_&gt;
<a name="l02988"></a>02988     &gt;
<a name="l02989"></a>02989 {
<a name="l02990"></a>02990 <span class="keyword">public</span>:
<a name="l02991"></a>02991     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n = 4;
<a name="l02992"></a>02992 
<a name="l02993"></a>02993     <span class="keyword">typedef</span> type0_ type0;
<a name="l02994"></a>02994     <span class="keyword">typedef</span> type1_ type1;
<a name="l02995"></a>02995     <span class="keyword">typedef</span> type2_ type2;
<a name="l02996"></a>02996     <span class="keyword">typedef</span> type3_ type3;
<a name="l02997"></a>02997 
<a name="l02998"></a>02998     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const0 = <span class="keyword">false</span>;
<a name="l02999"></a>02999     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const1 = <span class="keyword">false</span>;
<a name="l03000"></a>03000     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const2 = <span class="keyword">false</span>;
<a name="l03001"></a>03001     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const3 = <span class="keyword">true</span>;
<a name="l03002"></a>03002     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_all_const = <span class="keyword">false</span>;
<a name="l03003"></a>03003     type0 i0;
<a name="l03004"></a>03004     type1 i1;
<a name="l03005"></a>03005     type2 i2;
<a name="l03006"></a>03006     <span class="keyword">static</span> <span class="keyword">const</span> type3 i3 = value3_;
<a name="l03007"></a>03007 
<a name="l03008"></a>03008     LITE_INLINE pack() 
<a name="l03009"></a>03009         : i0(),i1(),i2()    {}
<a name="l03010"></a>03010     
<a name="l03011"></a>03011     LITE_INLINE pack(<span class="keyword">const</span> type0&amp; a0)
<a name="l03012"></a>03012         : i0(a0) 
<a name="l03013"></a>03013      {}
<a name="l03014"></a>03014 
<a name="l03015"></a>03015     LITE_INLINE pack(
<a name="l03016"></a>03016         <span class="keyword">const</span> type0&amp; a0,
<a name="l03017"></a>03017         <span class="keyword">const</span> type1&amp; a1,
<a name="l03018"></a>03018         <span class="keyword">const</span> type2&amp; a2,
<a name="l03019"></a>03019         <span class="keyword">const</span> type3&amp; 
<a name="l03020"></a>03020         ) : i0(a0), i1(a1), i2(a2) {}
<a name="l03021"></a>03021 
<a name="l03022"></a>03022     <span class="keyword">template</span>&lt;
<a name="l03023"></a>03023         <span class="keyword">typename</span> other_type0_ ,
<a name="l03024"></a>03024         <span class="keyword">typename</span> other_type1_ ,
<a name="l03025"></a>03025         <span class="keyword">typename</span> other_type2_ ,
<a name="l03026"></a>03026         <span class="keyword">typename</span> other_type3_ 
<a name="l03027"></a>03027     &gt;
<a name="l03028"></a>03028     LITE_INLINE pack(<span class="keyword">const</span> pack&lt;
<a name="l03029"></a>03029         other_type0_,
<a name="l03030"></a>03030         other_type1_,
<a name="l03031"></a>03031         other_type2_,
<a name="l03032"></a>03032         other_type3_
<a name="l03033"></a>03033         &gt;&amp; other) : i0(other.i0), i1(other.i1), i2(other.i2)    {}
<a name="l03034"></a>03034 
<a name="l03035"></a>03035     LITE_INLINE pack&amp; 
<a name="l03036"></a>03036     operator= (<span class="keyword">const</span> pack&amp; other) 
<a name="l03037"></a>03037     {
<a name="l03038"></a>03038         i0 = other.i0;
<a name="l03039"></a>03039         i1 = other.i1;
<a name="l03040"></a>03040         i2 = other.i2;
<a name="l03041"></a>03041         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l03042"></a>03042     }
<a name="l03043"></a>03043 
<a name="l03044"></a>03044     <span class="keyword">template</span>&lt;
<a name="l03045"></a>03045         <span class="keyword">typename</span> other_type0_ ,
<a name="l03046"></a>03046         <span class="keyword">typename</span> other_type1_ ,
<a name="l03047"></a>03047         <span class="keyword">typename</span> other_type2_ ,
<a name="l03048"></a>03048         <span class="keyword">typename</span> other_type3_ 
<a name="l03049"></a>03049     &gt;
<a name="l03050"></a>03050     LITE_INLINE pack&amp;  
<a name="l03051"></a>03051     operator=(<span class="keyword">const</span> pack&lt;
<a name="l03052"></a>03052         other_type0_,
<a name="l03053"></a>03053         other_type1_,
<a name="l03054"></a>03054         other_type2_,
<a name="l03055"></a>03055         other_type3_
<a name="l03056"></a>03056         &gt;&amp; other) 
<a name="l03057"></a>03057     {
<a name="l03058"></a>03058         i0 = other.i0;
<a name="l03059"></a>03059         i1 = other.i1;
<a name="l03060"></a>03060         i2 = other.i2;
<a name="l03061"></a>03061         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l03062"></a>03062     }
<a name="l03063"></a>03063 
<a name="l03064"></a>03064     LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l03065"></a>03065         <span class="keyword">const</span> type0&amp; a0,
<a name="l03066"></a>03066         <span class="keyword">const</span> type1&amp; a1,
<a name="l03067"></a>03067         <span class="keyword">const</span> type2&amp; a2,
<a name="l03068"></a>03068         <span class="keyword">const</span> type3&amp; 
<a name="l03069"></a>03069         ) 
<a name="l03070"></a>03070     {
<a name="l03071"></a>03071             i0 = a0;
<a name="l03072"></a>03072             i1 = a1;
<a name="l03073"></a>03073             i2 = a2;
<a name="l03074"></a>03074     }
<a name="l03075"></a>03075 };
<a name="l03076"></a>03076 
<a name="l03077"></a>03077 
<a name="l03078"></a>03078 <span class="keyword">template</span>&lt;
<a name="l03079"></a>03079     <span class="keyword">typename</span> type0_,
<a name="l03080"></a>03080     <span class="keyword">typename</span> type1_,
<a name="l03081"></a>03081     <span class="keyword">typename</span> type2_,
<a name="l03082"></a>03082     <span class="keyword">typename</span> type3_, type3_ value3_
<a name="l03083"></a>03083     &gt;
<a name="l03084"></a>03084 <span class="keyword">const</span> type3_ pack&lt;
<a name="l03085"></a>03085     type0_,
<a name="l03086"></a>03086     type1_,
<a name="l03087"></a>03087     type2_,
<a name="l03088"></a>03088     constant&lt;type3_, value3_&gt;
<a name="l03089"></a>03089     &gt;::i3;
<a name="l03090"></a>03090 
<a name="l03091"></a>03091 <span class="comment">/***********************************************************************************************************/</span>
<a name="l03092"></a>03092 <span class="keyword">template</span>&lt;
<a name="l03093"></a>03093     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l03094"></a>03094     <span class="keyword">typename</span> type1_,
<a name="l03095"></a>03095     <span class="keyword">typename</span> type2_,
<a name="l03096"></a>03096     <span class="keyword">typename</span> type3_, type3_ value3_
<a name="l03097"></a>03097     &gt;
<a name="l03098"></a>03098 <span class="keyword">class </span>pack&lt;
<a name="l03099"></a>03099     constant&lt;type0_, value0_&gt;,
<a name="l03100"></a>03100     type1_,
<a name="l03101"></a>03101     type2_,
<a name="l03102"></a>03102     constant&lt;type3_, value3_&gt;
<a name="l03103"></a>03103     &gt;
<a name="l03104"></a>03104 {
<a name="l03105"></a>03105 <span class="keyword">public</span>:
<a name="l03106"></a>03106     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n = 4;
<a name="l03107"></a>03107 
<a name="l03108"></a>03108     <span class="keyword">typedef</span> type0_ type0;
<a name="l03109"></a>03109     <span class="keyword">typedef</span> type1_ type1;
<a name="l03110"></a>03110     <span class="keyword">typedef</span> type2_ type2;
<a name="l03111"></a>03111     <span class="keyword">typedef</span> type3_ type3;
<a name="l03112"></a>03112 
<a name="l03113"></a>03113     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const0 = <span class="keyword">true</span>;
<a name="l03114"></a>03114     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const1 = <span class="keyword">false</span>;
<a name="l03115"></a>03115     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const2 = <span class="keyword">false</span>;
<a name="l03116"></a>03116     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const3 = <span class="keyword">true</span>;
<a name="l03117"></a>03117     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_all_const = <span class="keyword">false</span>;
<a name="l03118"></a>03118     <span class="keyword">static</span> <span class="keyword">const</span> type0 i0 = value0_;
<a name="l03119"></a>03119     type1 i1;
<a name="l03120"></a>03120     type2 i2;
<a name="l03121"></a>03121     <span class="keyword">static</span> <span class="keyword">const</span> type3 i3 = value3_;
<a name="l03122"></a>03122 
<a name="l03123"></a>03123     LITE_INLINE pack() 
<a name="l03124"></a>03124         : i1(),i2()    {}
<a name="l03125"></a>03125     
<a name="l03126"></a>03126     LITE_INLINE pack(<span class="keyword">const</span> type0&amp; )
<a name="l03127"></a>03127      {}
<a name="l03128"></a>03128 
<a name="l03129"></a>03129     LITE_INLINE pack(
<a name="l03130"></a>03130         <span class="keyword">const</span> type0&amp; ,
<a name="l03131"></a>03131         <span class="keyword">const</span> type1&amp; a1,
<a name="l03132"></a>03132         <span class="keyword">const</span> type2&amp; a2,
<a name="l03133"></a>03133         <span class="keyword">const</span> type3&amp; 
<a name="l03134"></a>03134         ) : i1(a1), i2(a2) {}
<a name="l03135"></a>03135 
<a name="l03136"></a>03136     <span class="keyword">template</span>&lt;
<a name="l03137"></a>03137         <span class="keyword">typename</span> other_type0_ ,
<a name="l03138"></a>03138         <span class="keyword">typename</span> other_type1_ ,
<a name="l03139"></a>03139         <span class="keyword">typename</span> other_type2_ ,
<a name="l03140"></a>03140         <span class="keyword">typename</span> other_type3_ 
<a name="l03141"></a>03141     &gt;
<a name="l03142"></a>03142     LITE_INLINE pack(<span class="keyword">const</span> pack&lt;
<a name="l03143"></a>03143         other_type0_,
<a name="l03144"></a>03144         other_type1_,
<a name="l03145"></a>03145         other_type2_,
<a name="l03146"></a>03146         other_type3_
<a name="l03147"></a>03147         &gt;&amp; other) : i1(other.i1), i2(other.i2)    {}
<a name="l03148"></a>03148 
<a name="l03149"></a>03149     LITE_INLINE pack&amp; 
<a name="l03150"></a>03150     operator= (<span class="keyword">const</span> pack&amp; other) 
<a name="l03151"></a>03151     {
<a name="l03152"></a>03152         i1 = other.i1;
<a name="l03153"></a>03153         i2 = other.i2;
<a name="l03154"></a>03154         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l03155"></a>03155     }
<a name="l03156"></a>03156 
<a name="l03157"></a>03157     <span class="keyword">template</span>&lt;
<a name="l03158"></a>03158         <span class="keyword">typename</span> other_type0_ ,
<a name="l03159"></a>03159         <span class="keyword">typename</span> other_type1_ ,
<a name="l03160"></a>03160         <span class="keyword">typename</span> other_type2_ ,
<a name="l03161"></a>03161         <span class="keyword">typename</span> other_type3_ 
<a name="l03162"></a>03162     &gt;
<a name="l03163"></a>03163     LITE_INLINE pack&amp;  
<a name="l03164"></a>03164     operator=(<span class="keyword">const</span> pack&lt;
<a name="l03165"></a>03165         other_type0_,
<a name="l03166"></a>03166         other_type1_,
<a name="l03167"></a>03167         other_type2_,
<a name="l03168"></a>03168         other_type3_
<a name="l03169"></a>03169         &gt;&amp; other) 
<a name="l03170"></a>03170     {
<a name="l03171"></a>03171         i1 = other.i1;
<a name="l03172"></a>03172         i2 = other.i2;
<a name="l03173"></a>03173         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l03174"></a>03174     }
<a name="l03175"></a>03175 
<a name="l03176"></a>03176     LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l03177"></a>03177         <span class="keyword">const</span> type0&amp; ,
<a name="l03178"></a>03178         <span class="keyword">const</span> type1&amp; a1,
<a name="l03179"></a>03179         <span class="keyword">const</span> type2&amp; a2,
<a name="l03180"></a>03180         <span class="keyword">const</span> type3&amp; 
<a name="l03181"></a>03181         ) 
<a name="l03182"></a>03182     {
<a name="l03183"></a>03183             i1 = a1;
<a name="l03184"></a>03184             i2 = a2;
<a name="l03185"></a>03185     }
<a name="l03186"></a>03186 };
<a name="l03187"></a>03187 
<a name="l03188"></a>03188 
<a name="l03189"></a>03189 <span class="keyword">template</span>&lt;
<a name="l03190"></a>03190     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l03191"></a>03191     <span class="keyword">typename</span> type1_,
<a name="l03192"></a>03192     <span class="keyword">typename</span> type2_,
<a name="l03193"></a>03193     <span class="keyword">typename</span> type3_, type3_ value3_
<a name="l03194"></a>03194     &gt;
<a name="l03195"></a>03195 <span class="keyword">const</span> type0_ pack&lt;
<a name="l03196"></a>03196     constant&lt;type0_, value0_&gt;,
<a name="l03197"></a>03197     type1_,
<a name="l03198"></a>03198     type2_,
<a name="l03199"></a>03199     constant&lt;type3_, value3_&gt;
<a name="l03200"></a>03200     &gt;::i0;
<a name="l03201"></a>03201 
<a name="l03202"></a>03202 <span class="keyword">template</span>&lt;
<a name="l03203"></a>03203     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l03204"></a>03204     <span class="keyword">typename</span> type1_,
<a name="l03205"></a>03205     <span class="keyword">typename</span> type2_,
<a name="l03206"></a>03206     <span class="keyword">typename</span> type3_, type3_ value3_
<a name="l03207"></a>03207     &gt;
<a name="l03208"></a>03208 <span class="keyword">const</span> type3_ pack&lt;
<a name="l03209"></a>03209     constant&lt;type0_, value0_&gt;,
<a name="l03210"></a>03210     type1_,
<a name="l03211"></a>03211     type2_,
<a name="l03212"></a>03212     constant&lt;type3_, value3_&gt;
<a name="l03213"></a>03213     &gt;::i3;
<a name="l03214"></a>03214 
<a name="l03215"></a>03215 <span class="comment">/***********************************************************************************************************/</span>
<a name="l03216"></a>03216 <span class="keyword">template</span>&lt;
<a name="l03217"></a>03217     <span class="keyword">typename</span> type0_,
<a name="l03218"></a>03218     <span class="keyword">typename</span> type1_, type1_ value1_,
<a name="l03219"></a>03219     <span class="keyword">typename</span> type2_,
<a name="l03220"></a>03220     <span class="keyword">typename</span> type3_, type3_ value3_
<a name="l03221"></a>03221     &gt;
<a name="l03222"></a>03222 <span class="keyword">class </span>pack&lt;
<a name="l03223"></a>03223     type0_,
<a name="l03224"></a>03224     constant&lt;type1_, value1_&gt;,
<a name="l03225"></a>03225     type2_,
<a name="l03226"></a>03226     constant&lt;type3_, value3_&gt;
<a name="l03227"></a>03227     &gt;
<a name="l03228"></a>03228 {
<a name="l03229"></a>03229 <span class="keyword">public</span>:
<a name="l03230"></a>03230     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n = 4;
<a name="l03231"></a>03231 
<a name="l03232"></a>03232     <span class="keyword">typedef</span> type0_ type0;
<a name="l03233"></a>03233     <span class="keyword">typedef</span> type1_ type1;
<a name="l03234"></a>03234     <span class="keyword">typedef</span> type2_ type2;
<a name="l03235"></a>03235     <span class="keyword">typedef</span> type3_ type3;
<a name="l03236"></a>03236 
<a name="l03237"></a>03237     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const0 = <span class="keyword">false</span>;
<a name="l03238"></a>03238     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const1 = <span class="keyword">true</span>;
<a name="l03239"></a>03239     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const2 = <span class="keyword">false</span>;
<a name="l03240"></a>03240     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const3 = <span class="keyword">true</span>;
<a name="l03241"></a>03241     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_all_const = <span class="keyword">false</span>;
<a name="l03242"></a>03242     type0 i0;
<a name="l03243"></a>03243     <span class="keyword">static</span> <span class="keyword">const</span> type1 i1 = value1_;
<a name="l03244"></a>03244     type2 i2;
<a name="l03245"></a>03245     <span class="keyword">static</span> <span class="keyword">const</span> type3 i3 = value3_;
<a name="l03246"></a>03246 
<a name="l03247"></a>03247     LITE_INLINE pack() 
<a name="l03248"></a>03248         : i0(),i2()    {}
<a name="l03249"></a>03249     
<a name="l03250"></a>03250     LITE_INLINE pack(<span class="keyword">const</span> type0&amp; a0)
<a name="l03251"></a>03251         : i0(a0) 
<a name="l03252"></a>03252      {}
<a name="l03253"></a>03253 
<a name="l03254"></a>03254     LITE_INLINE pack(
<a name="l03255"></a>03255         <span class="keyword">const</span> type0&amp; a0,
<a name="l03256"></a>03256         <span class="keyword">const</span> type1&amp; ,
<a name="l03257"></a>03257         <span class="keyword">const</span> type2&amp; a2,
<a name="l03258"></a>03258         <span class="keyword">const</span> type3&amp; 
<a name="l03259"></a>03259         ) : i0(a0), i2(a2) {}
<a name="l03260"></a>03260 
<a name="l03261"></a>03261     <span class="keyword">template</span>&lt;
<a name="l03262"></a>03262         <span class="keyword">typename</span> other_type0_ ,
<a name="l03263"></a>03263         <span class="keyword">typename</span> other_type1_ ,
<a name="l03264"></a>03264         <span class="keyword">typename</span> other_type2_ ,
<a name="l03265"></a>03265         <span class="keyword">typename</span> other_type3_ 
<a name="l03266"></a>03266     &gt;
<a name="l03267"></a>03267     LITE_INLINE pack(<span class="keyword">const</span> pack&lt;
<a name="l03268"></a>03268         other_type0_,
<a name="l03269"></a>03269         other_type1_,
<a name="l03270"></a>03270         other_type2_,
<a name="l03271"></a>03271         other_type3_
<a name="l03272"></a>03272         &gt;&amp; other) : i0(other.i0), i2(other.i2)    {}
<a name="l03273"></a>03273 
<a name="l03274"></a>03274     LITE_INLINE pack&amp; 
<a name="l03275"></a>03275     operator= (<span class="keyword">const</span> pack&amp; other) 
<a name="l03276"></a>03276     {
<a name="l03277"></a>03277         i0 = other.i0;
<a name="l03278"></a>03278         i2 = other.i2;
<a name="l03279"></a>03279         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l03280"></a>03280     }
<a name="l03281"></a>03281 
<a name="l03282"></a>03282     <span class="keyword">template</span>&lt;
<a name="l03283"></a>03283         <span class="keyword">typename</span> other_type0_ ,
<a name="l03284"></a>03284         <span class="keyword">typename</span> other_type1_ ,
<a name="l03285"></a>03285         <span class="keyword">typename</span> other_type2_ ,
<a name="l03286"></a>03286         <span class="keyword">typename</span> other_type3_ 
<a name="l03287"></a>03287     &gt;
<a name="l03288"></a>03288     LITE_INLINE pack&amp;  
<a name="l03289"></a>03289     operator=(<span class="keyword">const</span> pack&lt;
<a name="l03290"></a>03290         other_type0_,
<a name="l03291"></a>03291         other_type1_,
<a name="l03292"></a>03292         other_type2_,
<a name="l03293"></a>03293         other_type3_
<a name="l03294"></a>03294         &gt;&amp; other) 
<a name="l03295"></a>03295     {
<a name="l03296"></a>03296         i0 = other.i0;
<a name="l03297"></a>03297         i2 = other.i2;
<a name="l03298"></a>03298         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l03299"></a>03299     }
<a name="l03300"></a>03300 
<a name="l03301"></a>03301     LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l03302"></a>03302         <span class="keyword">const</span> type0&amp; a0,
<a name="l03303"></a>03303         <span class="keyword">const</span> type1&amp; ,
<a name="l03304"></a>03304         <span class="keyword">const</span> type2&amp; a2,
<a name="l03305"></a>03305         <span class="keyword">const</span> type3&amp; 
<a name="l03306"></a>03306         ) 
<a name="l03307"></a>03307     {
<a name="l03308"></a>03308             i0 = a0;
<a name="l03309"></a>03309             i2 = a2;
<a name="l03310"></a>03310     }
<a name="l03311"></a>03311 };
<a name="l03312"></a>03312 
<a name="l03313"></a>03313 
<a name="l03314"></a>03314 <span class="keyword">template</span>&lt;
<a name="l03315"></a>03315     <span class="keyword">typename</span> type0_,
<a name="l03316"></a>03316     <span class="keyword">typename</span> type1_, type1_ value1_,
<a name="l03317"></a>03317     <span class="keyword">typename</span> type2_,
<a name="l03318"></a>03318     <span class="keyword">typename</span> type3_, type3_ value3_
<a name="l03319"></a>03319     &gt;
<a name="l03320"></a>03320 <span class="keyword">const</span> type1_ pack&lt;
<a name="l03321"></a>03321     type0_,
<a name="l03322"></a>03322     constant&lt;type1_, value1_&gt;,
<a name="l03323"></a>03323     type2_,
<a name="l03324"></a>03324     constant&lt;type3_, value3_&gt;
<a name="l03325"></a>03325     &gt;::i1;
<a name="l03326"></a>03326 
<a name="l03327"></a>03327 <span class="keyword">template</span>&lt;
<a name="l03328"></a>03328     <span class="keyword">typename</span> type0_,
<a name="l03329"></a>03329     <span class="keyword">typename</span> type1_, type1_ value1_,
<a name="l03330"></a>03330     <span class="keyword">typename</span> type2_,
<a name="l03331"></a>03331     <span class="keyword">typename</span> type3_, type3_ value3_
<a name="l03332"></a>03332     &gt;
<a name="l03333"></a>03333 <span class="keyword">const</span> type3_ pack&lt;
<a name="l03334"></a>03334     type0_,
<a name="l03335"></a>03335     constant&lt;type1_, value1_&gt;,
<a name="l03336"></a>03336     type2_,
<a name="l03337"></a>03337     constant&lt;type3_, value3_&gt;
<a name="l03338"></a>03338     &gt;::i3;
<a name="l03339"></a>03339 
<a name="l03340"></a>03340 <span class="comment">/***********************************************************************************************************/</span>
<a name="l03341"></a>03341 <span class="keyword">template</span>&lt;
<a name="l03342"></a>03342     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l03343"></a>03343     <span class="keyword">typename</span> type1_, type1_ value1_,
<a name="l03344"></a>03344     <span class="keyword">typename</span> type2_,
<a name="l03345"></a>03345     <span class="keyword">typename</span> type3_, type3_ value3_
<a name="l03346"></a>03346     &gt;
<a name="l03347"></a>03347 <span class="keyword">class </span>pack&lt;
<a name="l03348"></a>03348     constant&lt;type0_, value0_&gt;,
<a name="l03349"></a>03349     constant&lt;type1_, value1_&gt;,
<a name="l03350"></a>03350     type2_,
<a name="l03351"></a>03351     constant&lt;type3_, value3_&gt;
<a name="l03352"></a>03352     &gt;
<a name="l03353"></a>03353 {
<a name="l03354"></a>03354 <span class="keyword">public</span>:
<a name="l03355"></a>03355     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n = 4;
<a name="l03356"></a>03356 
<a name="l03357"></a>03357     <span class="keyword">typedef</span> type0_ type0;
<a name="l03358"></a>03358     <span class="keyword">typedef</span> type1_ type1;
<a name="l03359"></a>03359     <span class="keyword">typedef</span> type2_ type2;
<a name="l03360"></a>03360     <span class="keyword">typedef</span> type3_ type3;
<a name="l03361"></a>03361 
<a name="l03362"></a>03362     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const0 = <span class="keyword">true</span>;
<a name="l03363"></a>03363     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const1 = <span class="keyword">true</span>;
<a name="l03364"></a>03364     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const2 = <span class="keyword">false</span>;
<a name="l03365"></a>03365     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const3 = <span class="keyword">true</span>;
<a name="l03366"></a>03366     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_all_const = <span class="keyword">false</span>;
<a name="l03367"></a>03367     <span class="keyword">static</span> <span class="keyword">const</span> type0 i0 = value0_;
<a name="l03368"></a>03368     <span class="keyword">static</span> <span class="keyword">const</span> type1 i1 = value1_;
<a name="l03369"></a>03369     type2 i2;
<a name="l03370"></a>03370     <span class="keyword">static</span> <span class="keyword">const</span> type3 i3 = value3_;
<a name="l03371"></a>03371 
<a name="l03372"></a>03372     LITE_INLINE pack() 
<a name="l03373"></a>03373         : i2()    {}
<a name="l03374"></a>03374     
<a name="l03375"></a>03375     LITE_INLINE pack(<span class="keyword">const</span> type0&amp; )
<a name="l03376"></a>03376      {}
<a name="l03377"></a>03377 
<a name="l03378"></a>03378     LITE_INLINE pack(
<a name="l03379"></a>03379         <span class="keyword">const</span> type0&amp; ,
<a name="l03380"></a>03380         <span class="keyword">const</span> type1&amp; ,
<a name="l03381"></a>03381         <span class="keyword">const</span> type2&amp; a2,
<a name="l03382"></a>03382         <span class="keyword">const</span> type3&amp; 
<a name="l03383"></a>03383         ) : i2(a2) {}
<a name="l03384"></a>03384 
<a name="l03385"></a>03385     <span class="keyword">template</span>&lt;
<a name="l03386"></a>03386         <span class="keyword">typename</span> other_type0_ ,
<a name="l03387"></a>03387         <span class="keyword">typename</span> other_type1_ ,
<a name="l03388"></a>03388         <span class="keyword">typename</span> other_type2_ ,
<a name="l03389"></a>03389         <span class="keyword">typename</span> other_type3_ 
<a name="l03390"></a>03390     &gt;
<a name="l03391"></a>03391     LITE_INLINE pack(<span class="keyword">const</span> pack&lt;
<a name="l03392"></a>03392         other_type0_,
<a name="l03393"></a>03393         other_type1_,
<a name="l03394"></a>03394         other_type2_,
<a name="l03395"></a>03395         other_type3_
<a name="l03396"></a>03396         &gt;&amp; other) : i2(other.i2)    {}
<a name="l03397"></a>03397 
<a name="l03398"></a>03398     LITE_INLINE pack&amp; 
<a name="l03399"></a>03399     operator= (<span class="keyword">const</span> pack&amp; other) 
<a name="l03400"></a>03400     {
<a name="l03401"></a>03401         i2 = other.i2;
<a name="l03402"></a>03402         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l03403"></a>03403     }
<a name="l03404"></a>03404 
<a name="l03405"></a>03405     <span class="keyword">template</span>&lt;
<a name="l03406"></a>03406         <span class="keyword">typename</span> other_type0_ ,
<a name="l03407"></a>03407         <span class="keyword">typename</span> other_type1_ ,
<a name="l03408"></a>03408         <span class="keyword">typename</span> other_type2_ ,
<a name="l03409"></a>03409         <span class="keyword">typename</span> other_type3_ 
<a name="l03410"></a>03410     &gt;
<a name="l03411"></a>03411     LITE_INLINE pack&amp;  
<a name="l03412"></a>03412     operator=(<span class="keyword">const</span> pack&lt;
<a name="l03413"></a>03413         other_type0_,
<a name="l03414"></a>03414         other_type1_,
<a name="l03415"></a>03415         other_type2_,
<a name="l03416"></a>03416         other_type3_
<a name="l03417"></a>03417         &gt;&amp; other) 
<a name="l03418"></a>03418     {
<a name="l03419"></a>03419         i2 = other.i2;
<a name="l03420"></a>03420         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l03421"></a>03421     }
<a name="l03422"></a>03422 
<a name="l03423"></a>03423     LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l03424"></a>03424         <span class="keyword">const</span> type0&amp; ,
<a name="l03425"></a>03425         <span class="keyword">const</span> type1&amp; ,
<a name="l03426"></a>03426         <span class="keyword">const</span> type2&amp; a2,
<a name="l03427"></a>03427         <span class="keyword">const</span> type3&amp; 
<a name="l03428"></a>03428         ) 
<a name="l03429"></a>03429     {
<a name="l03430"></a>03430             i2 = a2;
<a name="l03431"></a>03431     }
<a name="l03432"></a>03432 };
<a name="l03433"></a>03433 
<a name="l03434"></a>03434 
<a name="l03435"></a>03435 <span class="keyword">template</span>&lt;
<a name="l03436"></a>03436     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l03437"></a>03437     <span class="keyword">typename</span> type1_, type1_ value1_,
<a name="l03438"></a>03438     <span class="keyword">typename</span> type2_,
<a name="l03439"></a>03439     <span class="keyword">typename</span> type3_, type3_ value3_
<a name="l03440"></a>03440     &gt;
<a name="l03441"></a>03441 <span class="keyword">const</span> type0_ pack&lt;
<a name="l03442"></a>03442     constant&lt;type0_, value0_&gt;,
<a name="l03443"></a>03443     constant&lt;type1_, value1_&gt;,
<a name="l03444"></a>03444     type2_,
<a name="l03445"></a>03445     constant&lt;type3_, value3_&gt;
<a name="l03446"></a>03446     &gt;::i0;
<a name="l03447"></a>03447 
<a name="l03448"></a>03448 <span class="keyword">template</span>&lt;
<a name="l03449"></a>03449     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l03450"></a>03450     <span class="keyword">typename</span> type1_, type1_ value1_,
<a name="l03451"></a>03451     <span class="keyword">typename</span> type2_,
<a name="l03452"></a>03452     <span class="keyword">typename</span> type3_, type3_ value3_
<a name="l03453"></a>03453     &gt;
<a name="l03454"></a>03454 <span class="keyword">const</span> type1_ pack&lt;
<a name="l03455"></a>03455     constant&lt;type0_, value0_&gt;,
<a name="l03456"></a>03456     constant&lt;type1_, value1_&gt;,
<a name="l03457"></a>03457     type2_,
<a name="l03458"></a>03458     constant&lt;type3_, value3_&gt;
<a name="l03459"></a>03459     &gt;::i1;
<a name="l03460"></a>03460 
<a name="l03461"></a>03461 <span class="keyword">template</span>&lt;
<a name="l03462"></a>03462     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l03463"></a>03463     <span class="keyword">typename</span> type1_, type1_ value1_,
<a name="l03464"></a>03464     <span class="keyword">typename</span> type2_,
<a name="l03465"></a>03465     <span class="keyword">typename</span> type3_, type3_ value3_
<a name="l03466"></a>03466     &gt;
<a name="l03467"></a>03467 <span class="keyword">const</span> type3_ pack&lt;
<a name="l03468"></a>03468     constant&lt;type0_, value0_&gt;,
<a name="l03469"></a>03469     constant&lt;type1_, value1_&gt;,
<a name="l03470"></a>03470     type2_,
<a name="l03471"></a>03471     constant&lt;type3_, value3_&gt;
<a name="l03472"></a>03472     &gt;::i3;
<a name="l03473"></a>03473 
<a name="l03474"></a>03474 <span class="comment">/***********************************************************************************************************/</span>
<a name="l03475"></a>03475 <span class="keyword">template</span>&lt;
<a name="l03476"></a>03476     <span class="keyword">typename</span> type0_,
<a name="l03477"></a>03477     <span class="keyword">typename</span> type1_,
<a name="l03478"></a>03478     <span class="keyword">typename</span> type2_, type2_ value2_,
<a name="l03479"></a>03479     <span class="keyword">typename</span> type3_, type3_ value3_
<a name="l03480"></a>03480     &gt;
<a name="l03481"></a>03481 <span class="keyword">class </span>pack&lt;
<a name="l03482"></a>03482     type0_,
<a name="l03483"></a>03483     type1_,
<a name="l03484"></a>03484     constant&lt;type2_, value2_&gt;,
<a name="l03485"></a>03485     constant&lt;type3_, value3_&gt;
<a name="l03486"></a>03486     &gt;
<a name="l03487"></a>03487 {
<a name="l03488"></a>03488 <span class="keyword">public</span>:
<a name="l03489"></a>03489     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n = 4;
<a name="l03490"></a>03490 
<a name="l03491"></a>03491     <span class="keyword">typedef</span> type0_ type0;
<a name="l03492"></a>03492     <span class="keyword">typedef</span> type1_ type1;
<a name="l03493"></a>03493     <span class="keyword">typedef</span> type2_ type2;
<a name="l03494"></a>03494     <span class="keyword">typedef</span> type3_ type3;
<a name="l03495"></a>03495 
<a name="l03496"></a>03496     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const0 = <span class="keyword">false</span>;
<a name="l03497"></a>03497     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const1 = <span class="keyword">false</span>;
<a name="l03498"></a>03498     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const2 = <span class="keyword">true</span>;
<a name="l03499"></a>03499     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const3 = <span class="keyword">true</span>;
<a name="l03500"></a>03500     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_all_const = <span class="keyword">false</span>;
<a name="l03501"></a>03501     type0 i0;
<a name="l03502"></a>03502     type1 i1;
<a name="l03503"></a>03503     <span class="keyword">static</span> <span class="keyword">const</span> type2 i2 = value2_;
<a name="l03504"></a>03504     <span class="keyword">static</span> <span class="keyword">const</span> type3 i3 = value3_;
<a name="l03505"></a>03505 
<a name="l03506"></a>03506     LITE_INLINE pack() 
<a name="l03507"></a>03507         : i0(),i1()    {}
<a name="l03508"></a>03508     
<a name="l03509"></a>03509     LITE_INLINE pack(<span class="keyword">const</span> type0&amp; a0)
<a name="l03510"></a>03510         : i0(a0) 
<a name="l03511"></a>03511      {}
<a name="l03512"></a>03512 
<a name="l03513"></a>03513     LITE_INLINE pack(
<a name="l03514"></a>03514         <span class="keyword">const</span> type0&amp; a0,
<a name="l03515"></a>03515         <span class="keyword">const</span> type1&amp; a1,
<a name="l03516"></a>03516         <span class="keyword">const</span> type2&amp; ,
<a name="l03517"></a>03517         <span class="keyword">const</span> type3&amp; 
<a name="l03518"></a>03518         ) : i0(a0), i1(a1) {}
<a name="l03519"></a>03519 
<a name="l03520"></a>03520     <span class="keyword">template</span>&lt;
<a name="l03521"></a>03521         <span class="keyword">typename</span> other_type0_ ,
<a name="l03522"></a>03522         <span class="keyword">typename</span> other_type1_ ,
<a name="l03523"></a>03523         <span class="keyword">typename</span> other_type2_ ,
<a name="l03524"></a>03524         <span class="keyword">typename</span> other_type3_ 
<a name="l03525"></a>03525     &gt;
<a name="l03526"></a>03526     LITE_INLINE pack(<span class="keyword">const</span> pack&lt;
<a name="l03527"></a>03527         other_type0_,
<a name="l03528"></a>03528         other_type1_,
<a name="l03529"></a>03529         other_type2_,
<a name="l03530"></a>03530         other_type3_
<a name="l03531"></a>03531         &gt;&amp; other) : i0(other.i0), i1(other.i1)    {}
<a name="l03532"></a>03532 
<a name="l03533"></a>03533     LITE_INLINE pack&amp; 
<a name="l03534"></a>03534     operator= (<span class="keyword">const</span> pack&amp; other) 
<a name="l03535"></a>03535     {
<a name="l03536"></a>03536         i0 = other.i0;
<a name="l03537"></a>03537         i1 = other.i1;
<a name="l03538"></a>03538         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l03539"></a>03539     }
<a name="l03540"></a>03540 
<a name="l03541"></a>03541     <span class="keyword">template</span>&lt;
<a name="l03542"></a>03542         <span class="keyword">typename</span> other_type0_ ,
<a name="l03543"></a>03543         <span class="keyword">typename</span> other_type1_ ,
<a name="l03544"></a>03544         <span class="keyword">typename</span> other_type2_ ,
<a name="l03545"></a>03545         <span class="keyword">typename</span> other_type3_ 
<a name="l03546"></a>03546     &gt;
<a name="l03547"></a>03547     LITE_INLINE pack&amp;  
<a name="l03548"></a>03548     operator=(<span class="keyword">const</span> pack&lt;
<a name="l03549"></a>03549         other_type0_,
<a name="l03550"></a>03550         other_type1_,
<a name="l03551"></a>03551         other_type2_,
<a name="l03552"></a>03552         other_type3_
<a name="l03553"></a>03553         &gt;&amp; other) 
<a name="l03554"></a>03554     {
<a name="l03555"></a>03555         i0 = other.i0;
<a name="l03556"></a>03556         i1 = other.i1;
<a name="l03557"></a>03557         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l03558"></a>03558     }
<a name="l03559"></a>03559 
<a name="l03560"></a>03560     LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l03561"></a>03561         <span class="keyword">const</span> type0&amp; a0,
<a name="l03562"></a>03562         <span class="keyword">const</span> type1&amp; a1,
<a name="l03563"></a>03563         <span class="keyword">const</span> type2&amp; ,
<a name="l03564"></a>03564         <span class="keyword">const</span> type3&amp; 
<a name="l03565"></a>03565         ) 
<a name="l03566"></a>03566     {
<a name="l03567"></a>03567             i0 = a0;
<a name="l03568"></a>03568             i1 = a1;
<a name="l03569"></a>03569     }
<a name="l03570"></a>03570 };
<a name="l03571"></a>03571 
<a name="l03572"></a>03572 
<a name="l03573"></a>03573 <span class="keyword">template</span>&lt;
<a name="l03574"></a>03574     <span class="keyword">typename</span> type0_,
<a name="l03575"></a>03575     <span class="keyword">typename</span> type1_,
<a name="l03576"></a>03576     <span class="keyword">typename</span> type2_, type2_ value2_,
<a name="l03577"></a>03577     <span class="keyword">typename</span> type3_, type3_ value3_
<a name="l03578"></a>03578     &gt;
<a name="l03579"></a>03579 <span class="keyword">const</span> type2_ pack&lt;
<a name="l03580"></a>03580     type0_,
<a name="l03581"></a>03581     type1_,
<a name="l03582"></a>03582     constant&lt;type2_, value2_&gt;,
<a name="l03583"></a>03583     constant&lt;type3_, value3_&gt;
<a name="l03584"></a>03584     &gt;::i2;
<a name="l03585"></a>03585 
<a name="l03586"></a>03586 <span class="keyword">template</span>&lt;
<a name="l03587"></a>03587     <span class="keyword">typename</span> type0_,
<a name="l03588"></a>03588     <span class="keyword">typename</span> type1_,
<a name="l03589"></a>03589     <span class="keyword">typename</span> type2_, type2_ value2_,
<a name="l03590"></a>03590     <span class="keyword">typename</span> type3_, type3_ value3_
<a name="l03591"></a>03591     &gt;
<a name="l03592"></a>03592 <span class="keyword">const</span> type3_ pack&lt;
<a name="l03593"></a>03593     type0_,
<a name="l03594"></a>03594     type1_,
<a name="l03595"></a>03595     constant&lt;type2_, value2_&gt;,
<a name="l03596"></a>03596     constant&lt;type3_, value3_&gt;
<a name="l03597"></a>03597     &gt;::i3;
<a name="l03598"></a>03598 
<a name="l03599"></a>03599 <span class="comment">/***********************************************************************************************************/</span>
<a name="l03600"></a>03600 <span class="keyword">template</span>&lt;
<a name="l03601"></a>03601     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l03602"></a>03602     <span class="keyword">typename</span> type1_,
<a name="l03603"></a>03603     <span class="keyword">typename</span> type2_, type2_ value2_,
<a name="l03604"></a>03604     <span class="keyword">typename</span> type3_, type3_ value3_
<a name="l03605"></a>03605     &gt;
<a name="l03606"></a>03606 <span class="keyword">class </span>pack&lt;
<a name="l03607"></a>03607     constant&lt;type0_, value0_&gt;,
<a name="l03608"></a>03608     type1_,
<a name="l03609"></a>03609     constant&lt;type2_, value2_&gt;,
<a name="l03610"></a>03610     constant&lt;type3_, value3_&gt;
<a name="l03611"></a>03611     &gt;
<a name="l03612"></a>03612 {
<a name="l03613"></a>03613 <span class="keyword">public</span>:
<a name="l03614"></a>03614     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n = 4;
<a name="l03615"></a>03615 
<a name="l03616"></a>03616     <span class="keyword">typedef</span> type0_ type0;
<a name="l03617"></a>03617     <span class="keyword">typedef</span> type1_ type1;
<a name="l03618"></a>03618     <span class="keyword">typedef</span> type2_ type2;
<a name="l03619"></a>03619     <span class="keyword">typedef</span> type3_ type3;
<a name="l03620"></a>03620 
<a name="l03621"></a>03621     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const0 = <span class="keyword">true</span>;
<a name="l03622"></a>03622     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const1 = <span class="keyword">false</span>;
<a name="l03623"></a>03623     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const2 = <span class="keyword">true</span>;
<a name="l03624"></a>03624     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const3 = <span class="keyword">true</span>;
<a name="l03625"></a>03625     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_all_const = <span class="keyword">false</span>;
<a name="l03626"></a>03626     <span class="keyword">static</span> <span class="keyword">const</span> type0 i0 = value0_;
<a name="l03627"></a>03627     type1 i1;
<a name="l03628"></a>03628     <span class="keyword">static</span> <span class="keyword">const</span> type2 i2 = value2_;
<a name="l03629"></a>03629     <span class="keyword">static</span> <span class="keyword">const</span> type3 i3 = value3_;
<a name="l03630"></a>03630 
<a name="l03631"></a>03631     LITE_INLINE pack() 
<a name="l03632"></a>03632         : i1()    {}
<a name="l03633"></a>03633     
<a name="l03634"></a>03634     LITE_INLINE pack(<span class="keyword">const</span> type0&amp; )
<a name="l03635"></a>03635      {}
<a name="l03636"></a>03636 
<a name="l03637"></a>03637     LITE_INLINE pack(
<a name="l03638"></a>03638         <span class="keyword">const</span> type0&amp; ,
<a name="l03639"></a>03639         <span class="keyword">const</span> type1&amp; a1,
<a name="l03640"></a>03640         <span class="keyword">const</span> type2&amp; ,
<a name="l03641"></a>03641         <span class="keyword">const</span> type3&amp; 
<a name="l03642"></a>03642         ) : i1(a1) {}
<a name="l03643"></a>03643 
<a name="l03644"></a>03644     <span class="keyword">template</span>&lt;
<a name="l03645"></a>03645         <span class="keyword">typename</span> other_type0_ ,
<a name="l03646"></a>03646         <span class="keyword">typename</span> other_type1_ ,
<a name="l03647"></a>03647         <span class="keyword">typename</span> other_type2_ ,
<a name="l03648"></a>03648         <span class="keyword">typename</span> other_type3_ 
<a name="l03649"></a>03649     &gt;
<a name="l03650"></a>03650     LITE_INLINE pack(<span class="keyword">const</span> pack&lt;
<a name="l03651"></a>03651         other_type0_,
<a name="l03652"></a>03652         other_type1_,
<a name="l03653"></a>03653         other_type2_,
<a name="l03654"></a>03654         other_type3_
<a name="l03655"></a>03655         &gt;&amp; other) : i1(other.i1)    {}
<a name="l03656"></a>03656 
<a name="l03657"></a>03657     LITE_INLINE pack&amp; 
<a name="l03658"></a>03658     operator= (<span class="keyword">const</span> pack&amp; other) 
<a name="l03659"></a>03659     {
<a name="l03660"></a>03660         i1 = other.i1;
<a name="l03661"></a>03661         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l03662"></a>03662     }
<a name="l03663"></a>03663 
<a name="l03664"></a>03664     <span class="keyword">template</span>&lt;
<a name="l03665"></a>03665         <span class="keyword">typename</span> other_type0_ ,
<a name="l03666"></a>03666         <span class="keyword">typename</span> other_type1_ ,
<a name="l03667"></a>03667         <span class="keyword">typename</span> other_type2_ ,
<a name="l03668"></a>03668         <span class="keyword">typename</span> other_type3_ 
<a name="l03669"></a>03669     &gt;
<a name="l03670"></a>03670     LITE_INLINE pack&amp;  
<a name="l03671"></a>03671     operator=(<span class="keyword">const</span> pack&lt;
<a name="l03672"></a>03672         other_type0_,
<a name="l03673"></a>03673         other_type1_,
<a name="l03674"></a>03674         other_type2_,
<a name="l03675"></a>03675         other_type3_
<a name="l03676"></a>03676         &gt;&amp; other) 
<a name="l03677"></a>03677     {
<a name="l03678"></a>03678         i1 = other.i1;
<a name="l03679"></a>03679         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l03680"></a>03680     }
<a name="l03681"></a>03681 
<a name="l03682"></a>03682     LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l03683"></a>03683         <span class="keyword">const</span> type0&amp; ,
<a name="l03684"></a>03684         <span class="keyword">const</span> type1&amp; a1,
<a name="l03685"></a>03685         <span class="keyword">const</span> type2&amp; ,
<a name="l03686"></a>03686         <span class="keyword">const</span> type3&amp; 
<a name="l03687"></a>03687         ) 
<a name="l03688"></a>03688     {
<a name="l03689"></a>03689             i1 = a1;
<a name="l03690"></a>03690     }
<a name="l03691"></a>03691 };
<a name="l03692"></a>03692 
<a name="l03693"></a>03693 
<a name="l03694"></a>03694 <span class="keyword">template</span>&lt;
<a name="l03695"></a>03695     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l03696"></a>03696     <span class="keyword">typename</span> type1_,
<a name="l03697"></a>03697     <span class="keyword">typename</span> type2_, type2_ value2_,
<a name="l03698"></a>03698     <span class="keyword">typename</span> type3_, type3_ value3_
<a name="l03699"></a>03699     &gt;
<a name="l03700"></a>03700 <span class="keyword">const</span> type0_ pack&lt;
<a name="l03701"></a>03701     constant&lt;type0_, value0_&gt;,
<a name="l03702"></a>03702     type1_,
<a name="l03703"></a>03703     constant&lt;type2_, value2_&gt;,
<a name="l03704"></a>03704     constant&lt;type3_, value3_&gt;
<a name="l03705"></a>03705     &gt;::i0;
<a name="l03706"></a>03706 
<a name="l03707"></a>03707 <span class="keyword">template</span>&lt;
<a name="l03708"></a>03708     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l03709"></a>03709     <span class="keyword">typename</span> type1_,
<a name="l03710"></a>03710     <span class="keyword">typename</span> type2_, type2_ value2_,
<a name="l03711"></a>03711     <span class="keyword">typename</span> type3_, type3_ value3_
<a name="l03712"></a>03712     &gt;
<a name="l03713"></a>03713 <span class="keyword">const</span> type2_ pack&lt;
<a name="l03714"></a>03714     constant&lt;type0_, value0_&gt;,
<a name="l03715"></a>03715     type1_,
<a name="l03716"></a>03716     constant&lt;type2_, value2_&gt;,
<a name="l03717"></a>03717     constant&lt;type3_, value3_&gt;
<a name="l03718"></a>03718     &gt;::i2;
<a name="l03719"></a>03719 
<a name="l03720"></a>03720 <span class="keyword">template</span>&lt;
<a name="l03721"></a>03721     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l03722"></a>03722     <span class="keyword">typename</span> type1_,
<a name="l03723"></a>03723     <span class="keyword">typename</span> type2_, type2_ value2_,
<a name="l03724"></a>03724     <span class="keyword">typename</span> type3_, type3_ value3_
<a name="l03725"></a>03725     &gt;
<a name="l03726"></a>03726 <span class="keyword">const</span> type3_ pack&lt;
<a name="l03727"></a>03727     constant&lt;type0_, value0_&gt;,
<a name="l03728"></a>03728     type1_,
<a name="l03729"></a>03729     constant&lt;type2_, value2_&gt;,
<a name="l03730"></a>03730     constant&lt;type3_, value3_&gt;
<a name="l03731"></a>03731     &gt;::i3;
<a name="l03732"></a>03732 
<a name="l03733"></a>03733 <span class="comment">/***********************************************************************************************************/</span>
<a name="l03734"></a>03734 <span class="keyword">template</span>&lt;
<a name="l03735"></a>03735     <span class="keyword">typename</span> type0_,
<a name="l03736"></a>03736     <span class="keyword">typename</span> type1_, type1_ value1_,
<a name="l03737"></a>03737     <span class="keyword">typename</span> type2_, type2_ value2_,
<a name="l03738"></a>03738     <span class="keyword">typename</span> type3_, type3_ value3_
<a name="l03739"></a>03739     &gt;
<a name="l03740"></a>03740 <span class="keyword">class </span>pack&lt;
<a name="l03741"></a>03741     type0_,
<a name="l03742"></a>03742     constant&lt;type1_, value1_&gt;,
<a name="l03743"></a>03743     constant&lt;type2_, value2_&gt;,
<a name="l03744"></a>03744     constant&lt;type3_, value3_&gt;
<a name="l03745"></a>03745     &gt;
<a name="l03746"></a>03746 {
<a name="l03747"></a>03747 <span class="keyword">public</span>:
<a name="l03748"></a>03748     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n = 4;
<a name="l03749"></a>03749 
<a name="l03750"></a>03750     <span class="keyword">typedef</span> type0_ type0;
<a name="l03751"></a>03751     <span class="keyword">typedef</span> type1_ type1;
<a name="l03752"></a>03752     <span class="keyword">typedef</span> type2_ type2;
<a name="l03753"></a>03753     <span class="keyword">typedef</span> type3_ type3;
<a name="l03754"></a>03754 
<a name="l03755"></a>03755     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const0 = <span class="keyword">false</span>;
<a name="l03756"></a>03756     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const1 = <span class="keyword">true</span>;
<a name="l03757"></a>03757     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const2 = <span class="keyword">true</span>;
<a name="l03758"></a>03758     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const3 = <span class="keyword">true</span>;
<a name="l03759"></a>03759     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_all_const = <span class="keyword">false</span>;
<a name="l03760"></a>03760     type0 i0;
<a name="l03761"></a>03761     <span class="keyword">static</span> <span class="keyword">const</span> type1 i1 = value1_;
<a name="l03762"></a>03762     <span class="keyword">static</span> <span class="keyword">const</span> type2 i2 = value2_;
<a name="l03763"></a>03763     <span class="keyword">static</span> <span class="keyword">const</span> type3 i3 = value3_;
<a name="l03764"></a>03764 
<a name="l03765"></a>03765     LITE_INLINE pack() 
<a name="l03766"></a>03766         : i0()    {}
<a name="l03767"></a>03767     
<a name="l03768"></a>03768     LITE_INLINE pack(<span class="keyword">const</span> type0&amp; a0)
<a name="l03769"></a>03769         : i0(a0) 
<a name="l03770"></a>03770      {}
<a name="l03771"></a>03771 
<a name="l03772"></a>03772     LITE_INLINE pack(
<a name="l03773"></a>03773         <span class="keyword">const</span> type0&amp; a0,
<a name="l03774"></a>03774         <span class="keyword">const</span> type1&amp; ,
<a name="l03775"></a>03775         <span class="keyword">const</span> type2&amp; ,
<a name="l03776"></a>03776         <span class="keyword">const</span> type3&amp; 
<a name="l03777"></a>03777         ) : i0(a0) {}
<a name="l03778"></a>03778 
<a name="l03779"></a>03779     <span class="keyword">template</span>&lt;
<a name="l03780"></a>03780         <span class="keyword">typename</span> other_type0_ ,
<a name="l03781"></a>03781         <span class="keyword">typename</span> other_type1_ ,
<a name="l03782"></a>03782         <span class="keyword">typename</span> other_type2_ ,
<a name="l03783"></a>03783         <span class="keyword">typename</span> other_type3_ 
<a name="l03784"></a>03784     &gt;
<a name="l03785"></a>03785     LITE_INLINE pack(<span class="keyword">const</span> pack&lt;
<a name="l03786"></a>03786         other_type0_,
<a name="l03787"></a>03787         other_type1_,
<a name="l03788"></a>03788         other_type2_,
<a name="l03789"></a>03789         other_type3_
<a name="l03790"></a>03790         &gt;&amp; other) : i0(other.i0)    {}
<a name="l03791"></a>03791 
<a name="l03792"></a>03792     LITE_INLINE pack&amp; 
<a name="l03793"></a>03793     operator= (<span class="keyword">const</span> pack&amp; other) 
<a name="l03794"></a>03794     {
<a name="l03795"></a>03795         i0 = other.i0;
<a name="l03796"></a>03796         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l03797"></a>03797     }
<a name="l03798"></a>03798 
<a name="l03799"></a>03799     <span class="keyword">template</span>&lt;
<a name="l03800"></a>03800         <span class="keyword">typename</span> other_type0_ ,
<a name="l03801"></a>03801         <span class="keyword">typename</span> other_type1_ ,
<a name="l03802"></a>03802         <span class="keyword">typename</span> other_type2_ ,
<a name="l03803"></a>03803         <span class="keyword">typename</span> other_type3_ 
<a name="l03804"></a>03804     &gt;
<a name="l03805"></a>03805     LITE_INLINE pack&amp;  
<a name="l03806"></a>03806     operator=(<span class="keyword">const</span> pack&lt;
<a name="l03807"></a>03807         other_type0_,
<a name="l03808"></a>03808         other_type1_,
<a name="l03809"></a>03809         other_type2_,
<a name="l03810"></a>03810         other_type3_
<a name="l03811"></a>03811         &gt;&amp; other) 
<a name="l03812"></a>03812     {
<a name="l03813"></a>03813         i0 = other.i0;
<a name="l03814"></a>03814         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l03815"></a>03815     }
<a name="l03816"></a>03816 
<a name="l03817"></a>03817     LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l03818"></a>03818         <span class="keyword">const</span> type0&amp; a0,
<a name="l03819"></a>03819         <span class="keyword">const</span> type1&amp; ,
<a name="l03820"></a>03820         <span class="keyword">const</span> type2&amp; ,
<a name="l03821"></a>03821         <span class="keyword">const</span> type3&amp; 
<a name="l03822"></a>03822         ) 
<a name="l03823"></a>03823     {
<a name="l03824"></a>03824             i0 = a0;
<a name="l03825"></a>03825     }
<a name="l03826"></a>03826 };
<a name="l03827"></a>03827 
<a name="l03828"></a>03828 
<a name="l03829"></a>03829 <span class="keyword">template</span>&lt;
<a name="l03830"></a>03830     <span class="keyword">typename</span> type0_,
<a name="l03831"></a>03831     <span class="keyword">typename</span> type1_, type1_ value1_,
<a name="l03832"></a>03832     <span class="keyword">typename</span> type2_, type2_ value2_,
<a name="l03833"></a>03833     <span class="keyword">typename</span> type3_, type3_ value3_
<a name="l03834"></a>03834     &gt;
<a name="l03835"></a>03835 <span class="keyword">const</span> type1_ pack&lt;
<a name="l03836"></a>03836     type0_,
<a name="l03837"></a>03837     constant&lt;type1_, value1_&gt;,
<a name="l03838"></a>03838     constant&lt;type2_, value2_&gt;,
<a name="l03839"></a>03839     constant&lt;type3_, value3_&gt;
<a name="l03840"></a>03840     &gt;::i1;
<a name="l03841"></a>03841 
<a name="l03842"></a>03842 <span class="keyword">template</span>&lt;
<a name="l03843"></a>03843     <span class="keyword">typename</span> type0_,
<a name="l03844"></a>03844     <span class="keyword">typename</span> type1_, type1_ value1_,
<a name="l03845"></a>03845     <span class="keyword">typename</span> type2_, type2_ value2_,
<a name="l03846"></a>03846     <span class="keyword">typename</span> type3_, type3_ value3_
<a name="l03847"></a>03847     &gt;
<a name="l03848"></a>03848 <span class="keyword">const</span> type2_ pack&lt;
<a name="l03849"></a>03849     type0_,
<a name="l03850"></a>03850     constant&lt;type1_, value1_&gt;,
<a name="l03851"></a>03851     constant&lt;type2_, value2_&gt;,
<a name="l03852"></a>03852     constant&lt;type3_, value3_&gt;
<a name="l03853"></a>03853     &gt;::i2;
<a name="l03854"></a>03854 
<a name="l03855"></a>03855 <span class="keyword">template</span>&lt;
<a name="l03856"></a>03856     <span class="keyword">typename</span> type0_,
<a name="l03857"></a>03857     <span class="keyword">typename</span> type1_, type1_ value1_,
<a name="l03858"></a>03858     <span class="keyword">typename</span> type2_, type2_ value2_,
<a name="l03859"></a>03859     <span class="keyword">typename</span> type3_, type3_ value3_
<a name="l03860"></a>03860     &gt;
<a name="l03861"></a>03861 <span class="keyword">const</span> type3_ pack&lt;
<a name="l03862"></a>03862     type0_,
<a name="l03863"></a>03863     constant&lt;type1_, value1_&gt;,
<a name="l03864"></a>03864     constant&lt;type2_, value2_&gt;,
<a name="l03865"></a>03865     constant&lt;type3_, value3_&gt;
<a name="l03866"></a>03866     &gt;::i3;
<a name="l03867"></a>03867 
<a name="l03868"></a>03868 <span class="comment">/***********************************************************************************************************/</span>
<a name="l03869"></a>03869 <span class="keyword">template</span>&lt;
<a name="l03870"></a>03870     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l03871"></a>03871     <span class="keyword">typename</span> type1_, type1_ value1_,
<a name="l03872"></a>03872     <span class="keyword">typename</span> type2_, type2_ value2_,
<a name="l03873"></a>03873     <span class="keyword">typename</span> type3_, type3_ value3_
<a name="l03874"></a>03874     &gt;
<a name="l03875"></a>03875 <span class="keyword">class </span>pack&lt;
<a name="l03876"></a>03876     constant&lt;type0_, value0_&gt;,
<a name="l03877"></a>03877     constant&lt;type1_, value1_&gt;,
<a name="l03878"></a>03878     constant&lt;type2_, value2_&gt;,
<a name="l03879"></a>03879     constant&lt;type3_, value3_&gt;
<a name="l03880"></a>03880     &gt;
<a name="l03881"></a>03881 {
<a name="l03882"></a>03882 <span class="keyword">public</span>:
<a name="l03883"></a>03883     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n = 4;
<a name="l03884"></a>03884 
<a name="l03885"></a>03885     <span class="keyword">typedef</span> type0_ type0;
<a name="l03886"></a>03886     <span class="keyword">typedef</span> type1_ type1;
<a name="l03887"></a>03887     <span class="keyword">typedef</span> type2_ type2;
<a name="l03888"></a>03888     <span class="keyword">typedef</span> type3_ type3;
<a name="l03889"></a>03889 
<a name="l03890"></a>03890     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const0 = <span class="keyword">true</span>;
<a name="l03891"></a>03891     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const1 = <span class="keyword">true</span>;
<a name="l03892"></a>03892     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const2 = <span class="keyword">true</span>;
<a name="l03893"></a>03893     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const3 = <span class="keyword">true</span>;
<a name="l03894"></a>03894     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_all_const = <span class="keyword">true</span>;
<a name="l03895"></a>03895     <span class="keyword">static</span> <span class="keyword">const</span> type0 i0 = value0_;
<a name="l03896"></a>03896     <span class="keyword">static</span> <span class="keyword">const</span> type1 i1 = value1_;
<a name="l03897"></a>03897     <span class="keyword">static</span> <span class="keyword">const</span> type2 i2 = value2_;
<a name="l03898"></a>03898     <span class="keyword">static</span> <span class="keyword">const</span> type3 i3 = value3_;
<a name="l03899"></a>03899 
<a name="l03900"></a>03900     LITE_INLINE pack() 
<a name="l03901"></a>03901              {}
<a name="l03902"></a>03902     
<a name="l03903"></a>03903     LITE_INLINE pack(<span class="keyword">const</span> type0&amp; )
<a name="l03904"></a>03904      {}
<a name="l03905"></a>03905 
<a name="l03906"></a>03906     LITE_INLINE pack(
<a name="l03907"></a>03907         <span class="keyword">const</span> type0&amp; ,
<a name="l03908"></a>03908         <span class="keyword">const</span> type1&amp; ,
<a name="l03909"></a>03909         <span class="keyword">const</span> type2&amp; ,
<a name="l03910"></a>03910         <span class="keyword">const</span> type3&amp; 
<a name="l03911"></a>03911         )  {}
<a name="l03912"></a>03912 
<a name="l03913"></a>03913     <span class="keyword">template</span>&lt;
<a name="l03914"></a>03914         <span class="keyword">typename</span> other_type0_ ,
<a name="l03915"></a>03915         <span class="keyword">typename</span> other_type1_ ,
<a name="l03916"></a>03916         <span class="keyword">typename</span> other_type2_ ,
<a name="l03917"></a>03917         <span class="keyword">typename</span> other_type3_ 
<a name="l03918"></a>03918     &gt;
<a name="l03919"></a>03919     LITE_INLINE pack(<span class="keyword">const</span> pack&lt;
<a name="l03920"></a>03920         other_type0_,
<a name="l03921"></a>03921         other_type1_,
<a name="l03922"></a>03922         other_type2_,
<a name="l03923"></a>03923         other_type3_
<a name="l03924"></a>03924         &gt;&amp; )     {}
<a name="l03925"></a>03925 
<a name="l03926"></a>03926     LITE_INLINE pack&amp; 
<a name="l03927"></a>03927     operator= (<span class="keyword">const</span> pack&amp; ) 
<a name="l03928"></a>03928     {
<a name="l03929"></a>03929         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l03930"></a>03930     }
<a name="l03931"></a>03931 
<a name="l03932"></a>03932     <span class="keyword">template</span>&lt;
<a name="l03933"></a>03933         <span class="keyword">typename</span> other_type0_ ,
<a name="l03934"></a>03934         <span class="keyword">typename</span> other_type1_ ,
<a name="l03935"></a>03935         <span class="keyword">typename</span> other_type2_ ,
<a name="l03936"></a>03936         <span class="keyword">typename</span> other_type3_ 
<a name="l03937"></a>03937     &gt;
<a name="l03938"></a>03938     LITE_INLINE pack&amp;  
<a name="l03939"></a>03939     operator=(<span class="keyword">const</span> pack&lt;
<a name="l03940"></a>03940         other_type0_,
<a name="l03941"></a>03941         other_type1_,
<a name="l03942"></a>03942         other_type2_,
<a name="l03943"></a>03943         other_type3_
<a name="l03944"></a>03944         &gt;&amp; ) 
<a name="l03945"></a>03945     {
<a name="l03946"></a>03946         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l03947"></a>03947     }
<a name="l03948"></a>03948 
<a name="l03949"></a>03949     LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l03950"></a>03950         <span class="keyword">const</span> type0&amp; ,
<a name="l03951"></a>03951         <span class="keyword">const</span> type1&amp; ,
<a name="l03952"></a>03952         <span class="keyword">const</span> type2&amp; ,
<a name="l03953"></a>03953         <span class="keyword">const</span> type3&amp; 
<a name="l03954"></a>03954         ) 
<a name="l03955"></a>03955     {
<a name="l03956"></a>03956     }
<a name="l03957"></a>03957 };
<a name="l03958"></a>03958 
<a name="l03959"></a>03959 
<a name="l03960"></a>03960 <span class="keyword">template</span>&lt;
<a name="l03961"></a>03961     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l03962"></a>03962     <span class="keyword">typename</span> type1_, type1_ value1_,
<a name="l03963"></a>03963     <span class="keyword">typename</span> type2_, type2_ value2_,
<a name="l03964"></a>03964     <span class="keyword">typename</span> type3_, type3_ value3_
<a name="l03965"></a>03965     &gt;
<a name="l03966"></a>03966 <span class="keyword">const</span> type0_ pack&lt;
<a name="l03967"></a>03967     constant&lt;type0_, value0_&gt;,
<a name="l03968"></a>03968     constant&lt;type1_, value1_&gt;,
<a name="l03969"></a>03969     constant&lt;type2_, value2_&gt;,
<a name="l03970"></a>03970     constant&lt;type3_, value3_&gt;
<a name="l03971"></a>03971     &gt;::i0;
<a name="l03972"></a>03972 
<a name="l03973"></a>03973 <span class="keyword">template</span>&lt;
<a name="l03974"></a>03974     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l03975"></a>03975     <span class="keyword">typename</span> type1_, type1_ value1_,
<a name="l03976"></a>03976     <span class="keyword">typename</span> type2_, type2_ value2_,
<a name="l03977"></a>03977     <span class="keyword">typename</span> type3_, type3_ value3_
<a name="l03978"></a>03978     &gt;
<a name="l03979"></a>03979 <span class="keyword">const</span> type1_ pack&lt;
<a name="l03980"></a>03980     constant&lt;type0_, value0_&gt;,
<a name="l03981"></a>03981     constant&lt;type1_, value1_&gt;,
<a name="l03982"></a>03982     constant&lt;type2_, value2_&gt;,
<a name="l03983"></a>03983     constant&lt;type3_, value3_&gt;
<a name="l03984"></a>03984     &gt;::i1;
<a name="l03985"></a>03985 
<a name="l03986"></a>03986 <span class="keyword">template</span>&lt;
<a name="l03987"></a>03987     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l03988"></a>03988     <span class="keyword">typename</span> type1_, type1_ value1_,
<a name="l03989"></a>03989     <span class="keyword">typename</span> type2_, type2_ value2_,
<a name="l03990"></a>03990     <span class="keyword">typename</span> type3_, type3_ value3_
<a name="l03991"></a>03991     &gt;
<a name="l03992"></a>03992 <span class="keyword">const</span> type2_ pack&lt;
<a name="l03993"></a>03993     constant&lt;type0_, value0_&gt;,
<a name="l03994"></a>03994     constant&lt;type1_, value1_&gt;,
<a name="l03995"></a>03995     constant&lt;type2_, value2_&gt;,
<a name="l03996"></a>03996     constant&lt;type3_, value3_&gt;
<a name="l03997"></a>03997     &gt;::i2;
<a name="l03998"></a>03998 
<a name="l03999"></a>03999 <span class="keyword">template</span>&lt;
<a name="l04000"></a>04000     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l04001"></a>04001     <span class="keyword">typename</span> type1_, type1_ value1_,
<a name="l04002"></a>04002     <span class="keyword">typename</span> type2_, type2_ value2_,
<a name="l04003"></a>04003     <span class="keyword">typename</span> type3_, type3_ value3_
<a name="l04004"></a>04004     &gt;
<a name="l04005"></a>04005 <span class="keyword">const</span> type3_ pack&lt;
<a name="l04006"></a>04006     constant&lt;type0_, value0_&gt;,
<a name="l04007"></a>04007     constant&lt;type1_, value1_&gt;,
<a name="l04008"></a>04008     constant&lt;type2_, value2_&gt;,
<a name="l04009"></a>04009     constant&lt;type3_, value3_&gt;
<a name="l04010"></a>04010     &gt;::i3;
<a name="l04011"></a>04011 
<a name="l04012"></a>04012 <span class="comment">/***********************************************************************************************************/</span>
<a name="l04013"></a>04013 <span class="keyword">template</span>&lt;
<a name="l04014"></a>04014     <span class="keyword">typename</span> type0_,
<a name="l04015"></a>04015     <span class="keyword">typename</span> type1_,
<a name="l04016"></a>04016     <span class="keyword">typename</span> type2_
<a name="l04017"></a>04017     &gt;
<a name="l04018"></a>04018 <span class="keyword">class </span>pack&lt;
<a name="l04019"></a>04019     type0_,
<a name="l04020"></a>04020     type1_,
<a name="l04021"></a>04021     type2_
<a name="l04022"></a>04022     &gt;
<a name="l04023"></a>04023 {
<a name="l04024"></a>04024 <span class="keyword">public</span>:
<a name="l04025"></a>04025     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n = 3;
<a name="l04026"></a>04026 
<a name="l04027"></a>04027     <span class="keyword">typedef</span> type0_ type0;
<a name="l04028"></a>04028     <span class="keyword">typedef</span> type1_ type1;
<a name="l04029"></a>04029     <span class="keyword">typedef</span> type2_ type2;
<a name="l04030"></a>04030 
<a name="l04031"></a>04031     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const0 = <span class="keyword">false</span>;
<a name="l04032"></a>04032     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const1 = <span class="keyword">false</span>;
<a name="l04033"></a>04033     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const2 = <span class="keyword">false</span>;
<a name="l04034"></a>04034     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_all_const = <span class="keyword">false</span>;
<a name="l04035"></a>04035     type0 i0;
<a name="l04036"></a>04036     type1 i1;
<a name="l04037"></a>04037     type2 i2;
<a name="l04038"></a>04038 
<a name="l04039"></a>04039     LITE_INLINE pack() 
<a name="l04040"></a>04040         : i0(),i1(),i2()    {}
<a name="l04041"></a>04041     
<a name="l04042"></a>04042     LITE_INLINE pack(<span class="keyword">const</span> type0&amp; a0)
<a name="l04043"></a>04043         : i0(a0) 
<a name="l04044"></a>04044      {}
<a name="l04045"></a>04045 
<a name="l04046"></a>04046     LITE_INLINE pack(
<a name="l04047"></a>04047         <span class="keyword">const</span> type0&amp; a0,
<a name="l04048"></a>04048         <span class="keyword">const</span> type1&amp; a1,
<a name="l04049"></a>04049         <span class="keyword">const</span> type2&amp; a2
<a name="l04050"></a>04050         ) : i0(a0), i1(a1), i2(a2) {}
<a name="l04051"></a>04051 
<a name="l04052"></a>04052     <span class="keyword">template</span>&lt;
<a name="l04053"></a>04053         <span class="keyword">typename</span> other_type0_ ,
<a name="l04054"></a>04054         <span class="keyword">typename</span> other_type1_ ,
<a name="l04055"></a>04055         <span class="keyword">typename</span> other_type2_ 
<a name="l04056"></a>04056     &gt;
<a name="l04057"></a>04057     LITE_INLINE pack(<span class="keyword">const</span> pack&lt;
<a name="l04058"></a>04058         other_type0_,
<a name="l04059"></a>04059         other_type1_,
<a name="l04060"></a>04060         other_type2_
<a name="l04061"></a>04061         &gt;&amp; other) : i0(other.i0), i1(other.i1), i2(other.i2)    {}
<a name="l04062"></a>04062 
<a name="l04063"></a>04063     LITE_INLINE pack&amp; 
<a name="l04064"></a>04064     operator= (<span class="keyword">const</span> pack&amp; other) 
<a name="l04065"></a>04065     {
<a name="l04066"></a>04066         i0 = other.i0;
<a name="l04067"></a>04067         i1 = other.i1;
<a name="l04068"></a>04068         i2 = other.i2;
<a name="l04069"></a>04069         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l04070"></a>04070     }
<a name="l04071"></a>04071 
<a name="l04072"></a>04072     <span class="keyword">template</span>&lt;
<a name="l04073"></a>04073         <span class="keyword">typename</span> other_type0_ ,
<a name="l04074"></a>04074         <span class="keyword">typename</span> other_type1_ ,
<a name="l04075"></a>04075         <span class="keyword">typename</span> other_type2_ 
<a name="l04076"></a>04076     &gt;
<a name="l04077"></a>04077     LITE_INLINE pack&amp;  
<a name="l04078"></a>04078     operator=(<span class="keyword">const</span> pack&lt;
<a name="l04079"></a>04079         other_type0_,
<a name="l04080"></a>04080         other_type1_,
<a name="l04081"></a>04081         other_type2_
<a name="l04082"></a>04082         &gt;&amp; other) 
<a name="l04083"></a>04083     {
<a name="l04084"></a>04084         i0 = other.i0;
<a name="l04085"></a>04085         i1 = other.i1;
<a name="l04086"></a>04086         i2 = other.i2;
<a name="l04087"></a>04087         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l04088"></a>04088     }
<a name="l04089"></a>04089 
<a name="l04090"></a>04090     LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l04091"></a>04091         <span class="keyword">const</span> type0&amp; a0,
<a name="l04092"></a>04092         <span class="keyword">const</span> type1&amp; a1,
<a name="l04093"></a>04093         <span class="keyword">const</span> type2&amp; a2
<a name="l04094"></a>04094         ) 
<a name="l04095"></a>04095     {
<a name="l04096"></a>04096             i0 = a0;
<a name="l04097"></a>04097             i1 = a1;
<a name="l04098"></a>04098             i2 = a2;
<a name="l04099"></a>04099     }
<a name="l04100"></a>04100 };
<a name="l04101"></a>04101 
<a name="l04102"></a>04102 
<a name="l04103"></a>04103 <span class="comment">/***********************************************************************************************************/</span>
<a name="l04104"></a>04104 <span class="keyword">template</span>&lt;
<a name="l04105"></a>04105     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l04106"></a>04106     <span class="keyword">typename</span> type1_,
<a name="l04107"></a>04107     <span class="keyword">typename</span> type2_
<a name="l04108"></a>04108     &gt;
<a name="l04109"></a>04109 <span class="keyword">class </span>pack&lt;
<a name="l04110"></a>04110     constant&lt;type0_, value0_&gt;,
<a name="l04111"></a>04111     type1_,
<a name="l04112"></a>04112     type2_
<a name="l04113"></a>04113     &gt;
<a name="l04114"></a>04114 {
<a name="l04115"></a>04115 <span class="keyword">public</span>:
<a name="l04116"></a>04116     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n = 3;
<a name="l04117"></a>04117 
<a name="l04118"></a>04118     <span class="keyword">typedef</span> type0_ type0;
<a name="l04119"></a>04119     <span class="keyword">typedef</span> type1_ type1;
<a name="l04120"></a>04120     <span class="keyword">typedef</span> type2_ type2;
<a name="l04121"></a>04121 
<a name="l04122"></a>04122     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const0 = <span class="keyword">true</span>;
<a name="l04123"></a>04123     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const1 = <span class="keyword">false</span>;
<a name="l04124"></a>04124     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const2 = <span class="keyword">false</span>;
<a name="l04125"></a>04125     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_all_const = <span class="keyword">false</span>;
<a name="l04126"></a>04126     <span class="keyword">static</span> <span class="keyword">const</span> type0 i0 = value0_;
<a name="l04127"></a>04127     type1 i1;
<a name="l04128"></a>04128     type2 i2;
<a name="l04129"></a>04129 
<a name="l04130"></a>04130     LITE_INLINE pack() 
<a name="l04131"></a>04131         : i1(),i2()    {}
<a name="l04132"></a>04132     
<a name="l04133"></a>04133     LITE_INLINE pack(<span class="keyword">const</span> type0&amp; )
<a name="l04134"></a>04134      {}
<a name="l04135"></a>04135 
<a name="l04136"></a>04136     LITE_INLINE pack(
<a name="l04137"></a>04137         <span class="keyword">const</span> type0&amp; ,
<a name="l04138"></a>04138         <span class="keyword">const</span> type1&amp; a1,
<a name="l04139"></a>04139         <span class="keyword">const</span> type2&amp; a2
<a name="l04140"></a>04140         ) : i1(a1), i2(a2) {}
<a name="l04141"></a>04141 
<a name="l04142"></a>04142     <span class="keyword">template</span>&lt;
<a name="l04143"></a>04143         <span class="keyword">typename</span> other_type0_ ,
<a name="l04144"></a>04144         <span class="keyword">typename</span> other_type1_ ,
<a name="l04145"></a>04145         <span class="keyword">typename</span> other_type2_ 
<a name="l04146"></a>04146     &gt;
<a name="l04147"></a>04147     LITE_INLINE pack(<span class="keyword">const</span> pack&lt;
<a name="l04148"></a>04148         other_type0_,
<a name="l04149"></a>04149         other_type1_,
<a name="l04150"></a>04150         other_type2_
<a name="l04151"></a>04151         &gt;&amp; other) : i1(other.i1), i2(other.i2)    {}
<a name="l04152"></a>04152 
<a name="l04153"></a>04153     LITE_INLINE pack&amp; 
<a name="l04154"></a>04154     operator= (<span class="keyword">const</span> pack&amp; other) 
<a name="l04155"></a>04155     {
<a name="l04156"></a>04156         i1 = other.i1;
<a name="l04157"></a>04157         i2 = other.i2;
<a name="l04158"></a>04158         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l04159"></a>04159     }
<a name="l04160"></a>04160 
<a name="l04161"></a>04161     <span class="keyword">template</span>&lt;
<a name="l04162"></a>04162         <span class="keyword">typename</span> other_type0_ ,
<a name="l04163"></a>04163         <span class="keyword">typename</span> other_type1_ ,
<a name="l04164"></a>04164         <span class="keyword">typename</span> other_type2_ 
<a name="l04165"></a>04165     &gt;
<a name="l04166"></a>04166     LITE_INLINE pack&amp;  
<a name="l04167"></a>04167     operator=(<span class="keyword">const</span> pack&lt;
<a name="l04168"></a>04168         other_type0_,
<a name="l04169"></a>04169         other_type1_,
<a name="l04170"></a>04170         other_type2_
<a name="l04171"></a>04171         &gt;&amp; other) 
<a name="l04172"></a>04172     {
<a name="l04173"></a>04173         i1 = other.i1;
<a name="l04174"></a>04174         i2 = other.i2;
<a name="l04175"></a>04175         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l04176"></a>04176     }
<a name="l04177"></a>04177 
<a name="l04178"></a>04178     LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l04179"></a>04179         <span class="keyword">const</span> type0&amp; ,
<a name="l04180"></a>04180         <span class="keyword">const</span> type1&amp; a1,
<a name="l04181"></a>04181         <span class="keyword">const</span> type2&amp; a2
<a name="l04182"></a>04182         ) 
<a name="l04183"></a>04183     {
<a name="l04184"></a>04184             i1 = a1;
<a name="l04185"></a>04185             i2 = a2;
<a name="l04186"></a>04186     }
<a name="l04187"></a>04187 };
<a name="l04188"></a>04188 
<a name="l04189"></a>04189 
<a name="l04190"></a>04190 <span class="keyword">template</span>&lt;
<a name="l04191"></a>04191     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l04192"></a>04192     <span class="keyword">typename</span> type1_,
<a name="l04193"></a>04193     <span class="keyword">typename</span> type2_
<a name="l04194"></a>04194     &gt;
<a name="l04195"></a>04195 <span class="keyword">const</span> type0_ pack&lt;
<a name="l04196"></a>04196     constant&lt;type0_, value0_&gt;,
<a name="l04197"></a>04197     type1_,
<a name="l04198"></a>04198     type2_
<a name="l04199"></a>04199     &gt;::i0;
<a name="l04200"></a>04200 
<a name="l04201"></a>04201 <span class="comment">/***********************************************************************************************************/</span>
<a name="l04202"></a>04202 <span class="keyword">template</span>&lt;
<a name="l04203"></a>04203     <span class="keyword">typename</span> type0_,
<a name="l04204"></a>04204     <span class="keyword">typename</span> type1_, type1_ value1_,
<a name="l04205"></a>04205     <span class="keyword">typename</span> type2_
<a name="l04206"></a>04206     &gt;
<a name="l04207"></a>04207 <span class="keyword">class </span>pack&lt;
<a name="l04208"></a>04208     type0_,
<a name="l04209"></a>04209     constant&lt;type1_, value1_&gt;,
<a name="l04210"></a>04210     type2_
<a name="l04211"></a>04211     &gt;
<a name="l04212"></a>04212 {
<a name="l04213"></a>04213 <span class="keyword">public</span>:
<a name="l04214"></a>04214     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n = 3;
<a name="l04215"></a>04215 
<a name="l04216"></a>04216     <span class="keyword">typedef</span> type0_ type0;
<a name="l04217"></a>04217     <span class="keyword">typedef</span> type1_ type1;
<a name="l04218"></a>04218     <span class="keyword">typedef</span> type2_ type2;
<a name="l04219"></a>04219 
<a name="l04220"></a>04220     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const0 = <span class="keyword">false</span>;
<a name="l04221"></a>04221     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const1 = <span class="keyword">true</span>;
<a name="l04222"></a>04222     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const2 = <span class="keyword">false</span>;
<a name="l04223"></a>04223     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_all_const = <span class="keyword">false</span>;
<a name="l04224"></a>04224     type0 i0;
<a name="l04225"></a>04225     <span class="keyword">static</span> <span class="keyword">const</span> type1 i1 = value1_;
<a name="l04226"></a>04226     type2 i2;
<a name="l04227"></a>04227 
<a name="l04228"></a>04228     LITE_INLINE pack() 
<a name="l04229"></a>04229         : i0(),i2()    {}
<a name="l04230"></a>04230     
<a name="l04231"></a>04231     LITE_INLINE pack(<span class="keyword">const</span> type0&amp; a0)
<a name="l04232"></a>04232         : i0(a0) 
<a name="l04233"></a>04233      {}
<a name="l04234"></a>04234 
<a name="l04235"></a>04235     LITE_INLINE pack(
<a name="l04236"></a>04236         <span class="keyword">const</span> type0&amp; a0,
<a name="l04237"></a>04237         <span class="keyword">const</span> type1&amp; ,
<a name="l04238"></a>04238         <span class="keyword">const</span> type2&amp; a2
<a name="l04239"></a>04239         ) : i0(a0), i2(a2) {}
<a name="l04240"></a>04240 
<a name="l04241"></a>04241     <span class="keyword">template</span>&lt;
<a name="l04242"></a>04242         <span class="keyword">typename</span> other_type0_ ,
<a name="l04243"></a>04243         <span class="keyword">typename</span> other_type1_ ,
<a name="l04244"></a>04244         <span class="keyword">typename</span> other_type2_ 
<a name="l04245"></a>04245     &gt;
<a name="l04246"></a>04246     LITE_INLINE pack(<span class="keyword">const</span> pack&lt;
<a name="l04247"></a>04247         other_type0_,
<a name="l04248"></a>04248         other_type1_,
<a name="l04249"></a>04249         other_type2_
<a name="l04250"></a>04250         &gt;&amp; other) : i0(other.i0), i2(other.i2)    {}
<a name="l04251"></a>04251 
<a name="l04252"></a>04252     LITE_INLINE pack&amp; 
<a name="l04253"></a>04253     operator= (<span class="keyword">const</span> pack&amp; other) 
<a name="l04254"></a>04254     {
<a name="l04255"></a>04255         i0 = other.i0;
<a name="l04256"></a>04256         i2 = other.i2;
<a name="l04257"></a>04257         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l04258"></a>04258     }
<a name="l04259"></a>04259 
<a name="l04260"></a>04260     <span class="keyword">template</span>&lt;
<a name="l04261"></a>04261         <span class="keyword">typename</span> other_type0_ ,
<a name="l04262"></a>04262         <span class="keyword">typename</span> other_type1_ ,
<a name="l04263"></a>04263         <span class="keyword">typename</span> other_type2_ 
<a name="l04264"></a>04264     &gt;
<a name="l04265"></a>04265     LITE_INLINE pack&amp;  
<a name="l04266"></a>04266     operator=(<span class="keyword">const</span> pack&lt;
<a name="l04267"></a>04267         other_type0_,
<a name="l04268"></a>04268         other_type1_,
<a name="l04269"></a>04269         other_type2_
<a name="l04270"></a>04270         &gt;&amp; other) 
<a name="l04271"></a>04271     {
<a name="l04272"></a>04272         i0 = other.i0;
<a name="l04273"></a>04273         i2 = other.i2;
<a name="l04274"></a>04274         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l04275"></a>04275     }
<a name="l04276"></a>04276 
<a name="l04277"></a>04277     LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l04278"></a>04278         <span class="keyword">const</span> type0&amp; a0,
<a name="l04279"></a>04279         <span class="keyword">const</span> type1&amp; ,
<a name="l04280"></a>04280         <span class="keyword">const</span> type2&amp; a2
<a name="l04281"></a>04281         ) 
<a name="l04282"></a>04282     {
<a name="l04283"></a>04283             i0 = a0;
<a name="l04284"></a>04284             i2 = a2;
<a name="l04285"></a>04285     }
<a name="l04286"></a>04286 };
<a name="l04287"></a>04287 
<a name="l04288"></a>04288 
<a name="l04289"></a>04289 <span class="keyword">template</span>&lt;
<a name="l04290"></a>04290     <span class="keyword">typename</span> type0_,
<a name="l04291"></a>04291     <span class="keyword">typename</span> type1_, type1_ value1_,
<a name="l04292"></a>04292     <span class="keyword">typename</span> type2_
<a name="l04293"></a>04293     &gt;
<a name="l04294"></a>04294 <span class="keyword">const</span> type1_ pack&lt;
<a name="l04295"></a>04295     type0_,
<a name="l04296"></a>04296     constant&lt;type1_, value1_&gt;,
<a name="l04297"></a>04297     type2_
<a name="l04298"></a>04298     &gt;::i1;
<a name="l04299"></a>04299 
<a name="l04300"></a>04300 <span class="comment">/***********************************************************************************************************/</span>
<a name="l04301"></a>04301 <span class="keyword">template</span>&lt;
<a name="l04302"></a>04302     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l04303"></a>04303     <span class="keyword">typename</span> type1_, type1_ value1_,
<a name="l04304"></a>04304     <span class="keyword">typename</span> type2_
<a name="l04305"></a>04305     &gt;
<a name="l04306"></a>04306 <span class="keyword">class </span>pack&lt;
<a name="l04307"></a>04307     constant&lt;type0_, value0_&gt;,
<a name="l04308"></a>04308     constant&lt;type1_, value1_&gt;,
<a name="l04309"></a>04309     type2_
<a name="l04310"></a>04310     &gt;
<a name="l04311"></a>04311 {
<a name="l04312"></a>04312 <span class="keyword">public</span>:
<a name="l04313"></a>04313     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n = 3;
<a name="l04314"></a>04314 
<a name="l04315"></a>04315     <span class="keyword">typedef</span> type0_ type0;
<a name="l04316"></a>04316     <span class="keyword">typedef</span> type1_ type1;
<a name="l04317"></a>04317     <span class="keyword">typedef</span> type2_ type2;
<a name="l04318"></a>04318 
<a name="l04319"></a>04319     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const0 = <span class="keyword">true</span>;
<a name="l04320"></a>04320     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const1 = <span class="keyword">true</span>;
<a name="l04321"></a>04321     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const2 = <span class="keyword">false</span>;
<a name="l04322"></a>04322     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_all_const = <span class="keyword">false</span>;
<a name="l04323"></a>04323     <span class="keyword">static</span> <span class="keyword">const</span> type0 i0 = value0_;
<a name="l04324"></a>04324     <span class="keyword">static</span> <span class="keyword">const</span> type1 i1 = value1_;
<a name="l04325"></a>04325     type2 i2;
<a name="l04326"></a>04326 
<a name="l04327"></a>04327     LITE_INLINE pack() 
<a name="l04328"></a>04328         : i2()    {}
<a name="l04329"></a>04329     
<a name="l04330"></a>04330     LITE_INLINE pack(<span class="keyword">const</span> type0&amp; )
<a name="l04331"></a>04331      {}
<a name="l04332"></a>04332 
<a name="l04333"></a>04333     LITE_INLINE pack(
<a name="l04334"></a>04334         <span class="keyword">const</span> type0&amp; ,
<a name="l04335"></a>04335         <span class="keyword">const</span> type1&amp; ,
<a name="l04336"></a>04336         <span class="keyword">const</span> type2&amp; a2
<a name="l04337"></a>04337         ) : i2(a2) {}
<a name="l04338"></a>04338 
<a name="l04339"></a>04339     <span class="keyword">template</span>&lt;
<a name="l04340"></a>04340         <span class="keyword">typename</span> other_type0_ ,
<a name="l04341"></a>04341         <span class="keyword">typename</span> other_type1_ ,
<a name="l04342"></a>04342         <span class="keyword">typename</span> other_type2_ 
<a name="l04343"></a>04343     &gt;
<a name="l04344"></a>04344     LITE_INLINE pack(<span class="keyword">const</span> pack&lt;
<a name="l04345"></a>04345         other_type0_,
<a name="l04346"></a>04346         other_type1_,
<a name="l04347"></a>04347         other_type2_
<a name="l04348"></a>04348         &gt;&amp; other) : i2(other.i2)    {}
<a name="l04349"></a>04349 
<a name="l04350"></a>04350     LITE_INLINE pack&amp; 
<a name="l04351"></a>04351     operator= (<span class="keyword">const</span> pack&amp; other) 
<a name="l04352"></a>04352     {
<a name="l04353"></a>04353         i2 = other.i2;
<a name="l04354"></a>04354         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l04355"></a>04355     }
<a name="l04356"></a>04356 
<a name="l04357"></a>04357     <span class="keyword">template</span>&lt;
<a name="l04358"></a>04358         <span class="keyword">typename</span> other_type0_ ,
<a name="l04359"></a>04359         <span class="keyword">typename</span> other_type1_ ,
<a name="l04360"></a>04360         <span class="keyword">typename</span> other_type2_ 
<a name="l04361"></a>04361     &gt;
<a name="l04362"></a>04362     LITE_INLINE pack&amp;  
<a name="l04363"></a>04363     operator=(<span class="keyword">const</span> pack&lt;
<a name="l04364"></a>04364         other_type0_,
<a name="l04365"></a>04365         other_type1_,
<a name="l04366"></a>04366         other_type2_
<a name="l04367"></a>04367         &gt;&amp; other) 
<a name="l04368"></a>04368     {
<a name="l04369"></a>04369         i2 = other.i2;
<a name="l04370"></a>04370         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l04371"></a>04371     }
<a name="l04372"></a>04372 
<a name="l04373"></a>04373     LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l04374"></a>04374         <span class="keyword">const</span> type0&amp; ,
<a name="l04375"></a>04375         <span class="keyword">const</span> type1&amp; ,
<a name="l04376"></a>04376         <span class="keyword">const</span> type2&amp; a2
<a name="l04377"></a>04377         ) 
<a name="l04378"></a>04378     {
<a name="l04379"></a>04379             i2 = a2;
<a name="l04380"></a>04380     }
<a name="l04381"></a>04381 };
<a name="l04382"></a>04382 
<a name="l04383"></a>04383 
<a name="l04384"></a>04384 <span class="keyword">template</span>&lt;
<a name="l04385"></a>04385     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l04386"></a>04386     <span class="keyword">typename</span> type1_, type1_ value1_,
<a name="l04387"></a>04387     <span class="keyword">typename</span> type2_
<a name="l04388"></a>04388     &gt;
<a name="l04389"></a>04389 <span class="keyword">const</span> type0_ pack&lt;
<a name="l04390"></a>04390     constant&lt;type0_, value0_&gt;,
<a name="l04391"></a>04391     constant&lt;type1_, value1_&gt;,
<a name="l04392"></a>04392     type2_
<a name="l04393"></a>04393     &gt;::i0;
<a name="l04394"></a>04394 
<a name="l04395"></a>04395 <span class="keyword">template</span>&lt;
<a name="l04396"></a>04396     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l04397"></a>04397     <span class="keyword">typename</span> type1_, type1_ value1_,
<a name="l04398"></a>04398     <span class="keyword">typename</span> type2_
<a name="l04399"></a>04399     &gt;
<a name="l04400"></a>04400 <span class="keyword">const</span> type1_ pack&lt;
<a name="l04401"></a>04401     constant&lt;type0_, value0_&gt;,
<a name="l04402"></a>04402     constant&lt;type1_, value1_&gt;,
<a name="l04403"></a>04403     type2_
<a name="l04404"></a>04404     &gt;::i1;
<a name="l04405"></a>04405 
<a name="l04406"></a>04406 <span class="comment">/***********************************************************************************************************/</span>
<a name="l04407"></a>04407 <span class="keyword">template</span>&lt;
<a name="l04408"></a>04408     <span class="keyword">typename</span> type0_,
<a name="l04409"></a>04409     <span class="keyword">typename</span> type1_,
<a name="l04410"></a>04410     <span class="keyword">typename</span> type2_, type2_ value2_
<a name="l04411"></a>04411     &gt;
<a name="l04412"></a>04412 <span class="keyword">class </span>pack&lt;
<a name="l04413"></a>04413     type0_,
<a name="l04414"></a>04414     type1_,
<a name="l04415"></a>04415     constant&lt;type2_, value2_&gt;
<a name="l04416"></a>04416     &gt;
<a name="l04417"></a>04417 {
<a name="l04418"></a>04418 <span class="keyword">public</span>:
<a name="l04419"></a>04419     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n = 3;
<a name="l04420"></a>04420 
<a name="l04421"></a>04421     <span class="keyword">typedef</span> type0_ type0;
<a name="l04422"></a>04422     <span class="keyword">typedef</span> type1_ type1;
<a name="l04423"></a>04423     <span class="keyword">typedef</span> type2_ type2;
<a name="l04424"></a>04424 
<a name="l04425"></a>04425     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const0 = <span class="keyword">false</span>;
<a name="l04426"></a>04426     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const1 = <span class="keyword">false</span>;
<a name="l04427"></a>04427     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const2 = <span class="keyword">true</span>;
<a name="l04428"></a>04428     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_all_const = <span class="keyword">false</span>;
<a name="l04429"></a>04429     type0 i0;
<a name="l04430"></a>04430     type1 i1;
<a name="l04431"></a>04431     <span class="keyword">static</span> <span class="keyword">const</span> type2 i2 = value2_;
<a name="l04432"></a>04432 
<a name="l04433"></a>04433     LITE_INLINE pack() 
<a name="l04434"></a>04434         : i0(),i1()    {}
<a name="l04435"></a>04435     
<a name="l04436"></a>04436     LITE_INLINE pack(<span class="keyword">const</span> type0&amp; a0)
<a name="l04437"></a>04437         : i0(a0) 
<a name="l04438"></a>04438      {}
<a name="l04439"></a>04439 
<a name="l04440"></a>04440     LITE_INLINE pack(
<a name="l04441"></a>04441         <span class="keyword">const</span> type0&amp; a0,
<a name="l04442"></a>04442         <span class="keyword">const</span> type1&amp; a1,
<a name="l04443"></a>04443         <span class="keyword">const</span> type2&amp; 
<a name="l04444"></a>04444         ) : i0(a0), i1(a1) {}
<a name="l04445"></a>04445 
<a name="l04446"></a>04446     <span class="keyword">template</span>&lt;
<a name="l04447"></a>04447         <span class="keyword">typename</span> other_type0_ ,
<a name="l04448"></a>04448         <span class="keyword">typename</span> other_type1_ ,
<a name="l04449"></a>04449         <span class="keyword">typename</span> other_type2_ 
<a name="l04450"></a>04450     &gt;
<a name="l04451"></a>04451     LITE_INLINE pack(<span class="keyword">const</span> pack&lt;
<a name="l04452"></a>04452         other_type0_,
<a name="l04453"></a>04453         other_type1_,
<a name="l04454"></a>04454         other_type2_
<a name="l04455"></a>04455         &gt;&amp; other) : i0(other.i0), i1(other.i1)    {}
<a name="l04456"></a>04456 
<a name="l04457"></a>04457     LITE_INLINE pack&amp; 
<a name="l04458"></a>04458     operator= (<span class="keyword">const</span> pack&amp; other) 
<a name="l04459"></a>04459     {
<a name="l04460"></a>04460         i0 = other.i0;
<a name="l04461"></a>04461         i1 = other.i1;
<a name="l04462"></a>04462         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l04463"></a>04463     }
<a name="l04464"></a>04464 
<a name="l04465"></a>04465     <span class="keyword">template</span>&lt;
<a name="l04466"></a>04466         <span class="keyword">typename</span> other_type0_ ,
<a name="l04467"></a>04467         <span class="keyword">typename</span> other_type1_ ,
<a name="l04468"></a>04468         <span class="keyword">typename</span> other_type2_ 
<a name="l04469"></a>04469     &gt;
<a name="l04470"></a>04470     LITE_INLINE pack&amp;  
<a name="l04471"></a>04471     operator=(<span class="keyword">const</span> pack&lt;
<a name="l04472"></a>04472         other_type0_,
<a name="l04473"></a>04473         other_type1_,
<a name="l04474"></a>04474         other_type2_
<a name="l04475"></a>04475         &gt;&amp; other) 
<a name="l04476"></a>04476     {
<a name="l04477"></a>04477         i0 = other.i0;
<a name="l04478"></a>04478         i1 = other.i1;
<a name="l04479"></a>04479         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l04480"></a>04480     }
<a name="l04481"></a>04481 
<a name="l04482"></a>04482     LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l04483"></a>04483         <span class="keyword">const</span> type0&amp; a0,
<a name="l04484"></a>04484         <span class="keyword">const</span> type1&amp; a1,
<a name="l04485"></a>04485         <span class="keyword">const</span> type2&amp; 
<a name="l04486"></a>04486         ) 
<a name="l04487"></a>04487     {
<a name="l04488"></a>04488             i0 = a0;
<a name="l04489"></a>04489             i1 = a1;
<a name="l04490"></a>04490     }
<a name="l04491"></a>04491 };
<a name="l04492"></a>04492 
<a name="l04493"></a>04493 
<a name="l04494"></a>04494 <span class="keyword">template</span>&lt;
<a name="l04495"></a>04495     <span class="keyword">typename</span> type0_,
<a name="l04496"></a>04496     <span class="keyword">typename</span> type1_,
<a name="l04497"></a>04497     <span class="keyword">typename</span> type2_, type2_ value2_
<a name="l04498"></a>04498     &gt;
<a name="l04499"></a>04499 <span class="keyword">const</span> type2_ pack&lt;
<a name="l04500"></a>04500     type0_,
<a name="l04501"></a>04501     type1_,
<a name="l04502"></a>04502     constant&lt;type2_, value2_&gt;
<a name="l04503"></a>04503     &gt;::i2;
<a name="l04504"></a>04504 
<a name="l04505"></a>04505 <span class="comment">/***********************************************************************************************************/</span>
<a name="l04506"></a>04506 <span class="keyword">template</span>&lt;
<a name="l04507"></a>04507     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l04508"></a>04508     <span class="keyword">typename</span> type1_,
<a name="l04509"></a>04509     <span class="keyword">typename</span> type2_, type2_ value2_
<a name="l04510"></a>04510     &gt;
<a name="l04511"></a>04511 <span class="keyword">class </span>pack&lt;
<a name="l04512"></a>04512     constant&lt;type0_, value0_&gt;,
<a name="l04513"></a>04513     type1_,
<a name="l04514"></a>04514     constant&lt;type2_, value2_&gt;
<a name="l04515"></a>04515     &gt;
<a name="l04516"></a>04516 {
<a name="l04517"></a>04517 <span class="keyword">public</span>:
<a name="l04518"></a>04518     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n = 3;
<a name="l04519"></a>04519 
<a name="l04520"></a>04520     <span class="keyword">typedef</span> type0_ type0;
<a name="l04521"></a>04521     <span class="keyword">typedef</span> type1_ type1;
<a name="l04522"></a>04522     <span class="keyword">typedef</span> type2_ type2;
<a name="l04523"></a>04523 
<a name="l04524"></a>04524     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const0 = <span class="keyword">true</span>;
<a name="l04525"></a>04525     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const1 = <span class="keyword">false</span>;
<a name="l04526"></a>04526     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const2 = <span class="keyword">true</span>;
<a name="l04527"></a>04527     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_all_const = <span class="keyword">false</span>;
<a name="l04528"></a>04528     <span class="keyword">static</span> <span class="keyword">const</span> type0 i0 = value0_;
<a name="l04529"></a>04529     type1 i1;
<a name="l04530"></a>04530     <span class="keyword">static</span> <span class="keyword">const</span> type2 i2 = value2_;
<a name="l04531"></a>04531 
<a name="l04532"></a>04532     LITE_INLINE pack() 
<a name="l04533"></a>04533         : i1()    {}
<a name="l04534"></a>04534     
<a name="l04535"></a>04535     LITE_INLINE pack(<span class="keyword">const</span> type0&amp; )
<a name="l04536"></a>04536      {}
<a name="l04537"></a>04537 
<a name="l04538"></a>04538     LITE_INLINE pack(
<a name="l04539"></a>04539         <span class="keyword">const</span> type0&amp; ,
<a name="l04540"></a>04540         <span class="keyword">const</span> type1&amp; a1,
<a name="l04541"></a>04541         <span class="keyword">const</span> type2&amp; 
<a name="l04542"></a>04542         ) : i1(a1) {}
<a name="l04543"></a>04543 
<a name="l04544"></a>04544     <span class="keyword">template</span>&lt;
<a name="l04545"></a>04545         <span class="keyword">typename</span> other_type0_ ,
<a name="l04546"></a>04546         <span class="keyword">typename</span> other_type1_ ,
<a name="l04547"></a>04547         <span class="keyword">typename</span> other_type2_ 
<a name="l04548"></a>04548     &gt;
<a name="l04549"></a>04549     LITE_INLINE pack(<span class="keyword">const</span> pack&lt;
<a name="l04550"></a>04550         other_type0_,
<a name="l04551"></a>04551         other_type1_,
<a name="l04552"></a>04552         other_type2_
<a name="l04553"></a>04553         &gt;&amp; other) : i1(other.i1)    {}
<a name="l04554"></a>04554 
<a name="l04555"></a>04555     LITE_INLINE pack&amp; 
<a name="l04556"></a>04556     operator= (<span class="keyword">const</span> pack&amp; other) 
<a name="l04557"></a>04557     {
<a name="l04558"></a>04558         i1 = other.i1;
<a name="l04559"></a>04559         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l04560"></a>04560     }
<a name="l04561"></a>04561 
<a name="l04562"></a>04562     <span class="keyword">template</span>&lt;
<a name="l04563"></a>04563         <span class="keyword">typename</span> other_type0_ ,
<a name="l04564"></a>04564         <span class="keyword">typename</span> other_type1_ ,
<a name="l04565"></a>04565         <span class="keyword">typename</span> other_type2_ 
<a name="l04566"></a>04566     &gt;
<a name="l04567"></a>04567     LITE_INLINE pack&amp;  
<a name="l04568"></a>04568     operator=(<span class="keyword">const</span> pack&lt;
<a name="l04569"></a>04569         other_type0_,
<a name="l04570"></a>04570         other_type1_,
<a name="l04571"></a>04571         other_type2_
<a name="l04572"></a>04572         &gt;&amp; other) 
<a name="l04573"></a>04573     {
<a name="l04574"></a>04574         i1 = other.i1;
<a name="l04575"></a>04575         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l04576"></a>04576     }
<a name="l04577"></a>04577 
<a name="l04578"></a>04578     LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l04579"></a>04579         <span class="keyword">const</span> type0&amp; ,
<a name="l04580"></a>04580         <span class="keyword">const</span> type1&amp; a1,
<a name="l04581"></a>04581         <span class="keyword">const</span> type2&amp; 
<a name="l04582"></a>04582         ) 
<a name="l04583"></a>04583     {
<a name="l04584"></a>04584             i1 = a1;
<a name="l04585"></a>04585     }
<a name="l04586"></a>04586 };
<a name="l04587"></a>04587 
<a name="l04588"></a>04588 
<a name="l04589"></a>04589 <span class="keyword">template</span>&lt;
<a name="l04590"></a>04590     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l04591"></a>04591     <span class="keyword">typename</span> type1_,
<a name="l04592"></a>04592     <span class="keyword">typename</span> type2_, type2_ value2_
<a name="l04593"></a>04593     &gt;
<a name="l04594"></a>04594 <span class="keyword">const</span> type0_ pack&lt;
<a name="l04595"></a>04595     constant&lt;type0_, value0_&gt;,
<a name="l04596"></a>04596     type1_,
<a name="l04597"></a>04597     constant&lt;type2_, value2_&gt;
<a name="l04598"></a>04598     &gt;::i0;
<a name="l04599"></a>04599 
<a name="l04600"></a>04600 <span class="keyword">template</span>&lt;
<a name="l04601"></a>04601     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l04602"></a>04602     <span class="keyword">typename</span> type1_,
<a name="l04603"></a>04603     <span class="keyword">typename</span> type2_, type2_ value2_
<a name="l04604"></a>04604     &gt;
<a name="l04605"></a>04605 <span class="keyword">const</span> type2_ pack&lt;
<a name="l04606"></a>04606     constant&lt;type0_, value0_&gt;,
<a name="l04607"></a>04607     type1_,
<a name="l04608"></a>04608     constant&lt;type2_, value2_&gt;
<a name="l04609"></a>04609     &gt;::i2;
<a name="l04610"></a>04610 
<a name="l04611"></a>04611 <span class="comment">/***********************************************************************************************************/</span>
<a name="l04612"></a>04612 <span class="keyword">template</span>&lt;
<a name="l04613"></a>04613     <span class="keyword">typename</span> type0_,
<a name="l04614"></a>04614     <span class="keyword">typename</span> type1_, type1_ value1_,
<a name="l04615"></a>04615     <span class="keyword">typename</span> type2_, type2_ value2_
<a name="l04616"></a>04616     &gt;
<a name="l04617"></a>04617 <span class="keyword">class </span>pack&lt;
<a name="l04618"></a>04618     type0_,
<a name="l04619"></a>04619     constant&lt;type1_, value1_&gt;,
<a name="l04620"></a>04620     constant&lt;type2_, value2_&gt;
<a name="l04621"></a>04621     &gt;
<a name="l04622"></a>04622 {
<a name="l04623"></a>04623 <span class="keyword">public</span>:
<a name="l04624"></a>04624     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n = 3;
<a name="l04625"></a>04625 
<a name="l04626"></a>04626     <span class="keyword">typedef</span> type0_ type0;
<a name="l04627"></a>04627     <span class="keyword">typedef</span> type1_ type1;
<a name="l04628"></a>04628     <span class="keyword">typedef</span> type2_ type2;
<a name="l04629"></a>04629 
<a name="l04630"></a>04630     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const0 = <span class="keyword">false</span>;
<a name="l04631"></a>04631     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const1 = <span class="keyword">true</span>;
<a name="l04632"></a>04632     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const2 = <span class="keyword">true</span>;
<a name="l04633"></a>04633     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_all_const = <span class="keyword">false</span>;
<a name="l04634"></a>04634     type0 i0;
<a name="l04635"></a>04635     <span class="keyword">static</span> <span class="keyword">const</span> type1 i1 = value1_;
<a name="l04636"></a>04636     <span class="keyword">static</span> <span class="keyword">const</span> type2 i2 = value2_;
<a name="l04637"></a>04637 
<a name="l04638"></a>04638     LITE_INLINE pack() 
<a name="l04639"></a>04639         : i0()    {}
<a name="l04640"></a>04640     
<a name="l04641"></a>04641     LITE_INLINE pack(<span class="keyword">const</span> type0&amp; a0)
<a name="l04642"></a>04642         : i0(a0) 
<a name="l04643"></a>04643      {}
<a name="l04644"></a>04644 
<a name="l04645"></a>04645     LITE_INLINE pack(
<a name="l04646"></a>04646         <span class="keyword">const</span> type0&amp; a0,
<a name="l04647"></a>04647         <span class="keyword">const</span> type1&amp; ,
<a name="l04648"></a>04648         <span class="keyword">const</span> type2&amp; 
<a name="l04649"></a>04649         ) : i0(a0) {}
<a name="l04650"></a>04650 
<a name="l04651"></a>04651     <span class="keyword">template</span>&lt;
<a name="l04652"></a>04652         <span class="keyword">typename</span> other_type0_ ,
<a name="l04653"></a>04653         <span class="keyword">typename</span> other_type1_ ,
<a name="l04654"></a>04654         <span class="keyword">typename</span> other_type2_ 
<a name="l04655"></a>04655     &gt;
<a name="l04656"></a>04656     LITE_INLINE pack(<span class="keyword">const</span> pack&lt;
<a name="l04657"></a>04657         other_type0_,
<a name="l04658"></a>04658         other_type1_,
<a name="l04659"></a>04659         other_type2_
<a name="l04660"></a>04660         &gt;&amp; other) : i0(other.i0)    {}
<a name="l04661"></a>04661 
<a name="l04662"></a>04662     LITE_INLINE pack&amp; 
<a name="l04663"></a>04663     operator= (<span class="keyword">const</span> pack&amp; other) 
<a name="l04664"></a>04664     {
<a name="l04665"></a>04665         i0 = other.i0;
<a name="l04666"></a>04666         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l04667"></a>04667     }
<a name="l04668"></a>04668 
<a name="l04669"></a>04669     <span class="keyword">template</span>&lt;
<a name="l04670"></a>04670         <span class="keyword">typename</span> other_type0_ ,
<a name="l04671"></a>04671         <span class="keyword">typename</span> other_type1_ ,
<a name="l04672"></a>04672         <span class="keyword">typename</span> other_type2_ 
<a name="l04673"></a>04673     &gt;
<a name="l04674"></a>04674     LITE_INLINE pack&amp;  
<a name="l04675"></a>04675     operator=(<span class="keyword">const</span> pack&lt;
<a name="l04676"></a>04676         other_type0_,
<a name="l04677"></a>04677         other_type1_,
<a name="l04678"></a>04678         other_type2_
<a name="l04679"></a>04679         &gt;&amp; other) 
<a name="l04680"></a>04680     {
<a name="l04681"></a>04681         i0 = other.i0;
<a name="l04682"></a>04682         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l04683"></a>04683     }
<a name="l04684"></a>04684 
<a name="l04685"></a>04685     LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l04686"></a>04686         <span class="keyword">const</span> type0&amp; a0,
<a name="l04687"></a>04687         <span class="keyword">const</span> type1&amp; ,
<a name="l04688"></a>04688         <span class="keyword">const</span> type2&amp; 
<a name="l04689"></a>04689         ) 
<a name="l04690"></a>04690     {
<a name="l04691"></a>04691             i0 = a0;
<a name="l04692"></a>04692     }
<a name="l04693"></a>04693 };
<a name="l04694"></a>04694 
<a name="l04695"></a>04695 
<a name="l04696"></a>04696 <span class="keyword">template</span>&lt;
<a name="l04697"></a>04697     <span class="keyword">typename</span> type0_,
<a name="l04698"></a>04698     <span class="keyword">typename</span> type1_, type1_ value1_,
<a name="l04699"></a>04699     <span class="keyword">typename</span> type2_, type2_ value2_
<a name="l04700"></a>04700     &gt;
<a name="l04701"></a>04701 <span class="keyword">const</span> type1_ pack&lt;
<a name="l04702"></a>04702     type0_,
<a name="l04703"></a>04703     constant&lt;type1_, value1_&gt;,
<a name="l04704"></a>04704     constant&lt;type2_, value2_&gt;
<a name="l04705"></a>04705     &gt;::i1;
<a name="l04706"></a>04706 
<a name="l04707"></a>04707 <span class="keyword">template</span>&lt;
<a name="l04708"></a>04708     <span class="keyword">typename</span> type0_,
<a name="l04709"></a>04709     <span class="keyword">typename</span> type1_, type1_ value1_,
<a name="l04710"></a>04710     <span class="keyword">typename</span> type2_, type2_ value2_
<a name="l04711"></a>04711     &gt;
<a name="l04712"></a>04712 <span class="keyword">const</span> type2_ pack&lt;
<a name="l04713"></a>04713     type0_,
<a name="l04714"></a>04714     constant&lt;type1_, value1_&gt;,
<a name="l04715"></a>04715     constant&lt;type2_, value2_&gt;
<a name="l04716"></a>04716     &gt;::i2;
<a name="l04717"></a>04717 
<a name="l04718"></a>04718 <span class="comment">/***********************************************************************************************************/</span>
<a name="l04719"></a>04719 <span class="keyword">template</span>&lt;
<a name="l04720"></a>04720     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l04721"></a>04721     <span class="keyword">typename</span> type1_, type1_ value1_,
<a name="l04722"></a>04722     <span class="keyword">typename</span> type2_, type2_ value2_
<a name="l04723"></a>04723     &gt;
<a name="l04724"></a>04724 <span class="keyword">class </span>pack&lt;
<a name="l04725"></a>04725     constant&lt;type0_, value0_&gt;,
<a name="l04726"></a>04726     constant&lt;type1_, value1_&gt;,
<a name="l04727"></a>04727     constant&lt;type2_, value2_&gt;
<a name="l04728"></a>04728     &gt;
<a name="l04729"></a>04729 {
<a name="l04730"></a>04730 <span class="keyword">public</span>:
<a name="l04731"></a>04731     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n = 3;
<a name="l04732"></a>04732 
<a name="l04733"></a>04733     <span class="keyword">typedef</span> type0_ type0;
<a name="l04734"></a>04734     <span class="keyword">typedef</span> type1_ type1;
<a name="l04735"></a>04735     <span class="keyword">typedef</span> type2_ type2;
<a name="l04736"></a>04736 
<a name="l04737"></a>04737     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const0 = <span class="keyword">true</span>;
<a name="l04738"></a>04738     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const1 = <span class="keyword">true</span>;
<a name="l04739"></a>04739     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const2 = <span class="keyword">true</span>;
<a name="l04740"></a>04740     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_all_const = <span class="keyword">true</span>;
<a name="l04741"></a>04741     <span class="keyword">static</span> <span class="keyword">const</span> type0 i0 = value0_;
<a name="l04742"></a>04742     <span class="keyword">static</span> <span class="keyword">const</span> type1 i1 = value1_;
<a name="l04743"></a>04743     <span class="keyword">static</span> <span class="keyword">const</span> type2 i2 = value2_;
<a name="l04744"></a>04744 
<a name="l04745"></a>04745     LITE_INLINE pack() 
<a name="l04746"></a>04746              {}
<a name="l04747"></a>04747     
<a name="l04748"></a>04748     LITE_INLINE pack(<span class="keyword">const</span> type0&amp; )
<a name="l04749"></a>04749      {}
<a name="l04750"></a>04750 
<a name="l04751"></a>04751     LITE_INLINE pack(
<a name="l04752"></a>04752         <span class="keyword">const</span> type0&amp; ,
<a name="l04753"></a>04753         <span class="keyword">const</span> type1&amp; ,
<a name="l04754"></a>04754         <span class="keyword">const</span> type2&amp; 
<a name="l04755"></a>04755         )  {}
<a name="l04756"></a>04756 
<a name="l04757"></a>04757     <span class="keyword">template</span>&lt;
<a name="l04758"></a>04758         <span class="keyword">typename</span> other_type0_ ,
<a name="l04759"></a>04759         <span class="keyword">typename</span> other_type1_ ,
<a name="l04760"></a>04760         <span class="keyword">typename</span> other_type2_ 
<a name="l04761"></a>04761     &gt;
<a name="l04762"></a>04762     LITE_INLINE pack(<span class="keyword">const</span> pack&lt;
<a name="l04763"></a>04763         other_type0_,
<a name="l04764"></a>04764         other_type1_,
<a name="l04765"></a>04765         other_type2_
<a name="l04766"></a>04766         &gt;&amp; )     {}
<a name="l04767"></a>04767 
<a name="l04768"></a>04768     LITE_INLINE pack&amp; 
<a name="l04769"></a>04769     operator= (<span class="keyword">const</span> pack&amp; ) 
<a name="l04770"></a>04770     {
<a name="l04771"></a>04771         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l04772"></a>04772     }
<a name="l04773"></a>04773 
<a name="l04774"></a>04774     <span class="keyword">template</span>&lt;
<a name="l04775"></a>04775         <span class="keyword">typename</span> other_type0_ ,
<a name="l04776"></a>04776         <span class="keyword">typename</span> other_type1_ ,
<a name="l04777"></a>04777         <span class="keyword">typename</span> other_type2_ 
<a name="l04778"></a>04778     &gt;
<a name="l04779"></a>04779     LITE_INLINE pack&amp;  
<a name="l04780"></a>04780     operator=(<span class="keyword">const</span> pack&lt;
<a name="l04781"></a>04781         other_type0_,
<a name="l04782"></a>04782         other_type1_,
<a name="l04783"></a>04783         other_type2_
<a name="l04784"></a>04784         &gt;&amp; ) 
<a name="l04785"></a>04785     {
<a name="l04786"></a>04786         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l04787"></a>04787     }
<a name="l04788"></a>04788 
<a name="l04789"></a>04789     LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l04790"></a>04790         <span class="keyword">const</span> type0&amp; ,
<a name="l04791"></a>04791         <span class="keyword">const</span> type1&amp; ,
<a name="l04792"></a>04792         <span class="keyword">const</span> type2&amp; 
<a name="l04793"></a>04793         ) 
<a name="l04794"></a>04794     {
<a name="l04795"></a>04795     }
<a name="l04796"></a>04796 };
<a name="l04797"></a>04797 
<a name="l04798"></a>04798 
<a name="l04799"></a>04799 <span class="keyword">template</span>&lt;
<a name="l04800"></a>04800     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l04801"></a>04801     <span class="keyword">typename</span> type1_, type1_ value1_,
<a name="l04802"></a>04802     <span class="keyword">typename</span> type2_, type2_ value2_
<a name="l04803"></a>04803     &gt;
<a name="l04804"></a>04804 <span class="keyword">const</span> type0_ pack&lt;
<a name="l04805"></a>04805     constant&lt;type0_, value0_&gt;,
<a name="l04806"></a>04806     constant&lt;type1_, value1_&gt;,
<a name="l04807"></a>04807     constant&lt;type2_, value2_&gt;
<a name="l04808"></a>04808     &gt;::i0;
<a name="l04809"></a>04809 
<a name="l04810"></a>04810 <span class="keyword">template</span>&lt;
<a name="l04811"></a>04811     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l04812"></a>04812     <span class="keyword">typename</span> type1_, type1_ value1_,
<a name="l04813"></a>04813     <span class="keyword">typename</span> type2_, type2_ value2_
<a name="l04814"></a>04814     &gt;
<a name="l04815"></a>04815 <span class="keyword">const</span> type1_ pack&lt;
<a name="l04816"></a>04816     constant&lt;type0_, value0_&gt;,
<a name="l04817"></a>04817     constant&lt;type1_, value1_&gt;,
<a name="l04818"></a>04818     constant&lt;type2_, value2_&gt;
<a name="l04819"></a>04819     &gt;::i1;
<a name="l04820"></a>04820 
<a name="l04821"></a>04821 <span class="keyword">template</span>&lt;
<a name="l04822"></a>04822     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l04823"></a>04823     <span class="keyword">typename</span> type1_, type1_ value1_,
<a name="l04824"></a>04824     <span class="keyword">typename</span> type2_, type2_ value2_
<a name="l04825"></a>04825     &gt;
<a name="l04826"></a>04826 <span class="keyword">const</span> type2_ pack&lt;
<a name="l04827"></a>04827     constant&lt;type0_, value0_&gt;,
<a name="l04828"></a>04828     constant&lt;type1_, value1_&gt;,
<a name="l04829"></a>04829     constant&lt;type2_, value2_&gt;
<a name="l04830"></a>04830     &gt;::i2;
<a name="l04831"></a>04831 
<a name="l04832"></a>04832 <span class="comment">/***********************************************************************************************************/</span>
<a name="l04833"></a>04833 <span class="keyword">template</span>&lt;
<a name="l04834"></a>04834     <span class="keyword">typename</span> type0_,
<a name="l04835"></a>04835     <span class="keyword">typename</span> type1_
<a name="l04836"></a>04836     &gt;
<a name="l04837"></a>04837 <span class="keyword">class </span>pack&lt;
<a name="l04838"></a>04838     type0_,
<a name="l04839"></a>04839     type1_
<a name="l04840"></a>04840     &gt;
<a name="l04841"></a>04841 {
<a name="l04842"></a>04842 <span class="keyword">public</span>:
<a name="l04843"></a>04843     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n = 2;
<a name="l04844"></a>04844 
<a name="l04845"></a>04845     <span class="keyword">typedef</span> type0_ type0;
<a name="l04846"></a>04846     <span class="keyword">typedef</span> type1_ type1;
<a name="l04847"></a>04847 
<a name="l04848"></a>04848     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const0 = <span class="keyword">false</span>;
<a name="l04849"></a>04849     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const1 = <span class="keyword">false</span>;
<a name="l04850"></a>04850     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_all_const = <span class="keyword">false</span>;
<a name="l04851"></a>04851     type0 i0;
<a name="l04852"></a>04852     type1 i1;
<a name="l04853"></a>04853 
<a name="l04854"></a>04854     LITE_INLINE pack() 
<a name="l04855"></a>04855         : i0(),i1()    {}
<a name="l04856"></a>04856     
<a name="l04857"></a>04857     LITE_INLINE pack(<span class="keyword">const</span> type0&amp; a0)
<a name="l04858"></a>04858         : i0(a0) 
<a name="l04859"></a>04859      {}
<a name="l04860"></a>04860 
<a name="l04861"></a>04861     LITE_INLINE pack(
<a name="l04862"></a>04862         <span class="keyword">const</span> type0&amp; a0,
<a name="l04863"></a>04863         <span class="keyword">const</span> type1&amp; a1
<a name="l04864"></a>04864         ) : i0(a0), i1(a1) {}
<a name="l04865"></a>04865 
<a name="l04866"></a>04866     <span class="keyword">template</span>&lt;
<a name="l04867"></a>04867         <span class="keyword">typename</span> other_type0_ ,
<a name="l04868"></a>04868         <span class="keyword">typename</span> other_type1_ 
<a name="l04869"></a>04869     &gt;
<a name="l04870"></a>04870     LITE_INLINE pack(<span class="keyword">const</span> pack&lt;
<a name="l04871"></a>04871         other_type0_,
<a name="l04872"></a>04872         other_type1_
<a name="l04873"></a>04873         &gt;&amp; other) : i0(other.i0), i1(other.i1)    {}
<a name="l04874"></a>04874 
<a name="l04875"></a>04875     LITE_INLINE pack&amp; 
<a name="l04876"></a>04876     operator= (<span class="keyword">const</span> pack&amp; other) 
<a name="l04877"></a>04877     {
<a name="l04878"></a>04878         i0 = other.i0;
<a name="l04879"></a>04879         i1 = other.i1;
<a name="l04880"></a>04880         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l04881"></a>04881     }
<a name="l04882"></a>04882 
<a name="l04883"></a>04883     <span class="keyword">template</span>&lt;
<a name="l04884"></a>04884         <span class="keyword">typename</span> other_type0_ ,
<a name="l04885"></a>04885         <span class="keyword">typename</span> other_type1_ 
<a name="l04886"></a>04886     &gt;
<a name="l04887"></a>04887     LITE_INLINE pack&amp;  
<a name="l04888"></a>04888     operator=(<span class="keyword">const</span> pack&lt;
<a name="l04889"></a>04889         other_type0_,
<a name="l04890"></a>04890         other_type1_
<a name="l04891"></a>04891         &gt;&amp; other) 
<a name="l04892"></a>04892     {
<a name="l04893"></a>04893         i0 = other.i0;
<a name="l04894"></a>04894         i1 = other.i1;
<a name="l04895"></a>04895         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l04896"></a>04896     }
<a name="l04897"></a>04897 
<a name="l04898"></a>04898     LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l04899"></a>04899         <span class="keyword">const</span> type0&amp; a0,
<a name="l04900"></a>04900         <span class="keyword">const</span> type1&amp; a1
<a name="l04901"></a>04901         ) 
<a name="l04902"></a>04902     {
<a name="l04903"></a>04903             i0 = a0;
<a name="l04904"></a>04904             i1 = a1;
<a name="l04905"></a>04905     }
<a name="l04906"></a>04906 };
<a name="l04907"></a>04907 
<a name="l04908"></a>04908 
<a name="l04909"></a>04909 <span class="comment">/***********************************************************************************************************/</span>
<a name="l04910"></a>04910 <span class="keyword">template</span>&lt;
<a name="l04911"></a>04911     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l04912"></a>04912     <span class="keyword">typename</span> type1_
<a name="l04913"></a>04913     &gt;
<a name="l04914"></a>04914 <span class="keyword">class </span>pack&lt;
<a name="l04915"></a>04915     constant&lt;type0_, value0_&gt;,
<a name="l04916"></a>04916     type1_
<a name="l04917"></a>04917     &gt;
<a name="l04918"></a>04918 {
<a name="l04919"></a>04919 <span class="keyword">public</span>:
<a name="l04920"></a>04920     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n = 2;
<a name="l04921"></a>04921 
<a name="l04922"></a>04922     <span class="keyword">typedef</span> type0_ type0;
<a name="l04923"></a>04923     <span class="keyword">typedef</span> type1_ type1;
<a name="l04924"></a>04924 
<a name="l04925"></a>04925     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const0 = <span class="keyword">true</span>;
<a name="l04926"></a>04926     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const1 = <span class="keyword">false</span>;
<a name="l04927"></a>04927     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_all_const = <span class="keyword">false</span>;
<a name="l04928"></a>04928     <span class="keyword">static</span> <span class="keyword">const</span> type0 i0 = value0_;
<a name="l04929"></a>04929     type1 i1;
<a name="l04930"></a>04930 
<a name="l04931"></a>04931     LITE_INLINE pack() 
<a name="l04932"></a>04932         : i1()    {}
<a name="l04933"></a>04933     
<a name="l04934"></a>04934     LITE_INLINE pack(<span class="keyword">const</span> type0&amp; )
<a name="l04935"></a>04935      {}
<a name="l04936"></a>04936 
<a name="l04937"></a>04937     LITE_INLINE pack(
<a name="l04938"></a>04938         <span class="keyword">const</span> type0&amp; ,
<a name="l04939"></a>04939         <span class="keyword">const</span> type1&amp; a1
<a name="l04940"></a>04940         ) : i1(a1) {}
<a name="l04941"></a>04941 
<a name="l04942"></a>04942     <span class="keyword">template</span>&lt;
<a name="l04943"></a>04943         <span class="keyword">typename</span> other_type0_ ,
<a name="l04944"></a>04944         <span class="keyword">typename</span> other_type1_ 
<a name="l04945"></a>04945     &gt;
<a name="l04946"></a>04946     LITE_INLINE pack(<span class="keyword">const</span> pack&lt;
<a name="l04947"></a>04947         other_type0_,
<a name="l04948"></a>04948         other_type1_
<a name="l04949"></a>04949         &gt;&amp; other) : i1(other.i1)    {}
<a name="l04950"></a>04950 
<a name="l04951"></a>04951     LITE_INLINE pack&amp; 
<a name="l04952"></a>04952     operator= (<span class="keyword">const</span> pack&amp; other) 
<a name="l04953"></a>04953     {
<a name="l04954"></a>04954         i1 = other.i1;
<a name="l04955"></a>04955         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l04956"></a>04956     }
<a name="l04957"></a>04957 
<a name="l04958"></a>04958     <span class="keyword">template</span>&lt;
<a name="l04959"></a>04959         <span class="keyword">typename</span> other_type0_ ,
<a name="l04960"></a>04960         <span class="keyword">typename</span> other_type1_ 
<a name="l04961"></a>04961     &gt;
<a name="l04962"></a>04962     LITE_INLINE pack&amp;  
<a name="l04963"></a>04963     operator=(<span class="keyword">const</span> pack&lt;
<a name="l04964"></a>04964         other_type0_,
<a name="l04965"></a>04965         other_type1_
<a name="l04966"></a>04966         &gt;&amp; other) 
<a name="l04967"></a>04967     {
<a name="l04968"></a>04968         i1 = other.i1;
<a name="l04969"></a>04969         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l04970"></a>04970     }
<a name="l04971"></a>04971 
<a name="l04972"></a>04972     LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l04973"></a>04973         <span class="keyword">const</span> type0&amp; ,
<a name="l04974"></a>04974         <span class="keyword">const</span> type1&amp; a1
<a name="l04975"></a>04975         ) 
<a name="l04976"></a>04976     {
<a name="l04977"></a>04977             i1 = a1;
<a name="l04978"></a>04978     }
<a name="l04979"></a>04979 };
<a name="l04980"></a>04980 
<a name="l04981"></a>04981 
<a name="l04982"></a>04982 <span class="keyword">template</span>&lt;
<a name="l04983"></a>04983     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l04984"></a>04984     <span class="keyword">typename</span> type1_
<a name="l04985"></a>04985     &gt;
<a name="l04986"></a>04986 <span class="keyword">const</span> type0_ pack&lt;
<a name="l04987"></a>04987     constant&lt;type0_, value0_&gt;,
<a name="l04988"></a>04988     type1_
<a name="l04989"></a>04989     &gt;::i0;
<a name="l04990"></a>04990 
<a name="l04991"></a>04991 <span class="comment">/***********************************************************************************************************/</span>
<a name="l04992"></a>04992 <span class="keyword">template</span>&lt;
<a name="l04993"></a>04993     <span class="keyword">typename</span> type0_,
<a name="l04994"></a>04994     <span class="keyword">typename</span> type1_, type1_ value1_
<a name="l04995"></a>04995     &gt;
<a name="l04996"></a>04996 <span class="keyword">class </span>pack&lt;
<a name="l04997"></a>04997     type0_,
<a name="l04998"></a>04998     constant&lt;type1_, value1_&gt;
<a name="l04999"></a>04999     &gt;
<a name="l05000"></a>05000 {
<a name="l05001"></a>05001 <span class="keyword">public</span>:
<a name="l05002"></a>05002     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n = 2;
<a name="l05003"></a>05003 
<a name="l05004"></a>05004     <span class="keyword">typedef</span> type0_ type0;
<a name="l05005"></a>05005     <span class="keyword">typedef</span> type1_ type1;
<a name="l05006"></a>05006 
<a name="l05007"></a>05007     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const0 = <span class="keyword">false</span>;
<a name="l05008"></a>05008     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const1 = <span class="keyword">true</span>;
<a name="l05009"></a>05009     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_all_const = <span class="keyword">false</span>;
<a name="l05010"></a>05010     type0 i0;
<a name="l05011"></a>05011     <span class="keyword">static</span> <span class="keyword">const</span> type1 i1 = value1_;
<a name="l05012"></a>05012 
<a name="l05013"></a>05013     LITE_INLINE pack() 
<a name="l05014"></a>05014         : i0()    {}
<a name="l05015"></a>05015     
<a name="l05016"></a>05016     LITE_INLINE pack(<span class="keyword">const</span> type0&amp; a0)
<a name="l05017"></a>05017         : i0(a0) 
<a name="l05018"></a>05018      {}
<a name="l05019"></a>05019 
<a name="l05020"></a>05020     LITE_INLINE pack(
<a name="l05021"></a>05021         <span class="keyword">const</span> type0&amp; a0,
<a name="l05022"></a>05022         <span class="keyword">const</span> type1&amp; 
<a name="l05023"></a>05023         ) : i0(a0) {}
<a name="l05024"></a>05024 
<a name="l05025"></a>05025     <span class="keyword">template</span>&lt;
<a name="l05026"></a>05026         <span class="keyword">typename</span> other_type0_ ,
<a name="l05027"></a>05027         <span class="keyword">typename</span> other_type1_ 
<a name="l05028"></a>05028     &gt;
<a name="l05029"></a>05029     LITE_INLINE pack(<span class="keyword">const</span> pack&lt;
<a name="l05030"></a>05030         other_type0_,
<a name="l05031"></a>05031         other_type1_
<a name="l05032"></a>05032         &gt;&amp; other) : i0(other.i0)    {}
<a name="l05033"></a>05033 
<a name="l05034"></a>05034     LITE_INLINE pack&amp; 
<a name="l05035"></a>05035     operator= (<span class="keyword">const</span> pack&amp; other) 
<a name="l05036"></a>05036     {
<a name="l05037"></a>05037         i0 = other.i0;
<a name="l05038"></a>05038         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l05039"></a>05039     }
<a name="l05040"></a>05040 
<a name="l05041"></a>05041     <span class="keyword">template</span>&lt;
<a name="l05042"></a>05042         <span class="keyword">typename</span> other_type0_ ,
<a name="l05043"></a>05043         <span class="keyword">typename</span> other_type1_ 
<a name="l05044"></a>05044     &gt;
<a name="l05045"></a>05045     LITE_INLINE pack&amp;  
<a name="l05046"></a>05046     operator=(<span class="keyword">const</span> pack&lt;
<a name="l05047"></a>05047         other_type0_,
<a name="l05048"></a>05048         other_type1_
<a name="l05049"></a>05049         &gt;&amp; other) 
<a name="l05050"></a>05050     {
<a name="l05051"></a>05051         i0 = other.i0;
<a name="l05052"></a>05052         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l05053"></a>05053     }
<a name="l05054"></a>05054 
<a name="l05055"></a>05055     LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l05056"></a>05056         <span class="keyword">const</span> type0&amp; a0,
<a name="l05057"></a>05057         <span class="keyword">const</span> type1&amp; 
<a name="l05058"></a>05058         ) 
<a name="l05059"></a>05059     {
<a name="l05060"></a>05060             i0 = a0;
<a name="l05061"></a>05061     }
<a name="l05062"></a>05062 };
<a name="l05063"></a>05063 
<a name="l05064"></a>05064 
<a name="l05065"></a>05065 <span class="keyword">template</span>&lt;
<a name="l05066"></a>05066     <span class="keyword">typename</span> type0_,
<a name="l05067"></a>05067     <span class="keyword">typename</span> type1_, type1_ value1_
<a name="l05068"></a>05068     &gt;
<a name="l05069"></a>05069 <span class="keyword">const</span> type1_ pack&lt;
<a name="l05070"></a>05070     type0_,
<a name="l05071"></a>05071     constant&lt;type1_, value1_&gt;
<a name="l05072"></a>05072     &gt;::i1;
<a name="l05073"></a>05073 
<a name="l05074"></a>05074 <span class="comment">/***********************************************************************************************************/</span>
<a name="l05075"></a>05075 <span class="keyword">template</span>&lt;
<a name="l05076"></a>05076     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l05077"></a>05077     <span class="keyword">typename</span> type1_, type1_ value1_
<a name="l05078"></a>05078     &gt;
<a name="l05079"></a>05079 <span class="keyword">class </span>pack&lt;
<a name="l05080"></a>05080     constant&lt;type0_, value0_&gt;,
<a name="l05081"></a>05081     constant&lt;type1_, value1_&gt;
<a name="l05082"></a>05082     &gt;
<a name="l05083"></a>05083 {
<a name="l05084"></a>05084 <span class="keyword">public</span>:
<a name="l05085"></a>05085     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n = 2;
<a name="l05086"></a>05086 
<a name="l05087"></a>05087     <span class="keyword">typedef</span> type0_ type0;
<a name="l05088"></a>05088     <span class="keyword">typedef</span> type1_ type1;
<a name="l05089"></a>05089 
<a name="l05090"></a>05090     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const0 = <span class="keyword">true</span>;
<a name="l05091"></a>05091     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const1 = <span class="keyword">true</span>;
<a name="l05092"></a>05092     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_all_const = <span class="keyword">true</span>;
<a name="l05093"></a>05093     <span class="keyword">static</span> <span class="keyword">const</span> type0 i0 = value0_;
<a name="l05094"></a>05094     <span class="keyword">static</span> <span class="keyword">const</span> type1 i1 = value1_;
<a name="l05095"></a>05095 
<a name="l05096"></a>05096     LITE_INLINE pack() 
<a name="l05097"></a>05097              {}
<a name="l05098"></a>05098     
<a name="l05099"></a>05099     LITE_INLINE pack(<span class="keyword">const</span> type0&amp; )
<a name="l05100"></a>05100      {}
<a name="l05101"></a>05101 
<a name="l05102"></a>05102     LITE_INLINE pack(
<a name="l05103"></a>05103         <span class="keyword">const</span> type0&amp; ,
<a name="l05104"></a>05104         <span class="keyword">const</span> type1&amp; 
<a name="l05105"></a>05105         )  {}
<a name="l05106"></a>05106 
<a name="l05107"></a>05107     <span class="keyword">template</span>&lt;
<a name="l05108"></a>05108         <span class="keyword">typename</span> other_type0_ ,
<a name="l05109"></a>05109         <span class="keyword">typename</span> other_type1_ 
<a name="l05110"></a>05110     &gt;
<a name="l05111"></a>05111     LITE_INLINE pack(<span class="keyword">const</span> pack&lt;
<a name="l05112"></a>05112         other_type0_,
<a name="l05113"></a>05113         other_type1_
<a name="l05114"></a>05114         &gt;&amp; )     {}
<a name="l05115"></a>05115 
<a name="l05116"></a>05116     LITE_INLINE pack&amp; 
<a name="l05117"></a>05117     operator= (<span class="keyword">const</span> pack&amp; ) 
<a name="l05118"></a>05118     {
<a name="l05119"></a>05119         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l05120"></a>05120     }
<a name="l05121"></a>05121 
<a name="l05122"></a>05122     <span class="keyword">template</span>&lt;
<a name="l05123"></a>05123         <span class="keyword">typename</span> other_type0_ ,
<a name="l05124"></a>05124         <span class="keyword">typename</span> other_type1_ 
<a name="l05125"></a>05125     &gt;
<a name="l05126"></a>05126     LITE_INLINE pack&amp;  
<a name="l05127"></a>05127     operator=(<span class="keyword">const</span> pack&lt;
<a name="l05128"></a>05128         other_type0_,
<a name="l05129"></a>05129         other_type1_
<a name="l05130"></a>05130         &gt;&amp; ) 
<a name="l05131"></a>05131     {
<a name="l05132"></a>05132         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l05133"></a>05133     }
<a name="l05134"></a>05134 
<a name="l05135"></a>05135     LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l05136"></a>05136         <span class="keyword">const</span> type0&amp; ,
<a name="l05137"></a>05137         <span class="keyword">const</span> type1&amp; 
<a name="l05138"></a>05138         ) 
<a name="l05139"></a>05139     {
<a name="l05140"></a>05140     }
<a name="l05141"></a>05141 };
<a name="l05142"></a>05142 
<a name="l05143"></a>05143 
<a name="l05144"></a>05144 <span class="keyword">template</span>&lt;
<a name="l05145"></a>05145     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l05146"></a>05146     <span class="keyword">typename</span> type1_, type1_ value1_
<a name="l05147"></a>05147     &gt;
<a name="l05148"></a>05148 <span class="keyword">const</span> type0_ pack&lt;
<a name="l05149"></a>05149     constant&lt;type0_, value0_&gt;,
<a name="l05150"></a>05150     constant&lt;type1_, value1_&gt;
<a name="l05151"></a>05151     &gt;::i0;
<a name="l05152"></a>05152 
<a name="l05153"></a>05153 <span class="keyword">template</span>&lt;
<a name="l05154"></a>05154     <span class="keyword">typename</span> type0_, type0_ value0_,
<a name="l05155"></a>05155     <span class="keyword">typename</span> type1_, type1_ value1_
<a name="l05156"></a>05156     &gt;
<a name="l05157"></a>05157 <span class="keyword">const</span> type1_ pack&lt;
<a name="l05158"></a>05158     constant&lt;type0_, value0_&gt;,
<a name="l05159"></a>05159     constant&lt;type1_, value1_&gt;
<a name="l05160"></a>05160     &gt;::i1;
<a name="l05161"></a>05161 
<a name="l05162"></a>05162 <span class="comment">/***********************************************************************************************************/</span>
<a name="l05163"></a>05163 <span class="keyword">template</span>&lt;
<a name="l05164"></a>05164     <span class="keyword">typename</span> type0_
<a name="l05165"></a>05165     &gt;
<a name="l05166"></a>05166 <span class="keyword">class </span>pack&lt;
<a name="l05167"></a>05167     type0_
<a name="l05168"></a>05168     &gt;
<a name="l05169"></a>05169 {
<a name="l05170"></a>05170 <span class="keyword">public</span>:
<a name="l05171"></a>05171     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n = 1;
<a name="l05172"></a>05172 
<a name="l05173"></a>05173     <span class="keyword">typedef</span> type0_ type0;
<a name="l05174"></a>05174 
<a name="l05175"></a>05175     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const0 = <span class="keyword">false</span>;
<a name="l05176"></a>05176     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_all_const = <span class="keyword">false</span>;
<a name="l05177"></a>05177     type0 i0;
<a name="l05178"></a>05178 
<a name="l05179"></a>05179     LITE_INLINE pack() 
<a name="l05180"></a>05180         : i0()    {}
<a name="l05181"></a>05181     
<a name="l05182"></a>05182 
<a name="l05183"></a>05183     LITE_INLINE pack(
<a name="l05184"></a>05184         <span class="keyword">const</span> type0&amp; a0
<a name="l05185"></a>05185         ) : i0(a0) {}
<a name="l05186"></a>05186 
<a name="l05187"></a>05187     <span class="keyword">template</span>&lt;
<a name="l05188"></a>05188         <span class="keyword">typename</span> other_type0_ 
<a name="l05189"></a>05189     &gt;
<a name="l05190"></a>05190     LITE_INLINE pack(<span class="keyword">const</span> pack&lt;
<a name="l05191"></a>05191         other_type0_
<a name="l05192"></a>05192         &gt;&amp; other) : i0(other.i0)    {}
<a name="l05193"></a>05193 
<a name="l05194"></a>05194     LITE_INLINE pack&amp; 
<a name="l05195"></a>05195     operator= (<span class="keyword">const</span> pack&amp; other) 
<a name="l05196"></a>05196     {
<a name="l05197"></a>05197         i0 = other.i0;
<a name="l05198"></a>05198         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l05199"></a>05199     }
<a name="l05200"></a>05200 
<a name="l05201"></a>05201     <span class="keyword">template</span>&lt;
<a name="l05202"></a>05202         <span class="keyword">typename</span> other_type0_ 
<a name="l05203"></a>05203     &gt;
<a name="l05204"></a>05204     LITE_INLINE pack&amp;  
<a name="l05205"></a>05205     operator=(<span class="keyword">const</span> pack&lt;
<a name="l05206"></a>05206         other_type0_
<a name="l05207"></a>05207         &gt;&amp; other) 
<a name="l05208"></a>05208     {
<a name="l05209"></a>05209         i0 = other.i0;
<a name="l05210"></a>05210         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l05211"></a>05211     }
<a name="l05212"></a>05212 
<a name="l05213"></a>05213     LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l05214"></a>05214         <span class="keyword">const</span> type0&amp; a0
<a name="l05215"></a>05215         ) 
<a name="l05216"></a>05216     {
<a name="l05217"></a>05217             i0 = a0;
<a name="l05218"></a>05218     }
<a name="l05219"></a>05219 };
<a name="l05220"></a>05220 
<a name="l05221"></a>05221 
<a name="l05222"></a>05222 <span class="comment">/***********************************************************************************************************/</span>
<a name="l05223"></a>05223 <span class="keyword">template</span>&lt;
<a name="l05224"></a>05224     <span class="keyword">typename</span> type0_, type0_ value0_
<a name="l05225"></a>05225     &gt;
<a name="l05226"></a>05226 <span class="keyword">class </span>pack&lt;
<a name="l05227"></a>05227     constant&lt;type0_, value0_&gt;
<a name="l05228"></a>05228     &gt;
<a name="l05229"></a>05229 {
<a name="l05230"></a>05230 <span class="keyword">public</span>:
<a name="l05231"></a>05231     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n = 1;
<a name="l05232"></a>05232 
<a name="l05233"></a>05233     <span class="keyword">typedef</span> type0_ type0;
<a name="l05234"></a>05234 
<a name="l05235"></a>05235     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_const0 = <span class="keyword">true</span>;
<a name="l05236"></a>05236     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_all_const = <span class="keyword">true</span>;
<a name="l05237"></a>05237     <span class="keyword">static</span> <span class="keyword">const</span> type0 i0 = value0_;
<a name="l05238"></a>05238 
<a name="l05239"></a>05239     LITE_INLINE pack() 
<a name="l05240"></a>05240              {}
<a name="l05241"></a>05241     
<a name="l05242"></a>05242 
<a name="l05243"></a>05243     LITE_INLINE pack(
<a name="l05244"></a>05244         <span class="keyword">const</span> type0&amp; 
<a name="l05245"></a>05245         )  {}
<a name="l05246"></a>05246 
<a name="l05247"></a>05247     <span class="keyword">template</span>&lt;
<a name="l05248"></a>05248         <span class="keyword">typename</span> other_type0_ 
<a name="l05249"></a>05249     &gt;
<a name="l05250"></a>05250     LITE_INLINE pack(<span class="keyword">const</span> pack&lt;
<a name="l05251"></a>05251         other_type0_
<a name="l05252"></a>05252         &gt;&amp; )     {}
<a name="l05253"></a>05253 
<a name="l05254"></a>05254     LITE_INLINE pack&amp; 
<a name="l05255"></a>05255     operator= (<span class="keyword">const</span> pack&amp; ) 
<a name="l05256"></a>05256     {
<a name="l05257"></a>05257         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l05258"></a>05258     }
<a name="l05259"></a>05259 
<a name="l05260"></a>05260     <span class="keyword">template</span>&lt;
<a name="l05261"></a>05261         <span class="keyword">typename</span> other_type0_ 
<a name="l05262"></a>05262     &gt;
<a name="l05263"></a>05263     LITE_INLINE pack&amp;  
<a name="l05264"></a>05264     operator=(<span class="keyword">const</span> pack&lt;
<a name="l05265"></a>05265         other_type0_
<a name="l05266"></a>05266         &gt;&amp; ) 
<a name="l05267"></a>05267     {
<a name="l05268"></a>05268         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l05269"></a>05269     }
<a name="l05270"></a>05270 
<a name="l05271"></a>05271     LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l05272"></a>05272         <span class="keyword">const</span> type0&amp; 
<a name="l05273"></a>05273         ) 
<a name="l05274"></a>05274     {
<a name="l05275"></a>05275     }
<a name="l05276"></a>05276 };
<a name="l05277"></a>05277 
<a name="l05278"></a>05278 
<a name="l05279"></a>05279 <span class="keyword">template</span>&lt;
<a name="l05280"></a>05280     <span class="keyword">typename</span> type0_, type0_ value0_
<a name="l05281"></a>05281     &gt;
<a name="l05282"></a>05282 <span class="keyword">const</span> type0_ pack&lt;
<a name="l05283"></a>05283     constant&lt;type0_, value0_&gt;
<a name="l05284"></a>05284     &gt;::i0;
<a name="l05285"></a>05285 
<a name="l05286"></a>05286 <span class="comment">/***********************************************************************************************************/</span>
<a name="l05287"></a>05287 
<a name="l05288"></a>05288 
<a name="l05289"></a>05289 <span class="comment">/***********************************************************************************************************/</span>
<a name="l05290"></a>05290 
<a name="l05291"></a>05291 <span class="keyword">template</span>&lt;&gt;
<a name="l05292"></a>05292 <span class="keyword">class </span>pack&lt;&gt;
<a name="l05293"></a>05293 {
<a name="l05294"></a>05294 <span class="keyword">public</span>:
<a name="l05295"></a>05295     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n = 0;
<a name="l05296"></a>05296 
<a name="l05297"></a>05297     LITE_INLINE pack() {}
<a name="l05298"></a>05298 
<a name="l05299"></a>05299     LITE_INLINE pack(<span class="keyword">const</span> pack&amp;) {}
<a name="l05300"></a>05300 
<a name="l05301"></a>05301     LITE_INLINE pack&amp; operator= (<span class="keyword">const</span> pack&amp;) 
<a name="l05302"></a>05302     { <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l05303"></a>05303 
<a name="l05304"></a>05304     LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>() 
<a name="l05305"></a>05305     {}
<a name="l05306"></a>05306 };
<a name="l05307"></a>05307 
<a name="l05308"></a>05308 <span class="preprocessor">#endif // !DOCUMENTATION_ONLY</span>
<a name="l05309"></a>05309 <span class="preprocessor"></span>
<a name="l05310"></a>05310 <span class="comment">/***********************************************************************************************************/</span>
<a name="l05311"></a>05311 <span class="comment">/* sub_pack ************************************************************************************************/</span>
<a name="l05312"></a>05312 <span class="comment">/***********************************************************************************************************/</span>
<a name="l05313"></a>05313 
<a name="l05314"></a>05314 <span class="preprocessor">#ifdef DOCUMENTATION_ONLY</span>
<a name="l05315"></a>05315 <span class="preprocessor"></span>
<a name="l05355"></a>05355 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> pack_type_, <span class="keywordtype">bool</span> keep0_ ..., <span class="keywordtype">bool</span> keepN_&gt;
<a name="l05356"></a><a class="code" href="classlite_1_1sub__pack.html">05356</a> <span class="keyword">class </span><a class="code" href="classlite_1_1sub__pack.html" title="This class can be used to define and extract a subset of element of a pack as another...">sub_pack</a>
<a name="l05357"></a>05357 {
<a name="l05358"></a>05358 <span class="keyword">public</span>:
<a name="l05359"></a><a class="code" href="classlite_1_1sub__pack.html#a69e01124edaa6d0aba7d8ca08743390d">05359</a>     <span class="keyword">typedef</span> pack_type_ input_pack_type; 
<a name="l05360"></a>05360 
<a name="l05361"></a><a class="code" href="classlite_1_1sub__pack.html#a24d8b6591a8a9054948e455ef3d63853">05361</a>     <span class="keyword">typedef</span> <a class="code" href="classlite_1_1pack.html" title="This is a general tuple class that can pack together elements of different types...">pack</a>&lt;...&gt; <a class="code" href="classlite_1_1pack.html">type</a>; 
<a name="l05362"></a>05362 
<a name="l05364"></a>05364     <span class="keyword">static</span> <span class="keywordtype">void</span> <span class="keyword">set</span>(<a class="code" href="classlite_1_1pack.html">type</a>&amp; res, input_pack_type::type0 a0, ..., input_pack_type::typeN aN);
<a name="l05365"></a>05365 
<a name="l05367"></a>05367     <span class="keyword">static</span> <span class="keywordtype">void</span> <span class="keyword">set</span>(<a class="code" href="classlite_1_1pack.html">type</a>&amp; res, <span class="keyword">const</span> input_pack_type&amp; org);
<a name="l05368"></a>05368 };
<a name="l05369"></a>05369 
<a name="l05370"></a>05370 <span class="preprocessor">#else // DOCUMENTATION_ONLY</span>
<a name="l05371"></a>05371 <span class="preprocessor"></span>
<a name="l05372"></a>05372 
<a name="l05373"></a>05373 <span class="keyword">template</span>&lt;
<a name="l05374"></a>05374     &gt;
<a name="l05375"></a>05375 <span class="keyword">class </span><a class="code" href="classlite_1_1sub__pack.html" title="This class can be used to define and extract a subset of element of a pack as another...">sub_pack</a>&lt;
<a name="l05376"></a>05376     <a class="code" href="classlite_1_1pack.html" title="This is a general tuple class that can pack together elements of different types...">pack</a>&lt;
<a name="l05377"></a>05377     &gt;
<a name="l05378"></a>05378     &gt;
<a name="l05379"></a>05379 {
<a name="l05380"></a>05380 <span class="keyword">public</span>:
<a name="l05381"></a>05381     <span class="keyword">typedef</span> <a class="code" href="classlite_1_1pack.html" title="This is a general tuple class that can pack together elements of different types...">pack</a>&lt;
<a name="l05382"></a>05382     &gt; input_pack_type;
<a name="l05383"></a>05383 
<a name="l05384"></a>05384     <span class="keyword">typedef</span> <a class="code" href="classlite_1_1pack.html" title="This is a general tuple class that can pack together elements of different types...">pack</a>&lt;
<a name="l05385"></a>05385     &gt; type;
<a name="l05386"></a>05386 
<a name="l05387"></a>05387     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l05388"></a>05388         type&amp; res
<a name="l05389"></a>05389         ) 
<a name="l05390"></a>05390     {
<a name="l05391"></a>05391         res.set();
<a name="l05392"></a>05392     }
<a name="l05393"></a>05393 
<a name="l05394"></a>05394     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(type&amp; res, <span class="keyword">const</span> input_pack_type&amp; org)
<a name="l05395"></a>05395     {
<a name="l05396"></a>05396         res.set();
<a name="l05397"></a>05397         LITE_ARRAY_USE(org);
<a name="l05398"></a>05398     }
<a name="l05399"></a>05399 };
<a name="l05400"></a>05400 
<a name="l05401"></a>05401 <span class="comment">/***********************************************************************************************************/</span>
<a name="l05402"></a>05402 
<a name="l05403"></a>05403 <span class="keyword">template</span>&lt;
<a name="l05404"></a>05404     <span class="keyword">typename</span> type0_
<a name="l05405"></a>05405     &gt;
<a name="l05406"></a>05406 <span class="keyword">class </span>sub_pack&lt;
<a name="l05407"></a>05407     pack&lt;
<a name="l05408"></a>05408         type0_
<a name="l05409"></a>05409     &gt;,
<a name="l05410"></a>05410     false
<a name="l05411"></a>05411     &gt;
<a name="l05412"></a>05412 {
<a name="l05413"></a>05413 <span class="keyword">public</span>:
<a name="l05414"></a>05414     <span class="keyword">typedef</span> pack&lt;
<a name="l05415"></a>05415         type0_
<a name="l05416"></a>05416     &gt; input_pack_type;
<a name="l05417"></a>05417 
<a name="l05418"></a>05418     <span class="keyword">typedef</span> pack&lt;
<a name="l05419"></a>05419     &gt; type;
<a name="l05420"></a>05420 
<a name="l05421"></a>05421     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l05422"></a>05422         type&amp; res,
<a name="l05423"></a>05423         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type0&amp; 
<a name="l05424"></a>05424         ) 
<a name="l05425"></a>05425     {
<a name="l05426"></a>05426         res.set();
<a name="l05427"></a>05427     }
<a name="l05428"></a>05428 
<a name="l05429"></a>05429     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(type&amp; res, <span class="keyword">const</span> input_pack_type&amp; org)
<a name="l05430"></a>05430     {
<a name="l05431"></a>05431         res.set();
<a name="l05432"></a>05432         LITE_ARRAY_USE(org);
<a name="l05433"></a>05433     }
<a name="l05434"></a>05434 };
<a name="l05435"></a>05435 
<a name="l05436"></a>05436 <span class="comment">/***********************************************************************************************************/</span>
<a name="l05437"></a>05437 
<a name="l05438"></a>05438 <span class="keyword">template</span>&lt;
<a name="l05439"></a>05439     <span class="keyword">typename</span> type0_
<a name="l05440"></a>05440     &gt;
<a name="l05441"></a>05441 <span class="keyword">class </span>sub_pack&lt;
<a name="l05442"></a>05442     pack&lt;
<a name="l05443"></a>05443         type0_
<a name="l05444"></a>05444     &gt;,
<a name="l05445"></a>05445     true
<a name="l05446"></a>05446     &gt;
<a name="l05447"></a>05447 {
<a name="l05448"></a>05448 <span class="keyword">public</span>:
<a name="l05449"></a>05449     <span class="keyword">typedef</span> pack&lt;
<a name="l05450"></a>05450         type0_
<a name="l05451"></a>05451     &gt; input_pack_type;
<a name="l05452"></a>05452 
<a name="l05453"></a>05453     <span class="keyword">typedef</span> pack&lt;
<a name="l05454"></a>05454         type0_
<a name="l05455"></a>05455     &gt; type;
<a name="l05456"></a>05456 
<a name="l05457"></a>05457     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l05458"></a>05458         type&amp; res,
<a name="l05459"></a>05459         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type0&amp; a0
<a name="l05460"></a>05460         ) 
<a name="l05461"></a>05461     {
<a name="l05462"></a>05462         res.set(a0);
<a name="l05463"></a>05463     }
<a name="l05464"></a>05464 
<a name="l05465"></a>05465     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(type&amp; res, <span class="keyword">const</span> input_pack_type&amp; org)
<a name="l05466"></a>05466     {
<a name="l05467"></a>05467         res.set(org.i0);
<a name="l05468"></a>05468         LITE_ARRAY_USE(org);
<a name="l05469"></a>05469     }
<a name="l05470"></a>05470 };
<a name="l05471"></a>05471 
<a name="l05472"></a>05472 <span class="comment">/***********************************************************************************************************/</span>
<a name="l05473"></a>05473 
<a name="l05474"></a>05474 <span class="keyword">template</span>&lt;
<a name="l05475"></a>05475     <span class="keyword">typename</span> type0_,
<a name="l05476"></a>05476     <span class="keyword">typename</span> type1_
<a name="l05477"></a>05477     &gt;
<a name="l05478"></a>05478 <span class="keyword">class </span>sub_pack&lt;
<a name="l05479"></a>05479     pack&lt;
<a name="l05480"></a>05480         type0_,
<a name="l05481"></a>05481         type1_
<a name="l05482"></a>05482     &gt;,
<a name="l05483"></a>05483     false,
<a name="l05484"></a>05484     false
<a name="l05485"></a>05485     &gt;
<a name="l05486"></a>05486 {
<a name="l05487"></a>05487 <span class="keyword">public</span>:
<a name="l05488"></a>05488     <span class="keyword">typedef</span> pack&lt;
<a name="l05489"></a>05489         type0_,
<a name="l05490"></a>05490         type1_
<a name="l05491"></a>05491     &gt; input_pack_type;
<a name="l05492"></a>05492 
<a name="l05493"></a>05493     <span class="keyword">typedef</span> pack&lt;
<a name="l05494"></a>05494     &gt; type;
<a name="l05495"></a>05495 
<a name="l05496"></a>05496     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l05497"></a>05497         type&amp; res,
<a name="l05498"></a>05498         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type0&amp; ,
<a name="l05499"></a>05499         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type1&amp; 
<a name="l05500"></a>05500         ) 
<a name="l05501"></a>05501     {
<a name="l05502"></a>05502         res.set();
<a name="l05503"></a>05503     }
<a name="l05504"></a>05504 
<a name="l05505"></a>05505     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(type&amp; res, <span class="keyword">const</span> input_pack_type&amp; org)
<a name="l05506"></a>05506     {
<a name="l05507"></a>05507         res.set();
<a name="l05508"></a>05508         LITE_ARRAY_USE(org);
<a name="l05509"></a>05509     }
<a name="l05510"></a>05510 };
<a name="l05511"></a>05511 
<a name="l05512"></a>05512 <span class="comment">/***********************************************************************************************************/</span>
<a name="l05513"></a>05513 
<a name="l05514"></a>05514 <span class="keyword">template</span>&lt;
<a name="l05515"></a>05515     <span class="keyword">typename</span> type0_,
<a name="l05516"></a>05516     <span class="keyword">typename</span> type1_
<a name="l05517"></a>05517     &gt;
<a name="l05518"></a>05518 <span class="keyword">class </span>sub_pack&lt;
<a name="l05519"></a>05519     pack&lt;
<a name="l05520"></a>05520         type0_,
<a name="l05521"></a>05521         type1_
<a name="l05522"></a>05522     &gt;,
<a name="l05523"></a>05523     true,
<a name="l05524"></a>05524     false
<a name="l05525"></a>05525     &gt;
<a name="l05526"></a>05526 {
<a name="l05527"></a>05527 <span class="keyword">public</span>:
<a name="l05528"></a>05528     <span class="keyword">typedef</span> pack&lt;
<a name="l05529"></a>05529         type0_,
<a name="l05530"></a>05530         type1_
<a name="l05531"></a>05531     &gt; input_pack_type;
<a name="l05532"></a>05532 
<a name="l05533"></a>05533     <span class="keyword">typedef</span> pack&lt;
<a name="l05534"></a>05534         type0_
<a name="l05535"></a>05535     &gt; type;
<a name="l05536"></a>05536 
<a name="l05537"></a>05537     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l05538"></a>05538         type&amp; res,
<a name="l05539"></a>05539         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type0&amp; a0,
<a name="l05540"></a>05540         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type1&amp; 
<a name="l05541"></a>05541         ) 
<a name="l05542"></a>05542     {
<a name="l05543"></a>05543         res.set(a0);
<a name="l05544"></a>05544     }
<a name="l05545"></a>05545 
<a name="l05546"></a>05546     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(type&amp; res, <span class="keyword">const</span> input_pack_type&amp; org)
<a name="l05547"></a>05547     {
<a name="l05548"></a>05548         res.set(org.i0);
<a name="l05549"></a>05549         LITE_ARRAY_USE(org);
<a name="l05550"></a>05550     }
<a name="l05551"></a>05551 };
<a name="l05552"></a>05552 
<a name="l05553"></a>05553 <span class="comment">/***********************************************************************************************************/</span>
<a name="l05554"></a>05554 
<a name="l05555"></a>05555 <span class="keyword">template</span>&lt;
<a name="l05556"></a>05556     <span class="keyword">typename</span> type0_,
<a name="l05557"></a>05557     <span class="keyword">typename</span> type1_
<a name="l05558"></a>05558     &gt;
<a name="l05559"></a>05559 <span class="keyword">class </span>sub_pack&lt;
<a name="l05560"></a>05560     pack&lt;
<a name="l05561"></a>05561         type0_,
<a name="l05562"></a>05562         type1_
<a name="l05563"></a>05563     &gt;,
<a name="l05564"></a>05564     false,
<a name="l05565"></a>05565     true
<a name="l05566"></a>05566     &gt;
<a name="l05567"></a>05567 {
<a name="l05568"></a>05568 <span class="keyword">public</span>:
<a name="l05569"></a>05569     <span class="keyword">typedef</span> pack&lt;
<a name="l05570"></a>05570         type0_,
<a name="l05571"></a>05571         type1_
<a name="l05572"></a>05572     &gt; input_pack_type;
<a name="l05573"></a>05573 
<a name="l05574"></a>05574     <span class="keyword">typedef</span> pack&lt;
<a name="l05575"></a>05575         type1_
<a name="l05576"></a>05576     &gt; type;
<a name="l05577"></a>05577 
<a name="l05578"></a>05578     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l05579"></a>05579         type&amp; res,
<a name="l05580"></a>05580         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type0&amp; ,
<a name="l05581"></a>05581         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type1&amp; a1
<a name="l05582"></a>05582         ) 
<a name="l05583"></a>05583     {
<a name="l05584"></a>05584         res.set(a1);
<a name="l05585"></a>05585     }
<a name="l05586"></a>05586 
<a name="l05587"></a>05587     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(type&amp; res, <span class="keyword">const</span> input_pack_type&amp; org)
<a name="l05588"></a>05588     {
<a name="l05589"></a>05589         res.set(org.i1);
<a name="l05590"></a>05590         LITE_ARRAY_USE(org);
<a name="l05591"></a>05591     }
<a name="l05592"></a>05592 };
<a name="l05593"></a>05593 
<a name="l05594"></a>05594 <span class="comment">/***********************************************************************************************************/</span>
<a name="l05595"></a>05595 
<a name="l05596"></a>05596 <span class="keyword">template</span>&lt;
<a name="l05597"></a>05597     <span class="keyword">typename</span> type0_,
<a name="l05598"></a>05598     <span class="keyword">typename</span> type1_
<a name="l05599"></a>05599     &gt;
<a name="l05600"></a>05600 <span class="keyword">class </span>sub_pack&lt;
<a name="l05601"></a>05601     pack&lt;
<a name="l05602"></a>05602         type0_,
<a name="l05603"></a>05603         type1_
<a name="l05604"></a>05604     &gt;,
<a name="l05605"></a>05605     true,
<a name="l05606"></a>05606     true
<a name="l05607"></a>05607     &gt;
<a name="l05608"></a>05608 {
<a name="l05609"></a>05609 <span class="keyword">public</span>:
<a name="l05610"></a>05610     <span class="keyword">typedef</span> pack&lt;
<a name="l05611"></a>05611         type0_,
<a name="l05612"></a>05612         type1_
<a name="l05613"></a>05613     &gt; input_pack_type;
<a name="l05614"></a>05614 
<a name="l05615"></a>05615     <span class="keyword">typedef</span> pack&lt;
<a name="l05616"></a>05616         type0_,
<a name="l05617"></a>05617         type1_
<a name="l05618"></a>05618     &gt; type;
<a name="l05619"></a>05619 
<a name="l05620"></a>05620     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l05621"></a>05621         type&amp; res,
<a name="l05622"></a>05622         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type0&amp; a0,
<a name="l05623"></a>05623         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type1&amp; a1
<a name="l05624"></a>05624         ) 
<a name="l05625"></a>05625     {
<a name="l05626"></a>05626         res.set(a0,a1);
<a name="l05627"></a>05627     }
<a name="l05628"></a>05628 
<a name="l05629"></a>05629     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(type&amp; res, <span class="keyword">const</span> input_pack_type&amp; org)
<a name="l05630"></a>05630     {
<a name="l05631"></a>05631         res.set(org.i0,org.i1);
<a name="l05632"></a>05632         LITE_ARRAY_USE(org);
<a name="l05633"></a>05633     }
<a name="l05634"></a>05634 };
<a name="l05635"></a>05635 
<a name="l05636"></a>05636 <span class="comment">/***********************************************************************************************************/</span>
<a name="l05637"></a>05637 
<a name="l05638"></a>05638 <span class="keyword">template</span>&lt;
<a name="l05639"></a>05639     <span class="keyword">typename</span> type0_,
<a name="l05640"></a>05640     <span class="keyword">typename</span> type1_,
<a name="l05641"></a>05641     <span class="keyword">typename</span> type2_
<a name="l05642"></a>05642     &gt;
<a name="l05643"></a>05643 <span class="keyword">class </span>sub_pack&lt;
<a name="l05644"></a>05644     pack&lt;
<a name="l05645"></a>05645         type0_,
<a name="l05646"></a>05646         type1_,
<a name="l05647"></a>05647         type2_
<a name="l05648"></a>05648     &gt;,
<a name="l05649"></a>05649     false,
<a name="l05650"></a>05650     false,
<a name="l05651"></a>05651     false
<a name="l05652"></a>05652     &gt;
<a name="l05653"></a>05653 {
<a name="l05654"></a>05654 <span class="keyword">public</span>:
<a name="l05655"></a>05655     <span class="keyword">typedef</span> pack&lt;
<a name="l05656"></a>05656         type0_,
<a name="l05657"></a>05657         type1_,
<a name="l05658"></a>05658         type2_
<a name="l05659"></a>05659     &gt; input_pack_type;
<a name="l05660"></a>05660 
<a name="l05661"></a>05661     <span class="keyword">typedef</span> pack&lt;
<a name="l05662"></a>05662     &gt; type;
<a name="l05663"></a>05663 
<a name="l05664"></a>05664     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l05665"></a>05665         type&amp; res,
<a name="l05666"></a>05666         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type0&amp; ,
<a name="l05667"></a>05667         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type1&amp; ,
<a name="l05668"></a>05668         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type2&amp; 
<a name="l05669"></a>05669         ) 
<a name="l05670"></a>05670     {
<a name="l05671"></a>05671         res.set();
<a name="l05672"></a>05672     }
<a name="l05673"></a>05673 
<a name="l05674"></a>05674     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(type&amp; res, <span class="keyword">const</span> input_pack_type&amp; org)
<a name="l05675"></a>05675     {
<a name="l05676"></a>05676         res.set();
<a name="l05677"></a>05677         LITE_ARRAY_USE(org);
<a name="l05678"></a>05678     }
<a name="l05679"></a>05679 };
<a name="l05680"></a>05680 
<a name="l05681"></a>05681 <span class="comment">/***********************************************************************************************************/</span>
<a name="l05682"></a>05682 
<a name="l05683"></a>05683 <span class="keyword">template</span>&lt;
<a name="l05684"></a>05684     <span class="keyword">typename</span> type0_,
<a name="l05685"></a>05685     <span class="keyword">typename</span> type1_,
<a name="l05686"></a>05686     <span class="keyword">typename</span> type2_
<a name="l05687"></a>05687     &gt;
<a name="l05688"></a>05688 <span class="keyword">class </span>sub_pack&lt;
<a name="l05689"></a>05689     pack&lt;
<a name="l05690"></a>05690         type0_,
<a name="l05691"></a>05691         type1_,
<a name="l05692"></a>05692         type2_
<a name="l05693"></a>05693     &gt;,
<a name="l05694"></a>05694     true,
<a name="l05695"></a>05695     false,
<a name="l05696"></a>05696     false
<a name="l05697"></a>05697     &gt;
<a name="l05698"></a>05698 {
<a name="l05699"></a>05699 <span class="keyword">public</span>:
<a name="l05700"></a>05700     <span class="keyword">typedef</span> pack&lt;
<a name="l05701"></a>05701         type0_,
<a name="l05702"></a>05702         type1_,
<a name="l05703"></a>05703         type2_
<a name="l05704"></a>05704     &gt; input_pack_type;
<a name="l05705"></a>05705 
<a name="l05706"></a>05706     <span class="keyword">typedef</span> pack&lt;
<a name="l05707"></a>05707         type0_
<a name="l05708"></a>05708     &gt; type;
<a name="l05709"></a>05709 
<a name="l05710"></a>05710     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l05711"></a>05711         type&amp; res,
<a name="l05712"></a>05712         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type0&amp; a0,
<a name="l05713"></a>05713         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type1&amp; ,
<a name="l05714"></a>05714         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type2&amp; 
<a name="l05715"></a>05715         ) 
<a name="l05716"></a>05716     {
<a name="l05717"></a>05717         res.set(a0);
<a name="l05718"></a>05718     }
<a name="l05719"></a>05719 
<a name="l05720"></a>05720     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(type&amp; res, <span class="keyword">const</span> input_pack_type&amp; org)
<a name="l05721"></a>05721     {
<a name="l05722"></a>05722         res.set(org.i0);
<a name="l05723"></a>05723         LITE_ARRAY_USE(org);
<a name="l05724"></a>05724     }
<a name="l05725"></a>05725 };
<a name="l05726"></a>05726 
<a name="l05727"></a>05727 <span class="comment">/***********************************************************************************************************/</span>
<a name="l05728"></a>05728 
<a name="l05729"></a>05729 <span class="keyword">template</span>&lt;
<a name="l05730"></a>05730     <span class="keyword">typename</span> type0_,
<a name="l05731"></a>05731     <span class="keyword">typename</span> type1_,
<a name="l05732"></a>05732     <span class="keyword">typename</span> type2_
<a name="l05733"></a>05733     &gt;
<a name="l05734"></a>05734 <span class="keyword">class </span>sub_pack&lt;
<a name="l05735"></a>05735     pack&lt;
<a name="l05736"></a>05736         type0_,
<a name="l05737"></a>05737         type1_,
<a name="l05738"></a>05738         type2_
<a name="l05739"></a>05739     &gt;,
<a name="l05740"></a>05740     false,
<a name="l05741"></a>05741     true,
<a name="l05742"></a>05742     false
<a name="l05743"></a>05743     &gt;
<a name="l05744"></a>05744 {
<a name="l05745"></a>05745 <span class="keyword">public</span>:
<a name="l05746"></a>05746     <span class="keyword">typedef</span> pack&lt;
<a name="l05747"></a>05747         type0_,
<a name="l05748"></a>05748         type1_,
<a name="l05749"></a>05749         type2_
<a name="l05750"></a>05750     &gt; input_pack_type;
<a name="l05751"></a>05751 
<a name="l05752"></a>05752     <span class="keyword">typedef</span> pack&lt;
<a name="l05753"></a>05753         type1_
<a name="l05754"></a>05754     &gt; type;
<a name="l05755"></a>05755 
<a name="l05756"></a>05756     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l05757"></a>05757         type&amp; res,
<a name="l05758"></a>05758         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type0&amp; ,
<a name="l05759"></a>05759         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type1&amp; a1,
<a name="l05760"></a>05760         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type2&amp; 
<a name="l05761"></a>05761         ) 
<a name="l05762"></a>05762     {
<a name="l05763"></a>05763         res.set(a1);
<a name="l05764"></a>05764     }
<a name="l05765"></a>05765 
<a name="l05766"></a>05766     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(type&amp; res, <span class="keyword">const</span> input_pack_type&amp; org)
<a name="l05767"></a>05767     {
<a name="l05768"></a>05768         res.set(org.i1);
<a name="l05769"></a>05769         LITE_ARRAY_USE(org);
<a name="l05770"></a>05770     }
<a name="l05771"></a>05771 };
<a name="l05772"></a>05772 
<a name="l05773"></a>05773 <span class="comment">/***********************************************************************************************************/</span>
<a name="l05774"></a>05774 
<a name="l05775"></a>05775 <span class="keyword">template</span>&lt;
<a name="l05776"></a>05776     <span class="keyword">typename</span> type0_,
<a name="l05777"></a>05777     <span class="keyword">typename</span> type1_,
<a name="l05778"></a>05778     <span class="keyword">typename</span> type2_
<a name="l05779"></a>05779     &gt;
<a name="l05780"></a>05780 <span class="keyword">class </span>sub_pack&lt;
<a name="l05781"></a>05781     pack&lt;
<a name="l05782"></a>05782         type0_,
<a name="l05783"></a>05783         type1_,
<a name="l05784"></a>05784         type2_
<a name="l05785"></a>05785     &gt;,
<a name="l05786"></a>05786     true,
<a name="l05787"></a>05787     true,
<a name="l05788"></a>05788     false
<a name="l05789"></a>05789     &gt;
<a name="l05790"></a>05790 {
<a name="l05791"></a>05791 <span class="keyword">public</span>:
<a name="l05792"></a>05792     <span class="keyword">typedef</span> pack&lt;
<a name="l05793"></a>05793         type0_,
<a name="l05794"></a>05794         type1_,
<a name="l05795"></a>05795         type2_
<a name="l05796"></a>05796     &gt; input_pack_type;
<a name="l05797"></a>05797 
<a name="l05798"></a>05798     <span class="keyword">typedef</span> pack&lt;
<a name="l05799"></a>05799         type0_,
<a name="l05800"></a>05800         type1_
<a name="l05801"></a>05801     &gt; type;
<a name="l05802"></a>05802 
<a name="l05803"></a>05803     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l05804"></a>05804         type&amp; res,
<a name="l05805"></a>05805         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type0&amp; a0,
<a name="l05806"></a>05806         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type1&amp; a1,
<a name="l05807"></a>05807         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type2&amp; 
<a name="l05808"></a>05808         ) 
<a name="l05809"></a>05809     {
<a name="l05810"></a>05810         res.set(a0,a1);
<a name="l05811"></a>05811     }
<a name="l05812"></a>05812 
<a name="l05813"></a>05813     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(type&amp; res, <span class="keyword">const</span> input_pack_type&amp; org)
<a name="l05814"></a>05814     {
<a name="l05815"></a>05815         res.set(org.i0,org.i1);
<a name="l05816"></a>05816         LITE_ARRAY_USE(org);
<a name="l05817"></a>05817     }
<a name="l05818"></a>05818 };
<a name="l05819"></a>05819 
<a name="l05820"></a>05820 <span class="comment">/***********************************************************************************************************/</span>
<a name="l05821"></a>05821 
<a name="l05822"></a>05822 <span class="keyword">template</span>&lt;
<a name="l05823"></a>05823     <span class="keyword">typename</span> type0_,
<a name="l05824"></a>05824     <span class="keyword">typename</span> type1_,
<a name="l05825"></a>05825     <span class="keyword">typename</span> type2_
<a name="l05826"></a>05826     &gt;
<a name="l05827"></a>05827 <span class="keyword">class </span>sub_pack&lt;
<a name="l05828"></a>05828     pack&lt;
<a name="l05829"></a>05829         type0_,
<a name="l05830"></a>05830         type1_,
<a name="l05831"></a>05831         type2_
<a name="l05832"></a>05832     &gt;,
<a name="l05833"></a>05833     false,
<a name="l05834"></a>05834     false,
<a name="l05835"></a>05835     true
<a name="l05836"></a>05836     &gt;
<a name="l05837"></a>05837 {
<a name="l05838"></a>05838 <span class="keyword">public</span>:
<a name="l05839"></a>05839     <span class="keyword">typedef</span> pack&lt;
<a name="l05840"></a>05840         type0_,
<a name="l05841"></a>05841         type1_,
<a name="l05842"></a>05842         type2_
<a name="l05843"></a>05843     &gt; input_pack_type;
<a name="l05844"></a>05844 
<a name="l05845"></a>05845     <span class="keyword">typedef</span> pack&lt;
<a name="l05846"></a>05846         type2_
<a name="l05847"></a>05847     &gt; type;
<a name="l05848"></a>05848 
<a name="l05849"></a>05849     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l05850"></a>05850         type&amp; res,
<a name="l05851"></a>05851         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type0&amp; ,
<a name="l05852"></a>05852         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type1&amp; ,
<a name="l05853"></a>05853         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type2&amp; a2
<a name="l05854"></a>05854         ) 
<a name="l05855"></a>05855     {
<a name="l05856"></a>05856         res.set(a2);
<a name="l05857"></a>05857     }
<a name="l05858"></a>05858 
<a name="l05859"></a>05859     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(type&amp; res, <span class="keyword">const</span> input_pack_type&amp; org)
<a name="l05860"></a>05860     {
<a name="l05861"></a>05861         res.set(org.i2);
<a name="l05862"></a>05862         LITE_ARRAY_USE(org);
<a name="l05863"></a>05863     }
<a name="l05864"></a>05864 };
<a name="l05865"></a>05865 
<a name="l05866"></a>05866 <span class="comment">/***********************************************************************************************************/</span>
<a name="l05867"></a>05867 
<a name="l05868"></a>05868 <span class="keyword">template</span>&lt;
<a name="l05869"></a>05869     <span class="keyword">typename</span> type0_,
<a name="l05870"></a>05870     <span class="keyword">typename</span> type1_,
<a name="l05871"></a>05871     <span class="keyword">typename</span> type2_
<a name="l05872"></a>05872     &gt;
<a name="l05873"></a>05873 <span class="keyword">class </span>sub_pack&lt;
<a name="l05874"></a>05874     pack&lt;
<a name="l05875"></a>05875         type0_,
<a name="l05876"></a>05876         type1_,
<a name="l05877"></a>05877         type2_
<a name="l05878"></a>05878     &gt;,
<a name="l05879"></a>05879     true,
<a name="l05880"></a>05880     false,
<a name="l05881"></a>05881     true
<a name="l05882"></a>05882     &gt;
<a name="l05883"></a>05883 {
<a name="l05884"></a>05884 <span class="keyword">public</span>:
<a name="l05885"></a>05885     <span class="keyword">typedef</span> pack&lt;
<a name="l05886"></a>05886         type0_,
<a name="l05887"></a>05887         type1_,
<a name="l05888"></a>05888         type2_
<a name="l05889"></a>05889     &gt; input_pack_type;
<a name="l05890"></a>05890 
<a name="l05891"></a>05891     <span class="keyword">typedef</span> pack&lt;
<a name="l05892"></a>05892         type0_,
<a name="l05893"></a>05893         type2_
<a name="l05894"></a>05894     &gt; type;
<a name="l05895"></a>05895 
<a name="l05896"></a>05896     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l05897"></a>05897         type&amp; res,
<a name="l05898"></a>05898         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type0&amp; a0,
<a name="l05899"></a>05899         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type1&amp; ,
<a name="l05900"></a>05900         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type2&amp; a2
<a name="l05901"></a>05901         ) 
<a name="l05902"></a>05902     {
<a name="l05903"></a>05903         res.set(a0,a2);
<a name="l05904"></a>05904     }
<a name="l05905"></a>05905 
<a name="l05906"></a>05906     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(type&amp; res, <span class="keyword">const</span> input_pack_type&amp; org)
<a name="l05907"></a>05907     {
<a name="l05908"></a>05908         res.set(org.i0,org.i2);
<a name="l05909"></a>05909         LITE_ARRAY_USE(org);
<a name="l05910"></a>05910     }
<a name="l05911"></a>05911 };
<a name="l05912"></a>05912 
<a name="l05913"></a>05913 <span class="comment">/***********************************************************************************************************/</span>
<a name="l05914"></a>05914 
<a name="l05915"></a>05915 <span class="keyword">template</span>&lt;
<a name="l05916"></a>05916     <span class="keyword">typename</span> type0_,
<a name="l05917"></a>05917     <span class="keyword">typename</span> type1_,
<a name="l05918"></a>05918     <span class="keyword">typename</span> type2_
<a name="l05919"></a>05919     &gt;
<a name="l05920"></a>05920 <span class="keyword">class </span>sub_pack&lt;
<a name="l05921"></a>05921     pack&lt;
<a name="l05922"></a>05922         type0_,
<a name="l05923"></a>05923         type1_,
<a name="l05924"></a>05924         type2_
<a name="l05925"></a>05925     &gt;,
<a name="l05926"></a>05926     false,
<a name="l05927"></a>05927     true,
<a name="l05928"></a>05928     true
<a name="l05929"></a>05929     &gt;
<a name="l05930"></a>05930 {
<a name="l05931"></a>05931 <span class="keyword">public</span>:
<a name="l05932"></a>05932     <span class="keyword">typedef</span> pack&lt;
<a name="l05933"></a>05933         type0_,
<a name="l05934"></a>05934         type1_,
<a name="l05935"></a>05935         type2_
<a name="l05936"></a>05936     &gt; input_pack_type;
<a name="l05937"></a>05937 
<a name="l05938"></a>05938     <span class="keyword">typedef</span> pack&lt;
<a name="l05939"></a>05939         type1_,
<a name="l05940"></a>05940         type2_
<a name="l05941"></a>05941     &gt; type;
<a name="l05942"></a>05942 
<a name="l05943"></a>05943     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l05944"></a>05944         type&amp; res,
<a name="l05945"></a>05945         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type0&amp; ,
<a name="l05946"></a>05946         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type1&amp; a1,
<a name="l05947"></a>05947         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type2&amp; a2
<a name="l05948"></a>05948         ) 
<a name="l05949"></a>05949     {
<a name="l05950"></a>05950         res.set(a1,a2);
<a name="l05951"></a>05951     }
<a name="l05952"></a>05952 
<a name="l05953"></a>05953     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(type&amp; res, <span class="keyword">const</span> input_pack_type&amp; org)
<a name="l05954"></a>05954     {
<a name="l05955"></a>05955         res.set(org.i1,org.i2);
<a name="l05956"></a>05956         LITE_ARRAY_USE(org);
<a name="l05957"></a>05957     }
<a name="l05958"></a>05958 };
<a name="l05959"></a>05959 
<a name="l05960"></a>05960 <span class="comment">/***********************************************************************************************************/</span>
<a name="l05961"></a>05961 
<a name="l05962"></a>05962 <span class="keyword">template</span>&lt;
<a name="l05963"></a>05963     <span class="keyword">typename</span> type0_,
<a name="l05964"></a>05964     <span class="keyword">typename</span> type1_,
<a name="l05965"></a>05965     <span class="keyword">typename</span> type2_
<a name="l05966"></a>05966     &gt;
<a name="l05967"></a>05967 <span class="keyword">class </span>sub_pack&lt;
<a name="l05968"></a>05968     pack&lt;
<a name="l05969"></a>05969         type0_,
<a name="l05970"></a>05970         type1_,
<a name="l05971"></a>05971         type2_
<a name="l05972"></a>05972     &gt;,
<a name="l05973"></a>05973     true,
<a name="l05974"></a>05974     true,
<a name="l05975"></a>05975     true
<a name="l05976"></a>05976     &gt;
<a name="l05977"></a>05977 {
<a name="l05978"></a>05978 <span class="keyword">public</span>:
<a name="l05979"></a>05979     <span class="keyword">typedef</span> pack&lt;
<a name="l05980"></a>05980         type0_,
<a name="l05981"></a>05981         type1_,
<a name="l05982"></a>05982         type2_
<a name="l05983"></a>05983     &gt; input_pack_type;
<a name="l05984"></a>05984 
<a name="l05985"></a>05985     <span class="keyword">typedef</span> pack&lt;
<a name="l05986"></a>05986         type0_,
<a name="l05987"></a>05987         type1_,
<a name="l05988"></a>05988         type2_
<a name="l05989"></a>05989     &gt; type;
<a name="l05990"></a>05990 
<a name="l05991"></a>05991     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l05992"></a>05992         type&amp; res,
<a name="l05993"></a>05993         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type0&amp; a0,
<a name="l05994"></a>05994         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type1&amp; a1,
<a name="l05995"></a>05995         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type2&amp; a2
<a name="l05996"></a>05996         ) 
<a name="l05997"></a>05997     {
<a name="l05998"></a>05998         res.set(a0,a1,a2);
<a name="l05999"></a>05999     }
<a name="l06000"></a>06000 
<a name="l06001"></a>06001     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(type&amp; res, <span class="keyword">const</span> input_pack_type&amp; org)
<a name="l06002"></a>06002     {
<a name="l06003"></a>06003         res.set(org.i0,org.i1,org.i2);
<a name="l06004"></a>06004         LITE_ARRAY_USE(org);
<a name="l06005"></a>06005     }
<a name="l06006"></a>06006 };
<a name="l06007"></a>06007 
<a name="l06008"></a>06008 <span class="comment">/***********************************************************************************************************/</span>
<a name="l06009"></a>06009 
<a name="l06010"></a>06010 <span class="keyword">template</span>&lt;
<a name="l06011"></a>06011     <span class="keyword">typename</span> type0_,
<a name="l06012"></a>06012     <span class="keyword">typename</span> type1_,
<a name="l06013"></a>06013     <span class="keyword">typename</span> type2_,
<a name="l06014"></a>06014     <span class="keyword">typename</span> type3_
<a name="l06015"></a>06015     &gt;
<a name="l06016"></a>06016 <span class="keyword">class </span>sub_pack&lt;
<a name="l06017"></a>06017     pack&lt;
<a name="l06018"></a>06018         type0_,
<a name="l06019"></a>06019         type1_,
<a name="l06020"></a>06020         type2_,
<a name="l06021"></a>06021         type3_
<a name="l06022"></a>06022     &gt;,
<a name="l06023"></a>06023     false,
<a name="l06024"></a>06024     false,
<a name="l06025"></a>06025     false,
<a name="l06026"></a>06026     false
<a name="l06027"></a>06027     &gt;
<a name="l06028"></a>06028 {
<a name="l06029"></a>06029 <span class="keyword">public</span>:
<a name="l06030"></a>06030     <span class="keyword">typedef</span> pack&lt;
<a name="l06031"></a>06031         type0_,
<a name="l06032"></a>06032         type1_,
<a name="l06033"></a>06033         type2_,
<a name="l06034"></a>06034         type3_
<a name="l06035"></a>06035     &gt; input_pack_type;
<a name="l06036"></a>06036 
<a name="l06037"></a>06037     <span class="keyword">typedef</span> pack&lt;
<a name="l06038"></a>06038     &gt; type;
<a name="l06039"></a>06039 
<a name="l06040"></a>06040     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l06041"></a>06041         type&amp; res,
<a name="l06042"></a>06042         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type0&amp; ,
<a name="l06043"></a>06043         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type1&amp; ,
<a name="l06044"></a>06044         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type2&amp; ,
<a name="l06045"></a>06045         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type3&amp; 
<a name="l06046"></a>06046         ) 
<a name="l06047"></a>06047     {
<a name="l06048"></a>06048         res.set();
<a name="l06049"></a>06049     }
<a name="l06050"></a>06050 
<a name="l06051"></a>06051     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(type&amp; res, <span class="keyword">const</span> input_pack_type&amp; org)
<a name="l06052"></a>06052     {
<a name="l06053"></a>06053         res.set();
<a name="l06054"></a>06054         LITE_ARRAY_USE(org);
<a name="l06055"></a>06055     }
<a name="l06056"></a>06056 };
<a name="l06057"></a>06057 
<a name="l06058"></a>06058 <span class="comment">/***********************************************************************************************************/</span>
<a name="l06059"></a>06059 
<a name="l06060"></a>06060 <span class="keyword">template</span>&lt;
<a name="l06061"></a>06061     <span class="keyword">typename</span> type0_,
<a name="l06062"></a>06062     <span class="keyword">typename</span> type1_,
<a name="l06063"></a>06063     <span class="keyword">typename</span> type2_,
<a name="l06064"></a>06064     <span class="keyword">typename</span> type3_
<a name="l06065"></a>06065     &gt;
<a name="l06066"></a>06066 <span class="keyword">class </span>sub_pack&lt;
<a name="l06067"></a>06067     pack&lt;
<a name="l06068"></a>06068         type0_,
<a name="l06069"></a>06069         type1_,
<a name="l06070"></a>06070         type2_,
<a name="l06071"></a>06071         type3_
<a name="l06072"></a>06072     &gt;,
<a name="l06073"></a>06073     true,
<a name="l06074"></a>06074     false,
<a name="l06075"></a>06075     false,
<a name="l06076"></a>06076     false
<a name="l06077"></a>06077     &gt;
<a name="l06078"></a>06078 {
<a name="l06079"></a>06079 <span class="keyword">public</span>:
<a name="l06080"></a>06080     <span class="keyword">typedef</span> pack&lt;
<a name="l06081"></a>06081         type0_,
<a name="l06082"></a>06082         type1_,
<a name="l06083"></a>06083         type2_,
<a name="l06084"></a>06084         type3_
<a name="l06085"></a>06085     &gt; input_pack_type;
<a name="l06086"></a>06086 
<a name="l06087"></a>06087     <span class="keyword">typedef</span> pack&lt;
<a name="l06088"></a>06088         type0_
<a name="l06089"></a>06089     &gt; type;
<a name="l06090"></a>06090 
<a name="l06091"></a>06091     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l06092"></a>06092         type&amp; res,
<a name="l06093"></a>06093         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type0&amp; a0,
<a name="l06094"></a>06094         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type1&amp; ,
<a name="l06095"></a>06095         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type2&amp; ,
<a name="l06096"></a>06096         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type3&amp; 
<a name="l06097"></a>06097         ) 
<a name="l06098"></a>06098     {
<a name="l06099"></a>06099         res.set(a0);
<a name="l06100"></a>06100     }
<a name="l06101"></a>06101 
<a name="l06102"></a>06102     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(type&amp; res, <span class="keyword">const</span> input_pack_type&amp; org)
<a name="l06103"></a>06103     {
<a name="l06104"></a>06104         res.set(org.i0);
<a name="l06105"></a>06105         LITE_ARRAY_USE(org);
<a name="l06106"></a>06106     }
<a name="l06107"></a>06107 };
<a name="l06108"></a>06108 
<a name="l06109"></a>06109 <span class="comment">/***********************************************************************************************************/</span>
<a name="l06110"></a>06110 
<a name="l06111"></a>06111 <span class="keyword">template</span>&lt;
<a name="l06112"></a>06112     <span class="keyword">typename</span> type0_,
<a name="l06113"></a>06113     <span class="keyword">typename</span> type1_,
<a name="l06114"></a>06114     <span class="keyword">typename</span> type2_,
<a name="l06115"></a>06115     <span class="keyword">typename</span> type3_
<a name="l06116"></a>06116     &gt;
<a name="l06117"></a>06117 <span class="keyword">class </span>sub_pack&lt;
<a name="l06118"></a>06118     pack&lt;
<a name="l06119"></a>06119         type0_,
<a name="l06120"></a>06120         type1_,
<a name="l06121"></a>06121         type2_,
<a name="l06122"></a>06122         type3_
<a name="l06123"></a>06123     &gt;,
<a name="l06124"></a>06124     false,
<a name="l06125"></a>06125     true,
<a name="l06126"></a>06126     false,
<a name="l06127"></a>06127     false
<a name="l06128"></a>06128     &gt;
<a name="l06129"></a>06129 {
<a name="l06130"></a>06130 <span class="keyword">public</span>:
<a name="l06131"></a>06131     <span class="keyword">typedef</span> pack&lt;
<a name="l06132"></a>06132         type0_,
<a name="l06133"></a>06133         type1_,
<a name="l06134"></a>06134         type2_,
<a name="l06135"></a>06135         type3_
<a name="l06136"></a>06136     &gt; input_pack_type;
<a name="l06137"></a>06137 
<a name="l06138"></a>06138     <span class="keyword">typedef</span> pack&lt;
<a name="l06139"></a>06139         type1_
<a name="l06140"></a>06140     &gt; type;
<a name="l06141"></a>06141 
<a name="l06142"></a>06142     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l06143"></a>06143         type&amp; res,
<a name="l06144"></a>06144         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type0&amp; ,
<a name="l06145"></a>06145         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type1&amp; a1,
<a name="l06146"></a>06146         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type2&amp; ,
<a name="l06147"></a>06147         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type3&amp; 
<a name="l06148"></a>06148         ) 
<a name="l06149"></a>06149     {
<a name="l06150"></a>06150         res.set(a1);
<a name="l06151"></a>06151     }
<a name="l06152"></a>06152 
<a name="l06153"></a>06153     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(type&amp; res, <span class="keyword">const</span> input_pack_type&amp; org)
<a name="l06154"></a>06154     {
<a name="l06155"></a>06155         res.set(org.i1);
<a name="l06156"></a>06156         LITE_ARRAY_USE(org);
<a name="l06157"></a>06157     }
<a name="l06158"></a>06158 };
<a name="l06159"></a>06159 
<a name="l06160"></a>06160 <span class="comment">/***********************************************************************************************************/</span>
<a name="l06161"></a>06161 
<a name="l06162"></a>06162 <span class="keyword">template</span>&lt;
<a name="l06163"></a>06163     <span class="keyword">typename</span> type0_,
<a name="l06164"></a>06164     <span class="keyword">typename</span> type1_,
<a name="l06165"></a>06165     <span class="keyword">typename</span> type2_,
<a name="l06166"></a>06166     <span class="keyword">typename</span> type3_
<a name="l06167"></a>06167     &gt;
<a name="l06168"></a>06168 <span class="keyword">class </span>sub_pack&lt;
<a name="l06169"></a>06169     pack&lt;
<a name="l06170"></a>06170         type0_,
<a name="l06171"></a>06171         type1_,
<a name="l06172"></a>06172         type2_,
<a name="l06173"></a>06173         type3_
<a name="l06174"></a>06174     &gt;,
<a name="l06175"></a>06175     true,
<a name="l06176"></a>06176     true,
<a name="l06177"></a>06177     false,
<a name="l06178"></a>06178     false
<a name="l06179"></a>06179     &gt;
<a name="l06180"></a>06180 {
<a name="l06181"></a>06181 <span class="keyword">public</span>:
<a name="l06182"></a>06182     <span class="keyword">typedef</span> pack&lt;
<a name="l06183"></a>06183         type0_,
<a name="l06184"></a>06184         type1_,
<a name="l06185"></a>06185         type2_,
<a name="l06186"></a>06186         type3_
<a name="l06187"></a>06187     &gt; input_pack_type;
<a name="l06188"></a>06188 
<a name="l06189"></a>06189     <span class="keyword">typedef</span> pack&lt;
<a name="l06190"></a>06190         type0_,
<a name="l06191"></a>06191         type1_
<a name="l06192"></a>06192     &gt; type;
<a name="l06193"></a>06193 
<a name="l06194"></a>06194     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l06195"></a>06195         type&amp; res,
<a name="l06196"></a>06196         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type0&amp; a0,
<a name="l06197"></a>06197         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type1&amp; a1,
<a name="l06198"></a>06198         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type2&amp; ,
<a name="l06199"></a>06199         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type3&amp; 
<a name="l06200"></a>06200         ) 
<a name="l06201"></a>06201     {
<a name="l06202"></a>06202         res.set(a0,a1);
<a name="l06203"></a>06203     }
<a name="l06204"></a>06204 
<a name="l06205"></a>06205     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(type&amp; res, <span class="keyword">const</span> input_pack_type&amp; org)
<a name="l06206"></a>06206     {
<a name="l06207"></a>06207         res.set(org.i0,org.i1);
<a name="l06208"></a>06208         LITE_ARRAY_USE(org);
<a name="l06209"></a>06209     }
<a name="l06210"></a>06210 };
<a name="l06211"></a>06211 
<a name="l06212"></a>06212 <span class="comment">/***********************************************************************************************************/</span>
<a name="l06213"></a>06213 
<a name="l06214"></a>06214 <span class="keyword">template</span>&lt;
<a name="l06215"></a>06215     <span class="keyword">typename</span> type0_,
<a name="l06216"></a>06216     <span class="keyword">typename</span> type1_,
<a name="l06217"></a>06217     <span class="keyword">typename</span> type2_,
<a name="l06218"></a>06218     <span class="keyword">typename</span> type3_
<a name="l06219"></a>06219     &gt;
<a name="l06220"></a>06220 <span class="keyword">class </span>sub_pack&lt;
<a name="l06221"></a>06221     pack&lt;
<a name="l06222"></a>06222         type0_,
<a name="l06223"></a>06223         type1_,
<a name="l06224"></a>06224         type2_,
<a name="l06225"></a>06225         type3_
<a name="l06226"></a>06226     &gt;,
<a name="l06227"></a>06227     false,
<a name="l06228"></a>06228     false,
<a name="l06229"></a>06229     true,
<a name="l06230"></a>06230     false
<a name="l06231"></a>06231     &gt;
<a name="l06232"></a>06232 {
<a name="l06233"></a>06233 <span class="keyword">public</span>:
<a name="l06234"></a>06234     <span class="keyword">typedef</span> pack&lt;
<a name="l06235"></a>06235         type0_,
<a name="l06236"></a>06236         type1_,
<a name="l06237"></a>06237         type2_,
<a name="l06238"></a>06238         type3_
<a name="l06239"></a>06239     &gt; input_pack_type;
<a name="l06240"></a>06240 
<a name="l06241"></a>06241     <span class="keyword">typedef</span> pack&lt;
<a name="l06242"></a>06242         type2_
<a name="l06243"></a>06243     &gt; type;
<a name="l06244"></a>06244 
<a name="l06245"></a>06245     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l06246"></a>06246         type&amp; res,
<a name="l06247"></a>06247         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type0&amp; ,
<a name="l06248"></a>06248         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type1&amp; ,
<a name="l06249"></a>06249         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type2&amp; a2,
<a name="l06250"></a>06250         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type3&amp; 
<a name="l06251"></a>06251         ) 
<a name="l06252"></a>06252     {
<a name="l06253"></a>06253         res.set(a2);
<a name="l06254"></a>06254     }
<a name="l06255"></a>06255 
<a name="l06256"></a>06256     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(type&amp; res, <span class="keyword">const</span> input_pack_type&amp; org)
<a name="l06257"></a>06257     {
<a name="l06258"></a>06258         res.set(org.i2);
<a name="l06259"></a>06259         LITE_ARRAY_USE(org);
<a name="l06260"></a>06260     }
<a name="l06261"></a>06261 };
<a name="l06262"></a>06262 
<a name="l06263"></a>06263 <span class="comment">/***********************************************************************************************************/</span>
<a name="l06264"></a>06264 
<a name="l06265"></a>06265 <span class="keyword">template</span>&lt;
<a name="l06266"></a>06266     <span class="keyword">typename</span> type0_,
<a name="l06267"></a>06267     <span class="keyword">typename</span> type1_,
<a name="l06268"></a>06268     <span class="keyword">typename</span> type2_,
<a name="l06269"></a>06269     <span class="keyword">typename</span> type3_
<a name="l06270"></a>06270     &gt;
<a name="l06271"></a>06271 <span class="keyword">class </span>sub_pack&lt;
<a name="l06272"></a>06272     pack&lt;
<a name="l06273"></a>06273         type0_,
<a name="l06274"></a>06274         type1_,
<a name="l06275"></a>06275         type2_,
<a name="l06276"></a>06276         type3_
<a name="l06277"></a>06277     &gt;,
<a name="l06278"></a>06278     true,
<a name="l06279"></a>06279     false,
<a name="l06280"></a>06280     true,
<a name="l06281"></a>06281     false
<a name="l06282"></a>06282     &gt;
<a name="l06283"></a>06283 {
<a name="l06284"></a>06284 <span class="keyword">public</span>:
<a name="l06285"></a>06285     <span class="keyword">typedef</span> pack&lt;
<a name="l06286"></a>06286         type0_,
<a name="l06287"></a>06287         type1_,
<a name="l06288"></a>06288         type2_,
<a name="l06289"></a>06289         type3_
<a name="l06290"></a>06290     &gt; input_pack_type;
<a name="l06291"></a>06291 
<a name="l06292"></a>06292     <span class="keyword">typedef</span> pack&lt;
<a name="l06293"></a>06293         type0_,
<a name="l06294"></a>06294         type2_
<a name="l06295"></a>06295     &gt; type;
<a name="l06296"></a>06296 
<a name="l06297"></a>06297     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l06298"></a>06298         type&amp; res,
<a name="l06299"></a>06299         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type0&amp; a0,
<a name="l06300"></a>06300         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type1&amp; ,
<a name="l06301"></a>06301         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type2&amp; a2,
<a name="l06302"></a>06302         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type3&amp; 
<a name="l06303"></a>06303         ) 
<a name="l06304"></a>06304     {
<a name="l06305"></a>06305         res.set(a0,a2);
<a name="l06306"></a>06306     }
<a name="l06307"></a>06307 
<a name="l06308"></a>06308     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(type&amp; res, <span class="keyword">const</span> input_pack_type&amp; org)
<a name="l06309"></a>06309     {
<a name="l06310"></a>06310         res.set(org.i0,org.i2);
<a name="l06311"></a>06311         LITE_ARRAY_USE(org);
<a name="l06312"></a>06312     }
<a name="l06313"></a>06313 };
<a name="l06314"></a>06314 
<a name="l06315"></a>06315 <span class="comment">/***********************************************************************************************************/</span>
<a name="l06316"></a>06316 
<a name="l06317"></a>06317 <span class="keyword">template</span>&lt;
<a name="l06318"></a>06318     <span class="keyword">typename</span> type0_,
<a name="l06319"></a>06319     <span class="keyword">typename</span> type1_,
<a name="l06320"></a>06320     <span class="keyword">typename</span> type2_,
<a name="l06321"></a>06321     <span class="keyword">typename</span> type3_
<a name="l06322"></a>06322     &gt;
<a name="l06323"></a>06323 <span class="keyword">class </span>sub_pack&lt;
<a name="l06324"></a>06324     pack&lt;
<a name="l06325"></a>06325         type0_,
<a name="l06326"></a>06326         type1_,
<a name="l06327"></a>06327         type2_,
<a name="l06328"></a>06328         type3_
<a name="l06329"></a>06329     &gt;,
<a name="l06330"></a>06330     false,
<a name="l06331"></a>06331     true,
<a name="l06332"></a>06332     true,
<a name="l06333"></a>06333     false
<a name="l06334"></a>06334     &gt;
<a name="l06335"></a>06335 {
<a name="l06336"></a>06336 <span class="keyword">public</span>:
<a name="l06337"></a>06337     <span class="keyword">typedef</span> pack&lt;
<a name="l06338"></a>06338         type0_,
<a name="l06339"></a>06339         type1_,
<a name="l06340"></a>06340         type2_,
<a name="l06341"></a>06341         type3_
<a name="l06342"></a>06342     &gt; input_pack_type;
<a name="l06343"></a>06343 
<a name="l06344"></a>06344     <span class="keyword">typedef</span> pack&lt;
<a name="l06345"></a>06345         type1_,
<a name="l06346"></a>06346         type2_
<a name="l06347"></a>06347     &gt; type;
<a name="l06348"></a>06348 
<a name="l06349"></a>06349     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l06350"></a>06350         type&amp; res,
<a name="l06351"></a>06351         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type0&amp; ,
<a name="l06352"></a>06352         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type1&amp; a1,
<a name="l06353"></a>06353         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type2&amp; a2,
<a name="l06354"></a>06354         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type3&amp; 
<a name="l06355"></a>06355         ) 
<a name="l06356"></a>06356     {
<a name="l06357"></a>06357         res.set(a1,a2);
<a name="l06358"></a>06358     }
<a name="l06359"></a>06359 
<a name="l06360"></a>06360     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(type&amp; res, <span class="keyword">const</span> input_pack_type&amp; org)
<a name="l06361"></a>06361     {
<a name="l06362"></a>06362         res.set(org.i1,org.i2);
<a name="l06363"></a>06363         LITE_ARRAY_USE(org);
<a name="l06364"></a>06364     }
<a name="l06365"></a>06365 };
<a name="l06366"></a>06366 
<a name="l06367"></a>06367 <span class="comment">/***********************************************************************************************************/</span>
<a name="l06368"></a>06368 
<a name="l06369"></a>06369 <span class="keyword">template</span>&lt;
<a name="l06370"></a>06370     <span class="keyword">typename</span> type0_,
<a name="l06371"></a>06371     <span class="keyword">typename</span> type1_,
<a name="l06372"></a>06372     <span class="keyword">typename</span> type2_,
<a name="l06373"></a>06373     <span class="keyword">typename</span> type3_
<a name="l06374"></a>06374     &gt;
<a name="l06375"></a>06375 <span class="keyword">class </span>sub_pack&lt;
<a name="l06376"></a>06376     pack&lt;
<a name="l06377"></a>06377         type0_,
<a name="l06378"></a>06378         type1_,
<a name="l06379"></a>06379         type2_,
<a name="l06380"></a>06380         type3_
<a name="l06381"></a>06381     &gt;,
<a name="l06382"></a>06382     true,
<a name="l06383"></a>06383     true,
<a name="l06384"></a>06384     true,
<a name="l06385"></a>06385     false
<a name="l06386"></a>06386     &gt;
<a name="l06387"></a>06387 {
<a name="l06388"></a>06388 <span class="keyword">public</span>:
<a name="l06389"></a>06389     <span class="keyword">typedef</span> pack&lt;
<a name="l06390"></a>06390         type0_,
<a name="l06391"></a>06391         type1_,
<a name="l06392"></a>06392         type2_,
<a name="l06393"></a>06393         type3_
<a name="l06394"></a>06394     &gt; input_pack_type;
<a name="l06395"></a>06395 
<a name="l06396"></a>06396     <span class="keyword">typedef</span> pack&lt;
<a name="l06397"></a>06397         type0_,
<a name="l06398"></a>06398         type1_,
<a name="l06399"></a>06399         type2_
<a name="l06400"></a>06400     &gt; type;
<a name="l06401"></a>06401 
<a name="l06402"></a>06402     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l06403"></a>06403         type&amp; res,
<a name="l06404"></a>06404         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type0&amp; a0,
<a name="l06405"></a>06405         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type1&amp; a1,
<a name="l06406"></a>06406         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type2&amp; a2,
<a name="l06407"></a>06407         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type3&amp; 
<a name="l06408"></a>06408         ) 
<a name="l06409"></a>06409     {
<a name="l06410"></a>06410         res.set(a0,a1,a2);
<a name="l06411"></a>06411     }
<a name="l06412"></a>06412 
<a name="l06413"></a>06413     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(type&amp; res, <span class="keyword">const</span> input_pack_type&amp; org)
<a name="l06414"></a>06414     {
<a name="l06415"></a>06415         res.set(org.i0,org.i1,org.i2);
<a name="l06416"></a>06416         LITE_ARRAY_USE(org);
<a name="l06417"></a>06417     }
<a name="l06418"></a>06418 };
<a name="l06419"></a>06419 
<a name="l06420"></a>06420 <span class="comment">/***********************************************************************************************************/</span>
<a name="l06421"></a>06421 
<a name="l06422"></a>06422 <span class="keyword">template</span>&lt;
<a name="l06423"></a>06423     <span class="keyword">typename</span> type0_,
<a name="l06424"></a>06424     <span class="keyword">typename</span> type1_,
<a name="l06425"></a>06425     <span class="keyword">typename</span> type2_,
<a name="l06426"></a>06426     <span class="keyword">typename</span> type3_
<a name="l06427"></a>06427     &gt;
<a name="l06428"></a>06428 <span class="keyword">class </span>sub_pack&lt;
<a name="l06429"></a>06429     pack&lt;
<a name="l06430"></a>06430         type0_,
<a name="l06431"></a>06431         type1_,
<a name="l06432"></a>06432         type2_,
<a name="l06433"></a>06433         type3_
<a name="l06434"></a>06434     &gt;,
<a name="l06435"></a>06435     false,
<a name="l06436"></a>06436     false,
<a name="l06437"></a>06437     false,
<a name="l06438"></a>06438     true
<a name="l06439"></a>06439     &gt;
<a name="l06440"></a>06440 {
<a name="l06441"></a>06441 <span class="keyword">public</span>:
<a name="l06442"></a>06442     <span class="keyword">typedef</span> pack&lt;
<a name="l06443"></a>06443         type0_,
<a name="l06444"></a>06444         type1_,
<a name="l06445"></a>06445         type2_,
<a name="l06446"></a>06446         type3_
<a name="l06447"></a>06447     &gt; input_pack_type;
<a name="l06448"></a>06448 
<a name="l06449"></a>06449     <span class="keyword">typedef</span> pack&lt;
<a name="l06450"></a>06450         type3_
<a name="l06451"></a>06451     &gt; type;
<a name="l06452"></a>06452 
<a name="l06453"></a>06453     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l06454"></a>06454         type&amp; res,
<a name="l06455"></a>06455         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type0&amp; ,
<a name="l06456"></a>06456         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type1&amp; ,
<a name="l06457"></a>06457         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type2&amp; ,
<a name="l06458"></a>06458         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type3&amp; a3
<a name="l06459"></a>06459         ) 
<a name="l06460"></a>06460     {
<a name="l06461"></a>06461         res.set(a3);
<a name="l06462"></a>06462     }
<a name="l06463"></a>06463 
<a name="l06464"></a>06464     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(type&amp; res, <span class="keyword">const</span> input_pack_type&amp; org)
<a name="l06465"></a>06465     {
<a name="l06466"></a>06466         res.set(org.i3);
<a name="l06467"></a>06467         LITE_ARRAY_USE(org);
<a name="l06468"></a>06468     }
<a name="l06469"></a>06469 };
<a name="l06470"></a>06470 
<a name="l06471"></a>06471 <span class="comment">/***********************************************************************************************************/</span>
<a name="l06472"></a>06472 
<a name="l06473"></a>06473 <span class="keyword">template</span>&lt;
<a name="l06474"></a>06474     <span class="keyword">typename</span> type0_,
<a name="l06475"></a>06475     <span class="keyword">typename</span> type1_,
<a name="l06476"></a>06476     <span class="keyword">typename</span> type2_,
<a name="l06477"></a>06477     <span class="keyword">typename</span> type3_
<a name="l06478"></a>06478     &gt;
<a name="l06479"></a>06479 <span class="keyword">class </span>sub_pack&lt;
<a name="l06480"></a>06480     pack&lt;
<a name="l06481"></a>06481         type0_,
<a name="l06482"></a>06482         type1_,
<a name="l06483"></a>06483         type2_,
<a name="l06484"></a>06484         type3_
<a name="l06485"></a>06485     &gt;,
<a name="l06486"></a>06486     true,
<a name="l06487"></a>06487     false,
<a name="l06488"></a>06488     false,
<a name="l06489"></a>06489     true
<a name="l06490"></a>06490     &gt;
<a name="l06491"></a>06491 {
<a name="l06492"></a>06492 <span class="keyword">public</span>:
<a name="l06493"></a>06493     <span class="keyword">typedef</span> pack&lt;
<a name="l06494"></a>06494         type0_,
<a name="l06495"></a>06495         type1_,
<a name="l06496"></a>06496         type2_,
<a name="l06497"></a>06497         type3_
<a name="l06498"></a>06498     &gt; input_pack_type;
<a name="l06499"></a>06499 
<a name="l06500"></a>06500     <span class="keyword">typedef</span> pack&lt;
<a name="l06501"></a>06501         type0_,
<a name="l06502"></a>06502         type3_
<a name="l06503"></a>06503     &gt; type;
<a name="l06504"></a>06504 
<a name="l06505"></a>06505     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l06506"></a>06506         type&amp; res,
<a name="l06507"></a>06507         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type0&amp; a0,
<a name="l06508"></a>06508         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type1&amp; ,
<a name="l06509"></a>06509         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type2&amp; ,
<a name="l06510"></a>06510         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type3&amp; a3
<a name="l06511"></a>06511         ) 
<a name="l06512"></a>06512     {
<a name="l06513"></a>06513         res.set(a0,a3);
<a name="l06514"></a>06514     }
<a name="l06515"></a>06515 
<a name="l06516"></a>06516     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(type&amp; res, <span class="keyword">const</span> input_pack_type&amp; org)
<a name="l06517"></a>06517     {
<a name="l06518"></a>06518         res.set(org.i0,org.i3);
<a name="l06519"></a>06519         LITE_ARRAY_USE(org);
<a name="l06520"></a>06520     }
<a name="l06521"></a>06521 };
<a name="l06522"></a>06522 
<a name="l06523"></a>06523 <span class="comment">/***********************************************************************************************************/</span>
<a name="l06524"></a>06524 
<a name="l06525"></a>06525 <span class="keyword">template</span>&lt;
<a name="l06526"></a>06526     <span class="keyword">typename</span> type0_,
<a name="l06527"></a>06527     <span class="keyword">typename</span> type1_,
<a name="l06528"></a>06528     <span class="keyword">typename</span> type2_,
<a name="l06529"></a>06529     <span class="keyword">typename</span> type3_
<a name="l06530"></a>06530     &gt;
<a name="l06531"></a>06531 <span class="keyword">class </span>sub_pack&lt;
<a name="l06532"></a>06532     pack&lt;
<a name="l06533"></a>06533         type0_,
<a name="l06534"></a>06534         type1_,
<a name="l06535"></a>06535         type2_,
<a name="l06536"></a>06536         type3_
<a name="l06537"></a>06537     &gt;,
<a name="l06538"></a>06538     false,
<a name="l06539"></a>06539     true,
<a name="l06540"></a>06540     false,
<a name="l06541"></a>06541     true
<a name="l06542"></a>06542     &gt;
<a name="l06543"></a>06543 {
<a name="l06544"></a>06544 <span class="keyword">public</span>:
<a name="l06545"></a>06545     <span class="keyword">typedef</span> pack&lt;
<a name="l06546"></a>06546         type0_,
<a name="l06547"></a>06547         type1_,
<a name="l06548"></a>06548         type2_,
<a name="l06549"></a>06549         type3_
<a name="l06550"></a>06550     &gt; input_pack_type;
<a name="l06551"></a>06551 
<a name="l06552"></a>06552     <span class="keyword">typedef</span> pack&lt;
<a name="l06553"></a>06553         type1_,
<a name="l06554"></a>06554         type3_
<a name="l06555"></a>06555     &gt; type;
<a name="l06556"></a>06556 
<a name="l06557"></a>06557     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l06558"></a>06558         type&amp; res,
<a name="l06559"></a>06559         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type0&amp; ,
<a name="l06560"></a>06560         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type1&amp; a1,
<a name="l06561"></a>06561         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type2&amp; ,
<a name="l06562"></a>06562         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type3&amp; a3
<a name="l06563"></a>06563         ) 
<a name="l06564"></a>06564     {
<a name="l06565"></a>06565         res.set(a1,a3);
<a name="l06566"></a>06566     }
<a name="l06567"></a>06567 
<a name="l06568"></a>06568     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(type&amp; res, <span class="keyword">const</span> input_pack_type&amp; org)
<a name="l06569"></a>06569     {
<a name="l06570"></a>06570         res.set(org.i1,org.i3);
<a name="l06571"></a>06571         LITE_ARRAY_USE(org);
<a name="l06572"></a>06572     }
<a name="l06573"></a>06573 };
<a name="l06574"></a>06574 
<a name="l06575"></a>06575 <span class="comment">/***********************************************************************************************************/</span>
<a name="l06576"></a>06576 
<a name="l06577"></a>06577 <span class="keyword">template</span>&lt;
<a name="l06578"></a>06578     <span class="keyword">typename</span> type0_,
<a name="l06579"></a>06579     <span class="keyword">typename</span> type1_,
<a name="l06580"></a>06580     <span class="keyword">typename</span> type2_,
<a name="l06581"></a>06581     <span class="keyword">typename</span> type3_
<a name="l06582"></a>06582     &gt;
<a name="l06583"></a>06583 <span class="keyword">class </span>sub_pack&lt;
<a name="l06584"></a>06584     pack&lt;
<a name="l06585"></a>06585         type0_,
<a name="l06586"></a>06586         type1_,
<a name="l06587"></a>06587         type2_,
<a name="l06588"></a>06588         type3_
<a name="l06589"></a>06589     &gt;,
<a name="l06590"></a>06590     true,
<a name="l06591"></a>06591     true,
<a name="l06592"></a>06592     false,
<a name="l06593"></a>06593     true
<a name="l06594"></a>06594     &gt;
<a name="l06595"></a>06595 {
<a name="l06596"></a>06596 <span class="keyword">public</span>:
<a name="l06597"></a>06597     <span class="keyword">typedef</span> pack&lt;
<a name="l06598"></a>06598         type0_,
<a name="l06599"></a>06599         type1_,
<a name="l06600"></a>06600         type2_,
<a name="l06601"></a>06601         type3_
<a name="l06602"></a>06602     &gt; input_pack_type;
<a name="l06603"></a>06603 
<a name="l06604"></a>06604     <span class="keyword">typedef</span> pack&lt;
<a name="l06605"></a>06605         type0_,
<a name="l06606"></a>06606         type1_,
<a name="l06607"></a>06607         type3_
<a name="l06608"></a>06608     &gt; type;
<a name="l06609"></a>06609 
<a name="l06610"></a>06610     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l06611"></a>06611         type&amp; res,
<a name="l06612"></a>06612         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type0&amp; a0,
<a name="l06613"></a>06613         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type1&amp; a1,
<a name="l06614"></a>06614         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type2&amp; ,
<a name="l06615"></a>06615         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type3&amp; a3
<a name="l06616"></a>06616         ) 
<a name="l06617"></a>06617     {
<a name="l06618"></a>06618         res.set(a0,a1,a3);
<a name="l06619"></a>06619     }
<a name="l06620"></a>06620 
<a name="l06621"></a>06621     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(type&amp; res, <span class="keyword">const</span> input_pack_type&amp; org)
<a name="l06622"></a>06622     {
<a name="l06623"></a>06623         res.set(org.i0,org.i1,org.i3);
<a name="l06624"></a>06624         LITE_ARRAY_USE(org);
<a name="l06625"></a>06625     }
<a name="l06626"></a>06626 };
<a name="l06627"></a>06627 
<a name="l06628"></a>06628 <span class="comment">/***********************************************************************************************************/</span>
<a name="l06629"></a>06629 
<a name="l06630"></a>06630 <span class="keyword">template</span>&lt;
<a name="l06631"></a>06631     <span class="keyword">typename</span> type0_,
<a name="l06632"></a>06632     <span class="keyword">typename</span> type1_,
<a name="l06633"></a>06633     <span class="keyword">typename</span> type2_,
<a name="l06634"></a>06634     <span class="keyword">typename</span> type3_
<a name="l06635"></a>06635     &gt;
<a name="l06636"></a>06636 <span class="keyword">class </span>sub_pack&lt;
<a name="l06637"></a>06637     pack&lt;
<a name="l06638"></a>06638         type0_,
<a name="l06639"></a>06639         type1_,
<a name="l06640"></a>06640         type2_,
<a name="l06641"></a>06641         type3_
<a name="l06642"></a>06642     &gt;,
<a name="l06643"></a>06643     false,
<a name="l06644"></a>06644     false,
<a name="l06645"></a>06645     true,
<a name="l06646"></a>06646     true
<a name="l06647"></a>06647     &gt;
<a name="l06648"></a>06648 {
<a name="l06649"></a>06649 <span class="keyword">public</span>:
<a name="l06650"></a>06650     <span class="keyword">typedef</span> pack&lt;
<a name="l06651"></a>06651         type0_,
<a name="l06652"></a>06652         type1_,
<a name="l06653"></a>06653         type2_,
<a name="l06654"></a>06654         type3_
<a name="l06655"></a>06655     &gt; input_pack_type;
<a name="l06656"></a>06656 
<a name="l06657"></a>06657     <span class="keyword">typedef</span> pack&lt;
<a name="l06658"></a>06658         type2_,
<a name="l06659"></a>06659         type3_
<a name="l06660"></a>06660     &gt; type;
<a name="l06661"></a>06661 
<a name="l06662"></a>06662     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l06663"></a>06663         type&amp; res,
<a name="l06664"></a>06664         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type0&amp; ,
<a name="l06665"></a>06665         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type1&amp; ,
<a name="l06666"></a>06666         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type2&amp; a2,
<a name="l06667"></a>06667         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type3&amp; a3
<a name="l06668"></a>06668         ) 
<a name="l06669"></a>06669     {
<a name="l06670"></a>06670         res.set(a2,a3);
<a name="l06671"></a>06671     }
<a name="l06672"></a>06672 
<a name="l06673"></a>06673     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(type&amp; res, <span class="keyword">const</span> input_pack_type&amp; org)
<a name="l06674"></a>06674     {
<a name="l06675"></a>06675         res.set(org.i2,org.i3);
<a name="l06676"></a>06676         LITE_ARRAY_USE(org);
<a name="l06677"></a>06677     }
<a name="l06678"></a>06678 };
<a name="l06679"></a>06679 
<a name="l06680"></a>06680 <span class="comment">/***********************************************************************************************************/</span>
<a name="l06681"></a>06681 
<a name="l06682"></a>06682 <span class="keyword">template</span>&lt;
<a name="l06683"></a>06683     <span class="keyword">typename</span> type0_,
<a name="l06684"></a>06684     <span class="keyword">typename</span> type1_,
<a name="l06685"></a>06685     <span class="keyword">typename</span> type2_,
<a name="l06686"></a>06686     <span class="keyword">typename</span> type3_
<a name="l06687"></a>06687     &gt;
<a name="l06688"></a>06688 <span class="keyword">class </span>sub_pack&lt;
<a name="l06689"></a>06689     pack&lt;
<a name="l06690"></a>06690         type0_,
<a name="l06691"></a>06691         type1_,
<a name="l06692"></a>06692         type2_,
<a name="l06693"></a>06693         type3_
<a name="l06694"></a>06694     &gt;,
<a name="l06695"></a>06695     true,
<a name="l06696"></a>06696     false,
<a name="l06697"></a>06697     true,
<a name="l06698"></a>06698     true
<a name="l06699"></a>06699     &gt;
<a name="l06700"></a>06700 {
<a name="l06701"></a>06701 <span class="keyword">public</span>:
<a name="l06702"></a>06702     <span class="keyword">typedef</span> pack&lt;
<a name="l06703"></a>06703         type0_,
<a name="l06704"></a>06704         type1_,
<a name="l06705"></a>06705         type2_,
<a name="l06706"></a>06706         type3_
<a name="l06707"></a>06707     &gt; input_pack_type;
<a name="l06708"></a>06708 
<a name="l06709"></a>06709     <span class="keyword">typedef</span> pack&lt;
<a name="l06710"></a>06710         type0_,
<a name="l06711"></a>06711         type2_,
<a name="l06712"></a>06712         type3_
<a name="l06713"></a>06713     &gt; type;
<a name="l06714"></a>06714 
<a name="l06715"></a>06715     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l06716"></a>06716         type&amp; res,
<a name="l06717"></a>06717         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type0&amp; a0,
<a name="l06718"></a>06718         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type1&amp; ,
<a name="l06719"></a>06719         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type2&amp; a2,
<a name="l06720"></a>06720         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type3&amp; a3
<a name="l06721"></a>06721         ) 
<a name="l06722"></a>06722     {
<a name="l06723"></a>06723         res.set(a0,a2,a3);
<a name="l06724"></a>06724     }
<a name="l06725"></a>06725 
<a name="l06726"></a>06726     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(type&amp; res, <span class="keyword">const</span> input_pack_type&amp; org)
<a name="l06727"></a>06727     {
<a name="l06728"></a>06728         res.set(org.i0,org.i2,org.i3);
<a name="l06729"></a>06729         LITE_ARRAY_USE(org);
<a name="l06730"></a>06730     }
<a name="l06731"></a>06731 };
<a name="l06732"></a>06732 
<a name="l06733"></a>06733 <span class="comment">/***********************************************************************************************************/</span>
<a name="l06734"></a>06734 
<a name="l06735"></a>06735 <span class="keyword">template</span>&lt;
<a name="l06736"></a>06736     <span class="keyword">typename</span> type0_,
<a name="l06737"></a>06737     <span class="keyword">typename</span> type1_,
<a name="l06738"></a>06738     <span class="keyword">typename</span> type2_,
<a name="l06739"></a>06739     <span class="keyword">typename</span> type3_
<a name="l06740"></a>06740     &gt;
<a name="l06741"></a>06741 <span class="keyword">class </span>sub_pack&lt;
<a name="l06742"></a>06742     pack&lt;
<a name="l06743"></a>06743         type0_,
<a name="l06744"></a>06744         type1_,
<a name="l06745"></a>06745         type2_,
<a name="l06746"></a>06746         type3_
<a name="l06747"></a>06747     &gt;,
<a name="l06748"></a>06748     false,
<a name="l06749"></a>06749     true,
<a name="l06750"></a>06750     true,
<a name="l06751"></a>06751     true
<a name="l06752"></a>06752     &gt;
<a name="l06753"></a>06753 {
<a name="l06754"></a>06754 <span class="keyword">public</span>:
<a name="l06755"></a>06755     <span class="keyword">typedef</span> pack&lt;
<a name="l06756"></a>06756         type0_,
<a name="l06757"></a>06757         type1_,
<a name="l06758"></a>06758         type2_,
<a name="l06759"></a>06759         type3_
<a name="l06760"></a>06760     &gt; input_pack_type;
<a name="l06761"></a>06761 
<a name="l06762"></a>06762     <span class="keyword">typedef</span> pack&lt;
<a name="l06763"></a>06763         type1_,
<a name="l06764"></a>06764         type2_,
<a name="l06765"></a>06765         type3_
<a name="l06766"></a>06766     &gt; type;
<a name="l06767"></a>06767 
<a name="l06768"></a>06768     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l06769"></a>06769         type&amp; res,
<a name="l06770"></a>06770         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type0&amp; ,
<a name="l06771"></a>06771         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type1&amp; a1,
<a name="l06772"></a>06772         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type2&amp; a2,
<a name="l06773"></a>06773         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type3&amp; a3
<a name="l06774"></a>06774         ) 
<a name="l06775"></a>06775     {
<a name="l06776"></a>06776         res.set(a1,a2,a3);
<a name="l06777"></a>06777     }
<a name="l06778"></a>06778 
<a name="l06779"></a>06779     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(type&amp; res, <span class="keyword">const</span> input_pack_type&amp; org)
<a name="l06780"></a>06780     {
<a name="l06781"></a>06781         res.set(org.i1,org.i2,org.i3);
<a name="l06782"></a>06782         LITE_ARRAY_USE(org);
<a name="l06783"></a>06783     }
<a name="l06784"></a>06784 };
<a name="l06785"></a>06785 
<a name="l06786"></a>06786 <span class="comment">/***********************************************************************************************************/</span>
<a name="l06787"></a>06787 
<a name="l06788"></a>06788 <span class="keyword">template</span>&lt;
<a name="l06789"></a>06789     <span class="keyword">typename</span> type0_,
<a name="l06790"></a>06790     <span class="keyword">typename</span> type1_,
<a name="l06791"></a>06791     <span class="keyword">typename</span> type2_,
<a name="l06792"></a>06792     <span class="keyword">typename</span> type3_
<a name="l06793"></a>06793     &gt;
<a name="l06794"></a>06794 <span class="keyword">class </span>sub_pack&lt;
<a name="l06795"></a>06795     pack&lt;
<a name="l06796"></a>06796         type0_,
<a name="l06797"></a>06797         type1_,
<a name="l06798"></a>06798         type2_,
<a name="l06799"></a>06799         type3_
<a name="l06800"></a>06800     &gt;,
<a name="l06801"></a>06801     true,
<a name="l06802"></a>06802     true,
<a name="l06803"></a>06803     true,
<a name="l06804"></a>06804     true
<a name="l06805"></a>06805     &gt;
<a name="l06806"></a>06806 {
<a name="l06807"></a>06807 <span class="keyword">public</span>:
<a name="l06808"></a>06808     <span class="keyword">typedef</span> pack&lt;
<a name="l06809"></a>06809         type0_,
<a name="l06810"></a>06810         type1_,
<a name="l06811"></a>06811         type2_,
<a name="l06812"></a>06812         type3_
<a name="l06813"></a>06813     &gt; input_pack_type;
<a name="l06814"></a>06814 
<a name="l06815"></a>06815     <span class="keyword">typedef</span> pack&lt;
<a name="l06816"></a>06816         type0_,
<a name="l06817"></a>06817         type1_,
<a name="l06818"></a>06818         type2_,
<a name="l06819"></a>06819         type3_
<a name="l06820"></a>06820     &gt; type;
<a name="l06821"></a>06821 
<a name="l06822"></a>06822     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(
<a name="l06823"></a>06823         type&amp; res,
<a name="l06824"></a>06824         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type0&amp; a0,
<a name="l06825"></a>06825         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type1&amp; a1,
<a name="l06826"></a>06826         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type2&amp; a2,
<a name="l06827"></a>06827         <span class="keyword">const</span> <span class="keyword">typename</span> input_pack_type::type3&amp; a3
<a name="l06828"></a>06828         ) 
<a name="l06829"></a>06829     {
<a name="l06830"></a>06830         res.set(a0,a1,a2,a3);
<a name="l06831"></a>06831     }
<a name="l06832"></a>06832 
<a name="l06833"></a>06833     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <span class="keyword">set</span>(type&amp; res, <span class="keyword">const</span> input_pack_type&amp; org)
<a name="l06834"></a>06834     {
<a name="l06835"></a>06835         res.set(org.i0,org.i1,org.i2,org.i3);
<a name="l06836"></a>06836         LITE_ARRAY_USE(org);
<a name="l06837"></a>06837     }
<a name="l06838"></a>06838 };
<a name="l06839"></a>06839 
<a name="l06840"></a>06840 <span class="comment">/***********************************************************************************************************/</span>
<a name="l06841"></a>06841 
<a name="l06842"></a>06842 <span class="preprocessor">#endif // !DOCUMENTATION_ONLY</span>
<a name="l06843"></a>06843 <span class="preprocessor"></span>
<a name="l06844"></a>06844 <span class="comment">/***********************************************************************************************************/</span>
<a name="l06845"></a>06845 <span class="comment">/* get_type ************************************************************************************************/</span>
<a name="l06846"></a>06846 <span class="comment">/***********************************************************************************************************/</span>
<a name="l06847"></a>06847 
<a name="l06848"></a>06848 <span class="preprocessor">#ifdef DOCUMENTATION_ONLY</span>
<a name="l06849"></a>06849 <span class="preprocessor"></span>
<a name="l06870"></a>06870 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> index_, <span class="keyword">typename</span> type_&gt;
<a name="l06871"></a><a class="code" href="structlite_1_1get__type.html">06871</a> <span class="keyword">struct </span><a class="code" href="structlite_1_1get__type.html" title="This class can be used to retrieve the type of the elements of a pack type.">get_type</a>
<a name="l06872"></a>06872 {
<a name="l06873"></a><a class="code" href="structlite_1_1get__type.html#a33cd0429e095ee5f3cbcd433c96f1a7c">06873</a>     <span class="keyword">typedef</span> ... type; 
<a name="l06874"></a>06874 };
<a name="l06875"></a>06875 
<a name="l06876"></a>06876 <span class="preprocessor">#else // DOCUMENTATION_ONLY</span>
<a name="l06877"></a>06877 <span class="preprocessor"></span>
<a name="l06878"></a>06878 
<a name="l06879"></a>06879 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> index_, <span class="keyword">typename</span> type_&gt;
<a name="l06880"></a>06880 <span class="keyword">struct </span><a class="code" href="structlite_1_1get__type.html" title="This class can be used to retrieve the type of the elements of a pack type.">get_type</a>;
<a name="l06881"></a>06881 
<a name="l06882"></a>06882 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_&gt;
<a name="l06883"></a>06883 <span class="keyword">struct </span><a class="code" href="structlite_1_1get__type.html" title="This class can be used to retrieve the type of the elements of a pack type.">get_type</a>&lt;0, type_&gt;
<a name="l06884"></a>06884 {
<a name="l06885"></a>06885     <span class="keyword">typedef</span> <span class="keyword">typename</span> type_::type0 type;
<a name="l06886"></a>06886 };
<a name="l06887"></a>06887 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_&gt;
<a name="l06888"></a>06888 <span class="keyword">struct </span>get_type&lt;1, type_&gt;
<a name="l06889"></a>06889 {
<a name="l06890"></a>06890     <span class="keyword">typedef</span> <span class="keyword">typename</span> type_::type1 type;
<a name="l06891"></a>06891 };
<a name="l06892"></a>06892 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_&gt;
<a name="l06893"></a>06893 <span class="keyword">struct </span>get_type&lt;2, type_&gt;
<a name="l06894"></a>06894 {
<a name="l06895"></a>06895     <span class="keyword">typedef</span> <span class="keyword">typename</span> type_::type2 type;
<a name="l06896"></a>06896 };
<a name="l06897"></a>06897 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_&gt;
<a name="l06898"></a>06898 <span class="keyword">struct </span>get_type&lt;3, type_&gt;
<a name="l06899"></a>06899 {
<a name="l06900"></a>06900     <span class="keyword">typedef</span> <span class="keyword">typename</span> type_::type3 type;
<a name="l06901"></a>06901 };
<a name="l06902"></a>06902 
<a name="l06903"></a>06903 <span class="preprocessor">#endif // !DOCUMENTATION_ONLY</span>
<a name="l06904"></a>06904 <span class="preprocessor"></span>
<a name="l06905"></a>06905 <span class="comment">/***********************************************************************************************************/</span>
<a name="l06906"></a>06906 <span class="comment">/* get *****************************************************************************************************/</span>
<a name="l06907"></a>06907 <span class="comment">/***********************************************************************************************************/</span>
<a name="l06908"></a>06908 
<a name="l06909"></a>06909 <span class="preprocessor">#ifdef DOCUMENTATION_ONLY</span>
<a name="l06910"></a>06910 <span class="preprocessor"></span>
<a name="l06928"></a>06928 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> index_, <span class="keyword">typename</span> type_&gt;
<a name="l06929"></a>06929 <span class="keyword">typename</span> get_type&lt;index_, type_&gt;::type <span class="keyword">get</span>(<span class="keyword">const</span> type_&amp; a);
<a name="l06930"></a>06930 
<a name="l06931"></a>06931 <span class="preprocessor">#else // DOCUMENTATION_ONLY</span>
<a name="l06932"></a>06932 <span class="preprocessor"></span>
<a name="l06933"></a>06933 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> index_, <span class="keyword">typename</span> type_&gt;
<a name="l06934"></a>06934 LITE_INLINE 
<a name="l06935"></a>06935 <span class="keyword">typename</span> detail::enable_if&lt;index_==0, typename get_type&lt;index_, type_&gt;::type&gt;::type 
<a name="l06936"></a>06936 <span class="keyword">get</span>(<span class="keyword">const</span> type_&amp; a)
<a name="l06937"></a>06937 {
<a name="l06938"></a>06938     LITE_ARRAY_USE(a);
<a name="l06939"></a>06939     <span class="keywordflow">return</span> a.i0;
<a name="l06940"></a>06940 };
<a name="l06941"></a>06941 
<a name="l06942"></a>06942 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> index_, <span class="keyword">typename</span> type_&gt;
<a name="l06943"></a>06943 LITE_INLINE 
<a name="l06944"></a>06944 <span class="keyword">typename</span> detail::enable_if&lt;index_==1, typename get_type&lt;index_, type_&gt;::type&gt;::type 
<a name="l06945"></a>06945 <span class="keyword">get</span>(<span class="keyword">const</span> type_&amp; a)
<a name="l06946"></a>06946 {
<a name="l06947"></a>06947     LITE_ARRAY_USE(a);
<a name="l06948"></a>06948     <span class="keywordflow">return</span> a.i1;
<a name="l06949"></a>06949 };
<a name="l06950"></a>06950 
<a name="l06951"></a>06951 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> index_, <span class="keyword">typename</span> type_&gt;
<a name="l06952"></a>06952 LITE_INLINE 
<a name="l06953"></a>06953 <span class="keyword">typename</span> detail::enable_if&lt;index_==2, typename get_type&lt;index_, type_&gt;::type&gt;::type 
<a name="l06954"></a>06954 <span class="keyword">get</span>(<span class="keyword">const</span> type_&amp; a)
<a name="l06955"></a>06955 {
<a name="l06956"></a>06956     LITE_ARRAY_USE(a);
<a name="l06957"></a>06957     <span class="keywordflow">return</span> a.i2;
<a name="l06958"></a>06958 };
<a name="l06959"></a>06959 
<a name="l06960"></a>06960 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> index_, <span class="keyword">typename</span> type_&gt;
<a name="l06961"></a>06961 LITE_INLINE 
<a name="l06962"></a>06962 <span class="keyword">typename</span> detail::enable_if&lt;index_==3, typename get_type&lt;index_, type_&gt;::type&gt;::type 
<a name="l06963"></a>06963 <span class="keyword">get</span>(<span class="keyword">const</span> type_&amp; a)
<a name="l06964"></a>06964 {
<a name="l06965"></a>06965     LITE_ARRAY_USE(a);
<a name="l06966"></a>06966     <span class="keywordflow">return</span> a.i3;
<a name="l06967"></a>06967 };
<a name="l06968"></a>06968 
<a name="l06969"></a>06969 
<a name="l06970"></a>06970 <span class="preprocessor">#endif // DOCUMENTATION_ONLY</span>
<a name="l06971"></a>06971 <span class="preprocessor"></span><span class="comment">/***********************************************************************************************************/</span>
<a name="l06972"></a>06972 <span class="comment">/* set *****************************************************************************************************/</span>
<a name="l06973"></a>06973 <span class="comment">/***********************************************************************************************************/</span>
<a name="l06974"></a>06974 
<a name="l06975"></a>06975 <span class="preprocessor">#ifdef DOCUMENTATION_ONLY</span>
<a name="l06976"></a>06976 <span class="preprocessor"></span>
<a name="l06997"></a>06997 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> index_, <span class="keyword">typename</span> type_,  <span class="keyword">typename</span> value_type_&gt;
<a name="l06998"></a>06998 <span class="keywordtype">void</span> <span class="keyword">set</span>(type_&amp; a, <span class="keyword">const</span> value_type_&amp; v);
<a name="l06999"></a>06999 
<a name="l07000"></a>07000 <span class="preprocessor">#else // DOCUMENTATION_ONLY</span>
<a name="l07001"></a>07001 <span class="preprocessor"></span>
<a name="l07002"></a>07002 
<a name="l07003"></a>07003 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> index_, <span class="keyword">typename</span> type_,  <span class="keyword">typename</span> value_type_&gt;
<a name="l07004"></a>07004 LITE_INLINE 
<a name="l07005"></a>07005 <span class="keyword">typename</span> detail::enable_if&lt;index_==0 &amp;&amp; type_::is_const0&gt;::type 
<a name="l07006"></a>07006 <span class="keyword">set</span>(type_&amp;, <span class="keyword">const</span> value_type_&amp;)
<a name="l07007"></a>07007 {}
<a name="l07008"></a>07008 
<a name="l07009"></a>07009 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> index_, <span class="keyword">typename</span> type_,  <span class="keyword">typename</span> value_type_&gt;
<a name="l07010"></a>07010 LITE_INLINE 
<a name="l07011"></a>07011 <span class="keyword">typename</span> detail::enable_if&lt;index_==0 &amp;&amp; !type_::is_const0&gt;::type 
<a name="l07012"></a>07012 <span class="keyword">set</span>(type_&amp; a, <span class="keyword">const</span> value_type_&amp; v)
<a name="l07013"></a>07013 {
<a name="l07014"></a>07014     a.i0 = v;
<a name="l07015"></a>07015 }
<a name="l07016"></a>07016 
<a name="l07017"></a>07017 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> index_, <span class="keyword">typename</span> type_,  <span class="keyword">typename</span> value_type_&gt;
<a name="l07018"></a>07018 LITE_INLINE 
<a name="l07019"></a>07019 <span class="keyword">typename</span> detail::enable_if&lt;index_==1 &amp;&amp; type_::is_const1&gt;::type 
<a name="l07020"></a>07020 <span class="keyword">set</span>(type_&amp;, <span class="keyword">const</span> value_type_&amp;)
<a name="l07021"></a>07021 {}
<a name="l07022"></a>07022 
<a name="l07023"></a>07023 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> index_, <span class="keyword">typename</span> type_,  <span class="keyword">typename</span> value_type_&gt;
<a name="l07024"></a>07024 LITE_INLINE 
<a name="l07025"></a>07025 <span class="keyword">typename</span> detail::enable_if&lt;index_==1 &amp;&amp; !type_::is_const1&gt;::type 
<a name="l07026"></a>07026 <span class="keyword">set</span>(type_&amp; a, <span class="keyword">const</span> value_type_&amp; v)
<a name="l07027"></a>07027 {
<a name="l07028"></a>07028     a.i1 = v;
<a name="l07029"></a>07029 }
<a name="l07030"></a>07030 
<a name="l07031"></a>07031 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> index_, <span class="keyword">typename</span> type_,  <span class="keyword">typename</span> value_type_&gt;
<a name="l07032"></a>07032 LITE_INLINE 
<a name="l07033"></a>07033 <span class="keyword">typename</span> detail::enable_if&lt;index_==2 &amp;&amp; type_::is_const2&gt;::type 
<a name="l07034"></a>07034 <span class="keyword">set</span>(type_&amp;, <span class="keyword">const</span> value_type_&amp;)
<a name="l07035"></a>07035 {}
<a name="l07036"></a>07036 
<a name="l07037"></a>07037 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> index_, <span class="keyword">typename</span> type_,  <span class="keyword">typename</span> value_type_&gt;
<a name="l07038"></a>07038 LITE_INLINE 
<a name="l07039"></a>07039 <span class="keyword">typename</span> detail::enable_if&lt;index_==2 &amp;&amp; !type_::is_const2&gt;::type 
<a name="l07040"></a>07040 <span class="keyword">set</span>(type_&amp; a, <span class="keyword">const</span> value_type_&amp; v)
<a name="l07041"></a>07041 {
<a name="l07042"></a>07042     a.i2 = v;
<a name="l07043"></a>07043 }
<a name="l07044"></a>07044 
<a name="l07045"></a>07045 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> index_, <span class="keyword">typename</span> type_,  <span class="keyword">typename</span> value_type_&gt;
<a name="l07046"></a>07046 LITE_INLINE 
<a name="l07047"></a>07047 <span class="keyword">typename</span> detail::enable_if&lt;index_==3 &amp;&amp; type_::is_const3&gt;::type 
<a name="l07048"></a>07048 <span class="keyword">set</span>(type_&amp;, <span class="keyword">const</span> value_type_&amp;)
<a name="l07049"></a>07049 {}
<a name="l07050"></a>07050 
<a name="l07051"></a>07051 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> index_, <span class="keyword">typename</span> type_,  <span class="keyword">typename</span> value_type_&gt;
<a name="l07052"></a>07052 LITE_INLINE 
<a name="l07053"></a>07053 <span class="keyword">typename</span> detail::enable_if&lt;index_==3 &amp;&amp; !type_::is_const3&gt;::type 
<a name="l07054"></a>07054 <span class="keyword">set</span>(type_&amp; a, <span class="keyword">const</span> value_type_&amp; v)
<a name="l07055"></a>07055 {
<a name="l07056"></a>07056     a.i3 = v;
<a name="l07057"></a>07057 }
<a name="l07058"></a>07058 
<a name="l07059"></a>07059 <span class="preprocessor">#endif // DOCUMENTATION_ONLY</span>
<a name="l07060"></a>07060 <span class="preprocessor"></span><span class="comment">/***********************************************************************************************************/</span>
<a name="l07061"></a>07061 <span class="comment">/* pack, operator&lt; *****************************************************************************************/</span>
<a name="l07062"></a>07062 <span class="comment">/***********************************************************************************************************/</span>
<a name="l07063"></a>07063 <span class="preprocessor">#ifdef DOCUMENTATION_ONLY</span>
<a name="l07064"></a>07064 <span class="preprocessor"></span>
<a name="l07069"></a>07069 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> l_type0_, ..., <span class="keyword">typename</span> l_typeN_, <span class="keyword">typename</span> r_type0_, ..., <span class="keyword">typename</span> r_typeN_&gt;
<a name="l07070"></a>07070 <span class="keywordtype">bool</span> <a class="code" href="group__array__tools.html#ga854b353df557e131b122b51e9cd9d141">operator&lt;</a>(<span class="keyword">const</span> pack&lt;l_type0_, ..., l_typeN_&gt;&amp;a, <span class="keyword">const</span> pack&lt;r_type0_, ..., r_typeN_&gt;&amp; b);
<a name="l07071"></a>07071 <span class="preprocessor">#endif // DOCUMENTATION_ONLY</span>
<a name="l07072"></a>07072 <span class="preprocessor"></span>
<a name="l07073"></a>07073 LITE_INLINE
<a name="l07074"></a>07074 <span class="keywordtype">bool</span> operator&lt;(const pack&lt;&gt;&amp;, <span class="keyword">const</span> pack&lt;&gt;&amp;)
<a name="l07075"></a>07075 { 
<a name="l07076"></a>07076     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l07077"></a>07077 }
<a name="l07078"></a>07078 
<a name="l07079"></a>07079 <span class="keyword">template</span>&lt;
<a name="l07080"></a>07080     <span class="keyword">typename</span> l_type0_,
<a name="l07081"></a>07081     <span class="keyword">typename</span> r_type0_ 
<a name="l07082"></a>07082 &gt;
<a name="l07083"></a>07083 LITE_INLINE
<a name="l07084"></a>07084 <span class="keywordtype">bool</span> <a class="code" href="group__array__tools.html#ga854b353df557e131b122b51e9cd9d141">operator&lt;</a>(
<a name="l07085"></a>07085     <span class="keyword">const</span> pack&lt;l_type0_&gt;&amp; a,
<a name="l07086"></a>07086     <span class="keyword">const</span> pack&lt;r_type0_&gt;&amp; b)
<a name="l07087"></a>07087 {
<a name="l07088"></a>07088     <span class="keywordflow">return</span> a.i0&lt;b.i0;
<a name="l07089"></a>07089     LITE_ARRAY_USE(a);
<a name="l07090"></a>07090     LITE_ARRAY_USE(b);
<a name="l07091"></a>07091 }
<a name="l07092"></a>07092 
<a name="l07093"></a>07093 <span class="keyword">template</span>&lt;
<a name="l07094"></a>07094     <span class="keyword">typename</span> l_type0_,
<a name="l07095"></a>07095     <span class="keyword">typename</span> l_type1_,
<a name="l07096"></a>07096     <span class="keyword">typename</span> r_type0_, 
<a name="l07097"></a>07097     <span class="keyword">typename</span> r_type1_ 
<a name="l07098"></a>07098 &gt;
<a name="l07099"></a>07099 LITE_INLINE
<a name="l07100"></a>07100 <span class="keywordtype">bool</span> <a class="code" href="group__array__tools.html#ga854b353df557e131b122b51e9cd9d141">operator&lt;</a>(
<a name="l07101"></a>07101     <span class="keyword">const</span> pack&lt;l_type0_, l_type1_&gt;&amp; a,
<a name="l07102"></a>07102     <span class="keyword">const</span> pack&lt;r_type0_, r_type1_&gt;&amp; b)
<a name="l07103"></a>07103 {
<a name="l07104"></a>07104     <span class="keywordflow">return</span> a.i0&lt;b.i0 &amp;&amp; a.i1&lt;b.i1;
<a name="l07105"></a>07105     LITE_ARRAY_USE(a);
<a name="l07106"></a>07106     LITE_ARRAY_USE(b);
<a name="l07107"></a>07107 }
<a name="l07108"></a>07108 
<a name="l07109"></a>07109 <span class="keyword">template</span>&lt;
<a name="l07110"></a>07110     <span class="keyword">typename</span> l_type0_,
<a name="l07111"></a>07111     <span class="keyword">typename</span> l_type1_,
<a name="l07112"></a>07112     <span class="keyword">typename</span> l_type2_,
<a name="l07113"></a>07113     <span class="keyword">typename</span> r_type0_, 
<a name="l07114"></a>07114     <span class="keyword">typename</span> r_type1_, 
<a name="l07115"></a>07115     <span class="keyword">typename</span> r_type2_ 
<a name="l07116"></a>07116 &gt;
<a name="l07117"></a>07117 LITE_INLINE
<a name="l07118"></a>07118 <span class="keywordtype">bool</span> <a class="code" href="group__array__tools.html#ga854b353df557e131b122b51e9cd9d141">operator&lt;</a>(
<a name="l07119"></a>07119     <span class="keyword">const</span> pack&lt;l_type0_, l_type1_, l_type2_&gt;&amp; a,
<a name="l07120"></a>07120     <span class="keyword">const</span> pack&lt;r_type0_, r_type1_, r_type2_&gt;&amp; b)
<a name="l07121"></a>07121 {
<a name="l07122"></a>07122     <span class="keywordflow">return</span> a.i0&lt;b.i0 &amp;&amp; a.i1&lt;b.i1 &amp;&amp; a.i2&lt;b.i2;
<a name="l07123"></a>07123     LITE_ARRAY_USE(a);
<a name="l07124"></a>07124     LITE_ARRAY_USE(b);
<a name="l07125"></a>07125 }
<a name="l07126"></a>07126 
<a name="l07127"></a>07127 <span class="comment">/***********************************************************************************************************/</span>
<a name="l07128"></a>07128 <span class="comment">/* pack, operator&lt;= ****************************************************************************************/</span>
<a name="l07129"></a>07129 <span class="comment">/***********************************************************************************************************/</span>
<a name="l07130"></a>07130 <span class="preprocessor">#ifdef DOCUMENTATION_ONLY</span>
<a name="l07131"></a>07131 <span class="preprocessor"></span>
<a name="l07136"></a>07136 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> l_type0_, ..., <span class="keyword">typename</span> l_typeN_, <span class="keyword">typename</span> r_type0_, ..., <span class="keyword">typename</span> r_typeN_&gt;
<a name="l07137"></a>07137 <span class="keywordtype">bool</span> <a class="code" href="group__array__tools.html#ga1bdec666b7f667470b9333c39408da25">operator&lt;=</a>(<span class="keyword">const</span> pack&lt;l_type0_, ..., l_typeN_&gt;&amp;a, <span class="keyword">const</span> pack&lt;r_type0_, ..., r_typeN_&gt;&amp; b);
<a name="l07138"></a>07138 <span class="preprocessor">#endif // DOCUMENTATION_ONLY</span>
<a name="l07139"></a>07139 <span class="preprocessor"></span>
<a name="l07140"></a>07140 LITE_INLINE
<a name="l07141"></a>07141 <span class="keywordtype">bool</span> operator&lt;=(const pack&lt;&gt;&amp;, <span class="keyword">const</span> pack&lt;&gt;&amp;)
<a name="l07142"></a>07142 { 
<a name="l07143"></a>07143     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l07144"></a>07144 }
<a name="l07145"></a>07145 
<a name="l07146"></a>07146 <span class="keyword">template</span>&lt;
<a name="l07147"></a>07147     <span class="keyword">typename</span> l_type0_,
<a name="l07148"></a>07148     <span class="keyword">typename</span> r_type0_ 
<a name="l07149"></a>07149 &gt;
<a name="l07150"></a>07150 LITE_INLINE
<a name="l07151"></a>07151 <span class="keywordtype">bool</span> <a class="code" href="group__array__tools.html#ga1bdec666b7f667470b9333c39408da25">operator&lt;=</a>(
<a name="l07152"></a>07152     <span class="keyword">const</span> pack&lt;l_type0_&gt;&amp; a,
<a name="l07153"></a>07153     <span class="keyword">const</span> pack&lt;r_type0_&gt;&amp; b)
<a name="l07154"></a>07154 {
<a name="l07155"></a>07155     <span class="keywordflow">return</span> a.i0&lt;=b.i0;
<a name="l07156"></a>07156     LITE_ARRAY_USE(a);
<a name="l07157"></a>07157     LITE_ARRAY_USE(b);
<a name="l07158"></a>07158 }
<a name="l07159"></a>07159 
<a name="l07160"></a>07160 <span class="keyword">template</span>&lt;
<a name="l07161"></a>07161     <span class="keyword">typename</span> l_type0_,
<a name="l07162"></a>07162     <span class="keyword">typename</span> l_type1_,
<a name="l07163"></a>07163     <span class="keyword">typename</span> r_type0_, 
<a name="l07164"></a>07164     <span class="keyword">typename</span> r_type1_ 
<a name="l07165"></a>07165 &gt;
<a name="l07166"></a>07166 LITE_INLINE
<a name="l07167"></a>07167 <span class="keywordtype">bool</span> <a class="code" href="group__array__tools.html#ga1bdec666b7f667470b9333c39408da25">operator&lt;=</a>(
<a name="l07168"></a>07168     <span class="keyword">const</span> pack&lt;l_type0_, l_type1_&gt;&amp; a,
<a name="l07169"></a>07169     <span class="keyword">const</span> pack&lt;r_type0_, r_type1_&gt;&amp; b)
<a name="l07170"></a>07170 {
<a name="l07171"></a>07171     <span class="keywordflow">return</span> a.i0&lt;=b.i0 &amp;&amp; a.i1&lt;=b.i1;
<a name="l07172"></a>07172     LITE_ARRAY_USE(a);
<a name="l07173"></a>07173     LITE_ARRAY_USE(b);
<a name="l07174"></a>07174 }
<a name="l07175"></a>07175 
<a name="l07176"></a>07176 <span class="keyword">template</span>&lt;
<a name="l07177"></a>07177     <span class="keyword">typename</span> l_type0_,
<a name="l07178"></a>07178     <span class="keyword">typename</span> l_type1_,
<a name="l07179"></a>07179     <span class="keyword">typename</span> l_type2_,
<a name="l07180"></a>07180     <span class="keyword">typename</span> r_type0_, 
<a name="l07181"></a>07181     <span class="keyword">typename</span> r_type1_, 
<a name="l07182"></a>07182     <span class="keyword">typename</span> r_type2_ 
<a name="l07183"></a>07183 &gt;
<a name="l07184"></a>07184 LITE_INLINE
<a name="l07185"></a>07185 <span class="keywordtype">bool</span> <a class="code" href="group__array__tools.html#ga1bdec666b7f667470b9333c39408da25">operator&lt;=</a>(
<a name="l07186"></a>07186     <span class="keyword">const</span> pack&lt;l_type0_, l_type1_, l_type2_&gt;&amp; a,
<a name="l07187"></a>07187     <span class="keyword">const</span> pack&lt;r_type0_, r_type1_, r_type2_&gt;&amp; b)
<a name="l07188"></a>07188 {
<a name="l07189"></a>07189     <span class="keywordflow">return</span> a.i0&lt;=b.i0 &amp;&amp; a.i1&lt;=b.i1 &amp;&amp; a.i2&lt;=b.i2;
<a name="l07190"></a>07190     LITE_ARRAY_USE(a);
<a name="l07191"></a>07191     LITE_ARRAY_USE(b);
<a name="l07192"></a>07192 }
<a name="l07193"></a>07193 
<a name="l07194"></a>07194 <span class="comment">/***********************************************************************************************************/</span>
<a name="l07195"></a>07195 <span class="comment">/* pack, operator== ****************************************************************************************/</span>
<a name="l07196"></a>07196 <span class="comment">/***********************************************************************************************************/</span>
<a name="l07197"></a>07197 <span class="preprocessor">#ifdef DOCUMENTATION_ONLY</span>
<a name="l07198"></a>07198 <span class="preprocessor"></span>
<a name="l07203"></a>07203 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> l_type0_, ..., <span class="keyword">typename</span> l_typeN_, <span class="keyword">typename</span> r_type0_, ..., <span class="keyword">typename</span> r_typeN_&gt;
<a name="l07204"></a>07204 <span class="keywordtype">bool</span> <a class="code" href="group__array__tools.html#gafb4665bc1c0357dfad90b38e7db87b42">operator==</a>(<span class="keyword">const</span> pack&lt;l_type0_, ..., l_typeN_&gt;&amp;a, <span class="keyword">const</span> pack&lt;r_type0_, ..., r_typeN_&gt;&amp; b);
<a name="l07205"></a>07205 <span class="preprocessor">#endif // DOCUMENTATION_ONLY</span>
<a name="l07206"></a>07206 <span class="preprocessor"></span>
<a name="l07207"></a>07207 LITE_INLINE
<a name="l07208"></a>07208 <span class="keywordtype">bool</span> <a class="code" href="group__array__tools.html#gafb4665bc1c0357dfad90b38e7db87b42">operator==</a>(<span class="keyword">const</span> pack&lt;&gt;&amp;, <span class="keyword">const</span> pack&lt;&gt;&amp;)
<a name="l07209"></a>07209 { 
<a name="l07210"></a>07210     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l07211"></a>07211 }
<a name="l07212"></a>07212 
<a name="l07213"></a>07213 <span class="keyword">template</span>&lt;
<a name="l07214"></a>07214     <span class="keyword">typename</span> l_type0_,
<a name="l07215"></a>07215     <span class="keyword">typename</span> r_type0_ 
<a name="l07216"></a>07216 &gt;
<a name="l07217"></a>07217 LITE_INLINE
<a name="l07218"></a>07218 <span class="keywordtype">bool</span> <a class="code" href="group__array__tools.html#gafb4665bc1c0357dfad90b38e7db87b42">operator==</a>(
<a name="l07219"></a>07219     <span class="keyword">const</span> pack&lt;l_type0_&gt;&amp; a,
<a name="l07220"></a>07220     <span class="keyword">const</span> pack&lt;r_type0_&gt;&amp; b)
<a name="l07221"></a>07221 {
<a name="l07222"></a>07222     <span class="keywordflow">return</span> a.i0==b.i0;
<a name="l07223"></a>07223     LITE_ARRAY_USE(a);
<a name="l07224"></a>07224     LITE_ARRAY_USE(b);
<a name="l07225"></a>07225 }
<a name="l07226"></a>07226 
<a name="l07227"></a>07227 <span class="keyword">template</span>&lt;
<a name="l07228"></a>07228     <span class="keyword">typename</span> l_type0_,
<a name="l07229"></a>07229     <span class="keyword">typename</span> l_type1_,
<a name="l07230"></a>07230     <span class="keyword">typename</span> r_type0_, 
<a name="l07231"></a>07231     <span class="keyword">typename</span> r_type1_ 
<a name="l07232"></a>07232 &gt;
<a name="l07233"></a>07233 LITE_INLINE
<a name="l07234"></a>07234 <span class="keywordtype">bool</span> <a class="code" href="group__array__tools.html#gafb4665bc1c0357dfad90b38e7db87b42">operator==</a>(
<a name="l07235"></a>07235     <span class="keyword">const</span> pack&lt;l_type0_, l_type1_&gt;&amp; a,
<a name="l07236"></a>07236     <span class="keyword">const</span> pack&lt;r_type0_, r_type1_&gt;&amp; b)
<a name="l07237"></a>07237 {
<a name="l07238"></a>07238     <span class="keywordflow">return</span> a.i0==b.i0 &amp;&amp; a.i1==b.i1;
<a name="l07239"></a>07239     LITE_ARRAY_USE(a);
<a name="l07240"></a>07240     LITE_ARRAY_USE(b);
<a name="l07241"></a>07241 }
<a name="l07242"></a>07242 
<a name="l07243"></a>07243 <span class="keyword">template</span>&lt;
<a name="l07244"></a>07244     <span class="keyword">typename</span> l_type0_,
<a name="l07245"></a>07245     <span class="keyword">typename</span> l_type1_,
<a name="l07246"></a>07246     <span class="keyword">typename</span> l_type2_,
<a name="l07247"></a>07247     <span class="keyword">typename</span> r_type0_, 
<a name="l07248"></a>07248     <span class="keyword">typename</span> r_type1_, 
<a name="l07249"></a>07249     <span class="keyword">typename</span> r_type2_ 
<a name="l07250"></a>07250 &gt;
<a name="l07251"></a>07251 LITE_INLINE
<a name="l07252"></a>07252 <span class="keywordtype">bool</span> <a class="code" href="group__array__tools.html#gafb4665bc1c0357dfad90b38e7db87b42">operator==</a>(
<a name="l07253"></a>07253     <span class="keyword">const</span> pack&lt;l_type0_, l_type1_, l_type2_&gt;&amp; a,
<a name="l07254"></a>07254     <span class="keyword">const</span> pack&lt;r_type0_, r_type1_, r_type2_&gt;&amp; b)
<a name="l07255"></a>07255 {
<a name="l07256"></a>07256     <span class="keywordflow">return</span> a.i0==b.i0 &amp;&amp; a.i1==b.i1 &amp;&amp; a.i2==b.i2;
<a name="l07257"></a>07257     LITE_ARRAY_USE(a);
<a name="l07258"></a>07258     LITE_ARRAY_USE(b);
<a name="l07259"></a>07259 }
<a name="l07260"></a>07260 
<a name="l07261"></a>07261 <span class="comment">/***********************************************************************************************************/</span>
<a name="l07262"></a>07262 <span class="comment">/* pack, operator&gt;= ****************************************************************************************/</span>
<a name="l07263"></a>07263 <span class="comment">/***********************************************************************************************************/</span>
<a name="l07264"></a>07264 <span class="preprocessor">#ifdef DOCUMENTATION_ONLY</span>
<a name="l07265"></a>07265 <span class="preprocessor"></span>
<a name="l07270"></a>07270 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> l_type0_, ..., <span class="keyword">typename</span> l_typeN_, <span class="keyword">typename</span> r_type0_, ..., <span class="keyword">typename</span> r_typeN_&gt;
<a name="l07271"></a>07271 <span class="keywordtype">bool</span> <a class="code" href="group__array__tools.html#ga70df6c75029086c5b4c387b5721d8fe4">operator&gt;=</a>(<span class="keyword">const</span> pack&lt;l_type0_, ..., l_typeN_&gt;&amp;a, <span class="keyword">const</span> pack&lt;r_type0_, ..., r_typeN_&gt;&amp; b);
<a name="l07272"></a>07272 <span class="preprocessor">#endif // DOCUMENTATION_ONLY</span>
<a name="l07273"></a>07273 <span class="preprocessor"></span>
<a name="l07274"></a>07274 LITE_INLINE
<a name="l07275"></a>07275 <span class="keywordtype">bool</span> <a class="code" href="group__array__tools.html#ga70df6c75029086c5b4c387b5721d8fe4">operator&gt;=</a>(<span class="keyword">const</span> pack&lt;&gt;&amp;, <span class="keyword">const</span> pack&lt;&gt;&amp;)
<a name="l07276"></a>07276 { 
<a name="l07277"></a>07277     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l07278"></a>07278 }
<a name="l07279"></a>07279 
<a name="l07280"></a>07280 <span class="keyword">template</span>&lt;
<a name="l07281"></a>07281     <span class="keyword">typename</span> l_type0_,
<a name="l07282"></a>07282     <span class="keyword">typename</span> r_type0_ 
<a name="l07283"></a>07283 &gt;
<a name="l07284"></a>07284 LITE_INLINE
<a name="l07285"></a>07285 <span class="keywordtype">bool</span> <a class="code" href="group__array__tools.html#ga70df6c75029086c5b4c387b5721d8fe4">operator&gt;=</a>(
<a name="l07286"></a>07286     <span class="keyword">const</span> pack&lt;l_type0_&gt;&amp; a,
<a name="l07287"></a>07287     <span class="keyword">const</span> pack&lt;r_type0_&gt;&amp; b)
<a name="l07288"></a>07288 {
<a name="l07289"></a>07289     <span class="keywordflow">return</span> a.i0&gt;=b.i0;
<a name="l07290"></a>07290     LITE_ARRAY_USE(a);
<a name="l07291"></a>07291     LITE_ARRAY_USE(b);
<a name="l07292"></a>07292 }
<a name="l07293"></a>07293 
<a name="l07294"></a>07294 <span class="keyword">template</span>&lt;
<a name="l07295"></a>07295     <span class="keyword">typename</span> l_type0_,
<a name="l07296"></a>07296     <span class="keyword">typename</span> l_type1_,
<a name="l07297"></a>07297     <span class="keyword">typename</span> r_type0_, 
<a name="l07298"></a>07298     <span class="keyword">typename</span> r_type1_ 
<a name="l07299"></a>07299 &gt;
<a name="l07300"></a>07300 LITE_INLINE
<a name="l07301"></a>07301 <span class="keywordtype">bool</span> <a class="code" href="group__array__tools.html#ga70df6c75029086c5b4c387b5721d8fe4">operator&gt;=</a>(
<a name="l07302"></a>07302     <span class="keyword">const</span> pack&lt;l_type0_, l_type1_&gt;&amp; a,
<a name="l07303"></a>07303     <span class="keyword">const</span> pack&lt;r_type0_, r_type1_&gt;&amp; b)
<a name="l07304"></a>07304 {
<a name="l07305"></a>07305     <span class="keywordflow">return</span> a.i0&gt;=b.i0 &amp;&amp; a.i1&gt;=b.i1;
<a name="l07306"></a>07306     LITE_ARRAY_USE(a);
<a name="l07307"></a>07307     LITE_ARRAY_USE(b);
<a name="l07308"></a>07308 }
<a name="l07309"></a>07309 
<a name="l07310"></a>07310 <span class="keyword">template</span>&lt;
<a name="l07311"></a>07311     <span class="keyword">typename</span> l_type0_,
<a name="l07312"></a>07312     <span class="keyword">typename</span> l_type1_,
<a name="l07313"></a>07313     <span class="keyword">typename</span> l_type2_,
<a name="l07314"></a>07314     <span class="keyword">typename</span> r_type0_, 
<a name="l07315"></a>07315     <span class="keyword">typename</span> r_type1_, 
<a name="l07316"></a>07316     <span class="keyword">typename</span> r_type2_ 
<a name="l07317"></a>07317 &gt;
<a name="l07318"></a>07318 LITE_INLINE
<a name="l07319"></a>07319 <span class="keywordtype">bool</span> <a class="code" href="group__array__tools.html#ga70df6c75029086c5b4c387b5721d8fe4">operator&gt;=</a>(
<a name="l07320"></a>07320     <span class="keyword">const</span> pack&lt;l_type0_, l_type1_, l_type2_&gt;&amp; a,
<a name="l07321"></a>07321     <span class="keyword">const</span> pack&lt;r_type0_, r_type1_, r_type2_&gt;&amp; b)
<a name="l07322"></a>07322 {
<a name="l07323"></a>07323     <span class="keywordflow">return</span> a.i0&gt;=b.i0 &amp;&amp; a.i1&gt;=b.i1 &amp;&amp; a.i2&gt;=b.i2;
<a name="l07324"></a>07324     LITE_ARRAY_USE(a);
<a name="l07325"></a>07325     LITE_ARRAY_USE(b);
<a name="l07326"></a>07326 }
<a name="l07327"></a>07327 
<a name="l07328"></a>07328 <span class="comment">/***********************************************************************************************************/</span>
<a name="l07329"></a>07329 <span class="comment">/* pack, operator&gt; *****************************************************************************************/</span>
<a name="l07330"></a>07330 <span class="comment">/***********************************************************************************************************/</span>
<a name="l07331"></a>07331 <span class="preprocessor">#ifdef DOCUMENTATION_ONLY</span>
<a name="l07332"></a>07332 <span class="preprocessor"></span>
<a name="l07337"></a>07337 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> l_type0_, ..., <span class="keyword">typename</span> l_typeN_, <span class="keyword">typename</span> r_type0_, ..., <span class="keyword">typename</span> r_typeN_&gt;
<a name="l07338"></a>07338 <span class="keywordtype">bool</span> <a class="code" href="group__array__tools.html#ga59489aa474069686a607b2a748fcc83e">operator&gt;</a>(<span class="keyword">const</span> pack&lt;l_type0_, ..., l_typeN_&gt;&amp;a, <span class="keyword">const</span> pack&lt;r_type0_, ..., r_typeN_&gt;&amp; b);
<a name="l07339"></a>07339 <span class="preprocessor">#endif // DOCUMENTATION_ONLY</span>
<a name="l07340"></a>07340 <span class="preprocessor"></span>
<a name="l07341"></a>07341 LITE_INLINE
<a name="l07342"></a>07342 <span class="keywordtype">bool</span> <a class="code" href="group__array__tools.html#ga59489aa474069686a607b2a748fcc83e">operator&gt;</a>(<span class="keyword">const</span> pack&lt;&gt;&amp;, <span class="keyword">const</span> pack&lt;&gt;&amp;)
<a name="l07343"></a>07343 { 
<a name="l07344"></a>07344     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l07345"></a>07345 }
<a name="l07346"></a>07346 
<a name="l07347"></a>07347 <span class="keyword">template</span>&lt;
<a name="l07348"></a>07348     <span class="keyword">typename</span> l_type0_,
<a name="l07349"></a>07349     <span class="keyword">typename</span> r_type0_ 
<a name="l07350"></a>07350 &gt;
<a name="l07351"></a>07351 LITE_INLINE
<a name="l07352"></a>07352 <span class="keywordtype">bool</span> <a class="code" href="group__array__tools.html#ga59489aa474069686a607b2a748fcc83e">operator&gt;</a>(
<a name="l07353"></a>07353     <span class="keyword">const</span> pack&lt;l_type0_&gt;&amp; a,
<a name="l07354"></a>07354     <span class="keyword">const</span> pack&lt;r_type0_&gt;&amp; b)
<a name="l07355"></a>07355 {
<a name="l07356"></a>07356     <span class="keywordflow">return</span> a.i0&gt;b.i0;
<a name="l07357"></a>07357     LITE_ARRAY_USE(a);
<a name="l07358"></a>07358     LITE_ARRAY_USE(b);
<a name="l07359"></a>07359 }
<a name="l07360"></a>07360 
<a name="l07361"></a>07361 <span class="keyword">template</span>&lt;
<a name="l07362"></a>07362     <span class="keyword">typename</span> l_type0_,
<a name="l07363"></a>07363     <span class="keyword">typename</span> l_type1_,
<a name="l07364"></a>07364     <span class="keyword">typename</span> r_type0_, 
<a name="l07365"></a>07365     <span class="keyword">typename</span> r_type1_ 
<a name="l07366"></a>07366 &gt;
<a name="l07367"></a>07367 LITE_INLINE
<a name="l07368"></a>07368 <span class="keywordtype">bool</span> <a class="code" href="group__array__tools.html#ga59489aa474069686a607b2a748fcc83e">operator&gt;</a>(
<a name="l07369"></a>07369     <span class="keyword">const</span> pack&lt;l_type0_, l_type1_&gt;&amp; a,
<a name="l07370"></a>07370     <span class="keyword">const</span> pack&lt;r_type0_, r_type1_&gt;&amp; b)
<a name="l07371"></a>07371 {
<a name="l07372"></a>07372     <span class="keywordflow">return</span> a.i0&gt;b.i0 &amp;&amp; a.i1&gt;b.i1;
<a name="l07373"></a>07373     LITE_ARRAY_USE(a);
<a name="l07374"></a>07374     LITE_ARRAY_USE(b);
<a name="l07375"></a>07375 }
<a name="l07376"></a>07376 
<a name="l07377"></a>07377 <span class="keyword">template</span>&lt;
<a name="l07378"></a>07378     <span class="keyword">typename</span> l_type0_,
<a name="l07379"></a>07379     <span class="keyword">typename</span> l_type1_,
<a name="l07380"></a>07380     <span class="keyword">typename</span> l_type2_,
<a name="l07381"></a>07381     <span class="keyword">typename</span> r_type0_, 
<a name="l07382"></a>07382     <span class="keyword">typename</span> r_type1_, 
<a name="l07383"></a>07383     <span class="keyword">typename</span> r_type2_ 
<a name="l07384"></a>07384 &gt;
<a name="l07385"></a>07385 LITE_INLINE
<a name="l07386"></a>07386 <span class="keywordtype">bool</span> <a class="code" href="group__array__tools.html#ga59489aa474069686a607b2a748fcc83e">operator&gt;</a>(
<a name="l07387"></a>07387     <span class="keyword">const</span> pack&lt;l_type0_, l_type1_, l_type2_&gt;&amp; a,
<a name="l07388"></a>07388     <span class="keyword">const</span> pack&lt;r_type0_, r_type1_, r_type2_&gt;&amp; b)
<a name="l07389"></a>07389 {
<a name="l07390"></a>07390     <span class="keywordflow">return</span> a.i0&gt;b.i0 &amp;&amp; a.i1&gt;b.i1 &amp;&amp; a.i2&gt;b.i2;
<a name="l07391"></a>07391     LITE_ARRAY_USE(a);
<a name="l07392"></a>07392     LITE_ARRAY_USE(b);
<a name="l07393"></a>07393 }
<a name="l07394"></a>07394 
<a name="l07395"></a>07395 
<a name="l07396"></a>07396 <span class="comment">/***********************************************************************************************************/</span>
<a name="l07397"></a>07397 <span class="comment">/* pack, operator!= ****************************************************************************************/</span>
<a name="l07398"></a>07398 <span class="comment">/***********************************************************************************************************/</span>
<a name="l07399"></a>07399 
<a name="l07400"></a>07400 <span class="preprocessor">#ifdef DOCUMENTATION_ONLY</span>
<a name="l07401"></a>07401 <span class="preprocessor"></span>
<a name="l07407"></a>07407 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> l_type0_, ..., <span class="keyword">typename</span> l_typeN_, <span class="keyword">typename</span> r_type0_, ..., <span class="keyword">typename</span> r_typeN_&gt;
<a name="l07408"></a>07408 <span class="keywordtype">bool</span> <a class="code" href="group__array__tools.html#ga0ce6a172c0bf2ab8bbc98e3f2a6f512a">operator!=</a>(<span class="keyword">const</span> pack&lt;l_type0_, ..., l_typeN_&gt;&amp;a, <span class="keyword">const</span> pack&lt;r_type0_, ..., r_typeN_&gt;&amp; b);
<a name="l07409"></a>07409 
<a name="l07410"></a>07410 <span class="preprocessor">#else // DOCUMENTATION_ONLY</span>
<a name="l07411"></a>07411 <span class="preprocessor"></span>
<a name="l07412"></a>07412 LITE_INLINE
<a name="l07413"></a>07413 <span class="keywordtype">bool</span> <a class="code" href="group__array__tools.html#ga0ce6a172c0bf2ab8bbc98e3f2a6f512a">operator!=</a>(<span class="keyword">const</span> pack&lt;&gt;&amp;, <span class="keyword">const</span> pack&lt;&gt;&amp;)
<a name="l07414"></a>07414 { 
<a name="l07415"></a>07415     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l07416"></a>07416 }
<a name="l07417"></a>07417 
<a name="l07418"></a>07418 <span class="keyword">template</span>&lt;
<a name="l07419"></a>07419     <span class="keyword">typename</span> l_type0_,
<a name="l07420"></a>07420     <span class="keyword">typename</span> r_type0_ 
<a name="l07421"></a>07421 &gt;
<a name="l07422"></a>07422 LITE_INLINE
<a name="l07423"></a>07423 <span class="keywordtype">bool</span> <a class="code" href="group__array__tools.html#ga0ce6a172c0bf2ab8bbc98e3f2a6f512a">operator!=</a>(
<a name="l07424"></a>07424     <span class="keyword">const</span> pack&lt;l_type0_&gt;&amp; a,
<a name="l07425"></a>07425     <span class="keyword">const</span> pack&lt;r_type0_&gt;&amp; b)
<a name="l07426"></a>07426 {
<a name="l07427"></a>07427     <span class="keywordflow">return</span> !(a==b);
<a name="l07428"></a>07428 }
<a name="l07429"></a>07429 
<a name="l07430"></a>07430 <span class="keyword">template</span>&lt;
<a name="l07431"></a>07431     <span class="keyword">typename</span> l_type0_,
<a name="l07432"></a>07432     <span class="keyword">typename</span> l_type1_,
<a name="l07433"></a>07433     <span class="keyword">typename</span> r_type0_, 
<a name="l07434"></a>07434     <span class="keyword">typename</span> r_type1_ 
<a name="l07435"></a>07435 &gt;
<a name="l07436"></a>07436 LITE_INLINE
<a name="l07437"></a>07437 <span class="keywordtype">bool</span> <a class="code" href="group__array__tools.html#ga0ce6a172c0bf2ab8bbc98e3f2a6f512a">operator!=</a>(
<a name="l07438"></a>07438     <span class="keyword">const</span> pack&lt;l_type0_,l_type1_&gt;&amp; a,
<a name="l07439"></a>07439     <span class="keyword">const</span> pack&lt;r_type0_,r_type1_&gt;&amp; b)
<a name="l07440"></a>07440 {
<a name="l07441"></a>07441     <span class="keywordflow">return</span> !(a==b);
<a name="l07442"></a>07442 }
<a name="l07443"></a>07443 
<a name="l07444"></a>07444 <span class="keyword">template</span>&lt;
<a name="l07445"></a>07445     <span class="keyword">typename</span> l_type0_,
<a name="l07446"></a>07446     <span class="keyword">typename</span> l_type1_,
<a name="l07447"></a>07447     <span class="keyword">typename</span> l_type2_,
<a name="l07448"></a>07448     <span class="keyword">typename</span> r_type0_, 
<a name="l07449"></a>07449     <span class="keyword">typename</span> r_type1_, 
<a name="l07450"></a>07450     <span class="keyword">typename</span> r_type2_ 
<a name="l07451"></a>07451 &gt;
<a name="l07452"></a>07452 LITE_INLINE
<a name="l07453"></a>07453 <span class="keywordtype">bool</span> <a class="code" href="group__array__tools.html#ga0ce6a172c0bf2ab8bbc98e3f2a6f512a">operator!=</a>(
<a name="l07454"></a>07454     <span class="keyword">const</span> pack&lt;l_type0_,l_type1_,l_type2_&gt;&amp; a,
<a name="l07455"></a>07455     <span class="keyword">const</span> pack&lt;r_type0_,r_type1_,r_type2_&gt;&amp; b)
<a name="l07456"></a>07456 {
<a name="l07457"></a>07457     <span class="keywordflow">return</span> !(a==b);
<a name="l07458"></a>07458 }
<a name="l07459"></a>07459 
<a name="l07460"></a>07460 
<a name="l07461"></a>07461 <span class="preprocessor">#endif // !DOCUMENTATION_ONLY</span>
<a name="l07462"></a>07462 <span class="preprocessor"></span><span class="comment">/***********************************************************************************************************/</span>
<a name="l07463"></a>07463 <span class="comment">/* pack io, operator&lt;&lt; *************************************************************************************/</span>
<a name="l07464"></a>07464 <span class="comment">/***********************************************************************************************************/</span>
<a name="l07465"></a>07465 
<a name="l07466"></a>07466 <span class="preprocessor">#ifdef DOCUMENTATION_ONLY</span>
<a name="l07467"></a>07467 <span class="preprocessor"></span>
<a name="l07490"></a>07490 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> char_type_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> type0_, ..., <span class="keyword">typename</span> typeN_&gt;
<a name="l07491"></a>07491 std::basic_ostream&lt;char_type_, traits_type_&gt;&amp;
<a name="l07492"></a>07492 <a class="code" href="group__array__tools.html#ga8e88646b15818ea64dbfe75eb110eccf" title="Prints the pack p to the output stream os.">operator&lt;&lt;</a>(
<a name="l07493"></a>07493     std::basic_ostream&lt;char_type_, traits_type_&gt;&amp; os, 
<a name="l07494"></a>07494     <span class="keyword">const</span> pack&lt;type0_, ..., typeN_&gt;&amp; p);
<a name="l07495"></a>07495 
<a name="l07496"></a>07496 <span class="preprocessor">#else // DOCUMENTATION_ONLY</span>
<a name="l07497"></a>07497 <span class="preprocessor"></span>
<a name="l07498"></a>07498 
<a name="l07499"></a>07499 <span class="keyword">template</span>&lt;
<a name="l07500"></a>07500     <span class="keyword">typename</span> char_type_,
<a name="l07501"></a>07501     <span class="keyword">typename</span> traits_type_
<a name="l07502"></a>07502     &gt;
<a name="l07503"></a>07503 std::basic_ostream&lt;char_type_, traits_type_&gt;&amp;
<a name="l07504"></a>07504 <a class="code" href="group__array__tools.html#ga8e88646b15818ea64dbfe75eb110eccf" title="Prints the pack p to the output stream os.">operator&lt;&lt;</a>(
<a name="l07505"></a>07505     std::basic_ostream&lt;char_type_, traits_type_&gt;&amp; os, 
<a name="l07506"></a>07506     <span class="keyword">const</span> pack&lt;&gt;&amp; p)
<a name="l07507"></a>07507 {
<a name="l07508"></a>07508     std::streamsize width = os.width();
<a name="l07509"></a>07509     <span class="keywordtype">bool</span> punct = (os.flags() &amp; std::ios_base::boolalpha) != 0;
<a name="l07510"></a>07510 
<a name="l07511"></a>07511     os.width(0);
<a name="l07512"></a>07512 
<a name="l07513"></a>07513     <span class="keywordflow">if</span> (punct)
<a name="l07514"></a>07514         os &lt;&lt; <span class="charliteral">&apos;[&apos;</span>;
<a name="l07515"></a>07515 
<a name="l07516"></a>07516 
<a name="l07517"></a>07517     <span class="keywordflow">if</span> (punct)
<a name="l07518"></a>07518         os &lt;&lt; <span class="charliteral">&apos;]&apos;</span>;
<a name="l07519"></a>07519     <span class="keywordflow">return</span> os;
<a name="l07520"></a>07520 
<a name="l07521"></a>07521     LITE_ARRAY_USE(p);
<a name="l07522"></a>07522 }
<a name="l07523"></a>07523 
<a name="l07524"></a>07524 
<a name="l07525"></a>07525 <span class="keyword">template</span>&lt;
<a name="l07526"></a>07526     <span class="keyword">typename</span> char_type_,
<a name="l07527"></a>07527     <span class="keyword">typename</span> traits_type_,
<a name="l07528"></a>07528     <span class="keyword">typename</span> type0_
<a name="l07529"></a>07529     &gt;
<a name="l07530"></a>07530 std::basic_ostream&lt;char_type_, traits_type_&gt;&amp;
<a name="l07531"></a>07531 <a class="code" href="group__array__tools.html#ga8e88646b15818ea64dbfe75eb110eccf" title="Prints the pack p to the output stream os.">operator&lt;&lt;</a>(
<a name="l07532"></a>07532     std::basic_ostream&lt;char_type_, traits_type_&gt;&amp; os, 
<a name="l07533"></a>07533     <span class="keyword">const</span> pack&lt;type0_&gt;&amp; p)
<a name="l07534"></a>07534 {
<a name="l07535"></a>07535     std::streamsize width = os.width();
<a name="l07536"></a>07536     <span class="keywordtype">bool</span> punct = (os.flags() &amp; std::ios_base::boolalpha) != 0;
<a name="l07537"></a>07537 
<a name="l07538"></a>07538     os.width(0);
<a name="l07539"></a>07539 
<a name="l07540"></a>07540     <span class="keywordflow">if</span> (punct)
<a name="l07541"></a>07541         os &lt;&lt; <span class="charliteral">&apos;[&apos;</span>;
<a name="l07542"></a>07542 
<a name="l07543"></a>07543     os.width(width); os &lt;&lt; p.i0;
<a name="l07544"></a>07544 
<a name="l07545"></a>07545     <span class="keywordflow">if</span> (punct)
<a name="l07546"></a>07546         os &lt;&lt; <span class="charliteral">&apos;]&apos;</span>;
<a name="l07547"></a>07547     <span class="keywordflow">return</span> os;
<a name="l07548"></a>07548 
<a name="l07549"></a>07549     LITE_ARRAY_USE(p);
<a name="l07550"></a>07550 }
<a name="l07551"></a>07551 
<a name="l07552"></a>07552 
<a name="l07553"></a>07553 <span class="keyword">template</span>&lt;
<a name="l07554"></a>07554     <span class="keyword">typename</span> char_type_,
<a name="l07555"></a>07555     <span class="keyword">typename</span> traits_type_,
<a name="l07556"></a>07556     <span class="keyword">typename</span> type0_,
<a name="l07557"></a>07557     <span class="keyword">typename</span> type1_
<a name="l07558"></a>07558     &gt;
<a name="l07559"></a>07559 std::basic_ostream&lt;char_type_, traits_type_&gt;&amp;
<a name="l07560"></a>07560 <a class="code" href="group__array__tools.html#ga8e88646b15818ea64dbfe75eb110eccf" title="Prints the pack p to the output stream os.">operator&lt;&lt;</a>(
<a name="l07561"></a>07561     std::basic_ostream&lt;char_type_, traits_type_&gt;&amp; os, 
<a name="l07562"></a>07562     <span class="keyword">const</span> pack&lt;type0_,type1_&gt;&amp; p)
<a name="l07563"></a>07563 {
<a name="l07564"></a>07564     std::streamsize width = os.width();
<a name="l07565"></a>07565     <span class="keywordtype">bool</span> punct = (os.flags() &amp; std::ios_base::boolalpha) != 0;
<a name="l07566"></a>07566 
<a name="l07567"></a>07567     os.width(0);
<a name="l07568"></a>07568 
<a name="l07569"></a>07569     <span class="keywordflow">if</span> (punct)
<a name="l07570"></a>07570         os &lt;&lt; <span class="charliteral">&apos;[&apos;</span>;
<a name="l07571"></a>07571 
<a name="l07572"></a>07572     os.width(width); os &lt;&lt; p.i0; os &lt;&lt; <span class="charliteral">&apos; &apos;</span>;
<a name="l07573"></a>07573     os.width(width); os &lt;&lt; p.i1;
<a name="l07574"></a>07574 
<a name="l07575"></a>07575     <span class="keywordflow">if</span> (punct)
<a name="l07576"></a>07576         os &lt;&lt; <span class="charliteral">&apos;]&apos;</span>;
<a name="l07577"></a>07577     <span class="keywordflow">return</span> os;
<a name="l07578"></a>07578 
<a name="l07579"></a>07579     LITE_ARRAY_USE(p);
<a name="l07580"></a>07580 }
<a name="l07581"></a>07581 
<a name="l07582"></a>07582 
<a name="l07583"></a>07583 <span class="keyword">template</span>&lt;
<a name="l07584"></a>07584     <span class="keyword">typename</span> char_type_,
<a name="l07585"></a>07585     <span class="keyword">typename</span> traits_type_,
<a name="l07586"></a>07586     <span class="keyword">typename</span> type0_,
<a name="l07587"></a>07587     <span class="keyword">typename</span> type1_,
<a name="l07588"></a>07588     <span class="keyword">typename</span> type2_
<a name="l07589"></a>07589     &gt;
<a name="l07590"></a>07590 std::basic_ostream&lt;char_type_, traits_type_&gt;&amp;
<a name="l07591"></a>07591 <a class="code" href="group__array__tools.html#ga8e88646b15818ea64dbfe75eb110eccf" title="Prints the pack p to the output stream os.">operator&lt;&lt;</a>(
<a name="l07592"></a>07592     std::basic_ostream&lt;char_type_, traits_type_&gt;&amp; os, 
<a name="l07593"></a>07593     <span class="keyword">const</span> pack&lt;type0_,type1_,type2_&gt;&amp; p)
<a name="l07594"></a>07594 {
<a name="l07595"></a>07595     std::streamsize width = os.width();
<a name="l07596"></a>07596     <span class="keywordtype">bool</span> punct = (os.flags() &amp; std::ios_base::boolalpha) != 0;
<a name="l07597"></a>07597 
<a name="l07598"></a>07598     os.width(0);
<a name="l07599"></a>07599 
<a name="l07600"></a>07600     <span class="keywordflow">if</span> (punct)
<a name="l07601"></a>07601         os &lt;&lt; <span class="charliteral">&apos;[&apos;</span>;
<a name="l07602"></a>07602 
<a name="l07603"></a>07603     os.width(width); os &lt;&lt; p.i0; os &lt;&lt; <span class="charliteral">&apos; &apos;</span>;
<a name="l07604"></a>07604     os.width(width); os &lt;&lt; p.i1; os &lt;&lt; <span class="charliteral">&apos; &apos;</span>;
<a name="l07605"></a>07605     os.width(width); os &lt;&lt; p.i2;
<a name="l07606"></a>07606 
<a name="l07607"></a>07607     <span class="keywordflow">if</span> (punct)
<a name="l07608"></a>07608         os &lt;&lt; <span class="charliteral">&apos;]&apos;</span>;
<a name="l07609"></a>07609     <span class="keywordflow">return</span> os;
<a name="l07610"></a>07610 
<a name="l07611"></a>07611     LITE_ARRAY_USE(p);
<a name="l07612"></a>07612 }
<a name="l07613"></a>07613 
<a name="l07614"></a>07614 
<a name="l07615"></a>07615 <span class="keyword">template</span>&lt;
<a name="l07616"></a>07616     <span class="keyword">typename</span> char_type_,
<a name="l07617"></a>07617     <span class="keyword">typename</span> traits_type_,
<a name="l07618"></a>07618     <span class="keyword">typename</span> type0_,
<a name="l07619"></a>07619     <span class="keyword">typename</span> type1_,
<a name="l07620"></a>07620     <span class="keyword">typename</span> type2_,
<a name="l07621"></a>07621     <span class="keyword">typename</span> type3_
<a name="l07622"></a>07622     &gt;
<a name="l07623"></a>07623 std::basic_ostream&lt;char_type_, traits_type_&gt;&amp;
<a name="l07624"></a>07624 <a class="code" href="group__array__tools.html#ga8e88646b15818ea64dbfe75eb110eccf" title="Prints the pack p to the output stream os.">operator&lt;&lt;</a>(
<a name="l07625"></a>07625     std::basic_ostream&lt;char_type_, traits_type_&gt;&amp; os, 
<a name="l07626"></a>07626     <span class="keyword">const</span> pack&lt;type0_,type1_,type2_,type3_&gt;&amp; p)
<a name="l07627"></a>07627 {
<a name="l07628"></a>07628     std::streamsize width = os.width();
<a name="l07629"></a>07629     <span class="keywordtype">bool</span> punct = (os.flags() &amp; std::ios_base::boolalpha) != 0;
<a name="l07630"></a>07630 
<a name="l07631"></a>07631     os.width(0);
<a name="l07632"></a>07632 
<a name="l07633"></a>07633     <span class="keywordflow">if</span> (punct)
<a name="l07634"></a>07634         os &lt;&lt; <span class="charliteral">&apos;[&apos;</span>;
<a name="l07635"></a>07635 
<a name="l07636"></a>07636     os.width(width); os &lt;&lt; p.i0; os &lt;&lt; <span class="charliteral">&apos; &apos;</span>;
<a name="l07637"></a>07637     os.width(width); os &lt;&lt; p.i1; os &lt;&lt; <span class="charliteral">&apos; &apos;</span>;
<a name="l07638"></a>07638     os.width(width); os &lt;&lt; p.i2; os &lt;&lt; <span class="charliteral">&apos; &apos;</span>;
<a name="l07639"></a>07639     os.width(width); os &lt;&lt; p.i3;
<a name="l07640"></a>07640 
<a name="l07641"></a>07641     <span class="keywordflow">if</span> (punct)
<a name="l07642"></a>07642         os &lt;&lt; <span class="charliteral">&apos;]&apos;</span>;
<a name="l07643"></a>07643     <span class="keywordflow">return</span> os;
<a name="l07644"></a>07644 
<a name="l07645"></a>07645     LITE_ARRAY_USE(p);
<a name="l07646"></a>07646 }
<a name="l07647"></a>07647 
<a name="l07648"></a>07648 
<a name="l07649"></a>07649 <span class="preprocessor">#endif // !DOCUMENTATION_ONLY</span>
<a name="l07650"></a>07650 <span class="preprocessor"></span><span class="comment">/***********************************************************************************************************/</span>
<a name="l07651"></a>07651 <span class="comment">/* pack io, operator&gt;&gt; *************************************************************************************/</span>
<a name="l07652"></a>07652 <span class="comment">/***********************************************************************************************************/</span>
<a name="l07653"></a>07653 
<a name="l07654"></a>07654 <span class="preprocessor">#ifdef DOCUMENTATION_ONLY</span>
<a name="l07655"></a>07655 <span class="preprocessor"></span>
<a name="l07681"></a>07681 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> char_type_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> type0_, ..., <span class="keyword">typename</span> typeN_&gt;
<a name="l07682"></a>07682 std::basic_istream&lt;char_type_, traits_type_&gt;&amp;
<a name="l07683"></a>07683 <a class="code" href="group__array__tools.html#ga4697e22d4ec02c8907b59732c57169dc" title="Scans (reads) the pack p from the input stream is.">operator&gt;&gt;</a>(
<a name="l07684"></a>07684     std::basic_istream&lt;char_type_, traits_type_&gt;&amp; is, 
<a name="l07685"></a>07685     pack&lt;type0_, ..., typeN_&gt;&amp; p);
<a name="l07686"></a>07686 
<a name="l07687"></a>07687 <span class="preprocessor">#else // DOCUMENTATION_ONLY</span>
<a name="l07688"></a>07688 <span class="preprocessor"></span>
<a name="l07689"></a>07689 
<a name="l07690"></a>07690 <span class="keyword">template</span>&lt;
<a name="l07691"></a>07691     <span class="keyword">typename</span> char_type_,
<a name="l07692"></a>07692     <span class="keyword">typename</span> traits_type_
<a name="l07693"></a>07693     &gt;
<a name="l07694"></a>07694 std::basic_istream&lt;char_type_, traits_type_&gt;&amp;
<a name="l07695"></a>07695 <a class="code" href="group__array__tools.html#ga4697e22d4ec02c8907b59732c57169dc" title="Scans (reads) the pack p from the input stream is.">operator&gt;&gt;</a>(
<a name="l07696"></a>07696     std::basic_ostream&lt;char_type_, traits_type_&gt;&amp; is, 
<a name="l07697"></a>07697     pack&lt;&gt;&amp; p)
<a name="l07698"></a>07698 {
<a name="l07699"></a>07699     char_type_ ch;
<a name="l07700"></a>07700 
<a name="l07701"></a>07701     <span class="keywordflow">if</span> (!(is &gt;&gt; ch))
<a name="l07702"></a>07702         <span class="keywordflow">return</span> is;
<a name="l07703"></a>07703         
<a name="l07704"></a>07704     <span class="keywordtype">bool</span> fancy = is.narrow(ch, <span class="charliteral">&apos;\0&apos;</span>) == <span class="charliteral">&apos;[&apos;</span>;
<a name="l07705"></a>07705 
<a name="l07706"></a>07706     <span class="keywordflow">if</span> (!fancy)
<a name="l07707"></a>07707         is.putback(ch);
<a name="l07708"></a>07708 
<a name="l07709"></a>07709 
<a name="l07710"></a>07710     ch = char_type_();
<a name="l07711"></a>07711     <span class="keywordflow">if</span> (fancy &amp;&amp; !(is &gt;&gt; ch &amp;&amp; is.narrow(ch, <span class="charliteral">&apos;\0&apos;</span>) == <span class="charliteral">&apos;]&apos;</span>)) {
<a name="l07712"></a>07712         is.setstate(std::ios_base::failbit);
<a name="l07713"></a>07713         <span class="keywordflow">return</span> is;
<a name="l07714"></a>07714     }
<a name="l07715"></a>07715     
<a name="l07716"></a>07716     p.set();
<a name="l07717"></a>07717     <span class="keywordflow">return</span> is;
<a name="l07718"></a>07718     LITE_ARRAY_USE(p);
<a name="l07719"></a>07719 }
<a name="l07720"></a>07720 
<a name="l07721"></a>07721 
<a name="l07722"></a>07722 <span class="keyword">template</span>&lt;
<a name="l07723"></a>07723     <span class="keyword">typename</span> char_type_,
<a name="l07724"></a>07724     <span class="keyword">typename</span> traits_type_,
<a name="l07725"></a>07725     <span class="keyword">typename</span> type0_
<a name="l07726"></a>07726     &gt;
<a name="l07727"></a>07727 std::basic_istream&lt;char_type_, traits_type_&gt;&amp;
<a name="l07728"></a>07728 <a class="code" href="group__array__tools.html#ga4697e22d4ec02c8907b59732c57169dc" title="Scans (reads) the pack p from the input stream is.">operator&gt;&gt;</a>(
<a name="l07729"></a>07729     std::basic_ostream&lt;char_type_, traits_type_&gt;&amp; is, 
<a name="l07730"></a>07730     pack&lt;type0_&gt;&amp; p)
<a name="l07731"></a>07731 {
<a name="l07732"></a>07732     char_type_ ch;
<a name="l07733"></a>07733 
<a name="l07734"></a>07734     <span class="keywordflow">if</span> (!(is &gt;&gt; ch))
<a name="l07735"></a>07735         <span class="keywordflow">return</span> is;
<a name="l07736"></a>07736         
<a name="l07737"></a>07737     <span class="keywordtype">bool</span> fancy = is.narrow(ch, <span class="charliteral">&apos;\0&apos;</span>) == <span class="charliteral">&apos;[&apos;</span>;
<a name="l07738"></a>07738 
<a name="l07739"></a>07739     <span class="keywordflow">if</span> (!fancy)
<a name="l07740"></a>07740         is.putback(ch);
<a name="l07741"></a>07741 
<a name="l07742"></a>07742     type0_ i0; is &gt;&gt; i0;
<a name="l07743"></a>07743 
<a name="l07744"></a>07744     ch = char_type_();
<a name="l07745"></a>07745     <span class="keywordflow">if</span> (fancy &amp;&amp; !(is &gt;&gt; ch &amp;&amp; is.narrow(ch, <span class="charliteral">&apos;\0&apos;</span>) == <span class="charliteral">&apos;]&apos;</span>)) {
<a name="l07746"></a>07746         is.setstate(std::ios_base::failbit);
<a name="l07747"></a>07747         <span class="keywordflow">return</span> is;
<a name="l07748"></a>07748     }
<a name="l07749"></a>07749     
<a name="l07750"></a>07750     p.set(i0);
<a name="l07751"></a>07751     <span class="keywordflow">return</span> is;
<a name="l07752"></a>07752 }
<a name="l07753"></a>07753 
<a name="l07754"></a>07754 
<a name="l07755"></a>07755 <span class="keyword">template</span>&lt;
<a name="l07756"></a>07756     <span class="keyword">typename</span> char_type_,
<a name="l07757"></a>07757     <span class="keyword">typename</span> traits_type_,
<a name="l07758"></a>07758     <span class="keyword">typename</span> type0_,
<a name="l07759"></a>07759     <span class="keyword">typename</span> type1_
<a name="l07760"></a>07760     &gt;
<a name="l07761"></a>07761 std::basic_istream&lt;char_type_, traits_type_&gt;&amp;
<a name="l07762"></a>07762 <a class="code" href="group__array__tools.html#ga4697e22d4ec02c8907b59732c57169dc" title="Scans (reads) the pack p from the input stream is.">operator&gt;&gt;</a>(
<a name="l07763"></a>07763     std::basic_ostream&lt;char_type_, traits_type_&gt;&amp; is, 
<a name="l07764"></a>07764     pack&lt;type0_,type1_&gt;&amp; p)
<a name="l07765"></a>07765 {
<a name="l07766"></a>07766     char_type_ ch;
<a name="l07767"></a>07767 
<a name="l07768"></a>07768     <span class="keywordflow">if</span> (!(is &gt;&gt; ch))
<a name="l07769"></a>07769         <span class="keywordflow">return</span> is;
<a name="l07770"></a>07770         
<a name="l07771"></a>07771     <span class="keywordtype">bool</span> fancy = is.narrow(ch, <span class="charliteral">&apos;\0&apos;</span>) == <span class="charliteral">&apos;[&apos;</span>;
<a name="l07772"></a>07772 
<a name="l07773"></a>07773     <span class="keywordflow">if</span> (!fancy)
<a name="l07774"></a>07774         is.putback(ch);
<a name="l07775"></a>07775 
<a name="l07776"></a>07776     type0_ i0; is &gt;&gt; i0;
<a name="l07777"></a>07777     type1_ i1; is &gt;&gt; i1;
<a name="l07778"></a>07778 
<a name="l07779"></a>07779     ch = char_type_();
<a name="l07780"></a>07780     <span class="keywordflow">if</span> (fancy &amp;&amp; !(is &gt;&gt; ch &amp;&amp; is.narrow(ch, <span class="charliteral">&apos;\0&apos;</span>) == <span class="charliteral">&apos;]&apos;</span>)) {
<a name="l07781"></a>07781         is.setstate(std::ios_base::failbit);
<a name="l07782"></a>07782         <span class="keywordflow">return</span> is;
<a name="l07783"></a>07783     }
<a name="l07784"></a>07784     
<a name="l07785"></a>07785     p.set(i0, i1);
<a name="l07786"></a>07786     <span class="keywordflow">return</span> is;
<a name="l07787"></a>07787 }
<a name="l07788"></a>07788 
<a name="l07789"></a>07789 
<a name="l07790"></a>07790 <span class="keyword">template</span>&lt;
<a name="l07791"></a>07791     <span class="keyword">typename</span> char_type_,
<a name="l07792"></a>07792     <span class="keyword">typename</span> traits_type_,
<a name="l07793"></a>07793     <span class="keyword">typename</span> type0_,
<a name="l07794"></a>07794     <span class="keyword">typename</span> type1_,
<a name="l07795"></a>07795     <span class="keyword">typename</span> type2_
<a name="l07796"></a>07796     &gt;
<a name="l07797"></a>07797 std::basic_istream&lt;char_type_, traits_type_&gt;&amp;
<a name="l07798"></a>07798 <a class="code" href="group__array__tools.html#ga4697e22d4ec02c8907b59732c57169dc" title="Scans (reads) the pack p from the input stream is.">operator&gt;&gt;</a>(
<a name="l07799"></a>07799     std::basic_ostream&lt;char_type_, traits_type_&gt;&amp; is, 
<a name="l07800"></a>07800     pack&lt;type0_,type1_,type2_&gt;&amp; p)
<a name="l07801"></a>07801 {
<a name="l07802"></a>07802     char_type_ ch;
<a name="l07803"></a>07803 
<a name="l07804"></a>07804     <span class="keywordflow">if</span> (!(is &gt;&gt; ch))
<a name="l07805"></a>07805         <span class="keywordflow">return</span> is;
<a name="l07806"></a>07806         
<a name="l07807"></a>07807     <span class="keywordtype">bool</span> fancy = is.narrow(ch, <span class="charliteral">&apos;\0&apos;</span>) == <span class="charliteral">&apos;[&apos;</span>;
<a name="l07808"></a>07808 
<a name="l07809"></a>07809     <span class="keywordflow">if</span> (!fancy)
<a name="l07810"></a>07810         is.putback(ch);
<a name="l07811"></a>07811 
<a name="l07812"></a>07812     type0_ i0; is &gt;&gt; i0;
<a name="l07813"></a>07813     type1_ i1; is &gt;&gt; i1;
<a name="l07814"></a>07814     type2_ i2; is &gt;&gt; i2;
<a name="l07815"></a>07815 
<a name="l07816"></a>07816     ch = char_type_();
<a name="l07817"></a>07817     <span class="keywordflow">if</span> (fancy &amp;&amp; !(is &gt;&gt; ch &amp;&amp; is.narrow(ch, <span class="charliteral">&apos;\0&apos;</span>) == <span class="charliteral">&apos;]&apos;</span>)) {
<a name="l07818"></a>07818         is.setstate(std::ios_base::failbit);
<a name="l07819"></a>07819         <span class="keywordflow">return</span> is;
<a name="l07820"></a>07820     }
<a name="l07821"></a>07821     
<a name="l07822"></a>07822     p.set(i0, i1, i2);
<a name="l07823"></a>07823     <span class="keywordflow">return</span> is;
<a name="l07824"></a>07824 }
<a name="l07825"></a>07825 
<a name="l07826"></a>07826 
<a name="l07827"></a>07827 <span class="keyword">template</span>&lt;
<a name="l07828"></a>07828     <span class="keyword">typename</span> char_type_,
<a name="l07829"></a>07829     <span class="keyword">typename</span> traits_type_,
<a name="l07830"></a>07830     <span class="keyword">typename</span> type0_,
<a name="l07831"></a>07831     <span class="keyword">typename</span> type1_,
<a name="l07832"></a>07832     <span class="keyword">typename</span> type2_,
<a name="l07833"></a>07833     <span class="keyword">typename</span> type3_
<a name="l07834"></a>07834     &gt;
<a name="l07835"></a>07835 std::basic_istream&lt;char_type_, traits_type_&gt;&amp;
<a name="l07836"></a>07836 <a class="code" href="group__array__tools.html#ga4697e22d4ec02c8907b59732c57169dc" title="Scans (reads) the pack p from the input stream is.">operator&gt;&gt;</a>(
<a name="l07837"></a>07837     std::basic_ostream&lt;char_type_, traits_type_&gt;&amp; is, 
<a name="l07838"></a>07838     pack&lt;type0_,type1_,type2_,type3_&gt;&amp; p)
<a name="l07839"></a>07839 {
<a name="l07840"></a>07840     char_type_ ch;
<a name="l07841"></a>07841 
<a name="l07842"></a>07842     <span class="keywordflow">if</span> (!(is &gt;&gt; ch))
<a name="l07843"></a>07843         <span class="keywordflow">return</span> is;
<a name="l07844"></a>07844         
<a name="l07845"></a>07845     <span class="keywordtype">bool</span> fancy = is.narrow(ch, <span class="charliteral">&apos;\0&apos;</span>) == <span class="charliteral">&apos;[&apos;</span>;
<a name="l07846"></a>07846 
<a name="l07847"></a>07847     <span class="keywordflow">if</span> (!fancy)
<a name="l07848"></a>07848         is.putback(ch);
<a name="l07849"></a>07849 
<a name="l07850"></a>07850     type0_ i0; is &gt;&gt; i0;
<a name="l07851"></a>07851     type1_ i1; is &gt;&gt; i1;
<a name="l07852"></a>07852     type2_ i2; is &gt;&gt; i2;
<a name="l07853"></a>07853     type3_ i3; is &gt;&gt; i3;
<a name="l07854"></a>07854 
<a name="l07855"></a>07855     ch = char_type_();
<a name="l07856"></a>07856     <span class="keywordflow">if</span> (fancy &amp;&amp; !(is &gt;&gt; ch &amp;&amp; is.narrow(ch, <span class="charliteral">&apos;\0&apos;</span>) == <span class="charliteral">&apos;]&apos;</span>)) {
<a name="l07857"></a>07857         is.setstate(std::ios_base::failbit);
<a name="l07858"></a>07858         <span class="keywordflow">return</span> is;
<a name="l07859"></a>07859     }
<a name="l07860"></a>07860     
<a name="l07861"></a>07861     p.set(i0, i1, i2, i3);
<a name="l07862"></a>07862     <span class="keywordflow">return</span> is;
<a name="l07863"></a>07863 }
<a name="l07864"></a>07864 
<a name="l07865"></a>07865 
<a name="l07866"></a>07866 <span class="preprocessor">#endif // !DOCUMENTATION_ONLY</span>
<a name="l07867"></a>07867 <span class="preprocessor"></span>
<a name="l07868"></a>07868 <span class="comment">/***********************************************************************************************************/</span>
<a name="l07869"></a>07869 <span class="comment">/* error checking functions ********************************************************************************/</span>
<a name="l07870"></a>07870 <span class="comment">/***********************************************************************************************************/</span>
<a name="l07871"></a>07871 
<a name="l07876"></a>07876 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> left_<span class="keywordtype">size_t</span>ype_, <span class="keyword">typename</span> right_<span class="keywordtype">size_t</span>ype_&gt;
<a name="l07877"></a><a class="code" href="group__array__tools.html#gad0c5ea5e13ce84f26c011f49a427c62f">07877</a> <span class="keywordtype">void</span> <a class="code" href="group__array__tools.html#gad0c5ea5e13ce84f26c011f49a427c62f">lite_array_size_check</a>(<span class="keyword">const</span> left_size_type_&amp; a, <span class="keyword">const</span> right_size_type_&amp; b, <span class="keyword">const</span> std::string&amp; msg)
<a name="l07878"></a>07878 {
<a name="l07879"></a>07879     <span class="keywordflow">if</span> (a != b)
<a name="l07880"></a>07880         <span class="keywordflow">throw</span> <a class="code" href="classlite_1_1size__mismatch__error.html" title="A mismatch between the sizes of two arrays in an operation or invalid size for a...">size_mismatch_error</a>(msg);
<a name="l07881"></a>07881 }
<a name="l07882"></a>07882 
<a name="l07883"></a>07883 } <span class="comment">// namespace lite</span>
<a name="l07884"></a>07884 
<a name="l07885"></a>07885 <span class="comment">/***********************************************************************************************************/</span>
<a name="l07886"></a>07886 <span class="comment">/* iterator_traits&lt;pack&lt;...&gt; &gt; *****************************************************************************/</span>
<a name="l07887"></a>07887 <span class="comment">/***********************************************************************************************************/</span>
<a name="l07888"></a>07888 
<a name="l07889"></a>07889 <span class="keyword">namespace </span>std
<a name="l07890"></a>07890 {
<a name="l07891"></a>07891     <span class="keyword">template</span>&lt;
<a name="l07892"></a>07892             <span class="keyword">typename</span> type0_,
<a name="l07893"></a>07893             <span class="keyword">typename</span> type1_,
<a name="l07894"></a>07894             <span class="keyword">typename</span> type2_,
<a name="l07895"></a>07895             <span class="keyword">typename</span> type3_
<a name="l07896"></a>07896             &gt;
<a name="l07897"></a>07897     <span class="keyword">struct </span>iterator_traits&lt;lite::pack&lt;
<a name="l07898"></a>07898             type0_,
<a name="l07899"></a>07899             type1_,
<a name="l07900"></a>07900             type2_,
<a name="l07901"></a>07901             type3_
<a name="l07902"></a>07902         &gt; &gt;
<a name="l07903"></a>07903         : <span class="keyword">public</span> iterator_traits&lt;type0_&gt;
<a name="l07904"></a>07904     {};
<a name="l07905"></a>07905 } <span class="comment">// namespace std</span>
<a name="l07906"></a>07906 
<a name="l07907"></a>07907 <span class="keyword">namespace </span>lite
<a name="l07908"></a>07908 { 
<a name="l07909"></a>07909 
<a name="l07910"></a>07910 <span class="comment">/***********************************************************************************************************/</span>
<a name="l07911"></a>07911 <span class="comment">/* s_iterator **********************************************************************************************/</span>
<a name="l07912"></a>07912 <span class="comment">/***********************************************************************************************************/</span>
<a name="l07913"></a>07913 
<a name="l07951"></a>07951 <span class="comment">/***********************************************************************************************************/</span>
<a name="l07952"></a>07952 <span class="comment">/* s_iterator, at() ****************************************************************************************/</span>
<a name="l07953"></a>07953 <span class="comment">/***********************************************************************************************************/</span>
<a name="l07954"></a>07954 
<a name="l07955"></a>07955 <span class="keyword">template</span>&lt;
<a name="l07956"></a>07956     <span class="keyword">typename</span> iter_type_
<a name="l07957"></a>07957     &gt;
<a name="l07958"></a>07958 LITE_INLINE 
<a name="l07959"></a>07959 <span class="keyword">typename</span> std::iterator_traits&lt;pack&lt;
<a name="l07960"></a>07960     iter_type_
<a name="l07961"></a>07961     &gt; &gt;::reference 
<a name="l07962"></a>07962 at(<span class="keyword">const</span> pack&lt;
<a name="l07963"></a>07963     iter_type_
<a name="l07964"></a>07964     &gt;&amp; it
<a name="l07965"></a>07965     )
<a name="l07966"></a>07966 {
<a name="l07967"></a>07967     <span class="keywordflow">return</span> *(it.i0);
<a name="l07968"></a>07968 }
<a name="l07969"></a>07969 <span class="keyword">template</span>&lt;
<a name="l07970"></a>07970     <span class="keyword">typename</span> iter_type_,
<a name="l07971"></a>07971     <span class="keyword">typename</span> ind_type0_
<a name="l07972"></a>07972     &gt;
<a name="l07973"></a>07973 LITE_INLINE 
<a name="l07974"></a>07974 <span class="keyword">typename</span> std::iterator_traits&lt;pack&lt;
<a name="l07975"></a>07975     iter_type_,
<a name="l07976"></a>07976     ind_type0_
<a name="l07977"></a>07977     &gt; &gt;::reference 
<a name="l07978"></a>07978 at(<span class="keyword">const</span> pack&lt;
<a name="l07979"></a>07979     iter_type_,
<a name="l07980"></a>07980     ind_type0_
<a name="l07981"></a>07981     &gt;&amp; it
<a name="l07982"></a>07982     )
<a name="l07983"></a>07983 {
<a name="l07984"></a>07984     <span class="keywordflow">return</span> *(it.i0);
<a name="l07985"></a>07985 }
<a name="l07986"></a>07986 <span class="keyword">template</span>&lt;
<a name="l07987"></a>07987     <span class="keyword">typename</span> iter_type_,
<a name="l07988"></a>07988     <span class="keyword">typename</span> ind_type0_
<a name="l07989"></a>07989     &gt;
<a name="l07990"></a>07990 LITE_INLINE 
<a name="l07991"></a>07991 <span class="keyword">typename</span> std::iterator_traits&lt;pack&lt;
<a name="l07992"></a>07992     iter_type_,
<a name="l07993"></a>07993     ind_type0_
<a name="l07994"></a>07994     &gt; &gt;::reference 
<a name="l07995"></a>07995 at(<span class="keyword">const</span> pack&lt;
<a name="l07996"></a>07996     iter_type_,
<a name="l07997"></a>07997     ind_type0_
<a name="l07998"></a>07998     &gt;&amp; it,
<a name="l07999"></a>07999     <span class="keywordtype">int</span> ind0
<a name="l08000"></a>08000     )
<a name="l08001"></a>08001 {
<a name="l08002"></a>08002     <span class="keywordflow">return</span> *(it.i0+ind0*it.i1);
<a name="l08003"></a>08003 }
<a name="l08004"></a>08004 <span class="keyword">template</span>&lt;
<a name="l08005"></a>08005     <span class="keyword">typename</span> iter_type_,
<a name="l08006"></a>08006     <span class="keyword">typename</span> ind_type0_,
<a name="l08007"></a>08007     <span class="keyword">typename</span> ind_type1_
<a name="l08008"></a>08008     &gt;
<a name="l08009"></a>08009 LITE_INLINE 
<a name="l08010"></a>08010 <span class="keyword">typename</span> std::iterator_traits&lt;pack&lt;
<a name="l08011"></a>08011     iter_type_,
<a name="l08012"></a>08012     ind_type0_,
<a name="l08013"></a>08013     ind_type1_
<a name="l08014"></a>08014     &gt; &gt;::reference 
<a name="l08015"></a>08015 at(<span class="keyword">const</span> pack&lt;
<a name="l08016"></a>08016     iter_type_,
<a name="l08017"></a>08017     ind_type0_,
<a name="l08018"></a>08018     ind_type1_
<a name="l08019"></a>08019     &gt;&amp; it
<a name="l08020"></a>08020     )
<a name="l08021"></a>08021 {
<a name="l08022"></a>08022     <span class="keywordflow">return</span> *(it.i0);
<a name="l08023"></a>08023 }
<a name="l08024"></a>08024 <span class="keyword">template</span>&lt;
<a name="l08025"></a>08025     <span class="keyword">typename</span> iter_type_,
<a name="l08026"></a>08026     <span class="keyword">typename</span> ind_type0_,
<a name="l08027"></a>08027     <span class="keyword">typename</span> ind_type1_
<a name="l08028"></a>08028     &gt;
<a name="l08029"></a>08029 LITE_INLINE 
<a name="l08030"></a>08030 <span class="keyword">typename</span> std::iterator_traits&lt;pack&lt;
<a name="l08031"></a>08031     iter_type_,
<a name="l08032"></a>08032     ind_type0_,
<a name="l08033"></a>08033     ind_type1_
<a name="l08034"></a>08034     &gt; &gt;::reference 
<a name="l08035"></a>08035 at(<span class="keyword">const</span> pack&lt;
<a name="l08036"></a>08036     iter_type_,
<a name="l08037"></a>08037     ind_type0_,
<a name="l08038"></a>08038     ind_type1_
<a name="l08039"></a>08039     &gt;&amp; it,
<a name="l08040"></a>08040     <span class="keywordtype">int</span> ind0
<a name="l08041"></a>08041     )
<a name="l08042"></a>08042 {
<a name="l08043"></a>08043     <span class="keywordflow">return</span> *(it.i0+ind0*it.i2);
<a name="l08044"></a>08044 }
<a name="l08045"></a>08045 <span class="keyword">template</span>&lt;
<a name="l08046"></a>08046     <span class="keyword">typename</span> iter_type_,
<a name="l08047"></a>08047     <span class="keyword">typename</span> ind_type0_,
<a name="l08048"></a>08048     <span class="keyword">typename</span> ind_type1_
<a name="l08049"></a>08049     &gt;
<a name="l08050"></a>08050 LITE_INLINE 
<a name="l08051"></a>08051 <span class="keyword">typename</span> std::iterator_traits&lt;pack&lt;
<a name="l08052"></a>08052     iter_type_,
<a name="l08053"></a>08053     ind_type0_,
<a name="l08054"></a>08054     ind_type1_
<a name="l08055"></a>08055     &gt; &gt;::reference 
<a name="l08056"></a>08056 at(<span class="keyword">const</span> pack&lt;
<a name="l08057"></a>08057     iter_type_,
<a name="l08058"></a>08058     ind_type0_,
<a name="l08059"></a>08059     ind_type1_
<a name="l08060"></a>08060     &gt;&amp; it,
<a name="l08061"></a>08061     <span class="keywordtype">int</span> ind0,
<a name="l08062"></a>08062     <span class="keywordtype">int</span> ind1
<a name="l08063"></a>08063     )
<a name="l08064"></a>08064 {
<a name="l08065"></a>08065     <span class="keywordflow">return</span> *(it.i0+ind0*it.i1+ind1*it.i2);
<a name="l08066"></a>08066 }
<a name="l08067"></a>08067 <span class="keyword">template</span>&lt;
<a name="l08068"></a>08068     <span class="keyword">typename</span> iter_type_,
<a name="l08069"></a>08069     <span class="keyword">typename</span> ind_type0_,
<a name="l08070"></a>08070     <span class="keyword">typename</span> ind_type1_,
<a name="l08071"></a>08071     <span class="keyword">typename</span> ind_type2_
<a name="l08072"></a>08072     &gt;
<a name="l08073"></a>08073 LITE_INLINE 
<a name="l08074"></a>08074 <span class="keyword">typename</span> std::iterator_traits&lt;pack&lt;
<a name="l08075"></a>08075     iter_type_,
<a name="l08076"></a>08076     ind_type0_,
<a name="l08077"></a>08077     ind_type1_,
<a name="l08078"></a>08078     ind_type2_
<a name="l08079"></a>08079     &gt; &gt;::reference 
<a name="l08080"></a>08080 at(<span class="keyword">const</span> pack&lt;
<a name="l08081"></a>08081     iter_type_,
<a name="l08082"></a>08082     ind_type0_,
<a name="l08083"></a>08083     ind_type1_,
<a name="l08084"></a>08084     ind_type2_
<a name="l08085"></a>08085     &gt;&amp; it
<a name="l08086"></a>08086     )
<a name="l08087"></a>08087 {
<a name="l08088"></a>08088     <span class="keywordflow">return</span> *(it.i0);
<a name="l08089"></a>08089 }
<a name="l08090"></a>08090 <span class="keyword">template</span>&lt;
<a name="l08091"></a>08091     <span class="keyword">typename</span> iter_type_,
<a name="l08092"></a>08092     <span class="keyword">typename</span> ind_type0_,
<a name="l08093"></a>08093     <span class="keyword">typename</span> ind_type1_,
<a name="l08094"></a>08094     <span class="keyword">typename</span> ind_type2_
<a name="l08095"></a>08095     &gt;
<a name="l08096"></a>08096 LITE_INLINE 
<a name="l08097"></a>08097 <span class="keyword">typename</span> std::iterator_traits&lt;pack&lt;
<a name="l08098"></a>08098     iter_type_,
<a name="l08099"></a>08099     ind_type0_,
<a name="l08100"></a>08100     ind_type1_,
<a name="l08101"></a>08101     ind_type2_
<a name="l08102"></a>08102     &gt; &gt;::reference 
<a name="l08103"></a>08103 at(<span class="keyword">const</span> pack&lt;
<a name="l08104"></a>08104     iter_type_,
<a name="l08105"></a>08105     ind_type0_,
<a name="l08106"></a>08106     ind_type1_,
<a name="l08107"></a>08107     ind_type2_
<a name="l08108"></a>08108     &gt;&amp; it,
<a name="l08109"></a>08109     <span class="keywordtype">int</span> ind0
<a name="l08110"></a>08110     )
<a name="l08111"></a>08111 {
<a name="l08112"></a>08112     <span class="keywordflow">return</span> *(it.i0+ind0*it.i3);
<a name="l08113"></a>08113 }
<a name="l08114"></a>08114 <span class="keyword">template</span>&lt;
<a name="l08115"></a>08115     <span class="keyword">typename</span> iter_type_,
<a name="l08116"></a>08116     <span class="keyword">typename</span> ind_type0_,
<a name="l08117"></a>08117     <span class="keyword">typename</span> ind_type1_,
<a name="l08118"></a>08118     <span class="keyword">typename</span> ind_type2_
<a name="l08119"></a>08119     &gt;
<a name="l08120"></a>08120 LITE_INLINE 
<a name="l08121"></a>08121 <span class="keyword">typename</span> std::iterator_traits&lt;pack&lt;
<a name="l08122"></a>08122     iter_type_,
<a name="l08123"></a>08123     ind_type0_,
<a name="l08124"></a>08124     ind_type1_,
<a name="l08125"></a>08125     ind_type2_
<a name="l08126"></a>08126     &gt; &gt;::reference 
<a name="l08127"></a>08127 at(<span class="keyword">const</span> pack&lt;
<a name="l08128"></a>08128     iter_type_,
<a name="l08129"></a>08129     ind_type0_,
<a name="l08130"></a>08130     ind_type1_,
<a name="l08131"></a>08131     ind_type2_
<a name="l08132"></a>08132     &gt;&amp; it,
<a name="l08133"></a>08133     <span class="keywordtype">int</span> ind0,
<a name="l08134"></a>08134     <span class="keywordtype">int</span> ind1
<a name="l08135"></a>08135     )
<a name="l08136"></a>08136 {
<a name="l08137"></a>08137     <span class="keywordflow">return</span> *(it.i0+ind0*it.i2+ind1*it.i3);
<a name="l08138"></a>08138 }
<a name="l08139"></a>08139 <span class="keyword">template</span>&lt;
<a name="l08140"></a>08140     <span class="keyword">typename</span> iter_type_,
<a name="l08141"></a>08141     <span class="keyword">typename</span> ind_type0_,
<a name="l08142"></a>08142     <span class="keyword">typename</span> ind_type1_,
<a name="l08143"></a>08143     <span class="keyword">typename</span> ind_type2_
<a name="l08144"></a>08144     &gt;
<a name="l08145"></a>08145 LITE_INLINE 
<a name="l08146"></a>08146 <span class="keyword">typename</span> std::iterator_traits&lt;pack&lt;
<a name="l08147"></a>08147     iter_type_,
<a name="l08148"></a>08148     ind_type0_,
<a name="l08149"></a>08149     ind_type1_,
<a name="l08150"></a>08150     ind_type2_
<a name="l08151"></a>08151     &gt; &gt;::reference 
<a name="l08152"></a>08152 at(<span class="keyword">const</span> pack&lt;
<a name="l08153"></a>08153     iter_type_,
<a name="l08154"></a>08154     ind_type0_,
<a name="l08155"></a>08155     ind_type1_,
<a name="l08156"></a>08156     ind_type2_
<a name="l08157"></a>08157     &gt;&amp; it,
<a name="l08158"></a>08158     <span class="keywordtype">int</span> ind0,
<a name="l08159"></a>08159     <span class="keywordtype">int</span> ind1,
<a name="l08160"></a>08160     <span class="keywordtype">int</span> ind2
<a name="l08161"></a>08161     )
<a name="l08162"></a>08162 {
<a name="l08163"></a>08163     <span class="keywordflow">return</span> *(it.i0+ind0*it.i1+ind1*it.i2+ind2*it.i3);
<a name="l08164"></a>08164 }
<a name="l08165"></a>08165 
<a name="l08166"></a>08166 <span class="comment">/***********************************************************************************************************/</span>
<a name="l08167"></a>08167 <span class="comment">/* s_iterator, inc() ***************************************************************************************/</span>
<a name="l08168"></a>08168 <span class="comment">/***********************************************************************************************************/</span>
<a name="l08169"></a>08169 
<a name="l08170"></a>08170 <span class="keyword">template</span>&lt;
<a name="l08171"></a>08171     <span class="keywordtype">int</span> dim_, 
<a name="l08172"></a>08172     <span class="keyword">typename</span> iter_type_,
<a name="l08173"></a>08173     <span class="keyword">typename</span> ind_type0_,
<a name="l08174"></a>08174     <span class="keyword">typename</span> ind_type1_,
<a name="l08175"></a>08175     <span class="keyword">typename</span> ind_type2_
<a name="l08176"></a>08176     &gt;
<a name="l08177"></a>08177 LITE_INLINE 
<a name="l08178"></a>08178 <span class="keyword">typename</span> detail::enable_if&lt;dim_==0, void&gt;::type 
<a name="l08179"></a>08179 inc(pack&lt;
<a name="l08180"></a>08180     iter_type_,
<a name="l08181"></a>08181     ind_type0_,
<a name="l08182"></a>08182     ind_type1_,
<a name="l08183"></a>08183     ind_type2_
<a name="l08184"></a>08184     &gt;&amp; it)
<a name="l08185"></a>08185 {
<a name="l08186"></a>08186     it.i0 += it.i1;
<a name="l08187"></a>08187 }
<a name="l08188"></a>08188 
<a name="l08189"></a>08189 <span class="keyword">template</span>&lt;
<a name="l08190"></a>08190     <span class="keywordtype">int</span> dim_, 
<a name="l08191"></a>08191     <span class="keyword">typename</span> iter_type_,
<a name="l08192"></a>08192     <span class="keyword">typename</span> ind_type0_,
<a name="l08193"></a>08193     <span class="keyword">typename</span> ind_type1_,
<a name="l08194"></a>08194     <span class="keyword">typename</span> ind_type2_
<a name="l08195"></a>08195     &gt;
<a name="l08196"></a>08196 LITE_INLINE 
<a name="l08197"></a>08197 <span class="keyword">typename</span> detail::enable_if&lt;dim_==1, void&gt;::type 
<a name="l08198"></a>08198 inc(pack&lt;
<a name="l08199"></a>08199     iter_type_,
<a name="l08200"></a>08200     ind_type0_,
<a name="l08201"></a>08201     ind_type1_,
<a name="l08202"></a>08202     ind_type2_
<a name="l08203"></a>08203     &gt;&amp; it)
<a name="l08204"></a>08204 {
<a name="l08205"></a>08205     it.i0 += it.i2;
<a name="l08206"></a>08206 }
<a name="l08207"></a>08207 
<a name="l08208"></a>08208 <span class="keyword">template</span>&lt;
<a name="l08209"></a>08209     <span class="keywordtype">int</span> dim_, 
<a name="l08210"></a>08210     <span class="keyword">typename</span> iter_type_,
<a name="l08211"></a>08211     <span class="keyword">typename</span> ind_type0_,
<a name="l08212"></a>08212     <span class="keyword">typename</span> ind_type1_,
<a name="l08213"></a>08213     <span class="keyword">typename</span> ind_type2_
<a name="l08214"></a>08214     &gt;
<a name="l08215"></a>08215 LITE_INLINE 
<a name="l08216"></a>08216 <span class="keyword">typename</span> detail::enable_if&lt;dim_==2, void&gt;::type 
<a name="l08217"></a>08217 inc(pack&lt;
<a name="l08218"></a>08218     iter_type_,
<a name="l08219"></a>08219     ind_type0_,
<a name="l08220"></a>08220     ind_type1_,
<a name="l08221"></a>08221     ind_type2_
<a name="l08222"></a>08222     &gt;&amp; it)
<a name="l08223"></a>08223 {
<a name="l08224"></a>08224     it.i0 += it.i3;
<a name="l08225"></a>08225 }
<a name="l08226"></a>08226 
<a name="l08227"></a>08227 
<a name="l08228"></a>08228 <span class="comment">/***********************************************************************************************************/</span>
<a name="l08229"></a>08229 <span class="comment">/* s_iterator, dec() ***************************************************************************************/</span>
<a name="l08230"></a>08230 <span class="comment">/***********************************************************************************************************/</span>
<a name="l08231"></a>08231 
<a name="l08232"></a>08232 <span class="keyword">template</span>&lt;
<a name="l08233"></a>08233     <span class="keywordtype">int</span> dim_, 
<a name="l08234"></a>08234     <span class="keyword">typename</span> iter_type_,
<a name="l08235"></a>08235     <span class="keyword">typename</span> ind_type0_,
<a name="l08236"></a>08236     <span class="keyword">typename</span> ind_type1_,
<a name="l08237"></a>08237     <span class="keyword">typename</span> ind_type2_
<a name="l08238"></a>08238     &gt;
<a name="l08239"></a>08239 LITE_INLINE 
<a name="l08240"></a>08240 <span class="keyword">typename</span> detail::enable_if&lt;dim_==0, void&gt;::type 
<a name="l08241"></a>08241 dec(pack&lt;
<a name="l08242"></a>08242     iter_type_,
<a name="l08243"></a>08243     ind_type0_,
<a name="l08244"></a>08244     ind_type1_,
<a name="l08245"></a>08245     ind_type2_
<a name="l08246"></a>08246     &gt;&amp; it)
<a name="l08247"></a>08247 {
<a name="l08248"></a>08248     it.i0 -= it.i1;
<a name="l08249"></a>08249 }
<a name="l08250"></a>08250 
<a name="l08251"></a>08251 <span class="keyword">template</span>&lt;
<a name="l08252"></a>08252     <span class="keywordtype">int</span> dim_, 
<a name="l08253"></a>08253     <span class="keyword">typename</span> iter_type_,
<a name="l08254"></a>08254     <span class="keyword">typename</span> ind_type0_,
<a name="l08255"></a>08255     <span class="keyword">typename</span> ind_type1_,
<a name="l08256"></a>08256     <span class="keyword">typename</span> ind_type2_
<a name="l08257"></a>08257     &gt;
<a name="l08258"></a>08258 LITE_INLINE 
<a name="l08259"></a>08259 <span class="keyword">typename</span> detail::enable_if&lt;dim_==1, void&gt;::type 
<a name="l08260"></a>08260 dec(pack&lt;
<a name="l08261"></a>08261     iter_type_,
<a name="l08262"></a>08262     ind_type0_,
<a name="l08263"></a>08263     ind_type1_,
<a name="l08264"></a>08264     ind_type2_
<a name="l08265"></a>08265     &gt;&amp; it)
<a name="l08266"></a>08266 {
<a name="l08267"></a>08267     it.i0 -= it.i2;
<a name="l08268"></a>08268 }
<a name="l08269"></a>08269 
<a name="l08270"></a>08270 <span class="keyword">template</span>&lt;
<a name="l08271"></a>08271     <span class="keywordtype">int</span> dim_, 
<a name="l08272"></a>08272     <span class="keyword">typename</span> iter_type_,
<a name="l08273"></a>08273     <span class="keyword">typename</span> ind_type0_,
<a name="l08274"></a>08274     <span class="keyword">typename</span> ind_type1_,
<a name="l08275"></a>08275     <span class="keyword">typename</span> ind_type2_
<a name="l08276"></a>08276     &gt;
<a name="l08277"></a>08277 LITE_INLINE 
<a name="l08278"></a>08278 <span class="keyword">typename</span> detail::enable_if&lt;dim_==2, void&gt;::type 
<a name="l08279"></a>08279 dec(pack&lt;
<a name="l08280"></a>08280     iter_type_,
<a name="l08281"></a>08281     ind_type0_,
<a name="l08282"></a>08282     ind_type1_,
<a name="l08283"></a>08283     ind_type2_
<a name="l08284"></a>08284     &gt;&amp; it)
<a name="l08285"></a>08285 {
<a name="l08286"></a>08286     it.i0 -= it.i3;
<a name="l08287"></a>08287 }
<a name="l08288"></a>08288 
<a name="l08289"></a>08289 
<a name="l08290"></a>08290 <span class="comment">/***********************************************************************************************************/</span>
<a name="l08291"></a>08291 <span class="comment">/* s_iterator, shift() *************************************************************************************/</span>
<a name="l08292"></a>08292 <span class="comment">/***********************************************************************************************************/</span>
<a name="l08293"></a>08293 
<a name="l08294"></a>08294 <span class="keyword">template</span>&lt;
<a name="l08295"></a>08295     <span class="keywordtype">int</span> dim_, 
<a name="l08296"></a>08296     <span class="keyword">typename</span> iter_type_,
<a name="l08297"></a>08297     <span class="keyword">typename</span> ind_type0_,
<a name="l08298"></a>08298     <span class="keyword">typename</span> ind_type1_,
<a name="l08299"></a>08299     <span class="keyword">typename</span> ind_type2_
<a name="l08300"></a>08300     &gt;
<a name="l08301"></a>08301 LITE_INLINE 
<a name="l08302"></a>08302 <span class="keyword">typename</span> detail::enable_if&lt;dim_==0, void&gt;::type 
<a name="l08303"></a>08303 shift(pack&lt;
<a name="l08304"></a>08304     iter_type_,
<a name="l08305"></a>08305     ind_type0_,
<a name="l08306"></a>08306     ind_type1_,
<a name="l08307"></a>08307     ind_type2_
<a name="l08308"></a>08308     &gt;&amp; it,
<a name="l08309"></a>08309     <span class="keywordtype">int</span> diff)
<a name="l08310"></a>08310 {
<a name="l08311"></a>08311     it.i0 += diff*it.i1;
<a name="l08312"></a>08312 }
<a name="l08313"></a>08313 
<a name="l08314"></a>08314 <span class="keyword">template</span>&lt;
<a name="l08315"></a>08315     <span class="keywordtype">int</span> dim_, 
<a name="l08316"></a>08316     <span class="keyword">typename</span> iter_type_,
<a name="l08317"></a>08317     <span class="keyword">typename</span> ind_type0_,
<a name="l08318"></a>08318     <span class="keyword">typename</span> ind_type1_,
<a name="l08319"></a>08319     <span class="keyword">typename</span> ind_type2_
<a name="l08320"></a>08320     &gt;
<a name="l08321"></a>08321 LITE_INLINE 
<a name="l08322"></a>08322 <span class="keyword">typename</span> detail::enable_if&lt;dim_==1, void&gt;::type 
<a name="l08323"></a>08323 shift(pack&lt;
<a name="l08324"></a>08324     iter_type_,
<a name="l08325"></a>08325     ind_type0_,
<a name="l08326"></a>08326     ind_type1_,
<a name="l08327"></a>08327     ind_type2_
<a name="l08328"></a>08328     &gt;&amp; it,
<a name="l08329"></a>08329     <span class="keywordtype">int</span> diff)
<a name="l08330"></a>08330 {
<a name="l08331"></a>08331     it.i0 += diff*it.i2;
<a name="l08332"></a>08332 }
<a name="l08333"></a>08333 
<a name="l08334"></a>08334 <span class="keyword">template</span>&lt;
<a name="l08335"></a>08335     <span class="keywordtype">int</span> dim_, 
<a name="l08336"></a>08336     <span class="keyword">typename</span> iter_type_,
<a name="l08337"></a>08337     <span class="keyword">typename</span> ind_type0_,
<a name="l08338"></a>08338     <span class="keyword">typename</span> ind_type1_,
<a name="l08339"></a>08339     <span class="keyword">typename</span> ind_type2_
<a name="l08340"></a>08340     &gt;
<a name="l08341"></a>08341 LITE_INLINE 
<a name="l08342"></a>08342 <span class="keyword">typename</span> detail::enable_if&lt;dim_==2, void&gt;::type 
<a name="l08343"></a>08343 shift(pack&lt;
<a name="l08344"></a>08344     iter_type_,
<a name="l08345"></a>08345     ind_type0_,
<a name="l08346"></a>08346     ind_type1_,
<a name="l08347"></a>08347     ind_type2_
<a name="l08348"></a>08348     &gt;&amp; it,
<a name="l08349"></a>08349     <span class="keywordtype">int</span> diff)
<a name="l08350"></a>08350 {
<a name="l08351"></a>08351     it.i0 += diff*it.i3;
<a name="l08352"></a>08352 }
<a name="l08353"></a>08353 
<a name="l08354"></a>08354 
<a name="l08355"></a>08355 <span class="comment">/***********************************************************************************************************/</span>
<a name="l08356"></a>08356 <span class="comment">/* c_iterator **********************************************************************************************/</span>
<a name="l08357"></a>08357 <span class="comment">/***********************************************************************************************************/</span>
<a name="l08358"></a>08358 
<a name="l08391"></a>08391 <span class="keyword">template</span>&lt;<span class="keyword">class</span> value_type_&gt;
<a name="l08392"></a><a class="code" href="classlite_1_1c__iterator.html">08392</a> <span class="keyword">class </span><a class="code" href="classlite_1_1c__iterator.html" title="This class implements an iterator that returns the same value everywhere.">c_iterator</a>
<a name="l08393"></a>08393 {
<a name="l08394"></a>08394 <span class="keyword">public</span>:
<a name="l08395"></a>08395     <span class="keyword">typedef</span> std::random_access_iterator_tag iterator_category; 
<a name="l08396"></a>08396     <span class="keyword">typedef</span> value_type_ value_type;
<a name="l08397"></a>08397     <span class="keyword">typedef</span> ptrdiff_t difference_type;
<a name="l08398"></a>08398     <span class="keyword">typedef</span> <span class="keyword">const</span> value_type_* pointer;
<a name="l08399"></a>08399     <span class="keyword">typedef</span> <span class="keyword">const</span> value_type_&amp; reference;
<a name="l08400"></a>08400 
<a name="l08401"></a>08401     LITE_INLINE <a class="code" href="classlite_1_1c__iterator.html" title="This class implements an iterator that returns the same value everywhere.">c_iterator</a>() {}
<a name="l08402"></a>08402 
<a name="l08404"></a><a class="code" href="classlite_1_1c__iterator.html#add3c5a8cde9695805f03fcd97ea03fc1">08404</a>     LITE_INLINE <a class="code" href="classlite_1_1c__iterator.html#add3c5a8cde9695805f03fcd97ea03fc1" title="Construct a c_iterator that returns value everywhere.">c_iterator</a>(<span class="keyword">const</span> value_type&amp; <a class="code" href="classlite_1_1c__iterator.html#a0ffd888252d8b8552bf974b9a7d12ee7" title="This variable stores the value that is returned by c_iterator.">value</a>) : value(value) {}
<a name="l08405"></a>08405 
<a name="l08406"></a>08406     LITE_INLINE <a class="code" href="classlite_1_1c__iterator.html" title="This class implements an iterator that returns the same value everywhere.">c_iterator</a>(<span class="keyword">const</span> <a class="code" href="classlite_1_1c__iterator.html" title="This class implements an iterator that returns the same value everywhere.">c_iterator</a>&amp; other) : <a class="code" href="classlite_1_1c__iterator.html#a0ffd888252d8b8552bf974b9a7d12ee7" title="This variable stores the value that is returned by c_iterator.">value</a>(other.<a class="code" href="classlite_1_1c__iterator.html#a0ffd888252d8b8552bf974b9a7d12ee7" title="This variable stores the value that is returned by c_iterator.">value</a>) {}
<a name="l08407"></a>08407 
<a name="l08408"></a>08408     <span class="keyword">template</span>&lt;<span class="keyword">class</span> other_value_type_&gt;
<a name="l08409"></a>08409     LITE_INLINE c_iterator(<span class="keyword">const</span> c_iterator&lt;other_value_type_&gt;&amp; other) : <a class="code" href="classlite_1_1c__iterator.html#a0ffd888252d8b8552bf974b9a7d12ee7" title="This variable stores the value that is returned by c_iterator.">value</a>(other.<a class="code" href="classlite_1_1c__iterator.html#a0ffd888252d8b8552bf974b9a7d12ee7" title="This variable stores the value that is returned by c_iterator.">value</a>) {}
<a name="l08410"></a>08410 
<a name="l08411"></a>08411     LITE_INLINE c_iterator&amp; operator=(<span class="keyword">const</span> c_iterator&amp; other) 
<a name="l08412"></a>08412     {
<a name="l08413"></a>08413         <a class="code" href="classlite_1_1c__iterator.html#a0ffd888252d8b8552bf974b9a7d12ee7" title="This variable stores the value that is returned by c_iterator.">value</a> = other.value;
<a name="l08414"></a>08414         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l08415"></a>08415     }
<a name="l08416"></a>08416 
<a name="l08417"></a>08417     <span class="keyword">template</span>&lt;<span class="keyword">class</span> other_value_type_&gt;
<a name="l08418"></a>08418     LITE_INLINE c_iterator&amp; operator=(<span class="keyword">const</span> c_iterator&lt;other_value_type_&gt;&amp; other)
<a name="l08419"></a>08419     {
<a name="l08420"></a>08420         <a class="code" href="classlite_1_1c__iterator.html#a0ffd888252d8b8552bf974b9a7d12ee7" title="This variable stores the value that is returned by c_iterator.">value</a> = other.value;
<a name="l08421"></a>08421         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l08422"></a>08422     }
<a name="l08423"></a>08423 
<a name="l08425"></a><a class="code" href="classlite_1_1c__iterator.html#a0ffd888252d8b8552bf974b9a7d12ee7">08425</a>     value_type <a class="code" href="classlite_1_1c__iterator.html#a0ffd888252d8b8552bf974b9a7d12ee7" title="This variable stores the value that is returned by c_iterator.">value</a>;
<a name="l08426"></a>08426 };
<a name="l08427"></a>08427 
<a name="l08433"></a>08433 <span class="keyword">template</span>&lt;<span class="keyword">class</span> value_type_&gt;
<a name="l08434"></a>08434 LITE_INLINE <a class="code" href="classlite_1_1c__iterator.html" title="This class implements an iterator that returns the same value everywhere.">c_iterator&lt;value_type_&gt;</a> 
<a name="l08435"></a><a class="code" href="group__array__advanced.html#ga96bbe207cf4044ddd6ac0079bcf2609b">08435</a> <a class="code" href="group__array__advanced.html#ga96bbe207cf4044ddd6ac0079bcf2609b" title="Constructs and returns a lite::c_iterator that returns val everywhere.">make_c_iterator</a>(<span class="keyword">const</span> value_type_&amp; val)
<a name="l08436"></a>08436 {
<a name="l08437"></a>08437     <span class="keywordflow">return</span> <a class="code" href="classlite_1_1c__iterator.html" title="This class implements an iterator that returns the same value everywhere.">c_iterator&lt;value_type_&gt;</a>(val);
<a name="l08438"></a>08438 }
<a name="l08439"></a>08439 
<a name="l08440"></a>08440 <span class="comment">/***********************************************************************************************************/</span>
<a name="l08441"></a>08441 <span class="comment">/* c_iterator, at() ****************************************************************************************/</span>
<a name="l08442"></a>08442 <span class="comment">/***********************************************************************************************************/</span>
<a name="l08443"></a>08443 
<a name="l08444"></a>08444 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> value_type_&gt;
<a name="l08445"></a>08445 LITE_INLINE 
<a name="l08446"></a>08446 <span class="keyword">typename</span> std::iterator_traits&lt;c_iterator&lt;value_type_&gt; &gt;::reference
<a name="l08447"></a>08447 at(<span class="keyword">const</span> c_iterator&lt;value_type_&gt;&amp; it )
<a name="l08448"></a>08448 {
<a name="l08449"></a>08449     <span class="keywordflow">return</span> it.value;
<a name="l08450"></a>08450 }
<a name="l08451"></a>08451 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> value_type_&gt;
<a name="l08452"></a>08452 LITE_INLINE 
<a name="l08453"></a>08453 <span class="keyword">typename</span> std::iterator_traits&lt;c_iterator&lt;value_type_&gt; &gt;::reference
<a name="l08454"></a>08454 at(<span class="keyword">const</span> c_iterator&lt;value_type_&gt;&amp; it, <span class="keywordtype">int</span> )
<a name="l08455"></a>08455 {
<a name="l08456"></a>08456     <span class="keywordflow">return</span> it.value;
<a name="l08457"></a>08457 }
<a name="l08458"></a>08458 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> value_type_&gt;
<a name="l08459"></a>08459 LITE_INLINE 
<a name="l08460"></a>08460 <span class="keyword">typename</span> std::iterator_traits&lt;c_iterator&lt;value_type_&gt; &gt;::reference
<a name="l08461"></a>08461 at(<span class="keyword">const</span> c_iterator&lt;value_type_&gt;&amp; it, <span class="keywordtype">int</span> , <span class="keywordtype">int</span> )
<a name="l08462"></a>08462 {
<a name="l08463"></a>08463     <span class="keywordflow">return</span> it.value;
<a name="l08464"></a>08464 }
<a name="l08465"></a>08465 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> value_type_&gt;
<a name="l08466"></a>08466 LITE_INLINE 
<a name="l08467"></a>08467 <span class="keyword">typename</span> std::iterator_traits&lt;c_iterator&lt;value_type_&gt; &gt;::reference
<a name="l08468"></a>08468 at(<span class="keyword">const</span> c_iterator&lt;value_type_&gt;&amp; it, <span class="keywordtype">int</span> , <span class="keywordtype">int</span> , <span class="keywordtype">int</span> )
<a name="l08469"></a>08469 {
<a name="l08470"></a>08470     <span class="keywordflow">return</span> it.value;
<a name="l08471"></a>08471 }
<a name="l08472"></a>08472 
<a name="l08473"></a>08473 <span class="comment">/***********************************************************************************************************/</span>
<a name="l08474"></a>08474 <span class="comment">/* c_iterator, inc() ***************************************************************************************/</span>
<a name="l08475"></a>08475 <span class="comment">/***********************************************************************************************************/</span>
<a name="l08476"></a>08476 
<a name="l08477"></a>08477 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim_, <span class="keyword">typename</span> value_type_&gt;
<a name="l08478"></a>08478 LITE_INLINE <span class="keywordtype">void</span> inc(c_iterator&lt;value_type_&gt;&amp;) {}
<a name="l08479"></a>08479 
<a name="l08480"></a>08480 <span class="comment">/***********************************************************************************************************/</span>
<a name="l08481"></a>08481 <span class="comment">/* c_iterator, dec() ***************************************************************************************/</span>
<a name="l08482"></a>08482 <span class="comment">/***********************************************************************************************************/</span>
<a name="l08483"></a>08483 
<a name="l08484"></a>08484 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim_, <span class="keyword">typename</span> value_type_&gt;
<a name="l08485"></a>08485 LITE_INLINE <span class="keywordtype">void</span> dec(c_iterator&lt;value_type_&gt;&amp;) {}
<a name="l08486"></a>08486 
<a name="l08487"></a>08487 <span class="comment">/***********************************************************************************************************/</span>
<a name="l08488"></a>08488 <span class="comment">/* c_iterator, shift() *************************************************************************************/</span>
<a name="l08489"></a>08489 <span class="comment">/***********************************************************************************************************/</span>
<a name="l08490"></a>08490 
<a name="l08491"></a>08491 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim_, <span class="keyword">typename</span> value_type_&gt;
<a name="l08492"></a>08492 LITE_INLINE <span class="keywordtype">void</span> shift(c_iterator&lt;value_type_&gt;&amp;, <span class="keywordtype">int</span>) {}
<a name="l08493"></a>08493 
<a name="l08494"></a>08494 <span class="comment">/***********************************************************************************************************/</span>
<a name="l08495"></a>08495 <span class="comment">/* u_iterator **********************************************************************************************/</span>
<a name="l08496"></a>08496 <span class="comment">/***********************************************************************************************************/</span>
<a name="l08497"></a>08497 
<a name="l08498"></a>08498 <span class="preprocessor">#ifdef DOCUMENTATION_ONLY</span>
<a name="l08499"></a>08499 <span class="preprocessor"></span>
<a name="l08542"></a>08542 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> base_iter_type_, <span class="keyword">typename</span> func_type_, <span class="keywordtype">bool</span> is_static_ =true&gt;
<a name="l08543"></a><a class="code" href="classlite_1_1u__iterator.html">08543</a> <span class="keyword">class </span><a class="code" href="classlite_1_1u__iterator.html" title="This class implements an iterator that returns the result of applying a function...">u_iterator</a>
<a name="l08544"></a>08544 {
<a name="l08545"></a>08545 <span class="keyword">public</span>:
<a name="l08546"></a>08546     <span class="keyword">typedef</span> base_iter_type_ base_iterator_type;
<a name="l08547"></a>08547     <span class="keyword">typedef</span> func_type_ function_type;
<a name="l08548"></a>08548     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_static = is_static_;
<a name="l08549"></a>08549 
<a name="l08550"></a>08550     <span class="keyword">typedef</span> std::random_access_iterator_tag iterator_category;
<a name="l08551"></a>08551     <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::remove&lt;typename func_type_::result_type, const volatile int&amp;&gt;::type value_type;
<a name="l08552"></a>08552     <span class="keyword">typedef</span> ptrdiff_t difference_type;
<a name="l08553"></a>08553     <span class="keyword">typedef</span> <span class="keyword">typename</span> func_type_::result_type reference;
<a name="l08554"></a>08554     <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::remove&lt;typename func_type_::result_type, int&amp;&gt;::type* pointer;
<a name="l08555"></a>08555 
<a name="l08556"></a>08556     LITE_INLINE <a class="code" href="classlite_1_1u__iterator.html" title="This class implements an iterator that returns the result of applying a function...">u_iterator</a>();
<a name="l08557"></a>08557 
<a name="l08559"></a>08559     <span class="keyword">template</span>&lt;<span class="keyword">class</span> other_base_iter_type_&gt;
<a name="l08560"></a>08560     LITE_INLINE u_iterator(<span class="keyword">const</span> other_base_iter_type_&amp; base_iter);
<a name="l08561"></a>08561 
<a name="l08567"></a>08567     <span class="keyword">template</span>&lt;<span class="keyword">class</span> other_base_iter_type_&gt;
<a name="l08568"></a>08568     LITE_INLINE u_iterator(<span class="keyword">const</span> other_base_iter_type_&amp; base_iter, <span class="keyword">const</span> function_type&amp; func);
<a name="l08569"></a>08569 
<a name="l08570"></a>08570     LITE_INLINE u_iterator(<span class="keyword">const</span> u_iterator&amp; other);
<a name="l08571"></a>08571 
<a name="l08572"></a>08572     <span class="keyword">template</span>&lt;<span class="keyword">class</span> other_base_iter_type_&gt;
<a name="l08573"></a>08573     LITE_INLINE u_iterator(<span class="keyword">const</span> <a class="code" href="classlite_1_1u__iterator.html" title="This class implements an iterator that returns the result of applying a function...">u_iterator&lt;other_base_iter_type_, func_type_, is_static_&gt;</a>&amp; other);
<a name="l08574"></a>08574 
<a name="l08575"></a>08575     LITE_INLINE u_iterator&amp; operator=(<span class="keyword">const</span> u_iterator&amp; other);
<a name="l08576"></a>08576 
<a name="l08577"></a>08577     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_base_iter_type_&gt;
<a name="l08578"></a>08578     LITE_INLINE u_iterator&amp; operator=(<span class="keyword">const</span> <a class="code" href="classlite_1_1u__iterator.html" title="This class implements an iterator that returns the result of applying a function...">u_iterator&lt;other_base_iter_type_, func_type_, is_static_&gt;</a>&amp; other);
<a name="l08579"></a>08579 
<a name="l08581"></a><a class="code" href="classlite_1_1u__iterator.html#a7347f04421cccc7337499d623d4f40e1">08581</a>     base_iterator_type <a class="code" href="classlite_1_1u__iterator.html#a7347f04421cccc7337499d623d4f40e1" title="This variable stores the base iterator.">base_iterator</a>;
<a name="l08582"></a>08582 
<a name="l08584"></a><a class="code" href="classlite_1_1u__iterator.html#ae3d820e2478d82889d247fc378982b45">08584</a>     function_type <a class="code" href="classlite_1_1u__iterator.html#ae3d820e2478d82889d247fc378982b45" title="This variable stores the function object. It will be a static member if is_static_...">function</a>;
<a name="l08585"></a>08585 };
<a name="l08586"></a>08586 
<a name="l08587"></a>08587 <span class="preprocessor">#endif // DOCUMENTATION_ONLY</span>
<a name="l08588"></a>08588 <span class="preprocessor"></span>
<a name="l08589"></a>08589 <span class="comment">/***********************************************************************************************************/</span>
<a name="l08590"></a>08590 <span class="comment">/* u_iterator - unary iterator (static) ********************************************************************/</span>
<a name="l08591"></a>08591 <span class="comment">/***********************************************************************************************************/</span>
<a name="l08592"></a>08592 
<a name="l08593"></a>08593 <span class="preprocessor">#ifndef DOCUMENTATION_ONLY</span>
<a name="l08594"></a>08594 <span class="preprocessor"></span>
<a name="l08595"></a>08595 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> base_iter_type_, <span class="keyword">typename</span> func_type_&gt;
<a name="l08596"></a>08596 <span class="keyword">class </span><a class="code" href="classlite_1_1u__iterator.html" title="This class implements an iterator that returns the result of applying a function...">u_iterator</a>&lt;base_iter_type_, func_type_, true&gt;
<a name="l08597"></a>08597 {
<a name="l08598"></a>08598 <span class="keyword">public</span>:
<a name="l08599"></a>08599     <span class="keyword">typedef</span> base_iter_type_ base_iterator_type;
<a name="l08600"></a>08600     <span class="keyword">typedef</span> func_type_ function_type;
<a name="l08601"></a>08601     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_static = <span class="keyword">true</span>;
<a name="l08602"></a>08602 
<a name="l08603"></a>08603     <span class="keyword">typedef</span> std::random_access_iterator_tag iterator_category;
<a name="l08604"></a>08604     <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::remove&lt;typename func_type_::result_type, const volatile int&amp;&gt;::type value_type;
<a name="l08605"></a>08605     <span class="keyword">typedef</span> ptrdiff_t difference_type;
<a name="l08606"></a>08606     <span class="keyword">typedef</span> <span class="keyword">typename</span> func_type_::result_type reference;
<a name="l08607"></a>08607     <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::remove&lt;typename func_type_::result_type, int&amp;&gt;::type* pointer;
<a name="l08608"></a>08608 
<a name="l08609"></a>08609     LITE_INLINE <a class="code" href="classlite_1_1u__iterator.html" title="This class implements an iterator that returns the result of applying a function...">u_iterator</a>() {}
<a name="l08610"></a>08610 
<a name="l08611"></a>08611     <span class="keyword">template</span>&lt;<span class="keyword">class</span> other_base_iter_type_&gt;
<a name="l08612"></a>08612     LITE_INLINE u_iterator(<span class="keyword">const</span> other_base_iter_type_&amp; base_iter)
<a name="l08613"></a>08613         : <a class="code" href="classlite_1_1u__iterator.html#a7347f04421cccc7337499d623d4f40e1" title="This variable stores the base iterator.">base_iterator</a>(base_iter) {}
<a name="l08614"></a>08614 
<a name="l08615"></a>08615     LITE_INLINE u_iterator(<span class="keyword">const</span> u_iterator&amp; other)
<a name="l08616"></a>08616         : <a class="code" href="classlite_1_1u__iterator.html#a7347f04421cccc7337499d623d4f40e1" title="This variable stores the base iterator.">base_iterator</a>(other.<a class="code" href="classlite_1_1u__iterator.html#a7347f04421cccc7337499d623d4f40e1" title="This variable stores the base iterator.">base_iterator</a>) {}
<a name="l08617"></a>08617 
<a name="l08618"></a>08618     <span class="keyword">template</span>&lt;<span class="keyword">class</span> other_base_iter_type_&gt;
<a name="l08619"></a>08619     LITE_INLINE u_iterator(<span class="keyword">const</span> u_iterator&lt;other_base_iter_type_, func_type_, true&gt;&amp; other)
<a name="l08620"></a>08620         : <a class="code" href="classlite_1_1u__iterator.html#a7347f04421cccc7337499d623d4f40e1" title="This variable stores the base iterator.">base_iterator</a>(other.<a class="code" href="classlite_1_1u__iterator.html#a7347f04421cccc7337499d623d4f40e1" title="This variable stores the base iterator.">base_iterator</a>) {}
<a name="l08621"></a>08621 
<a name="l08622"></a>08622     LITE_INLINE u_iterator&amp; operator=(<span class="keyword">const</span> u_iterator&amp; other)
<a name="l08623"></a>08623     {
<a name="l08624"></a>08624         <a class="code" href="classlite_1_1u__iterator.html#a7347f04421cccc7337499d623d4f40e1" title="This variable stores the base iterator.">base_iterator</a> = other.base_iterator;
<a name="l08625"></a>08625         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l08626"></a>08626     }
<a name="l08627"></a>08627 
<a name="l08628"></a>08628     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_base_iter_type_&gt;
<a name="l08629"></a>08629     LITE_INLINE u_iterator&amp; operator=(<span class="keyword">const</span> u_iterator&lt;other_base_iter_type_, func_type_, true&gt;&amp; other)
<a name="l08630"></a>08630     {
<a name="l08631"></a>08631         <a class="code" href="classlite_1_1u__iterator.html#a7347f04421cccc7337499d623d4f40e1" title="This variable stores the base iterator.">base_iterator</a> = other.base_iterator;
<a name="l08632"></a>08632         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l08633"></a>08633     }
<a name="l08634"></a>08634 
<a name="l08635"></a>08635     base_iterator_type <a class="code" href="classlite_1_1u__iterator.html#a7347f04421cccc7337499d623d4f40e1" title="This variable stores the base iterator.">base_iterator</a>;
<a name="l08636"></a>08636     <span class="keyword">static</span> function_type <a class="code" href="classlite_1_1u__iterator.html#ae3d820e2478d82889d247fc378982b45" title="This variable stores the function object. It will be a static member if is_static_...">function</a>;
<a name="l08637"></a>08637 };
<a name="l08638"></a>08638 
<a name="l08639"></a>08639 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> base_iter_type_, <span class="keyword">typename</span> func_type_&gt;
<a name="l08640"></a>08640 <span class="keyword">typename</span> u_iterator&lt;base_iter_type_, func_type_, true&gt;::function_type
<a name="l08641"></a>08641 u_iterator&lt;base_iter_type_, func_type_, true&gt;::function;
<a name="l08642"></a>08642 
<a name="l08643"></a>08643 <span class="preprocessor">#endif // !DOCUMENTATION_ONLY</span>
<a name="l08644"></a>08644 <span class="preprocessor"></span>
<a name="l08652"></a>08652 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> func_type_, <span class="keyword">typename</span> base_iter_type_&gt;
<a name="l08653"></a>08653 LITE_INLINE u_iterator&lt;base_iter_type_, func_type_, true&gt;
<a name="l08654"></a><a class="code" href="group__array__advanced.html#gacba2c5c5bf87aefe0f76dee0b2dc37ef">08654</a> <a class="code" href="group__array__advanced.html#gacba2c5c5bf87aefe0f76dee0b2dc37ef" title="Creates a lite::u_iterator from a base iterator it and a static function object of...">make_u_iterator</a>(<span class="keyword">const</span> base_iter_type_&amp; it)
<a name="l08655"></a>08655 {
<a name="l08656"></a>08656     <span class="keywordflow">return</span> <a class="code" href="classlite_1_1u__iterator.html" title="This class implements an iterator that returns the result of applying a function...">u_iterator&lt;base_iter_type_, func_type_, true&gt;</a>(it);
<a name="l08657"></a>08657 }
<a name="l08658"></a>08658 
<a name="l08659"></a>08659 <span class="comment">/***********************************************************************************************************/</span>
<a name="l08660"></a>08660 <span class="comment">/* u_iterator - unary iterator (non-static) ****************************************************************/</span>
<a name="l08661"></a>08661 <span class="comment">/***********************************************************************************************************/</span>
<a name="l08662"></a>08662 
<a name="l08663"></a>08663 <span class="preprocessor">#ifndef DOCUMENTATION_ONLY</span>
<a name="l08664"></a>08664 <span class="preprocessor"></span>
<a name="l08665"></a>08665 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> base_iter_type_, <span class="keyword">typename</span> func_type_&gt;
<a name="l08666"></a>08666 <span class="keyword">class </span>u_iterator&lt;base_iter_type_, func_type_, false&gt;
<a name="l08667"></a>08667 {
<a name="l08668"></a>08668 <span class="keyword">public</span>:
<a name="l08669"></a>08669     <span class="keyword">typedef</span> base_iter_type_ base_iterator_type;
<a name="l08670"></a>08670     <span class="keyword">typedef</span> func_type_ function_type;
<a name="l08671"></a>08671     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_static = <span class="keyword">false</span>;
<a name="l08672"></a>08672 
<a name="l08673"></a>08673     <span class="keyword">typedef</span> std::random_access_iterator_tag iterator_category;
<a name="l08674"></a>08674     <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::remove&lt;typename func_type_::result_type, const volatile int&amp;&gt;::type value_type;
<a name="l08675"></a>08675     <span class="keyword">typedef</span> ptrdiff_t difference_type;
<a name="l08676"></a>08676     <span class="keyword">typedef</span> <span class="keyword">typename</span> func_type_::result_type reference;
<a name="l08677"></a>08677     <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::remove&lt;typename func_type_::result_type, int&amp;&gt;::type* pointer;
<a name="l08678"></a>08678 
<a name="l08679"></a>08679     LITE_INLINE u_iterator() {}
<a name="l08680"></a>08680 
<a name="l08681"></a>08681     <span class="keyword">template</span>&lt;<span class="keyword">class</span> other_base_iter_type_&gt;
<a name="l08682"></a>08682     LITE_INLINE u_iterator(<span class="keyword">const</span> other_base_iter_type_&amp; base_iter, <span class="keyword">const</span> function_type&amp; func =function_type())
<a name="l08683"></a>08683         : <a class="code" href="classlite_1_1u__iterator.html#a7347f04421cccc7337499d623d4f40e1" title="This variable stores the base iterator.">base_iterator</a>(base_iter), <a class="code" href="classlite_1_1u__iterator.html#ae3d820e2478d82889d247fc378982b45" title="This variable stores the function object. It will be a static member if is_static_...">function</a>(func) {}
<a name="l08684"></a>08684 
<a name="l08685"></a>08685     LITE_INLINE u_iterator(<span class="keyword">const</span> u_iterator&amp; other)
<a name="l08686"></a>08686         : <a class="code" href="classlite_1_1u__iterator.html#a7347f04421cccc7337499d623d4f40e1" title="This variable stores the base iterator.">base_iterator</a>(other.<a class="code" href="classlite_1_1u__iterator.html#a7347f04421cccc7337499d623d4f40e1" title="This variable stores the base iterator.">base_iterator</a>), <a class="code" href="classlite_1_1u__iterator.html#ae3d820e2478d82889d247fc378982b45" title="This variable stores the function object. It will be a static member if is_static_...">function</a>(other.<a class="code" href="classlite_1_1u__iterator.html#ae3d820e2478d82889d247fc378982b45" title="This variable stores the function object. It will be a static member if is_static_...">function</a>) {}
<a name="l08687"></a>08687 
<a name="l08688"></a>08688     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_base_iter_type_&gt;
<a name="l08689"></a>08689     LITE_INLINE u_iterator(<span class="keyword">const</span> u_iterator&lt;other_base_iter_type_, func_type_, false&gt;&amp; other)
<a name="l08690"></a>08690         : <a class="code" href="classlite_1_1u__iterator.html#a7347f04421cccc7337499d623d4f40e1" title="This variable stores the base iterator.">base_iterator</a>(other.<a class="code" href="classlite_1_1u__iterator.html#a7347f04421cccc7337499d623d4f40e1" title="This variable stores the base iterator.">base_iterator</a>), <a class="code" href="classlite_1_1u__iterator.html#ae3d820e2478d82889d247fc378982b45" title="This variable stores the function object. It will be a static member if is_static_...">function</a>(other.<a class="code" href="classlite_1_1u__iterator.html#ae3d820e2478d82889d247fc378982b45" title="This variable stores the function object. It will be a static member if is_static_...">function</a>) {}
<a name="l08691"></a>08691 
<a name="l08692"></a>08692     LITE_INLINE u_iterator&amp; operator=(<span class="keyword">const</span> u_iterator&amp; other)
<a name="l08693"></a>08693     {
<a name="l08694"></a>08694         <a class="code" href="classlite_1_1u__iterator.html#a7347f04421cccc7337499d623d4f40e1" title="This variable stores the base iterator.">base_iterator</a> = other.base_iterator;
<a name="l08695"></a>08695         <a class="code" href="classlite_1_1u__iterator.html#ae3d820e2478d82889d247fc378982b45" title="This variable stores the function object. It will be a static member if is_static_...">function</a> = other.function;
<a name="l08696"></a>08696         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l08697"></a>08697     }
<a name="l08698"></a>08698 
<a name="l08699"></a>08699     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_base_iter_type_&gt;
<a name="l08700"></a>08700     LITE_INLINE u_iterator&amp; operator=(<span class="keyword">const</span> u_iterator&lt;other_base_iter_type_, func_type_, false&gt;&amp; other)
<a name="l08701"></a>08701     {
<a name="l08702"></a>08702         <a class="code" href="classlite_1_1u__iterator.html#a7347f04421cccc7337499d623d4f40e1" title="This variable stores the base iterator.">base_iterator</a> = other.base_iterator;
<a name="l08703"></a>08703         <a class="code" href="classlite_1_1u__iterator.html#ae3d820e2478d82889d247fc378982b45" title="This variable stores the function object. It will be a static member if is_static_...">function</a> = other.function;
<a name="l08704"></a>08704         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l08705"></a>08705     }
<a name="l08706"></a>08706 
<a name="l08707"></a>08707     base_iterator_type <a class="code" href="classlite_1_1u__iterator.html#a7347f04421cccc7337499d623d4f40e1" title="This variable stores the base iterator.">base_iterator</a>;
<a name="l08708"></a>08708     function_type <a class="code" href="classlite_1_1u__iterator.html#ae3d820e2478d82889d247fc378982b45" title="This variable stores the function object. It will be a static member if is_static_...">function</a>;
<a name="l08709"></a>08709 };
<a name="l08710"></a>08710 
<a name="l08711"></a>08711 <span class="preprocessor">#endif // !DOCUMENTATION_ONLY</span>
<a name="l08712"></a>08712 <span class="preprocessor"></span>
<a name="l08718"></a>08718 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> func_type_, <span class="keyword">typename</span> base_iter_type_&gt;
<a name="l08719"></a>08719 LITE_INLINE u_iterator&lt;base_iter_type_, func_type_, false&gt;
<a name="l08720"></a><a class="code" href="group__array__advanced.html#ga2df4ee35eeb32e5adc2eb8bf77e10f37">08720</a> <a class="code" href="group__array__advanced.html#gacba2c5c5bf87aefe0f76dee0b2dc37ef" title="Creates a lite::u_iterator from a base iterator it and a static function object of...">make_u_iterator</a>(<span class="keyword">const</span> base_iter_type_&amp; it, <span class="keyword">const</span> func_type_&amp; func)
<a name="l08721"></a>08721 {
<a name="l08722"></a>08722     <span class="keywordflow">return</span> <a class="code" href="classlite_1_1u__iterator.html" title="This class implements an iterator that returns the result of applying a function...">u_iterator&lt;base_iter_type_, func_type_, false&gt;</a>(it, func);
<a name="l08723"></a>08723 }
<a name="l08724"></a>08724 
<a name="l08725"></a>08725 <span class="comment">/***********************************************************************************************************/</span>
<a name="l08726"></a>08726 <span class="comment">/* u_iterator, at() ****************************************************************************************/</span>
<a name="l08727"></a>08727 <span class="comment">/***********************************************************************************************************/</span>
<a name="l08728"></a>08728 
<a name="l08729"></a>08729 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> base_iter_type_, <span class="keyword">typename</span> func_type_, <span class="keywordtype">bool</span> is_static_&gt;
<a name="l08730"></a>08730 LITE_INLINE 
<a name="l08731"></a>08731 <span class="keyword">typename</span> u_iterator&lt;base_iter_type_, func_type_, is_static_&gt;::reference
<a name="l08732"></a>08732 at(<span class="keyword">const</span> u_iterator&lt;base_iter_type_, func_type_, is_static_&gt;&amp; it
<a name="l08733"></a>08733     )
<a name="l08734"></a>08734 {
<a name="l08735"></a>08735     <span class="keywordflow">return</span> it.function(at(it.base_iterator 
<a name="l08736"></a>08736     ));
<a name="l08737"></a>08737 }
<a name="l08738"></a>08738 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> base_iter_type_, <span class="keyword">typename</span> func_type_, <span class="keywordtype">bool</span> is_static_&gt;
<a name="l08739"></a>08739 LITE_INLINE 
<a name="l08740"></a>08740 <span class="keyword">typename</span> u_iterator&lt;base_iter_type_, func_type_, is_static_&gt;::reference
<a name="l08741"></a>08741 at(<span class="keyword">const</span> u_iterator&lt;base_iter_type_, func_type_, is_static_&gt;&amp; it,
<a name="l08742"></a>08742     <span class="keywordtype">int</span> ind0
<a name="l08743"></a>08743     )
<a name="l08744"></a>08744 {
<a name="l08745"></a>08745     <span class="keywordflow">return</span> it.function(at(it.base_iterator, 
<a name="l08746"></a>08746         ind0
<a name="l08747"></a>08747     ));
<a name="l08748"></a>08748 }
<a name="l08749"></a>08749 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> base_iter_type_, <span class="keyword">typename</span> func_type_, <span class="keywordtype">bool</span> is_static_&gt;
<a name="l08750"></a>08750 LITE_INLINE 
<a name="l08751"></a>08751 <span class="keyword">typename</span> u_iterator&lt;base_iter_type_, func_type_, is_static_&gt;::reference
<a name="l08752"></a>08752 at(<span class="keyword">const</span> u_iterator&lt;base_iter_type_, func_type_, is_static_&gt;&amp; it,
<a name="l08753"></a>08753     <span class="keywordtype">int</span> ind0,
<a name="l08754"></a>08754     <span class="keywordtype">int</span> ind1
<a name="l08755"></a>08755     )
<a name="l08756"></a>08756 {
<a name="l08757"></a>08757     <span class="keywordflow">return</span> it.function(at(it.base_iterator, 
<a name="l08758"></a>08758         ind0,
<a name="l08759"></a>08759         ind1
<a name="l08760"></a>08760     ));
<a name="l08761"></a>08761 }
<a name="l08762"></a>08762 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> base_iter_type_, <span class="keyword">typename</span> func_type_, <span class="keywordtype">bool</span> is_static_&gt;
<a name="l08763"></a>08763 LITE_INLINE 
<a name="l08764"></a>08764 <span class="keyword">typename</span> u_iterator&lt;base_iter_type_, func_type_, is_static_&gt;::reference
<a name="l08765"></a>08765 at(<span class="keyword">const</span> u_iterator&lt;base_iter_type_, func_type_, is_static_&gt;&amp; it,
<a name="l08766"></a>08766     <span class="keywordtype">int</span> ind0,
<a name="l08767"></a>08767     <span class="keywordtype">int</span> ind1,
<a name="l08768"></a>08768     <span class="keywordtype">int</span> ind2
<a name="l08769"></a>08769     )
<a name="l08770"></a>08770 {
<a name="l08771"></a>08771     <span class="keywordflow">return</span> it.function(at(it.base_iterator, 
<a name="l08772"></a>08772         ind0,
<a name="l08773"></a>08773         ind1,
<a name="l08774"></a>08774         ind2
<a name="l08775"></a>08775     ));
<a name="l08776"></a>08776 }
<a name="l08777"></a>08777 
<a name="l08778"></a>08778 <span class="comment">/***********************************************************************************************************/</span>
<a name="l08779"></a>08779 <span class="comment">/* u_iterator, inc() ***************************************************************************************/</span>
<a name="l08780"></a>08780 <span class="comment">/***********************************************************************************************************/</span>
<a name="l08781"></a>08781 
<a name="l08782"></a>08782 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim_, <span class="keyword">typename</span> base_iter_type_, <span class="keyword">typename</span> func_type_, <span class="keywordtype">bool</span> is_static_&gt;
<a name="l08783"></a>08783 LITE_INLINE <span class="keywordtype">void</span> inc(u_iterator&lt;base_iter_type_, func_type_, is_static_&gt;&amp; it) 
<a name="l08784"></a>08784 {
<a name="l08785"></a>08785     inc&lt;dim_&gt;(it.base_iterator);
<a name="l08786"></a>08786 }
<a name="l08787"></a>08787 
<a name="l08788"></a>08788 <span class="comment">/***********************************************************************************************************/</span>
<a name="l08789"></a>08789 <span class="comment">/* u_iterator, dec() ***************************************************************************************/</span>
<a name="l08790"></a>08790 <span class="comment">/***********************************************************************************************************/</span>
<a name="l08791"></a>08791 
<a name="l08792"></a>08792 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim_, <span class="keyword">typename</span> base_iter_type_, <span class="keyword">typename</span> func_type_, <span class="keywordtype">bool</span> is_static_&gt;
<a name="l08793"></a>08793 LITE_INLINE <span class="keywordtype">void</span> dec(u_iterator&lt;base_iter_type_, func_type_, is_static_&gt;&amp; it) 
<a name="l08794"></a>08794 {
<a name="l08795"></a>08795     dec&lt;dim_&gt;(it.base_iterator);
<a name="l08796"></a>08796 }
<a name="l08797"></a>08797 
<a name="l08798"></a>08798 <span class="comment">/***********************************************************************************************************/</span>
<a name="l08799"></a>08799 <span class="comment">/* u_iterator, shift() *************************************************************************************/</span>
<a name="l08800"></a>08800 <span class="comment">/***********************************************************************************************************/</span>
<a name="l08801"></a>08801 
<a name="l08802"></a>08802 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim_, <span class="keyword">typename</span> base_iter_type_, <span class="keyword">typename</span> func_type_, <span class="keywordtype">bool</span> is_static_&gt;
<a name="l08803"></a>08803 LITE_INLINE <span class="keywordtype">void</span> shift(u_iterator&lt;base_iter_type_, func_type_, is_static_&gt;&amp; it, <span class="keywordtype">int</span> diff) 
<a name="l08804"></a>08804 {
<a name="l08805"></a>08805     shift&lt;dim_&gt;(it.base_iterator, diff);
<a name="l08806"></a>08806 }
<a name="l08807"></a>08807 
<a name="l08808"></a>08808 <span class="comment">/***********************************************************************************************************/</span>
<a name="l08809"></a>08809 <span class="comment">/* b_iterator **********************************************************************************************/</span>
<a name="l08810"></a>08810 <span class="comment">/***********************************************************************************************************/</span>
<a name="l08811"></a>08811 
<a name="l08812"></a>08812 <span class="preprocessor">#ifdef DOCUMENTATION_ONLY</span>
<a name="l08813"></a>08813 <span class="preprocessor"></span>
<a name="l08861"></a>08861 <span class="keyword">template</span>&lt;
<a name="l08862"></a>08862     <span class="keyword">typename</span> left_base_iterator_type_, 
<a name="l08863"></a>08863     <span class="keyword">typename</span> right_base_iterator_type_, 
<a name="l08864"></a>08864     <span class="keyword">typename</span> func_type_, 
<a name="l08865"></a>08865     <span class="keywordtype">bool</span> is_static_ =<span class="keyword">true</span>&gt;
<a name="l08866"></a><a class="code" href="classlite_1_1b__iterator.html">08866</a> <span class="keyword">class </span><a class="code" href="classlite_1_1b__iterator.html" title="This class implements an iterator that returns the result of applying a binary function...">b_iterator</a>
<a name="l08867"></a>08867 {
<a name="l08868"></a>08868 <span class="keyword">public</span>:
<a name="l08869"></a>08869     <span class="keyword">typedef</span> left_base_iterator_type_ left_base_iterator_type;
<a name="l08870"></a>08870     <span class="keyword">typedef</span> right_base_iterator_type_ right_base_iterator_type;
<a name="l08871"></a>08871     <span class="keyword">typedef</span> func_type_ function_type;
<a name="l08872"></a>08872     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_static = is_static_;
<a name="l08873"></a>08873 
<a name="l08874"></a>08874     <span class="keyword">typedef</span> std::random_access_iterator_tag iterator_category;
<a name="l08875"></a>08875     <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::remove&lt;typename func_type_::result_type, const volatile int&amp;&gt;::type value_type;
<a name="l08876"></a>08876     <span class="keyword">typedef</span> ptrdiff_t difference_type;
<a name="l08877"></a>08877     <span class="keyword">typedef</span> <span class="keyword">typename</span> func_type_::result_type reference;
<a name="l08878"></a>08878     <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::remove&lt;typename func_type_::result_type, int&amp;&gt;::type* pointer;
<a name="l08879"></a>08879 
<a name="l08880"></a>08880     LITE_INLINE <a class="code" href="classlite_1_1b__iterator.html" title="This class implements an iterator that returns the result of applying a binary function...">b_iterator</a>() {}
<a name="l08881"></a>08881 
<a name="l08882"></a>08882     
<a name="l08884"></a>08884     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_left_base_iterator_type_, <span class="keyword">typename</span> other_right_base_iterator_type_&gt;
<a name="l08885"></a>08885     LITE_INLINE <a class="code" href="classlite_1_1b__iterator.html" title="This class implements an iterator that returns the result of applying a binary function...">b_iterator</a>(
<a name="l08886"></a>08886         <span class="keyword">const</span> other_left_base_iterator_type_&amp; lbase_iter, 
<a name="l08887"></a>08887         <span class="keyword">const</span> other_right_base_iterator_type_&amp; rbase_iter);
<a name="l08888"></a>08888 
<a name="l08889"></a>08889     LITE_INLINE b_iterator(<span class="keyword">const</span> b_iterator&amp; other);
<a name="l08890"></a>08890 
<a name="l08898"></a>08898     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_left_base_iterator_type_, <span class="keyword">typename</span> other_right_base_iterator_type_&gt;
<a name="l08899"></a>08899     LITE_INLINE b_iterator(
<a name="l08900"></a>08900         <span class="keyword">const</span> b_iterator&lt;
<a name="l08901"></a>08901             other_left_base_iterator_type_, 
<a name="l08902"></a>08902             other_right_base_iterator_type_, 
<a name="l08903"></a>08903             func_type_, 
<a name="l08904"></a>08904             is_static_&gt;&amp; other);
<a name="l08905"></a>08905 
<a name="l08906"></a>08906     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_left_base_iterator_type_, <span class="keyword">typename</span> other_right_base_iterator_type_&gt;
<a name="l08907"></a>08907     LITE_INLINE b_iterator(
<a name="l08908"></a>08908         <span class="keyword">const</span> other_left_base_iterator_type_&amp; lbase_iter, 
<a name="l08909"></a>08909         <span class="keyword">const</span> other_right_base_iterator_type_&amp; rbase_iter, 
<a name="l08910"></a>08910         <span class="keyword">const</span> function_type&amp; func);
<a name="l08911"></a>08911 
<a name="l08912"></a>08912 
<a name="l08913"></a>08913     LITE_INLINE b_iterator&amp; operator=(<span class="keyword">const</span> b_iterator&amp; other);
<a name="l08914"></a>08914 
<a name="l08915"></a>08915     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_left_base_iterator_type_, <span class="keyword">typename</span> other_right_base_iterator_type_&gt;
<a name="l08916"></a>08916     LITE_INLINE b_iterator&amp; 
<a name="l08917"></a>08917     operator=(<span class="keyword">const</span> b_iterator&lt;
<a name="l08918"></a>08918         other_left_base_iterator_type_, 
<a name="l08919"></a>08919         other_right_base_iterator_type_, 
<a name="l08920"></a>08920         func_type_, 
<a name="l08921"></a>08921         is_static_&gt;&amp; other);
<a name="l08922"></a>08922     
<a name="l08924"></a><a class="code" href="classlite_1_1b__iterator.html#a6a396646c46c211aafe3c930605d7b0c">08924</a>     left_base_iterator_type <a class="code" href="classlite_1_1b__iterator.html#a6a396646c46c211aafe3c930605d7b0c" title="This variable stores the left base iterator.">left_base_iterator</a>;
<a name="l08925"></a>08925 
<a name="l08927"></a><a class="code" href="classlite_1_1b__iterator.html#a73bdb284a4d4ed46d7ec4bd62073447b">08927</a>     right_base_iterator_type <a class="code" href="classlite_1_1b__iterator.html#a73bdb284a4d4ed46d7ec4bd62073447b" title="This variable stores the right base iterator.">right_base_iterator</a>;
<a name="l08928"></a>08928 
<a name="l08930"></a><a class="code" href="classlite_1_1b__iterator.html#a3052f914480ba1ee5985e6fc51316db0">08930</a>     function_type <a class="code" href="classlite_1_1b__iterator.html#a3052f914480ba1ee5985e6fc51316db0" title="This variable stores the function object. It will be a static member if is_static_...">function</a>;
<a name="l08931"></a>08931 };
<a name="l08932"></a>08932 
<a name="l08933"></a>08933 
<a name="l08934"></a>08934 <span class="preprocessor">#endif // DOCUMENTATION_ONLY</span>
<a name="l08935"></a>08935 <span class="preprocessor"></span>
<a name="l08936"></a>08936 <span class="comment">/***********************************************************************************************************/</span>
<a name="l08937"></a>08937 <span class="comment">/* b_iterator - binary iterator (static) *******************************************************************/</span>
<a name="l08938"></a>08938 <span class="comment">/***********************************************************************************************************/</span>
<a name="l08939"></a>08939 
<a name="l08940"></a>08940 <span class="preprocessor">#ifndef DOCUMENTATION_ONLY</span>
<a name="l08941"></a>08941 <span class="preprocessor"></span>
<a name="l08942"></a>08942 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> left_base_iterator_type_, <span class="keyword">typename</span> right_base_iterator_type_, <span class="keyword">typename</span> func_type_&gt;
<a name="l08943"></a>08943 <span class="keyword">class </span><a class="code" href="classlite_1_1b__iterator.html" title="This class implements an iterator that returns the result of applying a binary function...">b_iterator</a>&lt;left_base_iterator_type_, right_base_iterator_type_, func_type_, true&gt;
<a name="l08944"></a>08944 {
<a name="l08945"></a>08945 <span class="keyword">public</span>:
<a name="l08946"></a>08946     <span class="keyword">typedef</span> left_base_iterator_type_ left_base_iterator_type;
<a name="l08947"></a>08947     <span class="keyword">typedef</span> right_base_iterator_type_ right_base_iterator_type;
<a name="l08948"></a>08948     <span class="keyword">typedef</span> func_type_ function_type;
<a name="l08949"></a>08949     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_static = <span class="keyword">true</span>;
<a name="l08950"></a>08950 
<a name="l08951"></a>08951     <span class="keyword">typedef</span> std::random_access_iterator_tag iterator_category;
<a name="l08952"></a>08952     <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::remove&lt;typename func_type_::result_type, const volatile int&amp;&gt;::type value_type;
<a name="l08953"></a>08953     <span class="keyword">typedef</span> ptrdiff_t difference_type;
<a name="l08954"></a>08954     <span class="keyword">typedef</span> <span class="keyword">typename</span> func_type_::result_type reference;
<a name="l08955"></a>08955     <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::remove&lt;typename func_type_::result_type, int&amp;&gt;::type* pointer;
<a name="l08956"></a>08956 
<a name="l08957"></a>08957     LITE_INLINE <a class="code" href="classlite_1_1b__iterator.html" title="This class implements an iterator that returns the result of applying a binary function...">b_iterator</a>() {}
<a name="l08958"></a>08958 
<a name="l08959"></a>08959     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_left_base_iterator_type_, <span class="keyword">typename</span> other_right_base_iterator_type_&gt;
<a name="l08960"></a>08960     LITE_INLINE b_iterator(
<a name="l08961"></a>08961         <span class="keyword">const</span> other_left_base_iterator_type_&amp; lbase_iter, 
<a name="l08962"></a>08962         <span class="keyword">const</span> other_right_base_iterator_type_&amp; rbase_iter)
<a name="l08963"></a>08963         : <a class="code" href="classlite_1_1b__iterator.html#a6a396646c46c211aafe3c930605d7b0c" title="This variable stores the left base iterator.">left_base_iterator</a>(lbase_iter), <a class="code" href="classlite_1_1b__iterator.html#a73bdb284a4d4ed46d7ec4bd62073447b" title="This variable stores the right base iterator.">right_base_iterator</a>(rbase_iter) {}
<a name="l08964"></a>08964 
<a name="l08965"></a>08965     LITE_INLINE b_iterator(<span class="keyword">const</span> b_iterator&amp; other)
<a name="l08966"></a>08966         : <a class="code" href="classlite_1_1b__iterator.html#a6a396646c46c211aafe3c930605d7b0c" title="This variable stores the left base iterator.">left_base_iterator</a>(other.<a class="code" href="classlite_1_1b__iterator.html#a6a396646c46c211aafe3c930605d7b0c" title="This variable stores the left base iterator.">left_base_iterator</a>), 
<a name="l08967"></a>08967         <a class="code" href="classlite_1_1b__iterator.html#a73bdb284a4d4ed46d7ec4bd62073447b" title="This variable stores the right base iterator.">right_base_iterator</a>(other.<a class="code" href="classlite_1_1b__iterator.html#a73bdb284a4d4ed46d7ec4bd62073447b" title="This variable stores the right base iterator.">right_base_iterator</a>)
<a name="l08968"></a>08968     {}
<a name="l08969"></a>08969 
<a name="l08970"></a>08970     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_left_base_iterator_type_, <span class="keyword">typename</span> other_right_base_iterator_type_&gt;
<a name="l08971"></a>08971     LITE_INLINE b_iterator(
<a name="l08972"></a>08972         <span class="keyword">const</span> b_iterator&lt;
<a name="l08973"></a>08973             other_left_base_iterator_type_, 
<a name="l08974"></a>08974             other_right_base_iterator_type_, 
<a name="l08975"></a>08975             func_type_, 
<a name="l08976"></a>08976             <span class="keyword">true</span>&gt;&amp; other)
<a name="l08977"></a>08977         : <a class="code" href="classlite_1_1b__iterator.html#a6a396646c46c211aafe3c930605d7b0c" title="This variable stores the left base iterator.">left_base_iterator</a>(other.<a class="code" href="classlite_1_1b__iterator.html#a6a396646c46c211aafe3c930605d7b0c" title="This variable stores the left base iterator.">left_base_iterator</a>), 
<a name="l08978"></a>08978         <a class="code" href="classlite_1_1b__iterator.html#a73bdb284a4d4ed46d7ec4bd62073447b" title="This variable stores the right base iterator.">right_base_iterator</a>(other.<a class="code" href="classlite_1_1b__iterator.html#a73bdb284a4d4ed46d7ec4bd62073447b" title="This variable stores the right base iterator.">right_base_iterator</a>)
<a name="l08979"></a>08979     {}
<a name="l08980"></a>08980 
<a name="l08981"></a>08981     LITE_INLINE b_iterator&amp; operator=(<span class="keyword">const</span> b_iterator&amp; other)
<a name="l08982"></a>08982     {
<a name="l08983"></a>08983         <a class="code" href="classlite_1_1b__iterator.html#a6a396646c46c211aafe3c930605d7b0c" title="This variable stores the left base iterator.">left_base_iterator</a> = other.left_base_iterator;
<a name="l08984"></a>08984         <a class="code" href="classlite_1_1b__iterator.html#a73bdb284a4d4ed46d7ec4bd62073447b" title="This variable stores the right base iterator.">right_base_iterator</a> = other.right_base_iterator;
<a name="l08985"></a>08985         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l08986"></a>08986     }
<a name="l08987"></a>08987 
<a name="l08988"></a>08988     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_left_base_iterator_type_, <span class="keyword">typename</span> other_right_base_iterator_type_&gt;
<a name="l08989"></a>08989     LITE_INLINE b_iterator&amp; 
<a name="l08990"></a>08990     operator=(<span class="keyword">const</span> b_iterator&lt;
<a name="l08991"></a>08991         other_left_base_iterator_type_, 
<a name="l08992"></a>08992         other_right_base_iterator_type_, 
<a name="l08993"></a>08993         func_type_, 
<a name="l08994"></a>08994         <span class="keyword">true</span>&gt;&amp; other)
<a name="l08995"></a>08995     {
<a name="l08996"></a>08996         <a class="code" href="classlite_1_1b__iterator.html#a6a396646c46c211aafe3c930605d7b0c" title="This variable stores the left base iterator.">left_base_iterator</a> = other.left_base_iterator;
<a name="l08997"></a>08997         <a class="code" href="classlite_1_1b__iterator.html#a73bdb284a4d4ed46d7ec4bd62073447b" title="This variable stores the right base iterator.">right_base_iterator</a> = other.right_base_iterator;
<a name="l08998"></a>08998         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l08999"></a>08999     }
<a name="l09000"></a>09000     
<a name="l09001"></a>09001     left_base_iterator_type <a class="code" href="classlite_1_1b__iterator.html#a6a396646c46c211aafe3c930605d7b0c" title="This variable stores the left base iterator.">left_base_iterator</a>;
<a name="l09002"></a>09002     right_base_iterator_type <a class="code" href="classlite_1_1b__iterator.html#a73bdb284a4d4ed46d7ec4bd62073447b" title="This variable stores the right base iterator.">right_base_iterator</a>;
<a name="l09003"></a>09003     <span class="keyword">static</span> function_type <a class="code" href="classlite_1_1b__iterator.html#a3052f914480ba1ee5985e6fc51316db0" title="This variable stores the function object. It will be a static member if is_static_...">function</a>;
<a name="l09004"></a>09004 };
<a name="l09005"></a>09005 
<a name="l09006"></a>09006 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> left_base_iterator_type_, <span class="keyword">typename</span> right_base_iterator_type_, <span class="keyword">typename</span> func_type_&gt;
<a name="l09007"></a>09007 <span class="keyword">typename</span> b_iterator&lt;left_base_iterator_type_, right_base_iterator_type_, func_type_, true&gt;::function_type
<a name="l09008"></a>09008 b_iterator&lt;left_base_iterator_type_, right_base_iterator_type_, func_type_, true&gt;::function;
<a name="l09009"></a>09009 
<a name="l09010"></a>09010 <span class="preprocessor">#endif // !DOCUMENTATION_ONLY</span>
<a name="l09011"></a>09011 <span class="preprocessor"></span>
<a name="l09019"></a>09019 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> func_type_, <span class="keyword">typename</span> left_base_iterator_type_, <span class="keyword">typename</span> right_base_iterator_type_&gt;
<a name="l09020"></a>09020 LITE_INLINE b_iterator&lt;left_base_iterator_type_, right_base_iterator_type_, func_type_, true&gt;
<a name="l09021"></a><a class="code" href="group__array__advanced.html#gae6a79728f8cfa5ebe774ce4fd4394548">09021</a> <a class="code" href="group__array__advanced.html#gae6a79728f8cfa5ebe774ce4fd4394548" title="Creates a lite::b_iterator from base iterators left_it and right_it and a static...">make_b_iterator</a>(
<a name="l09022"></a>09022     <span class="keyword">const</span> left_base_iterator_type_&amp; left_it, 
<a name="l09023"></a>09023     <span class="keyword">const</span> right_base_iterator_type_&amp; right_it)
<a name="l09024"></a>09024 {
<a name="l09025"></a>09025     <span class="keywordflow">return</span> <a class="code" href="classlite_1_1b__iterator.html" title="This class implements an iterator that returns the result of applying a binary function...">b_iterator&lt;left_base_iterator_type_, right_base_iterator_type_, func_type_, true&gt;</a>
<a name="l09026"></a>09026         (left_it, right_it);
<a name="l09027"></a>09027 }
<a name="l09028"></a>09028 
<a name="l09029"></a>09029 <span class="comment">/***********************************************************************************************************/</span>
<a name="l09030"></a>09030 <span class="comment">/* b_iterator - binary iterator (non-static) ***************************************************************/</span>
<a name="l09031"></a>09031 <span class="comment">/***********************************************************************************************************/</span>
<a name="l09032"></a>09032 
<a name="l09033"></a>09033 <span class="preprocessor">#ifndef DOCUMENTATION_ONLY</span>
<a name="l09034"></a>09034 <span class="preprocessor"></span>
<a name="l09035"></a>09035 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> left_base_iterator_type_, <span class="keyword">typename</span> right_base_iterator_type_, <span class="keyword">typename</span> func_type_&gt;
<a name="l09036"></a>09036 <span class="keyword">class </span>b_iterator&lt;left_base_iterator_type_, right_base_iterator_type_, func_type_, false&gt;
<a name="l09037"></a>09037 {
<a name="l09038"></a>09038 <span class="keyword">public</span>:
<a name="l09039"></a>09039     <span class="keyword">typedef</span> left_base_iterator_type_ left_base_iterator_type;
<a name="l09040"></a>09040     <span class="keyword">typedef</span> right_base_iterator_type_ right_base_iterator_type;
<a name="l09041"></a>09041     <span class="keyword">typedef</span> func_type_ function_type;
<a name="l09042"></a>09042     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_static = <span class="keyword">false</span>;
<a name="l09043"></a>09043 
<a name="l09044"></a>09044     <span class="keyword">typedef</span> std::random_access_iterator_tag iterator_category;
<a name="l09045"></a>09045     <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::remove&lt;typename func_type_::result_type, const volatile int&amp;&gt;::type value_type;
<a name="l09046"></a>09046     <span class="keyword">typedef</span> ptrdiff_t difference_type;
<a name="l09047"></a>09047     <span class="keyword">typedef</span> <span class="keyword">typename</span> func_type_::result_type reference;
<a name="l09048"></a>09048     <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::remove&lt;typename func_type_::result_type, int&amp;&gt;::type* pointer;
<a name="l09049"></a>09049 
<a name="l09050"></a>09050     LITE_INLINE b_iterator() {}
<a name="l09051"></a>09051 
<a name="l09052"></a>09052     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_left_base_iterator_type_, <span class="keyword">typename</span> other_right_base_iterator_type_&gt;
<a name="l09053"></a>09053     LITE_INLINE b_iterator(
<a name="l09054"></a>09054         <span class="keyword">const</span> other_left_base_iterator_type_&amp; lbase_iter, 
<a name="l09055"></a>09055         <span class="keyword">const</span> other_right_base_iterator_type_&amp; rbase_iter, 
<a name="l09056"></a>09056         <span class="keyword">const</span> function_type&amp; func = function_type())
<a name="l09057"></a>09057         : <a class="code" href="classlite_1_1b__iterator.html#a6a396646c46c211aafe3c930605d7b0c" title="This variable stores the left base iterator.">left_base_iterator</a>(lbase_iter), <a class="code" href="classlite_1_1b__iterator.html#a73bdb284a4d4ed46d7ec4bd62073447b" title="This variable stores the right base iterator.">right_base_iterator</a>(rbase_iter), <a class="code" href="classlite_1_1b__iterator.html#a3052f914480ba1ee5985e6fc51316db0" title="This variable stores the function object. It will be a static member if is_static_...">function</a>(func) {}
<a name="l09058"></a>09058 
<a name="l09059"></a>09059     LITE_INLINE b_iterator(<span class="keyword">const</span> b_iterator&amp; other)
<a name="l09060"></a>09060         : <a class="code" href="classlite_1_1b__iterator.html#a6a396646c46c211aafe3c930605d7b0c" title="This variable stores the left base iterator.">left_base_iterator</a>(other.<a class="code" href="classlite_1_1b__iterator.html#a6a396646c46c211aafe3c930605d7b0c" title="This variable stores the left base iterator.">left_base_iterator</a>), 
<a name="l09061"></a>09061         <a class="code" href="classlite_1_1b__iterator.html#a73bdb284a4d4ed46d7ec4bd62073447b" title="This variable stores the right base iterator.">right_base_iterator</a>(other.<a class="code" href="classlite_1_1b__iterator.html#a73bdb284a4d4ed46d7ec4bd62073447b" title="This variable stores the right base iterator.">right_base_iterator</a>), 
<a name="l09062"></a>09062         <a class="code" href="classlite_1_1b__iterator.html#a3052f914480ba1ee5985e6fc51316db0" title="This variable stores the function object. It will be a static member if is_static_...">function</a>(other.<a class="code" href="classlite_1_1b__iterator.html#a3052f914480ba1ee5985e6fc51316db0" title="This variable stores the function object. It will be a static member if is_static_...">function</a>) 
<a name="l09063"></a>09063     {}
<a name="l09064"></a>09064 
<a name="l09065"></a>09065     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_left_base_iterator_type_, <span class="keyword">typename</span> other_right_base_iterator_type_&gt;
<a name="l09066"></a>09066     LITE_INLINE b_iterator(
<a name="l09067"></a>09067         <span class="keyword">const</span> b_iterator&lt;
<a name="l09068"></a>09068             other_left_base_iterator_type_, 
<a name="l09069"></a>09069             other_right_base_iterator_type_, 
<a name="l09070"></a>09070             func_type_, 
<a name="l09071"></a>09071             <span class="keyword">false</span>&gt;&amp; other)
<a name="l09072"></a>09072         : <a class="code" href="classlite_1_1b__iterator.html#a6a396646c46c211aafe3c930605d7b0c" title="This variable stores the left base iterator.">left_base_iterator</a>(other.<a class="code" href="classlite_1_1b__iterator.html#a6a396646c46c211aafe3c930605d7b0c" title="This variable stores the left base iterator.">left_base_iterator</a>), 
<a name="l09073"></a>09073         <a class="code" href="classlite_1_1b__iterator.html#a73bdb284a4d4ed46d7ec4bd62073447b" title="This variable stores the right base iterator.">right_base_iterator</a>(other.<a class="code" href="classlite_1_1b__iterator.html#a73bdb284a4d4ed46d7ec4bd62073447b" title="This variable stores the right base iterator.">right_base_iterator</a>), 
<a name="l09074"></a>09074         <a class="code" href="classlite_1_1b__iterator.html#a3052f914480ba1ee5985e6fc51316db0" title="This variable stores the function object. It will be a static member if is_static_...">function</a>(other.<a class="code" href="classlite_1_1b__iterator.html#a3052f914480ba1ee5985e6fc51316db0" title="This variable stores the function object. It will be a static member if is_static_...">function</a>) 
<a name="l09075"></a>09075     {}
<a name="l09076"></a>09076 
<a name="l09077"></a>09077     LITE_INLINE b_iterator&amp; operator=(<span class="keyword">const</span> b_iterator&amp; other)
<a name="l09078"></a>09078     {
<a name="l09079"></a>09079         <a class="code" href="classlite_1_1b__iterator.html#a6a396646c46c211aafe3c930605d7b0c" title="This variable stores the left base iterator.">left_base_iterator</a> = other.left_base_iterator;
<a name="l09080"></a>09080         <a class="code" href="classlite_1_1b__iterator.html#a73bdb284a4d4ed46d7ec4bd62073447b" title="This variable stores the right base iterator.">right_base_iterator</a> = other.right_base_iterator;
<a name="l09081"></a>09081         <a class="code" href="classlite_1_1b__iterator.html#a3052f914480ba1ee5985e6fc51316db0" title="This variable stores the function object. It will be a static member if is_static_...">function</a> = other.function;
<a name="l09082"></a>09082         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l09083"></a>09083     }
<a name="l09084"></a>09084 
<a name="l09085"></a>09085     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_left_base_iterator_type_, <span class="keyword">typename</span> other_right_base_iterator_type_&gt;
<a name="l09086"></a>09086     LITE_INLINE b_iterator&amp; 
<a name="l09087"></a>09087     operator=(<span class="keyword">const</span> b_iterator&lt;
<a name="l09088"></a>09088         other_left_base_iterator_type_, 
<a name="l09089"></a>09089         other_right_base_iterator_type_, 
<a name="l09090"></a>09090         func_type_, 
<a name="l09091"></a>09091         <span class="keyword">false</span>&gt;&amp; other)
<a name="l09092"></a>09092     {
<a name="l09093"></a>09093         <a class="code" href="classlite_1_1b__iterator.html#a6a396646c46c211aafe3c930605d7b0c" title="This variable stores the left base iterator.">left_base_iterator</a> = other.left_base_iterator;
<a name="l09094"></a>09094         <a class="code" href="classlite_1_1b__iterator.html#a73bdb284a4d4ed46d7ec4bd62073447b" title="This variable stores the right base iterator.">right_base_iterator</a> = other.right_base_iterator;
<a name="l09095"></a>09095         <a class="code" href="classlite_1_1b__iterator.html#a3052f914480ba1ee5985e6fc51316db0" title="This variable stores the function object. It will be a static member if is_static_...">function</a> = other.function;
<a name="l09096"></a>09096         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l09097"></a>09097     }
<a name="l09098"></a>09098     
<a name="l09099"></a>09099     left_base_iterator_type <a class="code" href="classlite_1_1b__iterator.html#a6a396646c46c211aafe3c930605d7b0c" title="This variable stores the left base iterator.">left_base_iterator</a>;
<a name="l09100"></a>09100     right_base_iterator_type <a class="code" href="classlite_1_1b__iterator.html#a73bdb284a4d4ed46d7ec4bd62073447b" title="This variable stores the right base iterator.">right_base_iterator</a>;
<a name="l09101"></a>09101     function_type <a class="code" href="classlite_1_1b__iterator.html#a3052f914480ba1ee5985e6fc51316db0" title="This variable stores the function object. It will be a static member if is_static_...">function</a>;
<a name="l09102"></a>09102 };
<a name="l09103"></a>09103 
<a name="l09104"></a>09104 <span class="preprocessor">#endif // DOCUMENTATION_ONLY</span>
<a name="l09105"></a>09105 <span class="preprocessor"></span>
<a name="l09113"></a>09113 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> func_type_, <span class="keyword">typename</span> left_base_iterator_type_, <span class="keyword">typename</span> right_base_iterator_type_&gt;
<a name="l09114"></a>09114 LITE_INLINE b_iterator&lt;left_base_iterator_type_, right_base_iterator_type_, func_type_, false&gt;
<a name="l09115"></a><a class="code" href="group__array__advanced.html#ga8412cdbe188c46d88331421fc0209794">09115</a> <a class="code" href="group__array__advanced.html#gae6a79728f8cfa5ebe774ce4fd4394548" title="Creates a lite::b_iterator from base iterators left_it and right_it and a static...">make_b_iterator</a>(
<a name="l09116"></a>09116     <span class="keyword">const</span> left_base_iterator_type_&amp; left_it, 
<a name="l09117"></a>09117     <span class="keyword">const</span> right_base_iterator_type_&amp; right_it, 
<a name="l09118"></a>09118     <span class="keyword">const</span> func_type_&amp; func)
<a name="l09119"></a>09119 {
<a name="l09120"></a>09120     <span class="keywordflow">return</span> <a class="code" href="classlite_1_1b__iterator.html" title="This class implements an iterator that returns the result of applying a binary function...">b_iterator&lt;left_base_iterator_type_, right_base_iterator_type_, func_type_, false&gt;</a>
<a name="l09121"></a>09121         (left_it, right_it, func);
<a name="l09122"></a>09122 }
<a name="l09123"></a>09123 
<a name="l09124"></a>09124 <span class="comment">/***********************************************************************************************************/</span>
<a name="l09125"></a>09125 <span class="comment">/* b_iterator, at() ****************************************************************************************/</span>
<a name="l09126"></a>09126 <span class="comment">/***********************************************************************************************************/</span>
<a name="l09127"></a>09127 
<a name="l09128"></a>09128 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> left_base_iter_type_, <span class="keyword">typename</span> right_base_iter_type_, <span class="keyword">typename</span> func_type_, <span class="keywordtype">bool</span> is_static_&gt;
<a name="l09129"></a>09129 LITE_INLINE
<a name="l09130"></a>09130 <span class="keyword">typename</span> b_iterator&lt;left_base_iter_type_, right_base_iter_type_, func_type_, is_static_&gt;::reference
<a name="l09131"></a>09131 at(<span class="keyword">const</span> b_iterator&lt;left_base_iter_type_, right_base_iter_type_, func_type_, is_static_&gt;&amp; it
<a name="l09132"></a>09132     )
<a name="l09133"></a>09133 {
<a name="l09134"></a>09134     <span class="keywordflow">return</span> it.function(
<a name="l09135"></a>09135         at(it.left_base_iterator 
<a name="l09136"></a>09136         ),
<a name="l09137"></a>09137         at(it.right_base_iterator 
<a name="l09138"></a>09138         )
<a name="l09139"></a>09139     );
<a name="l09140"></a>09140 }
<a name="l09141"></a>09141 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> left_base_iter_type_, <span class="keyword">typename</span> right_base_iter_type_, <span class="keyword">typename</span> func_type_, <span class="keywordtype">bool</span> is_static_&gt;
<a name="l09142"></a>09142 LITE_INLINE
<a name="l09143"></a>09143 <span class="keyword">typename</span> b_iterator&lt;left_base_iter_type_, right_base_iter_type_, func_type_, is_static_&gt;::reference
<a name="l09144"></a>09144 at(<span class="keyword">const</span> b_iterator&lt;left_base_iter_type_, right_base_iter_type_, func_type_, is_static_&gt;&amp; it,
<a name="l09145"></a>09145     <span class="keywordtype">int</span> ind0
<a name="l09146"></a>09146     )
<a name="l09147"></a>09147 {
<a name="l09148"></a>09148     <span class="keywordflow">return</span> it.function(
<a name="l09149"></a>09149         at(it.left_base_iterator, 
<a name="l09150"></a>09150         ind0
<a name="l09151"></a>09151         ),
<a name="l09152"></a>09152         at(it.right_base_iterator, 
<a name="l09153"></a>09153         ind0
<a name="l09154"></a>09154         )
<a name="l09155"></a>09155     );
<a name="l09156"></a>09156 }
<a name="l09157"></a>09157 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> left_base_iter_type_, <span class="keyword">typename</span> right_base_iter_type_, <span class="keyword">typename</span> func_type_, <span class="keywordtype">bool</span> is_static_&gt;
<a name="l09158"></a>09158 LITE_INLINE
<a name="l09159"></a>09159 <span class="keyword">typename</span> b_iterator&lt;left_base_iter_type_, right_base_iter_type_, func_type_, is_static_&gt;::reference
<a name="l09160"></a>09160 at(<span class="keyword">const</span> b_iterator&lt;left_base_iter_type_, right_base_iter_type_, func_type_, is_static_&gt;&amp; it,
<a name="l09161"></a>09161     <span class="keywordtype">int</span> ind0,
<a name="l09162"></a>09162     <span class="keywordtype">int</span> ind1
<a name="l09163"></a>09163     )
<a name="l09164"></a>09164 {
<a name="l09165"></a>09165     <span class="keywordflow">return</span> it.function(
<a name="l09166"></a>09166         at(it.left_base_iterator, 
<a name="l09167"></a>09167         ind0,
<a name="l09168"></a>09168         ind1
<a name="l09169"></a>09169         ),
<a name="l09170"></a>09170         at(it.right_base_iterator, 
<a name="l09171"></a>09171         ind0,
<a name="l09172"></a>09172         ind1
<a name="l09173"></a>09173         )
<a name="l09174"></a>09174     );
<a name="l09175"></a>09175 }
<a name="l09176"></a>09176 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> left_base_iter_type_, <span class="keyword">typename</span> right_base_iter_type_, <span class="keyword">typename</span> func_type_, <span class="keywordtype">bool</span> is_static_&gt;
<a name="l09177"></a>09177 LITE_INLINE
<a name="l09178"></a>09178 <span class="keyword">typename</span> b_iterator&lt;left_base_iter_type_, right_base_iter_type_, func_type_, is_static_&gt;::reference
<a name="l09179"></a>09179 at(<span class="keyword">const</span> b_iterator&lt;left_base_iter_type_, right_base_iter_type_, func_type_, is_static_&gt;&amp; it,
<a name="l09180"></a>09180     <span class="keywordtype">int</span> ind0,
<a name="l09181"></a>09181     <span class="keywordtype">int</span> ind1,
<a name="l09182"></a>09182     <span class="keywordtype">int</span> ind2
<a name="l09183"></a>09183     )
<a name="l09184"></a>09184 {
<a name="l09185"></a>09185     <span class="keywordflow">return</span> it.function(
<a name="l09186"></a>09186         at(it.left_base_iterator, 
<a name="l09187"></a>09187         ind0,
<a name="l09188"></a>09188         ind1,
<a name="l09189"></a>09189         ind2
<a name="l09190"></a>09190         ),
<a name="l09191"></a>09191         at(it.right_base_iterator, 
<a name="l09192"></a>09192         ind0,
<a name="l09193"></a>09193         ind1,
<a name="l09194"></a>09194         ind2
<a name="l09195"></a>09195         )
<a name="l09196"></a>09196     );
<a name="l09197"></a>09197 }
<a name="l09198"></a>09198 
<a name="l09199"></a>09199 <span class="comment">/***********************************************************************************************************/</span>
<a name="l09200"></a>09200 <span class="comment">/* b_iterator, inc() ***************************************************************************************/</span>
<a name="l09201"></a>09201 <span class="comment">/***********************************************************************************************************/</span>
<a name="l09202"></a>09202 
<a name="l09203"></a>09203 <span class="keyword">template</span>&lt;
<a name="l09204"></a>09204     <span class="keywordtype">int</span> dim_, 
<a name="l09205"></a>09205     <span class="keyword">typename</span> left_base_iter_type_, 
<a name="l09206"></a>09206     <span class="keyword">typename</span> right_base_iter_type_, 
<a name="l09207"></a>09207     <span class="keyword">typename</span> func_type_, 
<a name="l09208"></a>09208     <span class="keywordtype">bool</span> is_static_&gt;
<a name="l09209"></a>09209 LITE_INLINE <span class="keywordtype">void</span> inc(b_iterator&lt;left_base_iter_type_, right_base_iter_type_, func_type_, is_static_&gt;&amp; it) 
<a name="l09210"></a>09210 {
<a name="l09211"></a>09211     inc&lt;dim_&gt;(it.left_base_iterator);
<a name="l09212"></a>09212     inc&lt;dim_&gt;(it.right_base_iterator);
<a name="l09213"></a>09213 }
<a name="l09214"></a>09214 
<a name="l09215"></a>09215 <span class="comment">/***********************************************************************************************************/</span>
<a name="l09216"></a>09216 <span class="comment">/* b_iterator, dec() ***************************************************************************************/</span>
<a name="l09217"></a>09217 <span class="comment">/***********************************************************************************************************/</span>
<a name="l09218"></a>09218 
<a name="l09219"></a>09219 <span class="keyword">template</span>&lt;
<a name="l09220"></a>09220     <span class="keywordtype">int</span> dim_, 
<a name="l09221"></a>09221     <span class="keyword">typename</span> left_base_iter_type_, 
<a name="l09222"></a>09222     <span class="keyword">typename</span> right_base_iter_type_, 
<a name="l09223"></a>09223     <span class="keyword">typename</span> func_type_, 
<a name="l09224"></a>09224     <span class="keywordtype">bool</span> is_static_&gt;
<a name="l09225"></a>09225 LITE_INLINE <span class="keywordtype">void</span> dec(b_iterator&lt;left_base_iter_type_, right_base_iter_type_, func_type_, is_static_&gt;&amp; it) 
<a name="l09226"></a>09226 {
<a name="l09227"></a>09227     dec&lt;dim_&gt;(it.left_base_iterator);
<a name="l09228"></a>09228     dec&lt;dim_&gt;(it.right_base_iterator);
<a name="l09229"></a>09229 }
<a name="l09230"></a>09230 
<a name="l09231"></a>09231 <span class="comment">/***********************************************************************************************************/</span>
<a name="l09232"></a>09232 <span class="comment">/* b_iterator, shift() *************************************************************************************/</span>
<a name="l09233"></a>09233 <span class="comment">/***********************************************************************************************************/</span>
<a name="l09234"></a>09234 
<a name="l09235"></a>09235 <span class="keyword">template</span>&lt;
<a name="l09236"></a>09236     <span class="keywordtype">int</span> dim_, 
<a name="l09237"></a>09237     <span class="keyword">typename</span> left_base_iter_type_, 
<a name="l09238"></a>09238     <span class="keyword">typename</span> right_base_iter_type_, 
<a name="l09239"></a>09239     <span class="keyword">typename</span> func_type_, 
<a name="l09240"></a>09240     <span class="keywordtype">bool</span> is_static_&gt;
<a name="l09241"></a>09241 LITE_INLINE 
<a name="l09242"></a>09242 <span class="keywordtype">void</span> shift(b_iterator&lt;left_base_iter_type_, right_base_iter_type_, func_type_, is_static_&gt;&amp; it, <span class="keywordtype">int</span> diff) 
<a name="l09243"></a>09243 {
<a name="l09244"></a>09244     shift&lt;dim_&gt;(it.left_base_iterator, diff);
<a name="l09245"></a>09245     shift&lt;dim_&gt;(it.right_base_iterator, diff);
<a name="l09246"></a>09246 }
<a name="l09247"></a>09247 
<a name="l09248"></a>09248 <span class="comment">/***********************************************************************************************************/</span>
<a name="l09249"></a>09249 <span class="comment">/* size_transformer ****************************************************************************************/</span>
<a name="l09250"></a>09250 <span class="comment">/***********************************************************************************************************/</span>
<a name="l09251"></a>09251 
<a name="l09252"></a>09252 <span class="preprocessor">#ifdef DOCUMENTATION_ONLY</span>
<a name="l09253"></a>09253 <span class="preprocessor"></span>
<a name="l09263"></a>09263 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_, <span class="keyword">typename</span> input_<span class="keywordtype">size_t</span>ype_&gt;
<a name="l09264"></a><a class="code" href="structlite_1_1size__transformer.html">09264</a> <span class="keyword">struct </span><a class="code" href="structlite_1_1size__transformer.html" title="This can be used to apply a transform object of type transform_type_ to a size object...">size_transformer</a>
<a name="l09265"></a>09265 {
<a name="l09266"></a>09266 <span class="keyword">public</span>:
<a name="l09268"></a><a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73">09268</a>     <span class="keyword">typedef</span> ??? <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>;
<a name="l09269"></a>09269 
<a name="l09278"></a>09278     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structlite_1_1size__transformer.html#a5a5eced0d3d9e624fb1513e036f392bf" title="Apply the transform to the size object org and store the result in res.">transform</a>(<span class="keyword">const</span> input_size_type_&amp; org, <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>&amp; res);
<a name="l09279"></a>09279 
<a name="l09283"></a>09283     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structlite_1_1size__transformer.html#a5a5eced0d3d9e624fb1513e036f392bf" title="Apply the transform to the size object org and store the result in res.">transform</a>(<span class="keyword">const</span> transform_type&amp; trans, <span class="keyword">const</span> input_size_type_&amp; org, <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>&amp; res);
<a name="l09284"></a>09284 };
<a name="l09285"></a>09285 
<a name="l09286"></a>09286 <span class="preprocessor">#endif // DOCUMENTATION_ONLY</span>
<a name="l09287"></a>09287 <span class="preprocessor"></span>
<a name="l09288"></a>09288 <span class="comment">/***********************************************************************************************************/</span>
<a name="l09289"></a>09289 <span class="comment">/* iterator_transformer ************************************************************************************/</span>
<a name="l09290"></a>09290 <span class="comment">/***********************************************************************************************************/</span>
<a name="l09291"></a>09291 
<a name="l09292"></a>09292 <span class="preprocessor">#ifdef DOCUMENTATION_ONLY</span>
<a name="l09293"></a>09293 <span class="preprocessor"></span>
<a name="l09304"></a>09304 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_, <span class="keyword">typename</span> input_iterator_type_, <span class="keyword">typename</span> input_<span class="keywordtype">size_t</span>ype_&gt;
<a name="l09305"></a><a class="code" href="structlite_1_1iterator__transformer.html">09305</a> <span class="keyword">struct </span><a class="code" href="structlite_1_1iterator__transformer.html" title="This can be used to apply a transform object of type transform_type_ to a pair of...">iterator_transformer</a>
<a name="l09306"></a>09306 {
<a name="l09307"></a>09307 <span class="keyword">public</span>:
<a name="l09309"></a><a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd">09309</a>     <span class="keyword">typedef</span> ??? <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>;
<a name="l09310"></a>09310 
<a name="l09320"></a>09320     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l09321"></a>09321         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l09322"></a>09322         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res);
<a name="l09323"></a>09323 
<a name="l09333"></a>09333     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l09334"></a>09334         <span class="keyword">const</span> transform_type_&amp; trans, 
<a name="l09335"></a>09335         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l09336"></a>09336         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res);
<a name="l09337"></a>09337 
<a name="l09343"></a>09343     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l09344"></a>09344         <span class="keyword">const</span> transform_type_&amp; trans, 
<a name="l09345"></a>09345         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l09346"></a>09346         <span class="keyword">const</span> input_size_type_&amp; sz,
<a name="l09347"></a>09347         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res);
<a name="l09348"></a>09348 };
<a name="l09349"></a>09349 
<a name="l09350"></a>09350 <span class="preprocessor">#endif // DOCUMENTATION_ONLY</span>
<a name="l09351"></a>09351 <span class="preprocessor"></span>
<a name="l09352"></a>09352 <span class="comment">/***********************************************************************************************************/</span>
<a name="l09353"></a>09353 <span class="comment">/* iterator_transformer, c_iterator ************************************************************************/</span>
<a name="l09354"></a>09354 <span class="comment">/***********************************************************************************************************/</span>
<a name="l09355"></a>09355 
<a name="l09356"></a>09356 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_, <span class="keyword">typename</span> value_type_, <span class="keyword">typename</span> input_<span class="keywordtype">size_t</span>ype_&gt;
<a name="l09357"></a>09357 <span class="keyword">struct </span><a class="code" href="structlite_1_1iterator__transformer.html" title="This can be used to apply a transform object of type transform_type_ to a pair of...">iterator_transformer</a>&lt;transform_type_, <a class="code" href="classlite_1_1c__iterator.html" title="This class implements an iterator that returns the same value everywhere.">c_iterator</a>&lt;value_type_&gt;, input_size_type_&gt;
<a name="l09358"></a>09358 {
<a name="l09359"></a>09359 <span class="keyword">public</span>:
<a name="l09360"></a>09360     <span class="keyword">typedef</span> <a class="code" href="classlite_1_1c__iterator.html" title="This class implements an iterator that returns the same value everywhere.">c_iterator&lt;value_type_&gt;</a> input_iterator_type;
<a name="l09361"></a>09361     <span class="keyword">typedef</span> input_iterator_type <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>;
<a name="l09362"></a>09362 
<a name="l09363"></a>09363     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l09364"></a>09364         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l09365"></a>09365         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l09366"></a>09366     {
<a name="l09367"></a>09367         res.value = org.value;
<a name="l09368"></a>09368     }
<a name="l09369"></a>09369 
<a name="l09370"></a>09370     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l09371"></a>09371         <span class="keyword">const</span> transform_type_&amp;, 
<a name="l09372"></a>09372         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l09373"></a>09373         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l09374"></a>09374     {
<a name="l09375"></a>09375         res.value = org.value;
<a name="l09376"></a>09376     }
<a name="l09377"></a>09377 
<a name="l09378"></a>09378     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l09379"></a>09379         <span class="keyword">const</span> transform_type_&amp;, 
<a name="l09380"></a>09380         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l09381"></a>09381         <span class="keyword">const</span> input_size_type_&amp;,
<a name="l09382"></a>09382         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l09383"></a>09383     {
<a name="l09384"></a>09384         res.value = org.value;
<a name="l09385"></a>09385     }
<a name="l09386"></a>09386 };
<a name="l09387"></a>09387 
<a name="l09388"></a>09388 <span class="comment">/***********************************************************************************************************/</span>
<a name="l09389"></a>09389 <span class="comment">/* iterator_transformer, u_iterator ************************************************************************/</span>
<a name="l09390"></a>09390 <span class="comment">/***********************************************************************************************************/</span>
<a name="l09391"></a>09391 
<a name="l09392"></a>09392 <span class="keyword">template</span>&lt;
<a name="l09393"></a>09393     <span class="keyword">typename</span> transform_type_,
<a name="l09394"></a>09394     <span class="keyword">typename</span> base_iter_type_, 
<a name="l09395"></a>09395     <span class="keyword">typename</span> func_type_, 
<a name="l09396"></a>09396     <span class="keyword">typename</span> input_size_type_&gt;
<a name="l09397"></a>09397 <span class="keyword">struct </span>iterator_transformer&lt;
<a name="l09398"></a>09398     transform_type_, 
<a name="l09399"></a>09399     u_iterator&lt;base_iter_type_, func_type_, true&gt;, 
<a name="l09400"></a>09400     input_size_type_&gt;
<a name="l09401"></a>09401 {
<a name="l09402"></a>09402 <span class="keyword">public</span>:
<a name="l09403"></a>09403     <span class="keyword">typedef</span> iterator_transformer&lt;transform_type_, base_iter_type_, input_size_type_&gt; base_transformer;
<a name="l09404"></a>09404 
<a name="l09405"></a>09405     <span class="keyword">typedef</span> u_iterator&lt;base_iter_type_, func_type_, true&gt; input_iterator_type;
<a name="l09406"></a>09406     <span class="keyword">typedef</span> u_iterator&lt;typename base_transformer::iterator_type, func_type_, true&gt; <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>;
<a name="l09407"></a>09407 
<a name="l09408"></a>09408     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l09409"></a>09409         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l09410"></a>09410         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l09411"></a>09411     {
<a name="l09412"></a>09412         <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">base_transformer::transform</a>(org.base_iterator, res.base_iterator);
<a name="l09413"></a>09413     }
<a name="l09414"></a>09414 
<a name="l09415"></a>09415     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l09416"></a>09416         <span class="keyword">const</span> transform_type_&amp; trans, 
<a name="l09417"></a>09417         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l09418"></a>09418         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l09419"></a>09419     {
<a name="l09420"></a>09420         <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">base_transformer::transform</a>(trans, org.base_iterator, res.base_iterator);
<a name="l09421"></a>09421     }
<a name="l09422"></a>09422 
<a name="l09423"></a>09423     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l09424"></a>09424         <span class="keyword">const</span> transform_type_&amp; trans, 
<a name="l09425"></a>09425         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l09426"></a>09426         <span class="keyword">const</span> input_size_type_&amp; sz,
<a name="l09427"></a>09427         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l09428"></a>09428     {
<a name="l09429"></a>09429         <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">base_transformer::transform</a>(trans, org.base_iterator, sz, res.base_iterator);
<a name="l09430"></a>09430     }
<a name="l09431"></a>09431 };
<a name="l09432"></a>09432 
<a name="l09433"></a>09433 <span class="comment">/***********************************************************************************************************/</span>
<a name="l09434"></a>09434 
<a name="l09435"></a>09435 <span class="keyword">template</span>&lt;
<a name="l09436"></a>09436     <span class="keyword">typename</span> transform_type_,
<a name="l09437"></a>09437     <span class="keyword">typename</span> base_iter_type_, 
<a name="l09438"></a>09438     <span class="keyword">typename</span> func_type_, 
<a name="l09439"></a>09439     <span class="keyword">typename</span> input_size_type_&gt;
<a name="l09440"></a>09440 <span class="keyword">struct </span>iterator_transformer&lt;
<a name="l09441"></a>09441     transform_type_, 
<a name="l09442"></a>09442     u_iterator&lt;base_iter_type_, func_type_, false&gt;, 
<a name="l09443"></a>09443     input_size_type_&gt;
<a name="l09444"></a>09444 {
<a name="l09445"></a>09445 <span class="keyword">public</span>:
<a name="l09446"></a>09446     <span class="keyword">typedef</span> iterator_transformer&lt;transform_type_, base_iter_type_, input_size_type_&gt; base_transformer;
<a name="l09447"></a>09447 
<a name="l09448"></a>09448     <span class="keyword">typedef</span> u_iterator&lt;base_iter_type_, func_type_, false&gt; input_iterator_type;
<a name="l09449"></a>09449     <span class="keyword">typedef</span> u_iterator&lt;typename base_transformer::iterator_type, func_type_, false&gt; <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>;
<a name="l09450"></a>09450 
<a name="l09451"></a>09451     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l09452"></a>09452         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l09453"></a>09453         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l09454"></a>09454     {
<a name="l09455"></a>09455         <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">base_transformer::transform</a>(org.base_iterator, res.base_iterator);
<a name="l09456"></a>09456         res.function = org.function;
<a name="l09457"></a>09457     }
<a name="l09458"></a>09458 
<a name="l09459"></a>09459     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l09460"></a>09460         <span class="keyword">const</span> transform_type_&amp; trans, 
<a name="l09461"></a>09461         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l09462"></a>09462         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l09463"></a>09463     {
<a name="l09464"></a>09464         <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">base_transformer::transform</a>(trans, org.base_iterator, res.base_iterator);
<a name="l09465"></a>09465         res.function = org.function;
<a name="l09466"></a>09466     }
<a name="l09467"></a>09467 
<a name="l09468"></a>09468     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l09469"></a>09469         <span class="keyword">const</span> transform_type_&amp; trans, 
<a name="l09470"></a>09470         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l09471"></a>09471         <span class="keyword">const</span> input_size_type_&amp; sz,
<a name="l09472"></a>09472         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l09473"></a>09473     {
<a name="l09474"></a>09474         <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">base_transformer::transform</a>(trans, org.base_iterator, sz, res.base_iterator);
<a name="l09475"></a>09475         res.function = org.function;
<a name="l09476"></a>09476     }
<a name="l09477"></a>09477 };
<a name="l09478"></a>09478 
<a name="l09479"></a>09479 <span class="comment">/***********************************************************************************************************/</span>
<a name="l09480"></a>09480 <span class="comment">/* iterator_transformer, b_iterator ************************************************************************/</span>
<a name="l09481"></a>09481 <span class="comment">/***********************************************************************************************************/</span>
<a name="l09482"></a>09482 
<a name="l09483"></a>09483 <span class="keyword">template</span>&lt;
<a name="l09484"></a>09484     <span class="keyword">typename</span> transform_type_,
<a name="l09485"></a>09485     <span class="keyword">typename</span> left_base_iter_type_, 
<a name="l09486"></a>09486     <span class="keyword">typename</span> right_base_iter_type_, 
<a name="l09487"></a>09487     <span class="keyword">typename</span> func_type_, 
<a name="l09488"></a>09488     <span class="keyword">typename</span> input_size_type_&gt;
<a name="l09489"></a>09489 <span class="keyword">struct </span>iterator_transformer&lt;
<a name="l09490"></a>09490     transform_type_, 
<a name="l09491"></a>09491     b_iterator&lt;left_base_iter_type_, right_base_iter_type_, func_type_, true&gt;, 
<a name="l09492"></a>09492     input_size_type_&gt;
<a name="l09493"></a>09493 {
<a name="l09494"></a>09494 <span class="keyword">public</span>:
<a name="l09495"></a>09495     <span class="keyword">typedef</span> iterator_transformer&lt;transform_type_, left_base_iter_type_, input_size_type_&gt; 
<a name="l09496"></a>09496         left_base_transformer;
<a name="l09497"></a>09497 
<a name="l09498"></a>09498     <span class="keyword">typedef</span> iterator_transformer&lt;transform_type_, right_base_iter_type_, input_size_type_&gt; 
<a name="l09499"></a>09499         right_base_transformer;
<a name="l09500"></a>09500 
<a name="l09501"></a>09501     <span class="keyword">typedef</span> b_iterator&lt;left_base_iter_type_, right_base_iter_type_, func_type_, true&gt; input_iterator_type;
<a name="l09502"></a>09502 
<a name="l09503"></a>09503     <span class="keyword">typedef</span> b_iterator&lt;
<a name="l09504"></a>09504         <span class="keyword">typename</span> left_base_transformer::iterator_type, 
<a name="l09505"></a>09505         <span class="keyword">typename</span> right_base_transformer::iterator_type, 
<a name="l09506"></a>09506         func_type_, 
<a name="l09507"></a>09507         <span class="keyword">true</span>&gt; 
<a name="l09508"></a>09508         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>;
<a name="l09509"></a>09509 
<a name="l09510"></a>09510     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l09511"></a>09511         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l09512"></a>09512         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l09513"></a>09513     {
<a name="l09514"></a>09514         <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">left_base_transformer::transform</a>(org.left_base_iterator, res.left_base_iterator);
<a name="l09515"></a>09515         <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">right_base_transformer::transform</a>(org.right_base_iterator, res.right_base_iterator);
<a name="l09516"></a>09516     }
<a name="l09517"></a>09517 
<a name="l09518"></a>09518     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l09519"></a>09519         <span class="keyword">const</span> transform_type_&amp; trans, 
<a name="l09520"></a>09520         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l09521"></a>09521         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l09522"></a>09522     {
<a name="l09523"></a>09523         <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">left_base_transformer::transform</a>(trans, org.left_base_iterator, res.left_base_iterator);
<a name="l09524"></a>09524         <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">right_base_transformer::transform</a>(trans, org.right_base_iterator, res.right_base_iterator);
<a name="l09525"></a>09525     }
<a name="l09526"></a>09526 
<a name="l09527"></a>09527     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l09528"></a>09528         <span class="keyword">const</span> transform_type_&amp; trans, 
<a name="l09529"></a>09529         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l09530"></a>09530         <span class="keyword">const</span> input_size_type_&amp; sz,
<a name="l09531"></a>09531         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l09532"></a>09532     {
<a name="l09533"></a>09533         <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">left_base_transformer::transform</a>(trans, org.left_base_iterator, sz, res.left_base_iterator);
<a name="l09534"></a>09534         <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">right_base_transformer::transform</a>(trans, org.right_base_iterator, sz, res.right_base_iterator);
<a name="l09535"></a>09535     }
<a name="l09536"></a>09536 };
<a name="l09537"></a>09537 
<a name="l09538"></a>09538 <span class="comment">/***********************************************************************************************************/</span>
<a name="l09539"></a>09539 
<a name="l09540"></a>09540 <span class="keyword">template</span>&lt;
<a name="l09541"></a>09541     <span class="keyword">typename</span> transform_type_,
<a name="l09542"></a>09542     <span class="keyword">typename</span> left_base_iter_type_, 
<a name="l09543"></a>09543     <span class="keyword">typename</span> right_base_iter_type_, 
<a name="l09544"></a>09544     <span class="keyword">typename</span> func_type_, 
<a name="l09545"></a>09545     <span class="keyword">typename</span> input_size_type_&gt;
<a name="l09546"></a>09546 <span class="keyword">struct </span>iterator_transformer&lt;
<a name="l09547"></a>09547     transform_type_, 
<a name="l09548"></a>09548     b_iterator&lt;left_base_iter_type_, right_base_iter_type_, func_type_, false&gt;, 
<a name="l09549"></a>09549     input_size_type_&gt;
<a name="l09550"></a>09550 {
<a name="l09551"></a>09551 <span class="keyword">public</span>:
<a name="l09552"></a>09552     <span class="keyword">typedef</span> iterator_transformer&lt;transform_type_, left_base_iter_type_, input_size_type_&gt; 
<a name="l09553"></a>09553         left_base_transformer;
<a name="l09554"></a>09554 
<a name="l09555"></a>09555     <span class="keyword">typedef</span> iterator_transformer&lt;transform_type_, right_base_iter_type_, input_size_type_&gt; 
<a name="l09556"></a>09556         right_base_transformer;
<a name="l09557"></a>09557 
<a name="l09558"></a>09558     <span class="keyword">typedef</span> b_iterator&lt;left_base_iter_type_, right_base_iter_type_, func_type_, false&gt; input_iterator_type;
<a name="l09559"></a>09559 
<a name="l09560"></a>09560     <span class="keyword">typedef</span> b_iterator&lt;
<a name="l09561"></a>09561         <span class="keyword">typename</span> left_base_transformer::iterator_type, 
<a name="l09562"></a>09562         <span class="keyword">typename</span> right_base_transformer::iterator_type, 
<a name="l09563"></a>09563         func_type_, 
<a name="l09564"></a>09564         <span class="keyword">false</span>&gt; 
<a name="l09565"></a>09565         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>;
<a name="l09566"></a>09566 
<a name="l09567"></a>09567     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l09568"></a>09568         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l09569"></a>09569         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l09570"></a>09570     {
<a name="l09571"></a>09571         <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">left_base_transformer::transform</a>(org.left_base_iterator, res.left_base_iterator);
<a name="l09572"></a>09572         <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">right_base_transformer::transform</a>(org.right_base_iterator, res.right_base_iterator);
<a name="l09573"></a>09573         res.function = org.function;
<a name="l09574"></a>09574     }
<a name="l09575"></a>09575 
<a name="l09576"></a>09576     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l09577"></a>09577         <span class="keyword">const</span> transform_type_&amp; trans, 
<a name="l09578"></a>09578         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l09579"></a>09579         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l09580"></a>09580     {
<a name="l09581"></a>09581         <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">left_base_transformer::transform</a>(trans, org.left_base_iterator, res.left_base_iterator);
<a name="l09582"></a>09582         <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">right_base_transformer::transform</a>(trans, org.right_base_iterator, res.right_base_iterator);
<a name="l09583"></a>09583         res.function = org.function;
<a name="l09584"></a>09584     }
<a name="l09585"></a>09585 
<a name="l09586"></a>09586     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l09587"></a>09587         <span class="keyword">const</span> transform_type_&amp; trans, 
<a name="l09588"></a>09588         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l09589"></a>09589         <span class="keyword">const</span> input_size_type_&amp; sz,
<a name="l09590"></a>09590         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l09591"></a>09591     {
<a name="l09592"></a>09592         <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">left_base_transformer::transform</a>(trans, org.left_base_iterator, sz, res.left_base_iterator);
<a name="l09593"></a>09593         <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">right_base_transformer::transform</a>(trans, org.right_base_iterator, sz, res.right_base_iterator);
<a name="l09594"></a>09594         res.function = org.function;
<a name="l09595"></a>09595     }
<a name="l09596"></a>09596 };
<a name="l09597"></a>09597 
<a name="l09598"></a>09598 <span class="comment">/***********************************************************************************************************/</span>
<a name="l09599"></a>09599 <span class="comment">/* plane ***************************************************************************************************/</span>
<a name="l09600"></a>09600 <span class="comment">/***********************************************************************************************************/</span>
<a name="l09601"></a>09601 
<a name="l09626"></a>09626 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim_&gt;
<a name="l09627"></a><a class="code" href="classlite_1_1plane.html">09627</a> <span class="keyword">class </span><a class="code" href="classlite_1_1plane.html" title="This transform, when applied to an array of dimension N, returns a reference array...">plane</a>
<a name="l09628"></a>09628 {
<a name="l09629"></a>09629 <span class="keyword">public</span>:
<a name="l09631"></a><a class="code" href="classlite_1_1plane.html#a7092b7351cbf9b0fefd97f9be6c8c5c3">09631</a>     LITE_INLINE <a class="code" href="classlite_1_1plane.html#a7092b7351cbf9b0fefd97f9be6c8c5c3" title="Creates a plane that fixes the index at dimension dim_ to index.">plane</a>(<span class="keywordtype">int</span> <a class="code" href="classlite_1_1plane.html#a11f97fc5cbe08a4c6a03589680d9f65b" title="The index at dimension dim_.">index</a> =0) : <a class="code" href="classlite_1_1plane.html#a11f97fc5cbe08a4c6a03589680d9f65b" title="The index at dimension dim_.">index</a>(<a class="code" href="classlite_1_1plane.html#a11f97fc5cbe08a4c6a03589680d9f65b" title="The index at dimension dim_.">index</a>) {}
<a name="l09632"></a>09632 
<a name="l09633"></a>09633     LITE_INLINE <a class="code" href="classlite_1_1plane.html#a7092b7351cbf9b0fefd97f9be6c8c5c3" title="Creates a plane that fixes the index at dimension dim_ to index.">plane</a>(<span class="keyword">const</span> <a class="code" href="classlite_1_1plane.html" title="This transform, when applied to an array of dimension N, returns a reference array...">plane</a>&amp; other) : <a class="code" href="classlite_1_1plane.html#a11f97fc5cbe08a4c6a03589680d9f65b" title="The index at dimension dim_.">index</a>(other.<a class="code" href="classlite_1_1plane.html#a11f97fc5cbe08a4c6a03589680d9f65b" title="The index at dimension dim_.">index</a>) {}
<a name="l09634"></a>09634 
<a name="l09635"></a>09635     LITE_INLINE <a class="code" href="classlite_1_1plane.html#a7092b7351cbf9b0fefd97f9be6c8c5c3" title="Creates a plane that fixes the index at dimension dim_ to index.">plane</a>&amp; operator=(<span class="keyword">const</span> <a class="code" href="classlite_1_1plane.html#a7092b7351cbf9b0fefd97f9be6c8c5c3" title="Creates a plane that fixes the index at dimension dim_ to index.">plane</a>&amp; other) { <a class="code" href="classlite_1_1plane.html#a11f97fc5cbe08a4c6a03589680d9f65b" title="The index at dimension dim_.">index</a> = other.index; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l09636"></a>09636 
<a name="l09638"></a><a class="code" href="classlite_1_1plane.html#a11f97fc5cbe08a4c6a03589680d9f65b">09638</a>     <span class="keywordtype">int</span> <a class="code" href="classlite_1_1plane.html#a11f97fc5cbe08a4c6a03589680d9f65b" title="The index at dimension dim_.">index</a>;
<a name="l09639"></a>09639 };
<a name="l09640"></a>09640 
<a name="l09641"></a>09641 <span class="comment">/***********************************************************************************************************/</span>
<a name="l09642"></a>09642 <span class="comment">/* size_transformer, plane *********************************************************************************/</span>
<a name="l09643"></a>09643 <span class="comment">/***********************************************************************************************************/</span>
<a name="l09644"></a>09644 
<a name="l09645"></a>09645 <span class="keyword">template</span>&lt;
<a name="l09646"></a>09646     <span class="keyword">typename</span> type0_
<a name="l09647"></a>09647     &gt;
<a name="l09648"></a>09648 <span class="keyword">struct </span><a class="code" href="structlite_1_1size__transformer.html" title="This can be used to apply a transform object of type transform_type_ to a size object...">size_transformer</a>&lt;
<a name="l09649"></a>09649     <a class="code" href="classlite_1_1plane.html" title="This transform, when applied to an array of dimension N, returns a reference array...">plane</a>&lt;0&gt;, 
<a name="l09650"></a>09650     <a class="code" href="classlite_1_1pack.html" title="This is a general tuple class that can pack together elements of different types...">pack</a>&lt;
<a name="l09651"></a>09651         type0_
<a name="l09652"></a>09652     &gt; &gt;
<a name="l09653"></a>09653 {
<a name="l09654"></a>09654 <span class="keyword">public</span>:
<a name="l09655"></a>09655     <span class="keyword">typedef</span> <a class="code" href="classlite_1_1plane.html" title="This transform, when applied to an array of dimension N, returns a reference array...">plane&lt;0&gt;</a> transform_type;
<a name="l09656"></a>09656 
<a name="l09657"></a>09657     <span class="keyword">typedef</span> <a class="code" href="classlite_1_1pack.html" title="This is a general tuple class that can pack together elements of different types...">pack</a>&lt;
<a name="l09658"></a>09658         type0_
<a name="l09659"></a>09659         &gt; input_size_type;
<a name="l09660"></a>09660 
<a name="l09661"></a>09661     <span class="keyword">typedef</span> <a class="code" href="classlite_1_1sub__pack.html" title="This class can be used to define and extract a subset of element of a pack as another...">sub_pack</a>&lt;
<a name="l09662"></a>09662         input_size_type,
<a name="l09663"></a>09663         <span class="keyword">false</span>
<a name="l09664"></a>09664         &gt; sub_pack_type;
<a name="l09665"></a>09665 
<a name="l09666"></a>09666     <span class="keyword">typedef</span> <span class="keyword">typename</span> sub_pack_type::type <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>;
<a name="l09667"></a>09667 
<a name="l09668"></a>09668     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1size__transformer.html#a5a5eced0d3d9e624fb1513e036f392bf" title="Apply the transform to the size object org and store the result in res.">transform</a>(<span class="keyword">const</span> input_size_type&amp; org, <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>&amp; res)
<a name="l09669"></a>09669     {
<a name="l09670"></a>09670         <a class="code" href="group__array__tools.html#ga86cbd758c7c991ccb4aac651392c5e84">sub_pack_type::set</a>(res, org);
<a name="l09671"></a>09671     }
<a name="l09672"></a>09672 
<a name="l09673"></a>09673     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1size__transformer.html#a5a5eced0d3d9e624fb1513e036f392bf" title="Apply the transform to the size object org and store the result in res.">transform</a>(<span class="keyword">const</span> transform_type&amp;, <span class="keyword">const</span> input_size_type&amp; org, <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>&amp; res)
<a name="l09674"></a>09674     {
<a name="l09675"></a>09675         <a class="code" href="group__array__tools.html#ga86cbd758c7c991ccb4aac651392c5e84">sub_pack_type::set</a>(res, org);
<a name="l09676"></a>09676     }
<a name="l09677"></a>09677 };
<a name="l09678"></a>09678 
<a name="l09679"></a>09679 <span class="comment">/***********************************************************************************************************/</span>
<a name="l09680"></a>09680 <span class="keyword">template</span>&lt;
<a name="l09681"></a>09681     <span class="keyword">typename</span> type0_,
<a name="l09682"></a>09682     <span class="keyword">typename</span> type1_
<a name="l09683"></a>09683     &gt;
<a name="l09684"></a>09684 <span class="keyword">struct </span>size_transformer&lt;
<a name="l09685"></a>09685     plane&lt;0&gt;, 
<a name="l09686"></a>09686     pack&lt;
<a name="l09687"></a>09687         type0_,
<a name="l09688"></a>09688         type1_
<a name="l09689"></a>09689     &gt; &gt;
<a name="l09690"></a>09690 {
<a name="l09691"></a>09691 <span class="keyword">public</span>:
<a name="l09692"></a>09692     <span class="keyword">typedef</span> plane&lt;0&gt; transform_type;
<a name="l09693"></a>09693 
<a name="l09694"></a>09694     <span class="keyword">typedef</span> pack&lt;
<a name="l09695"></a>09695         type0_,
<a name="l09696"></a>09696         type1_
<a name="l09697"></a>09697         &gt; input_size_type;
<a name="l09698"></a>09698 
<a name="l09699"></a>09699     <span class="keyword">typedef</span> sub_pack&lt;
<a name="l09700"></a>09700         input_size_type,
<a name="l09701"></a>09701         <span class="keyword">false</span>,
<a name="l09702"></a>09702         <span class="keyword">true</span>
<a name="l09703"></a>09703         &gt; sub_pack_type;
<a name="l09704"></a>09704 
<a name="l09705"></a>09705     <span class="keyword">typedef</span> <span class="keyword">typename</span> sub_pack_type::type <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>;
<a name="l09706"></a>09706 
<a name="l09707"></a>09707     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1size__transformer.html#a5a5eced0d3d9e624fb1513e036f392bf" title="Apply the transform to the size object org and store the result in res.">transform</a>(<span class="keyword">const</span> input_size_type&amp; org, <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>&amp; res)
<a name="l09708"></a>09708     {
<a name="l09709"></a>09709         <a class="code" href="group__array__tools.html#ga86cbd758c7c991ccb4aac651392c5e84">sub_pack_type::set</a>(res, org);
<a name="l09710"></a>09710     }
<a name="l09711"></a>09711 
<a name="l09712"></a>09712     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1size__transformer.html#a5a5eced0d3d9e624fb1513e036f392bf" title="Apply the transform to the size object org and store the result in res.">transform</a>(<span class="keyword">const</span> transform_type&amp;, <span class="keyword">const</span> input_size_type&amp; org, <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>&amp; res)
<a name="l09713"></a>09713     {
<a name="l09714"></a>09714         <a class="code" href="group__array__tools.html#ga86cbd758c7c991ccb4aac651392c5e84">sub_pack_type::set</a>(res, org);
<a name="l09715"></a>09715     }
<a name="l09716"></a>09716 };
<a name="l09717"></a>09717 
<a name="l09718"></a>09718 <span class="comment">/***********************************************************************************************************/</span>
<a name="l09719"></a>09719 <span class="keyword">template</span>&lt;
<a name="l09720"></a>09720     <span class="keyword">typename</span> type0_,
<a name="l09721"></a>09721     <span class="keyword">typename</span> type1_,
<a name="l09722"></a>09722     <span class="keyword">typename</span> type2_
<a name="l09723"></a>09723     &gt;
<a name="l09724"></a>09724 <span class="keyword">struct </span>size_transformer&lt;
<a name="l09725"></a>09725     plane&lt;0&gt;, 
<a name="l09726"></a>09726     pack&lt;
<a name="l09727"></a>09727         type0_,
<a name="l09728"></a>09728         type1_,
<a name="l09729"></a>09729         type2_
<a name="l09730"></a>09730     &gt; &gt;
<a name="l09731"></a>09731 {
<a name="l09732"></a>09732 <span class="keyword">public</span>:
<a name="l09733"></a>09733     <span class="keyword">typedef</span> plane&lt;0&gt; transform_type;
<a name="l09734"></a>09734 
<a name="l09735"></a>09735     <span class="keyword">typedef</span> pack&lt;
<a name="l09736"></a>09736         type0_,
<a name="l09737"></a>09737         type1_,
<a name="l09738"></a>09738         type2_
<a name="l09739"></a>09739         &gt; input_size_type;
<a name="l09740"></a>09740 
<a name="l09741"></a>09741     <span class="keyword">typedef</span> sub_pack&lt;
<a name="l09742"></a>09742         input_size_type,
<a name="l09743"></a>09743         <span class="keyword">false</span>,
<a name="l09744"></a>09744         <span class="keyword">true</span>,
<a name="l09745"></a>09745         <span class="keyword">true</span>
<a name="l09746"></a>09746         &gt; sub_pack_type;
<a name="l09747"></a>09747 
<a name="l09748"></a>09748     <span class="keyword">typedef</span> <span class="keyword">typename</span> sub_pack_type::type <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>;
<a name="l09749"></a>09749 
<a name="l09750"></a>09750     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1size__transformer.html#a5a5eced0d3d9e624fb1513e036f392bf" title="Apply the transform to the size object org and store the result in res.">transform</a>(<span class="keyword">const</span> input_size_type&amp; org, <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>&amp; res)
<a name="l09751"></a>09751     {
<a name="l09752"></a>09752         <a class="code" href="group__array__tools.html#ga86cbd758c7c991ccb4aac651392c5e84">sub_pack_type::set</a>(res, org);
<a name="l09753"></a>09753     }
<a name="l09754"></a>09754 
<a name="l09755"></a>09755     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1size__transformer.html#a5a5eced0d3d9e624fb1513e036f392bf" title="Apply the transform to the size object org and store the result in res.">transform</a>(<span class="keyword">const</span> transform_type&amp;, <span class="keyword">const</span> input_size_type&amp; org, <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>&amp; res)
<a name="l09756"></a>09756     {
<a name="l09757"></a>09757         <a class="code" href="group__array__tools.html#ga86cbd758c7c991ccb4aac651392c5e84">sub_pack_type::set</a>(res, org);
<a name="l09758"></a>09758     }
<a name="l09759"></a>09759 };
<a name="l09760"></a>09760 
<a name="l09761"></a>09761 <span class="comment">/***********************************************************************************************************/</span>
<a name="l09762"></a>09762 <span class="keyword">template</span>&lt;
<a name="l09763"></a>09763     <span class="keyword">typename</span> type0_,
<a name="l09764"></a>09764     <span class="keyword">typename</span> type1_
<a name="l09765"></a>09765     &gt;
<a name="l09766"></a>09766 <span class="keyword">struct </span>size_transformer&lt;
<a name="l09767"></a>09767     plane&lt;1&gt;, 
<a name="l09768"></a>09768     pack&lt;
<a name="l09769"></a>09769         type0_,
<a name="l09770"></a>09770         type1_
<a name="l09771"></a>09771     &gt; &gt;
<a name="l09772"></a>09772 {
<a name="l09773"></a>09773 <span class="keyword">public</span>:
<a name="l09774"></a>09774     <span class="keyword">typedef</span> plane&lt;1&gt; transform_type;
<a name="l09775"></a>09775 
<a name="l09776"></a>09776     <span class="keyword">typedef</span> pack&lt;
<a name="l09777"></a>09777         type0_,
<a name="l09778"></a>09778         type1_
<a name="l09779"></a>09779         &gt; input_size_type;
<a name="l09780"></a>09780 
<a name="l09781"></a>09781     <span class="keyword">typedef</span> sub_pack&lt;
<a name="l09782"></a>09782         input_size_type,
<a name="l09783"></a>09783         <span class="keyword">true</span>,
<a name="l09784"></a>09784         <span class="keyword">false</span>
<a name="l09785"></a>09785         &gt; sub_pack_type;
<a name="l09786"></a>09786 
<a name="l09787"></a>09787     <span class="keyword">typedef</span> <span class="keyword">typename</span> sub_pack_type::type <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>;
<a name="l09788"></a>09788 
<a name="l09789"></a>09789     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1size__transformer.html#a5a5eced0d3d9e624fb1513e036f392bf" title="Apply the transform to the size object org and store the result in res.">transform</a>(<span class="keyword">const</span> input_size_type&amp; org, <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>&amp; res)
<a name="l09790"></a>09790     {
<a name="l09791"></a>09791         <a class="code" href="group__array__tools.html#ga86cbd758c7c991ccb4aac651392c5e84">sub_pack_type::set</a>(res, org);
<a name="l09792"></a>09792     }
<a name="l09793"></a>09793 
<a name="l09794"></a>09794     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1size__transformer.html#a5a5eced0d3d9e624fb1513e036f392bf" title="Apply the transform to the size object org and store the result in res.">transform</a>(<span class="keyword">const</span> transform_type&amp;, <span class="keyword">const</span> input_size_type&amp; org, <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>&amp; res)
<a name="l09795"></a>09795     {
<a name="l09796"></a>09796         <a class="code" href="group__array__tools.html#ga86cbd758c7c991ccb4aac651392c5e84">sub_pack_type::set</a>(res, org);
<a name="l09797"></a>09797     }
<a name="l09798"></a>09798 };
<a name="l09799"></a>09799 
<a name="l09800"></a>09800 <span class="comment">/***********************************************************************************************************/</span>
<a name="l09801"></a>09801 <span class="keyword">template</span>&lt;
<a name="l09802"></a>09802     <span class="keyword">typename</span> type0_,
<a name="l09803"></a>09803     <span class="keyword">typename</span> type1_,
<a name="l09804"></a>09804     <span class="keyword">typename</span> type2_
<a name="l09805"></a>09805     &gt;
<a name="l09806"></a>09806 <span class="keyword">struct </span>size_transformer&lt;
<a name="l09807"></a>09807     plane&lt;1&gt;, 
<a name="l09808"></a>09808     pack&lt;
<a name="l09809"></a>09809         type0_,
<a name="l09810"></a>09810         type1_,
<a name="l09811"></a>09811         type2_
<a name="l09812"></a>09812     &gt; &gt;
<a name="l09813"></a>09813 {
<a name="l09814"></a>09814 <span class="keyword">public</span>:
<a name="l09815"></a>09815     <span class="keyword">typedef</span> plane&lt;1&gt; transform_type;
<a name="l09816"></a>09816 
<a name="l09817"></a>09817     <span class="keyword">typedef</span> pack&lt;
<a name="l09818"></a>09818         type0_,
<a name="l09819"></a>09819         type1_,
<a name="l09820"></a>09820         type2_
<a name="l09821"></a>09821         &gt; input_size_type;
<a name="l09822"></a>09822 
<a name="l09823"></a>09823     <span class="keyword">typedef</span> sub_pack&lt;
<a name="l09824"></a>09824         input_size_type,
<a name="l09825"></a>09825         <span class="keyword">true</span>,
<a name="l09826"></a>09826         <span class="keyword">false</span>,
<a name="l09827"></a>09827         <span class="keyword">true</span>
<a name="l09828"></a>09828         &gt; sub_pack_type;
<a name="l09829"></a>09829 
<a name="l09830"></a>09830     <span class="keyword">typedef</span> <span class="keyword">typename</span> sub_pack_type::type <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>;
<a name="l09831"></a>09831 
<a name="l09832"></a>09832     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1size__transformer.html#a5a5eced0d3d9e624fb1513e036f392bf" title="Apply the transform to the size object org and store the result in res.">transform</a>(<span class="keyword">const</span> input_size_type&amp; org, <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>&amp; res)
<a name="l09833"></a>09833     {
<a name="l09834"></a>09834         <a class="code" href="group__array__tools.html#ga86cbd758c7c991ccb4aac651392c5e84">sub_pack_type::set</a>(res, org);
<a name="l09835"></a>09835     }
<a name="l09836"></a>09836 
<a name="l09837"></a>09837     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1size__transformer.html#a5a5eced0d3d9e624fb1513e036f392bf" title="Apply the transform to the size object org and store the result in res.">transform</a>(<span class="keyword">const</span> transform_type&amp;, <span class="keyword">const</span> input_size_type&amp; org, <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>&amp; res)
<a name="l09838"></a>09838     {
<a name="l09839"></a>09839         <a class="code" href="group__array__tools.html#ga86cbd758c7c991ccb4aac651392c5e84">sub_pack_type::set</a>(res, org);
<a name="l09840"></a>09840     }
<a name="l09841"></a>09841 };
<a name="l09842"></a>09842 
<a name="l09843"></a>09843 <span class="comment">/***********************************************************************************************************/</span>
<a name="l09844"></a>09844 <span class="keyword">template</span>&lt;
<a name="l09845"></a>09845     <span class="keyword">typename</span> type0_,
<a name="l09846"></a>09846     <span class="keyword">typename</span> type1_,
<a name="l09847"></a>09847     <span class="keyword">typename</span> type2_
<a name="l09848"></a>09848     &gt;
<a name="l09849"></a>09849 <span class="keyword">struct </span>size_transformer&lt;
<a name="l09850"></a>09850     plane&lt;2&gt;, 
<a name="l09851"></a>09851     pack&lt;
<a name="l09852"></a>09852         type0_,
<a name="l09853"></a>09853         type1_,
<a name="l09854"></a>09854         type2_
<a name="l09855"></a>09855     &gt; &gt;
<a name="l09856"></a>09856 {
<a name="l09857"></a>09857 <span class="keyword">public</span>:
<a name="l09858"></a>09858     <span class="keyword">typedef</span> plane&lt;2&gt; transform_type;
<a name="l09859"></a>09859 
<a name="l09860"></a>09860     <span class="keyword">typedef</span> pack&lt;
<a name="l09861"></a>09861         type0_,
<a name="l09862"></a>09862         type1_,
<a name="l09863"></a>09863         type2_
<a name="l09864"></a>09864         &gt; input_size_type;
<a name="l09865"></a>09865 
<a name="l09866"></a>09866     <span class="keyword">typedef</span> sub_pack&lt;
<a name="l09867"></a>09867         input_size_type,
<a name="l09868"></a>09868         <span class="keyword">true</span>,
<a name="l09869"></a>09869         <span class="keyword">true</span>,
<a name="l09870"></a>09870         <span class="keyword">false</span>
<a name="l09871"></a>09871         &gt; sub_pack_type;
<a name="l09872"></a>09872 
<a name="l09873"></a>09873     <span class="keyword">typedef</span> <span class="keyword">typename</span> sub_pack_type::type <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>;
<a name="l09874"></a>09874 
<a name="l09875"></a>09875     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1size__transformer.html#a5a5eced0d3d9e624fb1513e036f392bf" title="Apply the transform to the size object org and store the result in res.">transform</a>(<span class="keyword">const</span> input_size_type&amp; org, <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>&amp; res)
<a name="l09876"></a>09876     {
<a name="l09877"></a>09877         <a class="code" href="group__array__tools.html#ga86cbd758c7c991ccb4aac651392c5e84">sub_pack_type::set</a>(res, org);
<a name="l09878"></a>09878     }
<a name="l09879"></a>09879 
<a name="l09880"></a>09880     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1size__transformer.html#a5a5eced0d3d9e624fb1513e036f392bf" title="Apply the transform to the size object org and store the result in res.">transform</a>(<span class="keyword">const</span> transform_type&amp;, <span class="keyword">const</span> input_size_type&amp; org, <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>&amp; res)
<a name="l09881"></a>09881     {
<a name="l09882"></a>09882         <a class="code" href="group__array__tools.html#ga86cbd758c7c991ccb4aac651392c5e84">sub_pack_type::set</a>(res, org);
<a name="l09883"></a>09883     }
<a name="l09884"></a>09884 };
<a name="l09885"></a>09885 
<a name="l09886"></a>09886 <span class="comment">/***********************************************************************************************************/</span>
<a name="l09887"></a>09887 
<a name="l09888"></a>09888 <span class="comment">/***********************************************************************************************************/</span>
<a name="l09889"></a>09889 <span class="comment">/* iterator_transformer, plane *****************************************************************************/</span>
<a name="l09890"></a>09890 <span class="comment">/***********************************************************************************************************/</span>
<a name="l09891"></a>09891 
<a name="l09892"></a>09892 <span class="keyword">template</span>&lt;
<a name="l09893"></a>09893     <span class="keyword">typename</span> base_iter_type_,
<a name="l09894"></a>09894     <span class="keyword">typename</span> type0_,
<a name="l09895"></a>09895     <span class="keyword">typename</span> input_size_type_&gt;
<a name="l09896"></a>09896 <span class="keyword">struct </span>iterator_transformer&lt;
<a name="l09897"></a>09897     plane&lt;0&gt;, 
<a name="l09898"></a>09898     pack&lt;
<a name="l09899"></a>09899         base_iter_type_,
<a name="l09900"></a>09900         type0_
<a name="l09901"></a>09901     &gt;,
<a name="l09902"></a>09902     input_size_type_&gt;
<a name="l09903"></a>09903 {
<a name="l09904"></a>09904 <span class="keyword">public</span>:
<a name="l09905"></a>09905     <span class="keyword">typedef</span> plane&lt;0&gt; transform_type;
<a name="l09906"></a>09906 
<a name="l09907"></a>09907     <span class="keyword">typedef</span> pack&lt;
<a name="l09908"></a>09908         base_iter_type_,
<a name="l09909"></a>09909         type0_
<a name="l09910"></a>09910         &gt; input_iterator_type;
<a name="l09911"></a>09911 
<a name="l09912"></a>09912     <span class="keyword">typedef</span> input_size_type_ input_size_type;
<a name="l09913"></a>09913 
<a name="l09914"></a>09914     <span class="keyword">typedef</span> sub_pack&lt;
<a name="l09915"></a>09915         input_iterator_type,
<a name="l09916"></a>09916         <span class="keyword">true</span>,
<a name="l09917"></a>09917         <span class="keyword">false</span>
<a name="l09918"></a>09918         &gt; sub_pack_type;
<a name="l09919"></a>09919 
<a name="l09920"></a>09920     <span class="keyword">typedef</span> <span class="keyword">typename</span> sub_pack_type::type <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>;
<a name="l09921"></a>09921 
<a name="l09922"></a>09922     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l09923"></a>09923         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l09924"></a>09924         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l09925"></a>09925     {
<a name="l09926"></a>09926         <a class="code" href="group__array__tools.html#ga86cbd758c7c991ccb4aac651392c5e84">sub_pack_type::set</a>(res, org);
<a name="l09927"></a>09927     }
<a name="l09928"></a>09928 
<a name="l09929"></a>09929     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l09930"></a>09930         <span class="keyword">const</span> transform_type&amp; trans, 
<a name="l09931"></a>09931         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l09932"></a>09932         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l09933"></a>09933     {
<a name="l09934"></a>09934         <a class="code" href="group__array__tools.html#ga86cbd758c7c991ccb4aac651392c5e84">sub_pack_type::set</a>(res, org.i0+trans.index*org.i1, org.i1);
<a name="l09935"></a>09935     }
<a name="l09936"></a>09936 
<a name="l09937"></a>09937     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l09938"></a>09938         <span class="keyword">const</span> transform_type&amp; trans, 
<a name="l09939"></a>09939         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l09940"></a>09940         <span class="keyword">const</span> input_size_type&amp;,
<a name="l09941"></a>09941         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l09942"></a>09942     {
<a name="l09943"></a>09943         <a class="code" href="group__array__tools.html#ga86cbd758c7c991ccb4aac651392c5e84">sub_pack_type::set</a>(res, org.i0+trans.index*org.i1, org.i1);
<a name="l09944"></a>09944     }
<a name="l09945"></a>09945 };
<a name="l09946"></a>09946 
<a name="l09947"></a>09947 <span class="comment">/***********************************************************************************************************/</span>
<a name="l09948"></a>09948 <span class="keyword">template</span>&lt;
<a name="l09949"></a>09949     <span class="keyword">typename</span> base_iter_type_,
<a name="l09950"></a>09950     <span class="keyword">typename</span> type0_,
<a name="l09951"></a>09951     <span class="keyword">typename</span> type1_,
<a name="l09952"></a>09952     <span class="keyword">typename</span> input_size_type_&gt;
<a name="l09953"></a>09953 <span class="keyword">struct </span>iterator_transformer&lt;
<a name="l09954"></a>09954     plane&lt;0&gt;, 
<a name="l09955"></a>09955     pack&lt;
<a name="l09956"></a>09956         base_iter_type_,
<a name="l09957"></a>09957         type0_,
<a name="l09958"></a>09958         type1_
<a name="l09959"></a>09959     &gt;,
<a name="l09960"></a>09960     input_size_type_&gt;
<a name="l09961"></a>09961 {
<a name="l09962"></a>09962 <span class="keyword">public</span>:
<a name="l09963"></a>09963     <span class="keyword">typedef</span> plane&lt;0&gt; transform_type;
<a name="l09964"></a>09964 
<a name="l09965"></a>09965     <span class="keyword">typedef</span> pack&lt;
<a name="l09966"></a>09966         base_iter_type_,
<a name="l09967"></a>09967         type0_,
<a name="l09968"></a>09968         type1_
<a name="l09969"></a>09969         &gt; input_iterator_type;
<a name="l09970"></a>09970 
<a name="l09971"></a>09971     <span class="keyword">typedef</span> input_size_type_ input_size_type;
<a name="l09972"></a>09972 
<a name="l09973"></a>09973     <span class="keyword">typedef</span> sub_pack&lt;
<a name="l09974"></a>09974         input_iterator_type,
<a name="l09975"></a>09975         <span class="keyword">true</span>,
<a name="l09976"></a>09976         <span class="keyword">false</span>,
<a name="l09977"></a>09977         <span class="keyword">true</span>
<a name="l09978"></a>09978         &gt; sub_pack_type;
<a name="l09979"></a>09979 
<a name="l09980"></a>09980     <span class="keyword">typedef</span> <span class="keyword">typename</span> sub_pack_type::type <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>;
<a name="l09981"></a>09981 
<a name="l09982"></a>09982     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l09983"></a>09983         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l09984"></a>09984         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l09985"></a>09985     {
<a name="l09986"></a>09986         <a class="code" href="group__array__tools.html#ga86cbd758c7c991ccb4aac651392c5e84">sub_pack_type::set</a>(res, org);
<a name="l09987"></a>09987     }
<a name="l09988"></a>09988 
<a name="l09989"></a>09989     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l09990"></a>09990         <span class="keyword">const</span> transform_type&amp; trans, 
<a name="l09991"></a>09991         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l09992"></a>09992         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l09993"></a>09993     {
<a name="l09994"></a>09994         <a class="code" href="group__array__tools.html#ga86cbd758c7c991ccb4aac651392c5e84">sub_pack_type::set</a>(res, org.i0+trans.index*org.i1, org.i1, org.i2);
<a name="l09995"></a>09995     }
<a name="l09996"></a>09996 
<a name="l09997"></a>09997     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l09998"></a>09998         <span class="keyword">const</span> transform_type&amp; trans, 
<a name="l09999"></a>09999         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l10000"></a>10000         <span class="keyword">const</span> input_size_type&amp;,
<a name="l10001"></a>10001         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l10002"></a>10002     {
<a name="l10003"></a>10003         <a class="code" href="group__array__tools.html#ga86cbd758c7c991ccb4aac651392c5e84">sub_pack_type::set</a>(res, org.i0+trans.index*org.i1, org.i1, org.i2);
<a name="l10004"></a>10004     }
<a name="l10005"></a>10005 };
<a name="l10006"></a>10006 
<a name="l10007"></a>10007 <span class="comment">/***********************************************************************************************************/</span>
<a name="l10008"></a>10008 <span class="keyword">template</span>&lt;
<a name="l10009"></a>10009     <span class="keyword">typename</span> base_iter_type_,
<a name="l10010"></a>10010     <span class="keyword">typename</span> type0_,
<a name="l10011"></a>10011     <span class="keyword">typename</span> type1_,
<a name="l10012"></a>10012     <span class="keyword">typename</span> type2_,
<a name="l10013"></a>10013     <span class="keyword">typename</span> input_size_type_&gt;
<a name="l10014"></a>10014 <span class="keyword">struct </span>iterator_transformer&lt;
<a name="l10015"></a>10015     plane&lt;0&gt;, 
<a name="l10016"></a>10016     pack&lt;
<a name="l10017"></a>10017         base_iter_type_,
<a name="l10018"></a>10018         type0_,
<a name="l10019"></a>10019         type1_,
<a name="l10020"></a>10020         type2_
<a name="l10021"></a>10021     &gt;,
<a name="l10022"></a>10022     input_size_type_&gt;
<a name="l10023"></a>10023 {
<a name="l10024"></a>10024 <span class="keyword">public</span>:
<a name="l10025"></a>10025     <span class="keyword">typedef</span> plane&lt;0&gt; transform_type;
<a name="l10026"></a>10026 
<a name="l10027"></a>10027     <span class="keyword">typedef</span> pack&lt;
<a name="l10028"></a>10028         base_iter_type_,
<a name="l10029"></a>10029         type0_,
<a name="l10030"></a>10030         type1_,
<a name="l10031"></a>10031         type2_
<a name="l10032"></a>10032         &gt; input_iterator_type;
<a name="l10033"></a>10033 
<a name="l10034"></a>10034     <span class="keyword">typedef</span> input_size_type_ input_size_type;
<a name="l10035"></a>10035 
<a name="l10036"></a>10036     <span class="keyword">typedef</span> sub_pack&lt;
<a name="l10037"></a>10037         input_iterator_type,
<a name="l10038"></a>10038         <span class="keyword">true</span>,
<a name="l10039"></a>10039         <span class="keyword">false</span>,
<a name="l10040"></a>10040         <span class="keyword">true</span>,
<a name="l10041"></a>10041         <span class="keyword">true</span>
<a name="l10042"></a>10042         &gt; sub_pack_type;
<a name="l10043"></a>10043 
<a name="l10044"></a>10044     <span class="keyword">typedef</span> <span class="keyword">typename</span> sub_pack_type::type <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>;
<a name="l10045"></a>10045 
<a name="l10046"></a>10046     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l10047"></a>10047         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l10048"></a>10048         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l10049"></a>10049     {
<a name="l10050"></a>10050         <a class="code" href="group__array__tools.html#ga86cbd758c7c991ccb4aac651392c5e84">sub_pack_type::set</a>(res, org);
<a name="l10051"></a>10051     }
<a name="l10052"></a>10052 
<a name="l10053"></a>10053     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l10054"></a>10054         <span class="keyword">const</span> transform_type&amp; trans, 
<a name="l10055"></a>10055         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l10056"></a>10056         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l10057"></a>10057     {
<a name="l10058"></a>10058         <a class="code" href="group__array__tools.html#ga86cbd758c7c991ccb4aac651392c5e84">sub_pack_type::set</a>(res, org.i0+trans.index*org.i1, org.i1, org.i2, org.i3);
<a name="l10059"></a>10059     }
<a name="l10060"></a>10060 
<a name="l10061"></a>10061     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l10062"></a>10062         <span class="keyword">const</span> transform_type&amp; trans, 
<a name="l10063"></a>10063         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l10064"></a>10064         <span class="keyword">const</span> input_size_type&amp;,
<a name="l10065"></a>10065         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l10066"></a>10066     {
<a name="l10067"></a>10067         <a class="code" href="group__array__tools.html#ga86cbd758c7c991ccb4aac651392c5e84">sub_pack_type::set</a>(res, org.i0+trans.index*org.i1, org.i1, org.i2, org.i3);
<a name="l10068"></a>10068     }
<a name="l10069"></a>10069 };
<a name="l10070"></a>10070 
<a name="l10071"></a>10071 <span class="comment">/***********************************************************************************************************/</span>
<a name="l10072"></a>10072 <span class="keyword">template</span>&lt;
<a name="l10073"></a>10073     <span class="keyword">typename</span> base_iter_type_,
<a name="l10074"></a>10074     <span class="keyword">typename</span> type0_,
<a name="l10075"></a>10075     <span class="keyword">typename</span> type1_,
<a name="l10076"></a>10076     <span class="keyword">typename</span> input_size_type_&gt;
<a name="l10077"></a>10077 <span class="keyword">struct </span>iterator_transformer&lt;
<a name="l10078"></a>10078     plane&lt;1&gt;, 
<a name="l10079"></a>10079     pack&lt;
<a name="l10080"></a>10080         base_iter_type_,
<a name="l10081"></a>10081         type0_,
<a name="l10082"></a>10082         type1_
<a name="l10083"></a>10083     &gt;,
<a name="l10084"></a>10084     input_size_type_&gt;
<a name="l10085"></a>10085 {
<a name="l10086"></a>10086 <span class="keyword">public</span>:
<a name="l10087"></a>10087     <span class="keyword">typedef</span> plane&lt;1&gt; transform_type;
<a name="l10088"></a>10088 
<a name="l10089"></a>10089     <span class="keyword">typedef</span> pack&lt;
<a name="l10090"></a>10090         base_iter_type_,
<a name="l10091"></a>10091         type0_,
<a name="l10092"></a>10092         type1_
<a name="l10093"></a>10093         &gt; input_iterator_type;
<a name="l10094"></a>10094 
<a name="l10095"></a>10095     <span class="keyword">typedef</span> input_size_type_ input_size_type;
<a name="l10096"></a>10096 
<a name="l10097"></a>10097     <span class="keyword">typedef</span> sub_pack&lt;
<a name="l10098"></a>10098         input_iterator_type,
<a name="l10099"></a>10099         <span class="keyword">true</span>,
<a name="l10100"></a>10100         <span class="keyword">true</span>,
<a name="l10101"></a>10101         <span class="keyword">false</span>
<a name="l10102"></a>10102         &gt; sub_pack_type;
<a name="l10103"></a>10103 
<a name="l10104"></a>10104     <span class="keyword">typedef</span> <span class="keyword">typename</span> sub_pack_type::type <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>;
<a name="l10105"></a>10105 
<a name="l10106"></a>10106     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l10107"></a>10107         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l10108"></a>10108         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l10109"></a>10109     {
<a name="l10110"></a>10110         <a class="code" href="group__array__tools.html#ga86cbd758c7c991ccb4aac651392c5e84">sub_pack_type::set</a>(res, org);
<a name="l10111"></a>10111     }
<a name="l10112"></a>10112 
<a name="l10113"></a>10113     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l10114"></a>10114         <span class="keyword">const</span> transform_type&amp; trans, 
<a name="l10115"></a>10115         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l10116"></a>10116         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l10117"></a>10117     {
<a name="l10118"></a>10118         <a class="code" href="group__array__tools.html#ga86cbd758c7c991ccb4aac651392c5e84">sub_pack_type::set</a>(res, org.i0+trans.index*org.i2, org.i1, org.i2);
<a name="l10119"></a>10119     }
<a name="l10120"></a>10120 
<a name="l10121"></a>10121     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l10122"></a>10122         <span class="keyword">const</span> transform_type&amp; trans, 
<a name="l10123"></a>10123         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l10124"></a>10124         <span class="keyword">const</span> input_size_type&amp;,
<a name="l10125"></a>10125         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l10126"></a>10126     {
<a name="l10127"></a>10127         <a class="code" href="group__array__tools.html#ga86cbd758c7c991ccb4aac651392c5e84">sub_pack_type::set</a>(res, org.i0+trans.index*org.i2, org.i1, org.i2);
<a name="l10128"></a>10128     }
<a name="l10129"></a>10129 };
<a name="l10130"></a>10130 
<a name="l10131"></a>10131 <span class="comment">/***********************************************************************************************************/</span>
<a name="l10132"></a>10132 <span class="keyword">template</span>&lt;
<a name="l10133"></a>10133     <span class="keyword">typename</span> base_iter_type_,
<a name="l10134"></a>10134     <span class="keyword">typename</span> type0_,
<a name="l10135"></a>10135     <span class="keyword">typename</span> type1_,
<a name="l10136"></a>10136     <span class="keyword">typename</span> type2_,
<a name="l10137"></a>10137     <span class="keyword">typename</span> input_size_type_&gt;
<a name="l10138"></a>10138 <span class="keyword">struct </span>iterator_transformer&lt;
<a name="l10139"></a>10139     plane&lt;1&gt;, 
<a name="l10140"></a>10140     pack&lt;
<a name="l10141"></a>10141         base_iter_type_,
<a name="l10142"></a>10142         type0_,
<a name="l10143"></a>10143         type1_,
<a name="l10144"></a>10144         type2_
<a name="l10145"></a>10145     &gt;,
<a name="l10146"></a>10146     input_size_type_&gt;
<a name="l10147"></a>10147 {
<a name="l10148"></a>10148 <span class="keyword">public</span>:
<a name="l10149"></a>10149     <span class="keyword">typedef</span> plane&lt;1&gt; transform_type;
<a name="l10150"></a>10150 
<a name="l10151"></a>10151     <span class="keyword">typedef</span> pack&lt;
<a name="l10152"></a>10152         base_iter_type_,
<a name="l10153"></a>10153         type0_,
<a name="l10154"></a>10154         type1_,
<a name="l10155"></a>10155         type2_
<a name="l10156"></a>10156         &gt; input_iterator_type;
<a name="l10157"></a>10157 
<a name="l10158"></a>10158     <span class="keyword">typedef</span> input_size_type_ input_size_type;
<a name="l10159"></a>10159 
<a name="l10160"></a>10160     <span class="keyword">typedef</span> sub_pack&lt;
<a name="l10161"></a>10161         input_iterator_type,
<a name="l10162"></a>10162         <span class="keyword">true</span>,
<a name="l10163"></a>10163         <span class="keyword">true</span>,
<a name="l10164"></a>10164         <span class="keyword">false</span>,
<a name="l10165"></a>10165         <span class="keyword">true</span>
<a name="l10166"></a>10166         &gt; sub_pack_type;
<a name="l10167"></a>10167 
<a name="l10168"></a>10168     <span class="keyword">typedef</span> <span class="keyword">typename</span> sub_pack_type::type <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>;
<a name="l10169"></a>10169 
<a name="l10170"></a>10170     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l10171"></a>10171         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l10172"></a>10172         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l10173"></a>10173     {
<a name="l10174"></a>10174         <a class="code" href="group__array__tools.html#ga86cbd758c7c991ccb4aac651392c5e84">sub_pack_type::set</a>(res, org);
<a name="l10175"></a>10175     }
<a name="l10176"></a>10176 
<a name="l10177"></a>10177     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l10178"></a>10178         <span class="keyword">const</span> transform_type&amp; trans, 
<a name="l10179"></a>10179         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l10180"></a>10180         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l10181"></a>10181     {
<a name="l10182"></a>10182         <a class="code" href="group__array__tools.html#ga86cbd758c7c991ccb4aac651392c5e84">sub_pack_type::set</a>(res, org.i0+trans.index*org.i2, org.i1, org.i2, org.i3);
<a name="l10183"></a>10183     }
<a name="l10184"></a>10184 
<a name="l10185"></a>10185     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l10186"></a>10186         <span class="keyword">const</span> transform_type&amp; trans, 
<a name="l10187"></a>10187         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l10188"></a>10188         <span class="keyword">const</span> input_size_type&amp;,
<a name="l10189"></a>10189         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l10190"></a>10190     {
<a name="l10191"></a>10191         <a class="code" href="group__array__tools.html#ga86cbd758c7c991ccb4aac651392c5e84">sub_pack_type::set</a>(res, org.i0+trans.index*org.i2, org.i1, org.i2, org.i3);
<a name="l10192"></a>10192     }
<a name="l10193"></a>10193 };
<a name="l10194"></a>10194 
<a name="l10195"></a>10195 <span class="comment">/***********************************************************************************************************/</span>
<a name="l10196"></a>10196 <span class="keyword">template</span>&lt;
<a name="l10197"></a>10197     <span class="keyword">typename</span> base_iter_type_,
<a name="l10198"></a>10198     <span class="keyword">typename</span> type0_,
<a name="l10199"></a>10199     <span class="keyword">typename</span> type1_,
<a name="l10200"></a>10200     <span class="keyword">typename</span> type2_,
<a name="l10201"></a>10201     <span class="keyword">typename</span> input_size_type_&gt;
<a name="l10202"></a>10202 <span class="keyword">struct </span>iterator_transformer&lt;
<a name="l10203"></a>10203     plane&lt;2&gt;, 
<a name="l10204"></a>10204     pack&lt;
<a name="l10205"></a>10205         base_iter_type_,
<a name="l10206"></a>10206         type0_,
<a name="l10207"></a>10207         type1_,
<a name="l10208"></a>10208         type2_
<a name="l10209"></a>10209     &gt;,
<a name="l10210"></a>10210     input_size_type_&gt;
<a name="l10211"></a>10211 {
<a name="l10212"></a>10212 <span class="keyword">public</span>:
<a name="l10213"></a>10213     <span class="keyword">typedef</span> plane&lt;2&gt; transform_type;
<a name="l10214"></a>10214 
<a name="l10215"></a>10215     <span class="keyword">typedef</span> pack&lt;
<a name="l10216"></a>10216         base_iter_type_,
<a name="l10217"></a>10217         type0_,
<a name="l10218"></a>10218         type1_,
<a name="l10219"></a>10219         type2_
<a name="l10220"></a>10220         &gt; input_iterator_type;
<a name="l10221"></a>10221 
<a name="l10222"></a>10222     <span class="keyword">typedef</span> input_size_type_ input_size_type;
<a name="l10223"></a>10223 
<a name="l10224"></a>10224     <span class="keyword">typedef</span> sub_pack&lt;
<a name="l10225"></a>10225         input_iterator_type,
<a name="l10226"></a>10226         <span class="keyword">true</span>,
<a name="l10227"></a>10227         <span class="keyword">true</span>,
<a name="l10228"></a>10228         <span class="keyword">true</span>,
<a name="l10229"></a>10229         <span class="keyword">false</span>
<a name="l10230"></a>10230         &gt; sub_pack_type;
<a name="l10231"></a>10231 
<a name="l10232"></a>10232     <span class="keyword">typedef</span> <span class="keyword">typename</span> sub_pack_type::type <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>;
<a name="l10233"></a>10233 
<a name="l10234"></a>10234     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l10235"></a>10235         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l10236"></a>10236         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l10237"></a>10237     {
<a name="l10238"></a>10238         <a class="code" href="group__array__tools.html#ga86cbd758c7c991ccb4aac651392c5e84">sub_pack_type::set</a>(res, org);
<a name="l10239"></a>10239     }
<a name="l10240"></a>10240 
<a name="l10241"></a>10241     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l10242"></a>10242         <span class="keyword">const</span> transform_type&amp; trans, 
<a name="l10243"></a>10243         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l10244"></a>10244         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l10245"></a>10245     {
<a name="l10246"></a>10246         <a class="code" href="group__array__tools.html#ga86cbd758c7c991ccb4aac651392c5e84">sub_pack_type::set</a>(res, org.i0+trans.index*org.i3, org.i1, org.i2, org.i3);
<a name="l10247"></a>10247     }
<a name="l10248"></a>10248 
<a name="l10249"></a>10249     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l10250"></a>10250         <span class="keyword">const</span> transform_type&amp; trans, 
<a name="l10251"></a>10251         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l10252"></a>10252         <span class="keyword">const</span> input_size_type&amp;,
<a name="l10253"></a>10253         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l10254"></a>10254     {
<a name="l10255"></a>10255         <a class="code" href="group__array__tools.html#ga86cbd758c7c991ccb4aac651392c5e84">sub_pack_type::set</a>(res, org.i0+trans.index*org.i3, org.i1, org.i2, org.i3);
<a name="l10256"></a>10256     }
<a name="l10257"></a>10257 };
<a name="l10258"></a>10258 
<a name="l10259"></a>10259 <span class="comment">/***********************************************************************************************************/</span>
<a name="l10260"></a>10260 
<a name="l10261"></a>10261 <span class="comment">/***********************************************************************************************************/</span>
<a name="l10262"></a>10262 <span class="comment">/* diagonal ************************************************************************************************/</span>
<a name="l10263"></a>10263 <span class="comment">/***********************************************************************************************************/</span>
<a name="l10264"></a>10264 
<a name="l10289"></a><a class="code" href="classlite_1_1diagonal.html">10289</a> <span class="keyword">class </span><a class="code" href="classlite_1_1diagonal.html" title="This transform returns a 1-D reference array that corresponds to the main diagonal...">diagonal</a>
<a name="l10290"></a>10290 {
<a name="l10291"></a>10291 <span class="keyword">public</span>:
<a name="l10292"></a>10292     LITE_INLINE <a class="code" href="classlite_1_1diagonal.html" title="This transform returns a 1-D reference array that corresponds to the main diagonal...">diagonal</a>() {}
<a name="l10293"></a>10293 
<a name="l10294"></a>10294     LITE_INLINE <a class="code" href="classlite_1_1diagonal.html" title="This transform returns a 1-D reference array that corresponds to the main diagonal...">diagonal</a>(<span class="keyword">const</span> <a class="code" href="classlite_1_1diagonal.html" title="This transform returns a 1-D reference array that corresponds to the main diagonal...">diagonal</a>&amp;) {}
<a name="l10295"></a>10295 
<a name="l10296"></a>10296     LITE_INLINE <a class="code" href="classlite_1_1diagonal.html" title="This transform returns a 1-D reference array that corresponds to the main diagonal...">diagonal</a>&amp; operator=(<span class="keyword">const</span> <a class="code" href="classlite_1_1diagonal.html" title="This transform returns a 1-D reference array that corresponds to the main diagonal...">diagonal</a>&amp;) { <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l10297"></a>10297 };
<a name="l10298"></a>10298 
<a name="l10299"></a>10299 <span class="comment">/***********************************************************************************************************/</span>
<a name="l10300"></a>10300 <span class="comment">/* size_transformer, diagonal ******************************************************************************/</span>
<a name="l10301"></a>10301 <span class="comment">/***********************************************************************************************************/</span>
<a name="l10302"></a>10302 
<a name="l10303"></a>10303 <span class="keyword">template</span>&lt;&gt;
<a name="l10304"></a>10304 <span class="keyword">struct </span><a class="code" href="structlite_1_1size__transformer.html" title="This can be used to apply a transform object of type transform_type_ to a size object...">size_transformer</a>&lt;<a class="code" href="classlite_1_1diagonal.html" title="This transform returns a 1-D reference array that corresponds to the main diagonal...">diagonal</a>, <a class="code" href="classlite_1_1pack.html" title="This is a general tuple class that can pack together elements of different types...">pack</a>&lt;&gt; &gt;
<a name="l10305"></a>10305 {
<a name="l10306"></a>10306 <span class="keyword">public</span>:
<a name="l10307"></a>10307     <span class="keyword">typedef</span> <a class="code" href="classlite_1_1diagonal.html" title="This transform returns a 1-D reference array that corresponds to the main diagonal...">diagonal</a> transform_type;
<a name="l10308"></a>10308     <span class="keyword">typedef</span> <a class="code" href="classlite_1_1pack.html" title="This is a general tuple class that can pack together elements of different types...">pack&lt;&gt;</a> input_size_type;
<a name="l10309"></a>10309     <span class="keyword">typedef</span> <a class="code" href="classlite_1_1pack.html" title="This is a general tuple class that can pack together elements of different types...">pack&lt;&gt;</a> <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>;
<a name="l10310"></a>10310 
<a name="l10311"></a>10311     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1size__transformer.html#a5a5eced0d3d9e624fb1513e036f392bf" title="Apply the transform to the size object org and store the result in res.">transform</a>(<span class="keyword">const</span> input_size_type&amp;, <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>&amp;)
<a name="l10312"></a>10312     {}
<a name="l10313"></a>10313 
<a name="l10314"></a>10314     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1size__transformer.html#a5a5eced0d3d9e624fb1513e036f392bf" title="Apply the transform to the size object org and store the result in res.">transform</a>(<span class="keyword">const</span> transform_type&amp;, <span class="keyword">const</span> input_size_type&amp;, <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>&amp;)
<a name="l10315"></a>10315     {}
<a name="l10316"></a>10316 };
<a name="l10317"></a>10317 
<a name="l10318"></a>10318 <span class="comment">/***********************************************************************************************************/</span>
<a name="l10319"></a>10319 
<a name="l10320"></a>10320 <span class="keyword">template</span>&lt;
<a name="l10321"></a>10321     <span class="keyword">typename</span> type0_
<a name="l10322"></a>10322     &gt;
<a name="l10323"></a>10323 <span class="keyword">struct </span>size_transformer&lt;
<a name="l10324"></a>10324     diagonal, 
<a name="l10325"></a>10325     pack&lt;
<a name="l10326"></a>10326         type0_
<a name="l10327"></a>10327     &gt; &gt;
<a name="l10328"></a>10328 {
<a name="l10329"></a>10329 <span class="keyword">private</span>:
<a name="l10330"></a>10330     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n0_ = 
<a name="l10331"></a>10331         detail::type_if&lt;detail::same_type&lt;type0_, int&gt;::result, constant&lt;int, 0&gt;, type0_&gt;::type::value;
<a name="l10332"></a>10332 
<a name="l10333"></a>10333     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> min_upto_0_ = n0_;
<a name="l10334"></a>10334 
<a name="l10335"></a>10335     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> min_dim_size_ = min_upto_0_;
<a name="l10336"></a>10336 
<a name="l10337"></a>10337     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> has_var_size_ =
<a name="l10338"></a>10338         detail::same_type&lt;type0_, int&gt;::result
<a name="l10339"></a>10339         ;
<a name="l10340"></a>10340 
<a name="l10341"></a>10341 <span class="keyword">public</span>:
<a name="l10342"></a>10342     <span class="keyword">typedef</span> diagonal transform_type;
<a name="l10343"></a>10343 
<a name="l10344"></a>10344     <span class="keyword">typedef</span> pack&lt;
<a name="l10345"></a>10345         type0_
<a name="l10346"></a>10346         &gt; input_size_type;
<a name="l10347"></a>10347 
<a name="l10348"></a>10348 
<a name="l10349"></a>10349     <span class="keyword">typedef</span> pack&lt;
<a name="l10350"></a>10350         <span class="keyword">typename</span> detail::type_if&lt;has_var_size_, int, constant&lt;int, min_dim_size_&gt; &gt;::type
<a name="l10351"></a>10351         &gt; <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>;
<a name="l10352"></a>10352 
<a name="l10353"></a>10353     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1size__transformer.html#a5a5eced0d3d9e624fb1513e036f392bf" title="Apply the transform to the size object org and store the result in res.">transform</a>(<span class="keyword">const</span> input_size_type&amp; org, <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>&amp; res)
<a name="l10354"></a>10354     {
<a name="l10355"></a>10355         <span class="keyword">const</span> <span class="keywordtype">int</span> min_upto_0 = res.i0;
<a name="l10356"></a>10356 
<a name="l10357"></a>10357         res.set(min_upto_0);
<a name="l10358"></a>10358         LITE_ARRAY_USE(org);
<a name="l10359"></a>10359     }
<a name="l10360"></a>10360 
<a name="l10361"></a>10361     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1size__transformer.html#a5a5eced0d3d9e624fb1513e036f392bf" title="Apply the transform to the size object org and store the result in res.">transform</a>(<span class="keyword">const</span> transform_type&amp;, <span class="keyword">const</span> input_size_type&amp; org, <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>&amp; res)
<a name="l10362"></a>10362     {
<a name="l10363"></a>10363         <span class="keyword">const</span> <span class="keywordtype">int</span> min_upto_0 = res.i0;
<a name="l10364"></a>10364 
<a name="l10365"></a>10365         res.set(min_upto_0);
<a name="l10366"></a>10366         LITE_ARRAY_USE(org);
<a name="l10367"></a>10367     }
<a name="l10368"></a>10368 };
<a name="l10369"></a>10369 
<a name="l10370"></a>10370 <span class="comment">/***********************************************************************************************************/</span>
<a name="l10371"></a>10371 <span class="keyword">template</span>&lt;
<a name="l10372"></a>10372     <span class="keyword">typename</span> type0_,
<a name="l10373"></a>10373     <span class="keyword">typename</span> type1_
<a name="l10374"></a>10374     &gt;
<a name="l10375"></a>10375 <span class="keyword">struct </span>size_transformer&lt;
<a name="l10376"></a>10376     diagonal, 
<a name="l10377"></a>10377     pack&lt;
<a name="l10378"></a>10378         type0_,
<a name="l10379"></a>10379         type1_
<a name="l10380"></a>10380     &gt; &gt;
<a name="l10381"></a>10381 {
<a name="l10382"></a>10382 <span class="keyword">private</span>:
<a name="l10383"></a>10383     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n0_ = 
<a name="l10384"></a>10384         detail::type_if&lt;detail::same_type&lt;type0_, int&gt;::result, constant&lt;int, 0&gt;, type0_&gt;::type::value;
<a name="l10385"></a>10385     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n1_ = 
<a name="l10386"></a>10386         detail::type_if&lt;detail::same_type&lt;type1_, int&gt;::result, constant&lt;int, 0&gt;, type1_&gt;::type::value;
<a name="l10387"></a>10387 
<a name="l10388"></a>10388     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> min_upto_0_ = n0_;
<a name="l10389"></a>10389     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> min_upto_1_ = min_upto_0_ &lt; n1_ ? min_upto_0_ : n1_;
<a name="l10390"></a>10390 
<a name="l10391"></a>10391     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> min_dim_size_ = min_upto_1_;
<a name="l10392"></a>10392 
<a name="l10393"></a>10393     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> has_var_size_ =
<a name="l10394"></a>10394         detail::same_type&lt;type0_, int&gt;::result||
<a name="l10395"></a>10395         detail::same_type&lt;type1_, int&gt;::result
<a name="l10396"></a>10396         ;
<a name="l10397"></a>10397 
<a name="l10398"></a>10398 <span class="keyword">public</span>:
<a name="l10399"></a>10399     <span class="keyword">typedef</span> diagonal transform_type;
<a name="l10400"></a>10400 
<a name="l10401"></a>10401     <span class="keyword">typedef</span> pack&lt;
<a name="l10402"></a>10402         type0_,
<a name="l10403"></a>10403         type1_
<a name="l10404"></a>10404         &gt; input_size_type;
<a name="l10405"></a>10405 
<a name="l10406"></a>10406 
<a name="l10407"></a>10407     <span class="keyword">typedef</span> pack&lt;
<a name="l10408"></a>10408         <span class="keyword">typename</span> detail::type_if&lt;has_var_size_, int, constant&lt;int, min_dim_size_&gt; &gt;::type
<a name="l10409"></a>10409         &gt; <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>;
<a name="l10410"></a>10410 
<a name="l10411"></a>10411     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1size__transformer.html#a5a5eced0d3d9e624fb1513e036f392bf" title="Apply the transform to the size object org and store the result in res.">transform</a>(<span class="keyword">const</span> input_size_type&amp; org, <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>&amp; res)
<a name="l10412"></a>10412     {
<a name="l10413"></a>10413         <span class="keyword">const</span> <span class="keywordtype">int</span> min_upto_0 = res.i0;
<a name="l10414"></a>10414         <span class="keyword">const</span> <span class="keywordtype">int</span> min_upto_1 = min_upto_0 &lt; res.i1 ? min_upto_0 : res.i1;
<a name="l10415"></a>10415 
<a name="l10416"></a>10416         res.set(min_upto_1);
<a name="l10417"></a>10417         LITE_ARRAY_USE(org);
<a name="l10418"></a>10418     }
<a name="l10419"></a>10419 
<a name="l10420"></a>10420     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1size__transformer.html#a5a5eced0d3d9e624fb1513e036f392bf" title="Apply the transform to the size object org and store the result in res.">transform</a>(<span class="keyword">const</span> transform_type&amp;, <span class="keyword">const</span> input_size_type&amp; org, <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>&amp; res)
<a name="l10421"></a>10421     {
<a name="l10422"></a>10422         <span class="keyword">const</span> <span class="keywordtype">int</span> min_upto_0 = res.i0;
<a name="l10423"></a>10423         <span class="keyword">const</span> <span class="keywordtype">int</span> min_upto_1 = min_upto_0 &lt; org.i1 ? min_upto_0 : org.i1;
<a name="l10424"></a>10424 
<a name="l10425"></a>10425         res.set(min_upto_1);
<a name="l10426"></a>10426         LITE_ARRAY_USE(org);
<a name="l10427"></a>10427     }
<a name="l10428"></a>10428 };
<a name="l10429"></a>10429 
<a name="l10430"></a>10430 <span class="comment">/***********************************************************************************************************/</span>
<a name="l10431"></a>10431 <span class="keyword">template</span>&lt;
<a name="l10432"></a>10432     <span class="keyword">typename</span> type0_,
<a name="l10433"></a>10433     <span class="keyword">typename</span> type1_,
<a name="l10434"></a>10434     <span class="keyword">typename</span> type2_
<a name="l10435"></a>10435     &gt;
<a name="l10436"></a>10436 <span class="keyword">struct </span>size_transformer&lt;
<a name="l10437"></a>10437     diagonal, 
<a name="l10438"></a>10438     pack&lt;
<a name="l10439"></a>10439         type0_,
<a name="l10440"></a>10440         type1_,
<a name="l10441"></a>10441         type2_
<a name="l10442"></a>10442     &gt; &gt;
<a name="l10443"></a>10443 {
<a name="l10444"></a>10444 <span class="keyword">private</span>:
<a name="l10445"></a>10445     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n0_ = 
<a name="l10446"></a>10446         detail::type_if&lt;detail::same_type&lt;type0_, int&gt;::result, constant&lt;int, 0&gt;, type0_&gt;::type::value;
<a name="l10447"></a>10447     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n1_ = 
<a name="l10448"></a>10448         detail::type_if&lt;detail::same_type&lt;type1_, int&gt;::result, constant&lt;int, 0&gt;, type1_&gt;::type::value;
<a name="l10449"></a>10449     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n2_ = 
<a name="l10450"></a>10450         detail::type_if&lt;detail::same_type&lt;type2_, int&gt;::result, constant&lt;int, 0&gt;, type2_&gt;::type::value;
<a name="l10451"></a>10451 
<a name="l10452"></a>10452     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> min_upto_0_ = n0_;
<a name="l10453"></a>10453     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> min_upto_1_ = min_upto_0_ &lt; n1_ ? min_upto_0_ : n1_;
<a name="l10454"></a>10454     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> min_upto_2_ = min_upto_1_ &lt; n2_ ? min_upto_1_ : n2_;
<a name="l10455"></a>10455 
<a name="l10456"></a>10456     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> min_dim_size_ = min_upto_2_;
<a name="l10457"></a>10457 
<a name="l10458"></a>10458     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> has_var_size_ =
<a name="l10459"></a>10459         detail::same_type&lt;type0_, int&gt;::result||
<a name="l10460"></a>10460         detail::same_type&lt;type1_, int&gt;::result||
<a name="l10461"></a>10461         detail::same_type&lt;type2_, int&gt;::result
<a name="l10462"></a>10462         ;
<a name="l10463"></a>10463 
<a name="l10464"></a>10464 <span class="keyword">public</span>:
<a name="l10465"></a>10465     <span class="keyword">typedef</span> diagonal transform_type;
<a name="l10466"></a>10466 
<a name="l10467"></a>10467     <span class="keyword">typedef</span> pack&lt;
<a name="l10468"></a>10468         type0_,
<a name="l10469"></a>10469         type1_,
<a name="l10470"></a>10470         type2_
<a name="l10471"></a>10471         &gt; input_size_type;
<a name="l10472"></a>10472 
<a name="l10473"></a>10473 
<a name="l10474"></a>10474     <span class="keyword">typedef</span> pack&lt;
<a name="l10475"></a>10475         <span class="keyword">typename</span> detail::type_if&lt;has_var_size_, int, constant&lt;int, min_dim_size_&gt; &gt;::type
<a name="l10476"></a>10476         &gt; <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>;
<a name="l10477"></a>10477 
<a name="l10478"></a>10478     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1size__transformer.html#a5a5eced0d3d9e624fb1513e036f392bf" title="Apply the transform to the size object org and store the result in res.">transform</a>(<span class="keyword">const</span> input_size_type&amp; org, <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>&amp; res)
<a name="l10479"></a>10479     {
<a name="l10480"></a>10480         <span class="keyword">const</span> <span class="keywordtype">int</span> min_upto_0 = res.i0;
<a name="l10481"></a>10481         <span class="keyword">const</span> <span class="keywordtype">int</span> min_upto_1 = min_upto_0 &lt; res.i1 ? min_upto_0 : res.i1;
<a name="l10482"></a>10482         <span class="keyword">const</span> <span class="keywordtype">int</span> min_upto_2 = min_upto_1 &lt; res.i2 ? min_upto_1 : res.i2;
<a name="l10483"></a>10483 
<a name="l10484"></a>10484         res.set(min_upto_2);
<a name="l10485"></a>10485         LITE_ARRAY_USE(org);
<a name="l10486"></a>10486     }
<a name="l10487"></a>10487 
<a name="l10488"></a>10488     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1size__transformer.html#a5a5eced0d3d9e624fb1513e036f392bf" title="Apply the transform to the size object org and store the result in res.">transform</a>(<span class="keyword">const</span> transform_type&amp;, <span class="keyword">const</span> input_size_type&amp; org, <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>&amp; res)
<a name="l10489"></a>10489     {
<a name="l10490"></a>10490         <span class="keyword">const</span> <span class="keywordtype">int</span> min_upto_0 = res.i0;
<a name="l10491"></a>10491         <span class="keyword">const</span> <span class="keywordtype">int</span> min_upto_1 = min_upto_0 &lt; org.i1 ? min_upto_0 : org.i1;
<a name="l10492"></a>10492         <span class="keyword">const</span> <span class="keywordtype">int</span> min_upto_2 = min_upto_1 &lt; org.i2 ? min_upto_1 : org.i2;
<a name="l10493"></a>10493 
<a name="l10494"></a>10494         res.set(min_upto_2);
<a name="l10495"></a>10495         LITE_ARRAY_USE(org);
<a name="l10496"></a>10496     }
<a name="l10497"></a>10497 };
<a name="l10498"></a>10498 
<a name="l10499"></a>10499 <span class="comment">/***********************************************************************************************************/</span>
<a name="l10500"></a>10500 
<a name="l10501"></a>10501 <span class="comment">/***********************************************************************************************************/</span>
<a name="l10502"></a>10502 <span class="comment">/* iterator_transformer, diagonal **************************************************************************/</span>
<a name="l10503"></a>10503 <span class="comment">/***********************************************************************************************************/</span>
<a name="l10504"></a>10504 
<a name="l10505"></a>10505 
<a name="l10506"></a>10506 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> base_iter_type_, <span class="keyword">typename</span> input_<span class="keywordtype">size_t</span>ype_&gt;
<a name="l10507"></a>10507 <span class="keyword">struct </span>iterator_transformer&lt;diagonal, pack&lt;base_iter_type_&gt;, input_size_type_&gt;
<a name="l10508"></a>10508 {
<a name="l10509"></a>10509 <span class="keyword">public</span>:
<a name="l10510"></a>10510     <span class="keyword">typedef</span> pack&lt;base_iter_type_&gt; input_iterator_type;
<a name="l10511"></a>10511 
<a name="l10512"></a>10512     <span class="keyword">typedef</span> input_size_type_ input_size_type;
<a name="l10513"></a>10513 
<a name="l10514"></a>10514     <span class="keyword">typedef</span> pack&lt;base_iter_type_&gt; <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>;
<a name="l10515"></a>10515 
<a name="l10516"></a>10516     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l10517"></a>10517         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l10518"></a>10518         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l10519"></a>10519     {
<a name="l10520"></a>10520         res.i0 = org.i0;
<a name="l10521"></a>10521     }
<a name="l10522"></a>10522 
<a name="l10523"></a>10523     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l10524"></a>10524         <span class="keyword">const</span> diagonal&amp;, 
<a name="l10525"></a>10525         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l10526"></a>10526         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l10527"></a>10527     {
<a name="l10528"></a>10528         res.i0 = org.i0;
<a name="l10529"></a>10529     }
<a name="l10530"></a>10530 
<a name="l10531"></a>10531     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l10532"></a>10532         <span class="keyword">const</span> diagonal&amp;, 
<a name="l10533"></a>10533         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l10534"></a>10534         <span class="keyword">const</span> input_size_type&amp;,
<a name="l10535"></a>10535         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l10536"></a>10536     {
<a name="l10537"></a>10537         res.i0 = org.i0;
<a name="l10538"></a>10538     }
<a name="l10539"></a>10539 };
<a name="l10540"></a>10540 
<a name="l10541"></a>10541 <span class="comment">/***********************************************************************************************************/</span>
<a name="l10542"></a>10542 
<a name="l10543"></a>10543 <span class="keyword">template</span>&lt;
<a name="l10544"></a>10544     <span class="keyword">typename</span> base_iter_type_,
<a name="l10545"></a>10545     <span class="keyword">typename</span> type0_,
<a name="l10546"></a>10546     <span class="keyword">typename</span> input_size_type_&gt;
<a name="l10547"></a>10547 <span class="keyword">struct </span>iterator_transformer&lt;
<a name="l10548"></a>10548     diagonal, 
<a name="l10549"></a>10549     pack&lt;
<a name="l10550"></a>10550         base_iter_type_,
<a name="l10551"></a>10551         type0_
<a name="l10552"></a>10552     &gt;,
<a name="l10553"></a>10553     input_size_type_&gt;
<a name="l10554"></a>10554 {
<a name="l10555"></a>10555 <span class="keyword">private</span>:
<a name="l10556"></a>10556     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n0_ = 
<a name="l10557"></a>10557         detail::type_if&lt;detail::same_type&lt;type0_, int&gt;::result, constant&lt;int, 0&gt;, type0_&gt;::type::value;
<a name="l10558"></a>10558 
<a name="l10559"></a>10559     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> stride_ = n0_;
<a name="l10560"></a>10560 
<a name="l10561"></a>10561     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> has_var_stride_ =
<a name="l10562"></a>10562         detail::same_type&lt;type0_, int&gt;::result
<a name="l10563"></a>10563         ;
<a name="l10564"></a>10564 
<a name="l10565"></a>10565 <span class="keyword">public</span>:
<a name="l10566"></a>10566     <span class="keyword">typedef</span> diagonal transform_type;
<a name="l10567"></a>10567     <span class="keyword">typedef</span> pack&lt;
<a name="l10568"></a>10568         base_iter_type_,
<a name="l10569"></a>10569         type0_
<a name="l10570"></a>10570         &gt; input_iterator_type;
<a name="l10571"></a>10571 
<a name="l10572"></a>10572     <span class="keyword">typedef</span> input_size_type_ input_size_type;
<a name="l10573"></a>10573 
<a name="l10574"></a>10574     <span class="keyword">typedef</span> pack&lt;
<a name="l10575"></a>10575         base_iter_type_, 
<a name="l10576"></a>10576         <span class="keyword">typename</span> detail::type_if&lt;has_var_stride_, int, constant&lt;int, stride_&gt; &gt;::type&gt; 
<a name="l10577"></a>10577         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>;
<a name="l10578"></a>10578 
<a name="l10579"></a>10579     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l10580"></a>10580         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l10581"></a>10581         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l10582"></a>10582     {
<a name="l10583"></a>10583         res.set(org.i0, org.i1);
<a name="l10584"></a>10584     }
<a name="l10585"></a>10585 
<a name="l10586"></a>10586         <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l10587"></a>10587         <span class="keyword">const</span> transform_type&amp;, 
<a name="l10588"></a>10588         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l10589"></a>10589         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l10590"></a>10590     {
<a name="l10591"></a>10591         res.set(org.i0, org.i1);
<a name="l10592"></a>10592     }
<a name="l10593"></a>10593 
<a name="l10594"></a>10594     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l10595"></a>10595         <span class="keyword">const</span> transform_type&amp;, 
<a name="l10596"></a>10596         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l10597"></a>10597         <span class="keyword">const</span> input_size_type&amp;,
<a name="l10598"></a>10598         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l10599"></a>10599     {
<a name="l10600"></a>10600         res.set(org.i0, org.i1);
<a name="l10601"></a>10601     }
<a name="l10602"></a>10602 };
<a name="l10603"></a>10603 
<a name="l10604"></a>10604 <span class="comment">/***********************************************************************************************************/</span>
<a name="l10605"></a>10605 <span class="keyword">template</span>&lt;
<a name="l10606"></a>10606     <span class="keyword">typename</span> base_iter_type_,
<a name="l10607"></a>10607     <span class="keyword">typename</span> type0_,
<a name="l10608"></a>10608     <span class="keyword">typename</span> type1_,
<a name="l10609"></a>10609     <span class="keyword">typename</span> input_size_type_&gt;
<a name="l10610"></a>10610 <span class="keyword">struct </span>iterator_transformer&lt;
<a name="l10611"></a>10611     diagonal, 
<a name="l10612"></a>10612     pack&lt;
<a name="l10613"></a>10613         base_iter_type_,
<a name="l10614"></a>10614         type0_,
<a name="l10615"></a>10615         type1_
<a name="l10616"></a>10616     &gt;,
<a name="l10617"></a>10617     input_size_type_&gt;
<a name="l10618"></a>10618 {
<a name="l10619"></a>10619 <span class="keyword">private</span>:
<a name="l10620"></a>10620     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n0_ = 
<a name="l10621"></a>10621         detail::type_if&lt;detail::same_type&lt;type0_, int&gt;::result, constant&lt;int, 0&gt;, type0_&gt;::type::value;
<a name="l10622"></a>10622     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n1_ = 
<a name="l10623"></a>10623         detail::type_if&lt;detail::same_type&lt;type1_, int&gt;::result, constant&lt;int, 0&gt;, type1_&gt;::type::value;
<a name="l10624"></a>10624 
<a name="l10625"></a>10625     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> stride_ = n0_ + n1_;
<a name="l10626"></a>10626 
<a name="l10627"></a>10627     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> has_var_stride_ =
<a name="l10628"></a>10628         detail::same_type&lt;type0_, int&gt;::result||
<a name="l10629"></a>10629         detail::same_type&lt;type1_, int&gt;::result
<a name="l10630"></a>10630         ;
<a name="l10631"></a>10631 
<a name="l10632"></a>10632 <span class="keyword">public</span>:
<a name="l10633"></a>10633     <span class="keyword">typedef</span> diagonal transform_type;
<a name="l10634"></a>10634     <span class="keyword">typedef</span> pack&lt;
<a name="l10635"></a>10635         base_iter_type_,
<a name="l10636"></a>10636         type0_,
<a name="l10637"></a>10637         type1_
<a name="l10638"></a>10638         &gt; input_iterator_type;
<a name="l10639"></a>10639 
<a name="l10640"></a>10640     <span class="keyword">typedef</span> input_size_type_ input_size_type;
<a name="l10641"></a>10641 
<a name="l10642"></a>10642     <span class="keyword">typedef</span> pack&lt;
<a name="l10643"></a>10643         base_iter_type_, 
<a name="l10644"></a>10644         <span class="keyword">typename</span> detail::type_if&lt;has_var_stride_, int, constant&lt;int, stride_&gt; &gt;::type&gt; 
<a name="l10645"></a>10645         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>;
<a name="l10646"></a>10646 
<a name="l10647"></a>10647     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l10648"></a>10648         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l10649"></a>10649         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l10650"></a>10650     {
<a name="l10651"></a>10651         res.set(org.i0, org.i1org.i2);
<a name="l10652"></a>10652     }
<a name="l10653"></a>10653 
<a name="l10654"></a>10654         <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l10655"></a>10655         <span class="keyword">const</span> transform_type&amp;, 
<a name="l10656"></a>10656         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l10657"></a>10657         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l10658"></a>10658     {
<a name="l10659"></a>10659         res.set(org.i0, org.i1org.i2);
<a name="l10660"></a>10660     }
<a name="l10661"></a>10661 
<a name="l10662"></a>10662     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l10663"></a>10663         <span class="keyword">const</span> transform_type&amp;, 
<a name="l10664"></a>10664         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l10665"></a>10665         <span class="keyword">const</span> input_size_type&amp;,
<a name="l10666"></a>10666         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l10667"></a>10667     {
<a name="l10668"></a>10668         res.set(org.i0, org.i1 + org.i2);
<a name="l10669"></a>10669     }
<a name="l10670"></a>10670 };
<a name="l10671"></a>10671 
<a name="l10672"></a>10672 <span class="comment">/***********************************************************************************************************/</span>
<a name="l10673"></a>10673 <span class="keyword">template</span>&lt;
<a name="l10674"></a>10674     <span class="keyword">typename</span> base_iter_type_,
<a name="l10675"></a>10675     <span class="keyword">typename</span> type0_,
<a name="l10676"></a>10676     <span class="keyword">typename</span> type1_,
<a name="l10677"></a>10677     <span class="keyword">typename</span> type2_,
<a name="l10678"></a>10678     <span class="keyword">typename</span> input_size_type_&gt;
<a name="l10679"></a>10679 <span class="keyword">struct </span>iterator_transformer&lt;
<a name="l10680"></a>10680     diagonal, 
<a name="l10681"></a>10681     pack&lt;
<a name="l10682"></a>10682         base_iter_type_,
<a name="l10683"></a>10683         type0_,
<a name="l10684"></a>10684         type1_,
<a name="l10685"></a>10685         type2_
<a name="l10686"></a>10686     &gt;,
<a name="l10687"></a>10687     input_size_type_&gt;
<a name="l10688"></a>10688 {
<a name="l10689"></a>10689 <span class="keyword">private</span>:
<a name="l10690"></a>10690     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n0_ = 
<a name="l10691"></a>10691         detail::type_if&lt;detail::same_type&lt;type0_, int&gt;::result, constant&lt;int, 0&gt;, type0_&gt;::type::value;
<a name="l10692"></a>10692     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n1_ = 
<a name="l10693"></a>10693         detail::type_if&lt;detail::same_type&lt;type1_, int&gt;::result, constant&lt;int, 0&gt;, type1_&gt;::type::value;
<a name="l10694"></a>10694     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n2_ = 
<a name="l10695"></a>10695         detail::type_if&lt;detail::same_type&lt;type2_, int&gt;::result, constant&lt;int, 0&gt;, type2_&gt;::type::value;
<a name="l10696"></a>10696 
<a name="l10697"></a>10697     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> stride_ = n0_ + n1_ + n2_;
<a name="l10698"></a>10698 
<a name="l10699"></a>10699     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> has_var_stride_ =
<a name="l10700"></a>10700         detail::same_type&lt;type0_, int&gt;::result||
<a name="l10701"></a>10701         detail::same_type&lt;type1_, int&gt;::result||
<a name="l10702"></a>10702         detail::same_type&lt;type2_, int&gt;::result
<a name="l10703"></a>10703         ;
<a name="l10704"></a>10704 
<a name="l10705"></a>10705 <span class="keyword">public</span>:
<a name="l10706"></a>10706     <span class="keyword">typedef</span> diagonal transform_type;
<a name="l10707"></a>10707     <span class="keyword">typedef</span> pack&lt;
<a name="l10708"></a>10708         base_iter_type_,
<a name="l10709"></a>10709         type0_,
<a name="l10710"></a>10710         type1_,
<a name="l10711"></a>10711         type2_
<a name="l10712"></a>10712         &gt; input_iterator_type;
<a name="l10713"></a>10713 
<a name="l10714"></a>10714     <span class="keyword">typedef</span> input_size_type_ input_size_type;
<a name="l10715"></a>10715 
<a name="l10716"></a>10716     <span class="keyword">typedef</span> pack&lt;
<a name="l10717"></a>10717         base_iter_type_, 
<a name="l10718"></a>10718         <span class="keyword">typename</span> detail::type_if&lt;has_var_stride_, int, constant&lt;int, stride_&gt; &gt;::type&gt; 
<a name="l10719"></a>10719         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>;
<a name="l10720"></a>10720 
<a name="l10721"></a>10721     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l10722"></a>10722         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l10723"></a>10723         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l10724"></a>10724     {
<a name="l10725"></a>10725         res.set(org.i0, org.i1org.i2org.i3);
<a name="l10726"></a>10726     }
<a name="l10727"></a>10727 
<a name="l10728"></a>10728         <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l10729"></a>10729         <span class="keyword">const</span> transform_type&amp;, 
<a name="l10730"></a>10730         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l10731"></a>10731         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l10732"></a>10732     {
<a name="l10733"></a>10733         res.set(org.i0, org.i1org.i2org.i3);
<a name="l10734"></a>10734     }
<a name="l10735"></a>10735 
<a name="l10736"></a>10736     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l10737"></a>10737         <span class="keyword">const</span> transform_type&amp;, 
<a name="l10738"></a>10738         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l10739"></a>10739         <span class="keyword">const</span> input_size_type&amp;,
<a name="l10740"></a>10740         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l10741"></a>10741     {
<a name="l10742"></a>10742         res.set(org.i0, org.i1 + org.i2 + org.i3);
<a name="l10743"></a>10743     }
<a name="l10744"></a>10744 };
<a name="l10745"></a>10745 
<a name="l10746"></a>10746 <span class="comment">/***********************************************************************************************************/</span>
<a name="l10747"></a>10747 
<a name="l10748"></a>10748 <span class="comment">/***********************************************************************************************************/</span>
<a name="l10749"></a>10749 <span class="comment">/* transpose ***********************************************************************************************/</span>
<a name="l10750"></a>10750 <span class="comment">/***********************************************************************************************************/</span>
<a name="l10751"></a>10751 
<a name="l10772"></a><a class="code" href="classlite_1_1transpose.html">10772</a> <span class="keyword">class </span><a class="code" href="classlite_1_1transpose.html" title="This transform returns a reference array that references the original array but its...">transpose</a>
<a name="l10773"></a>10773 {
<a name="l10774"></a>10774 <span class="keyword">public</span>:
<a name="l10775"></a>10775     LITE_INLINE <a class="code" href="classlite_1_1transpose.html" title="This transform returns a reference array that references the original array but its...">transpose</a>() {}
<a name="l10776"></a>10776 
<a name="l10777"></a>10777     LITE_INLINE <a class="code" href="classlite_1_1transpose.html" title="This transform returns a reference array that references the original array but its...">transpose</a>(<span class="keyword">const</span> <a class="code" href="classlite_1_1transpose.html" title="This transform returns a reference array that references the original array but its...">transpose</a>&amp;) {}
<a name="l10778"></a>10778 
<a name="l10779"></a>10779     LITE_INLINE <a class="code" href="classlite_1_1transpose.html" title="This transform returns a reference array that references the original array but its...">transpose</a>&amp; operator=(<span class="keyword">const</span> <a class="code" href="classlite_1_1transpose.html" title="This transform returns a reference array that references the original array but its...">transpose</a>&amp;) { <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l10780"></a>10780 };
<a name="l10781"></a>10781 
<a name="l10782"></a>10782 <span class="comment">/***********************************************************************************************************/</span>
<a name="l10783"></a>10783 <span class="comment">/* size_transformer, transpose *****************************************************************************/</span>
<a name="l10784"></a>10784 <span class="comment">/***********************************************************************************************************/</span>
<a name="l10785"></a>10785 
<a name="l10786"></a>10786 <span class="keyword">template</span>&lt;&gt;
<a name="l10787"></a>10787 <span class="keyword">struct </span><a class="code" href="structlite_1_1size__transformer.html" title="This can be used to apply a transform object of type transform_type_ to a size object...">size_transformer</a>&lt;<a class="code" href="classlite_1_1transpose.html" title="This transform returns a reference array that references the original array but its...">transpose</a>, <a class="code" href="classlite_1_1pack.html" title="This is a general tuple class that can pack together elements of different types...">pack</a>&lt;&gt; &gt;
<a name="l10788"></a>10788 {
<a name="l10789"></a>10789 <span class="keyword">public</span>:
<a name="l10790"></a>10790     <span class="keyword">typedef</span> <a class="code" href="classlite_1_1transpose.html" title="This transform returns a reference array that references the original array but its...">transpose</a> transform_type;
<a name="l10791"></a>10791 
<a name="l10792"></a>10792     <span class="keyword">typedef</span> <a class="code" href="classlite_1_1pack.html" title="This is a general tuple class that can pack together elements of different types...">pack&lt;&gt;</a> input_size_type;
<a name="l10793"></a>10793 
<a name="l10794"></a>10794     <span class="keyword">typedef</span> <a class="code" href="classlite_1_1pack.html" title="This is a general tuple class that can pack together elements of different types...">pack&lt;&gt;</a> <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>;
<a name="l10795"></a>10795 
<a name="l10796"></a>10796     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1size__transformer.html#a5a5eced0d3d9e624fb1513e036f392bf" title="Apply the transform to the size object org and store the result in res.">transform</a>(<span class="keyword">const</span> input_size_type&amp;, <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>&amp;)
<a name="l10797"></a>10797     {}
<a name="l10798"></a>10798 
<a name="l10799"></a>10799     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1size__transformer.html#a5a5eced0d3d9e624fb1513e036f392bf" title="Apply the transform to the size object org and store the result in res.">transform</a>(<span class="keyword">const</span> transform_type&amp;, <span class="keyword">const</span> input_size_type&amp;, <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>&amp;)
<a name="l10800"></a>10800     {}
<a name="l10801"></a>10801 };
<a name="l10802"></a>10802 
<a name="l10803"></a>10803 <span class="comment">/***********************************************************************************************************/</span>
<a name="l10804"></a>10804 
<a name="l10805"></a>10805 <span class="keyword">template</span>&lt;
<a name="l10806"></a>10806     <span class="keyword">typename</span> type0_
<a name="l10807"></a>10807     &gt;
<a name="l10808"></a>10808 <span class="keyword">struct </span>size_transformer&lt;
<a name="l10809"></a>10809     transpose, 
<a name="l10810"></a>10810     pack&lt;
<a name="l10811"></a>10811         type0_
<a name="l10812"></a>10812     &gt; &gt;
<a name="l10813"></a>10813 {
<a name="l10814"></a>10814 <span class="keyword">public</span>:
<a name="l10815"></a>10815     <span class="keyword">typedef</span> transpose transform_type;
<a name="l10816"></a>10816 
<a name="l10817"></a>10817     <span class="keyword">typedef</span> pack&lt;
<a name="l10818"></a>10818         type0_
<a name="l10819"></a>10819         &gt; input_size_type;
<a name="l10820"></a>10820 
<a name="l10821"></a>10821     <span class="keyword">typedef</span> pack&lt;
<a name="l10822"></a>10822         type0_
<a name="l10823"></a>10823         &gt; <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>;
<a name="l10824"></a>10824 
<a name="l10825"></a>10825     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1size__transformer.html#a5a5eced0d3d9e624fb1513e036f392bf" title="Apply the transform to the size object org and store the result in res.">transform</a>(<span class="keyword">const</span> input_size_type&amp; org, <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>&amp; res)
<a name="l10826"></a>10826     {
<a name="l10827"></a>10827         set&lt;0&gt;(res, org.i0);
<a name="l10828"></a>10828         LITE_ARRAY_USE(org);
<a name="l10829"></a>10829     }
<a name="l10830"></a>10830 
<a name="l10831"></a>10831     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1size__transformer.html#a5a5eced0d3d9e624fb1513e036f392bf" title="Apply the transform to the size object org and store the result in res.">transform</a>(<span class="keyword">const</span> transform_type&amp;, <span class="keyword">const</span> input_size_type&amp; org, <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>&amp; res)
<a name="l10832"></a>10832     {
<a name="l10833"></a>10833         set&lt;0&gt;(res, org.i0);
<a name="l10834"></a>10834         LITE_ARRAY_USE(org);
<a name="l10835"></a>10835     }
<a name="l10836"></a>10836 };
<a name="l10837"></a>10837 
<a name="l10838"></a>10838 <span class="comment">/***********************************************************************************************************/</span>
<a name="l10839"></a>10839 <span class="keyword">template</span>&lt;
<a name="l10840"></a>10840     <span class="keyword">typename</span> type0_,
<a name="l10841"></a>10841     <span class="keyword">typename</span> type1_
<a name="l10842"></a>10842     &gt;
<a name="l10843"></a>10843 <span class="keyword">struct </span>size_transformer&lt;
<a name="l10844"></a>10844     transpose, 
<a name="l10845"></a>10845     pack&lt;
<a name="l10846"></a>10846         type0_,
<a name="l10847"></a>10847         type1_
<a name="l10848"></a>10848     &gt; &gt;
<a name="l10849"></a>10849 {
<a name="l10850"></a>10850 <span class="keyword">public</span>:
<a name="l10851"></a>10851     <span class="keyword">typedef</span> transpose transform_type;
<a name="l10852"></a>10852 
<a name="l10853"></a>10853     <span class="keyword">typedef</span> pack&lt;
<a name="l10854"></a>10854         type0_,
<a name="l10855"></a>10855         type1_
<a name="l10856"></a>10856         &gt; input_size_type;
<a name="l10857"></a>10857 
<a name="l10858"></a>10858     <span class="keyword">typedef</span> pack&lt;
<a name="l10859"></a>10859         type1_,
<a name="l10860"></a>10860         type0_
<a name="l10861"></a>10861         &gt; <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>;
<a name="l10862"></a>10862 
<a name="l10863"></a>10863     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1size__transformer.html#a5a5eced0d3d9e624fb1513e036f392bf" title="Apply the transform to the size object org and store the result in res.">transform</a>(<span class="keyword">const</span> input_size_type&amp; org, <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>&amp; res)
<a name="l10864"></a>10864     {
<a name="l10865"></a>10865         set&lt;0&gt;(res, org.i1);
<a name="l10866"></a>10866         set&lt;1&gt;(res, org.i0);
<a name="l10867"></a>10867         LITE_ARRAY_USE(org);
<a name="l10868"></a>10868     }
<a name="l10869"></a>10869 
<a name="l10870"></a>10870     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1size__transformer.html#a5a5eced0d3d9e624fb1513e036f392bf" title="Apply the transform to the size object org and store the result in res.">transform</a>(<span class="keyword">const</span> transform_type&amp;, <span class="keyword">const</span> input_size_type&amp; org, <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>&amp; res)
<a name="l10871"></a>10871     {
<a name="l10872"></a>10872         set&lt;0&gt;(res, org.i1);
<a name="l10873"></a>10873         set&lt;1&gt;(res, org.i0);
<a name="l10874"></a>10874         LITE_ARRAY_USE(org);
<a name="l10875"></a>10875     }
<a name="l10876"></a>10876 };
<a name="l10877"></a>10877 
<a name="l10878"></a>10878 <span class="comment">/***********************************************************************************************************/</span>
<a name="l10879"></a>10879 <span class="keyword">template</span>&lt;
<a name="l10880"></a>10880     <span class="keyword">typename</span> type0_,
<a name="l10881"></a>10881     <span class="keyword">typename</span> type1_,
<a name="l10882"></a>10882     <span class="keyword">typename</span> type2_
<a name="l10883"></a>10883     &gt;
<a name="l10884"></a>10884 <span class="keyword">struct </span>size_transformer&lt;
<a name="l10885"></a>10885     transpose, 
<a name="l10886"></a>10886     pack&lt;
<a name="l10887"></a>10887         type0_,
<a name="l10888"></a>10888         type1_,
<a name="l10889"></a>10889         type2_
<a name="l10890"></a>10890     &gt; &gt;
<a name="l10891"></a>10891 {
<a name="l10892"></a>10892 <span class="keyword">public</span>:
<a name="l10893"></a>10893     <span class="keyword">typedef</span> transpose transform_type;
<a name="l10894"></a>10894 
<a name="l10895"></a>10895     <span class="keyword">typedef</span> pack&lt;
<a name="l10896"></a>10896         type0_,
<a name="l10897"></a>10897         type1_,
<a name="l10898"></a>10898         type2_
<a name="l10899"></a>10899         &gt; input_size_type;
<a name="l10900"></a>10900 
<a name="l10901"></a>10901     <span class="keyword">typedef</span> pack&lt;
<a name="l10902"></a>10902         type2_,
<a name="l10903"></a>10903         type1_,
<a name="l10904"></a>10904         type0_
<a name="l10905"></a>10905         &gt; <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>;
<a name="l10906"></a>10906 
<a name="l10907"></a>10907     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1size__transformer.html#a5a5eced0d3d9e624fb1513e036f392bf" title="Apply the transform to the size object org and store the result in res.">transform</a>(<span class="keyword">const</span> input_size_type&amp; org, <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>&amp; res)
<a name="l10908"></a>10908     {
<a name="l10909"></a>10909         set&lt;0&gt;(res, org.i2);
<a name="l10910"></a>10910         set&lt;1&gt;(res, org.i1);
<a name="l10911"></a>10911         set&lt;2&gt;(res, org.i0);
<a name="l10912"></a>10912         LITE_ARRAY_USE(org);
<a name="l10913"></a>10913     }
<a name="l10914"></a>10914 
<a name="l10915"></a>10915     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1size__transformer.html#a5a5eced0d3d9e624fb1513e036f392bf" title="Apply the transform to the size object org and store the result in res.">transform</a>(<span class="keyword">const</span> transform_type&amp;, <span class="keyword">const</span> input_size_type&amp; org, <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>&amp; res)
<a name="l10916"></a>10916     {
<a name="l10917"></a>10917         set&lt;0&gt;(res, org.i2);
<a name="l10918"></a>10918         set&lt;1&gt;(res, org.i1);
<a name="l10919"></a>10919         set&lt;2&gt;(res, org.i0);
<a name="l10920"></a>10920         LITE_ARRAY_USE(org);
<a name="l10921"></a>10921     }
<a name="l10922"></a>10922 };
<a name="l10923"></a>10923 
<a name="l10924"></a>10924 <span class="comment">/***********************************************************************************************************/</span>
<a name="l10925"></a>10925 
<a name="l10926"></a>10926 <span class="comment">/***********************************************************************************************************/</span>
<a name="l10927"></a>10927 <span class="comment">/* iterator_transformer, transpose *************************************************************************/</span>
<a name="l10928"></a>10928 <span class="comment">/***********************************************************************************************************/</span>
<a name="l10929"></a>10929 
<a name="l10930"></a>10930 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> base_iter_type_, <span class="keyword">typename</span> input_<span class="keywordtype">size_t</span>ype_&gt;
<a name="l10931"></a>10931 <span class="keyword">struct </span>iterator_transformer&lt;transpose, pack&lt;base_iter_type_&gt;, input_size_type_&gt;
<a name="l10932"></a>10932 {
<a name="l10933"></a>10933 <span class="keyword">public</span>:
<a name="l10934"></a>10934     <span class="keyword">typedef</span> transpose transform_type;
<a name="l10935"></a>10935     <span class="keyword">typedef</span> pack&lt;base_iter_type_&gt; input_iterator_type;
<a name="l10936"></a>10936     <span class="keyword">typedef</span> input_size_type_ input_size_type;
<a name="l10937"></a>10937     <span class="keyword">typedef</span> pack&lt;base_iter_type_&gt; <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>;
<a name="l10938"></a>10938 
<a name="l10939"></a>10939     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l10940"></a>10940         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l10941"></a>10941         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l10942"></a>10942     {
<a name="l10943"></a>10943         res.i0 = org.i0;
<a name="l10944"></a>10944     }
<a name="l10945"></a>10945 
<a name="l10946"></a>10946     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l10947"></a>10947         <span class="keyword">const</span> transform_type&amp;, 
<a name="l10948"></a>10948         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l10949"></a>10949         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l10950"></a>10950     {
<a name="l10951"></a>10951         res.i0 = org.i0;
<a name="l10952"></a>10952     }
<a name="l10953"></a>10953 
<a name="l10954"></a>10954     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l10955"></a>10955         <span class="keyword">const</span> transform_type&amp;, 
<a name="l10956"></a>10956         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l10957"></a>10957         <span class="keyword">const</span> input_size_type&amp;,
<a name="l10958"></a>10958         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l10959"></a>10959     {
<a name="l10960"></a>10960         res.i0 = org.i0;
<a name="l10961"></a>10961     }
<a name="l10962"></a>10962 };
<a name="l10963"></a>10963 
<a name="l10964"></a>10964 <span class="comment">/***********************************************************************************************************/</span>
<a name="l10965"></a>10965 
<a name="l10966"></a>10966 
<a name="l10967"></a>10967 <span class="keyword">template</span>&lt;
<a name="l10968"></a>10968     <span class="keyword">typename</span> base_iter_type_,
<a name="l10969"></a>10969     <span class="keyword">typename</span> type0_,
<a name="l10970"></a>10970     <span class="keyword">typename</span> input_size_type_&gt;
<a name="l10971"></a>10971 <span class="keyword">struct </span>iterator_transformer&lt;
<a name="l10972"></a>10972     transpose, 
<a name="l10973"></a>10973     pack&lt;
<a name="l10974"></a>10974         base_iter_type_,
<a name="l10975"></a>10975         type0_
<a name="l10976"></a>10976     &gt;,
<a name="l10977"></a>10977     input_size_type_&gt;
<a name="l10978"></a>10978 {
<a name="l10979"></a>10979 <span class="keyword">public</span>:
<a name="l10980"></a>10980     <span class="keyword">typedef</span> transpose transform_type;
<a name="l10981"></a>10981     <span class="keyword">typedef</span> pack&lt;
<a name="l10982"></a>10982         base_iter_type_,
<a name="l10983"></a>10983         type0_
<a name="l10984"></a>10984         &gt; input_iterator_type;
<a name="l10985"></a>10985 
<a name="l10986"></a>10986     <span class="keyword">typedef</span> input_size_type_ input_size_type;
<a name="l10987"></a>10987     <span class="keyword">typedef</span> pack&lt;
<a name="l10988"></a>10988         base_iter_type_,
<a name="l10989"></a>10989         type0_
<a name="l10990"></a>10990         &gt; <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>;
<a name="l10991"></a>10991 
<a name="l10992"></a>10992     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l10993"></a>10993         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l10994"></a>10994         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l10995"></a>10995     {
<a name="l10996"></a>10996         res.i0 = org.i0;
<a name="l10997"></a>10997         set&lt;1&gt;(res, org.i1);
<a name="l10998"></a>10998     }
<a name="l10999"></a>10999 
<a name="l11000"></a>11000     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l11001"></a>11001         <span class="keyword">const</span> transform_type&amp;, 
<a name="l11002"></a>11002         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l11003"></a>11003         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l11004"></a>11004     {
<a name="l11005"></a>11005         res.i0 = org.i0;
<a name="l11006"></a>11006         set&lt;1&gt;(res, org.i1);
<a name="l11007"></a>11007     }
<a name="l11008"></a>11008 
<a name="l11009"></a>11009     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l11010"></a>11010         <span class="keyword">const</span> transform_type&amp;, 
<a name="l11011"></a>11011         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l11012"></a>11012         <span class="keyword">const</span> input_size_type&amp;,
<a name="l11013"></a>11013         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l11014"></a>11014     {
<a name="l11015"></a>11015         res.i0 = org.i0;
<a name="l11016"></a>11016         set&lt;1&gt;(res, org.i1);
<a name="l11017"></a>11017     }
<a name="l11018"></a>11018 };
<a name="l11019"></a>11019 
<a name="l11020"></a>11020 <span class="comment">/***********************************************************************************************************/</span>
<a name="l11021"></a>11021 
<a name="l11022"></a>11022 <span class="keyword">template</span>&lt;
<a name="l11023"></a>11023     <span class="keyword">typename</span> base_iter_type_,
<a name="l11024"></a>11024     <span class="keyword">typename</span> type0_,
<a name="l11025"></a>11025     <span class="keyword">typename</span> type1_,
<a name="l11026"></a>11026     <span class="keyword">typename</span> input_size_type_&gt;
<a name="l11027"></a>11027 <span class="keyword">struct </span>iterator_transformer&lt;
<a name="l11028"></a>11028     transpose, 
<a name="l11029"></a>11029     pack&lt;
<a name="l11030"></a>11030         base_iter_type_,
<a name="l11031"></a>11031         type0_,
<a name="l11032"></a>11032         type1_
<a name="l11033"></a>11033     &gt;,
<a name="l11034"></a>11034     input_size_type_&gt;
<a name="l11035"></a>11035 {
<a name="l11036"></a>11036 <span class="keyword">public</span>:
<a name="l11037"></a>11037     <span class="keyword">typedef</span> transpose transform_type;
<a name="l11038"></a>11038     <span class="keyword">typedef</span> pack&lt;
<a name="l11039"></a>11039         base_iter_type_,
<a name="l11040"></a>11040         type0_,
<a name="l11041"></a>11041         type1_
<a name="l11042"></a>11042         &gt; input_iterator_type;
<a name="l11043"></a>11043 
<a name="l11044"></a>11044     <span class="keyword">typedef</span> input_size_type_ input_size_type;
<a name="l11045"></a>11045     <span class="keyword">typedef</span> pack&lt;
<a name="l11046"></a>11046         base_iter_type_,
<a name="l11047"></a>11047         type1_,
<a name="l11048"></a>11048         type0_
<a name="l11049"></a>11049         &gt; <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>;
<a name="l11050"></a>11050 
<a name="l11051"></a>11051     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l11052"></a>11052         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l11053"></a>11053         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l11054"></a>11054     {
<a name="l11055"></a>11055         res.i0 = org.i0;
<a name="l11056"></a>11056         set&lt;1&gt;(res, org.i2);
<a name="l11057"></a>11057         set&lt;2&gt;(res, org.i1);
<a name="l11058"></a>11058     }
<a name="l11059"></a>11059 
<a name="l11060"></a>11060     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l11061"></a>11061         <span class="keyword">const</span> transform_type&amp;, 
<a name="l11062"></a>11062         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l11063"></a>11063         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l11064"></a>11064     {
<a name="l11065"></a>11065         res.i0 = org.i0;
<a name="l11066"></a>11066         set&lt;1&gt;(res, org.i2);
<a name="l11067"></a>11067         set&lt;2&gt;(res, org.i1);
<a name="l11068"></a>11068     }
<a name="l11069"></a>11069 
<a name="l11070"></a>11070     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l11071"></a>11071         <span class="keyword">const</span> transform_type&amp;, 
<a name="l11072"></a>11072         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l11073"></a>11073         <span class="keyword">const</span> input_size_type&amp;,
<a name="l11074"></a>11074         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l11075"></a>11075     {
<a name="l11076"></a>11076         res.i0 = org.i0;
<a name="l11077"></a>11077         set&lt;1&gt;(res, org.i2);
<a name="l11078"></a>11078         set&lt;2&gt;(res, org.i1);
<a name="l11079"></a>11079     }
<a name="l11080"></a>11080 };
<a name="l11081"></a>11081 
<a name="l11082"></a>11082 <span class="comment">/***********************************************************************************************************/</span>
<a name="l11083"></a>11083 
<a name="l11084"></a>11084 <span class="keyword">template</span>&lt;
<a name="l11085"></a>11085     <span class="keyword">typename</span> base_iter_type_,
<a name="l11086"></a>11086     <span class="keyword">typename</span> type0_,
<a name="l11087"></a>11087     <span class="keyword">typename</span> type1_,
<a name="l11088"></a>11088     <span class="keyword">typename</span> type2_,
<a name="l11089"></a>11089     <span class="keyword">typename</span> input_size_type_&gt;
<a name="l11090"></a>11090 <span class="keyword">struct </span>iterator_transformer&lt;
<a name="l11091"></a>11091     transpose, 
<a name="l11092"></a>11092     pack&lt;
<a name="l11093"></a>11093         base_iter_type_,
<a name="l11094"></a>11094         type0_,
<a name="l11095"></a>11095         type1_,
<a name="l11096"></a>11096         type2_
<a name="l11097"></a>11097     &gt;,
<a name="l11098"></a>11098     input_size_type_&gt;
<a name="l11099"></a>11099 {
<a name="l11100"></a>11100 <span class="keyword">public</span>:
<a name="l11101"></a>11101     <span class="keyword">typedef</span> transpose transform_type;
<a name="l11102"></a>11102     <span class="keyword">typedef</span> pack&lt;
<a name="l11103"></a>11103         base_iter_type_,
<a name="l11104"></a>11104         type0_,
<a name="l11105"></a>11105         type1_,
<a name="l11106"></a>11106         type2_
<a name="l11107"></a>11107         &gt; input_iterator_type;
<a name="l11108"></a>11108 
<a name="l11109"></a>11109     <span class="keyword">typedef</span> input_size_type_ input_size_type;
<a name="l11110"></a>11110     <span class="keyword">typedef</span> pack&lt;
<a name="l11111"></a>11111         base_iter_type_,
<a name="l11112"></a>11112         type2_,
<a name="l11113"></a>11113         type1_,
<a name="l11114"></a>11114         type0_
<a name="l11115"></a>11115         &gt; <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>;
<a name="l11116"></a>11116 
<a name="l11117"></a>11117     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l11118"></a>11118         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l11119"></a>11119         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l11120"></a>11120     {
<a name="l11121"></a>11121         res.i0 = org.i0;
<a name="l11122"></a>11122         set&lt;1&gt;(res, org.i3);
<a name="l11123"></a>11123         set&lt;2&gt;(res, org.i2);
<a name="l11124"></a>11124         set&lt;3&gt;(res, org.i1);
<a name="l11125"></a>11125     }
<a name="l11126"></a>11126 
<a name="l11127"></a>11127     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l11128"></a>11128         <span class="keyword">const</span> transform_type&amp;, 
<a name="l11129"></a>11129         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l11130"></a>11130         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l11131"></a>11131     {
<a name="l11132"></a>11132         res.i0 = org.i0;
<a name="l11133"></a>11133         set&lt;1&gt;(res, org.i3);
<a name="l11134"></a>11134         set&lt;2&gt;(res, org.i2);
<a name="l11135"></a>11135         set&lt;3&gt;(res, org.i1);
<a name="l11136"></a>11136     }
<a name="l11137"></a>11137 
<a name="l11138"></a>11138     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l11139"></a>11139         <span class="keyword">const</span> transform_type&amp;, 
<a name="l11140"></a>11140         <span class="keyword">const</span> input_iterator_type&amp; org, 
<a name="l11141"></a>11141         <span class="keyword">const</span> input_size_type&amp;,
<a name="l11142"></a>11142         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l11143"></a>11143     {
<a name="l11144"></a>11144         res.i0 = org.i0;
<a name="l11145"></a>11145         set&lt;1&gt;(res, org.i3);
<a name="l11146"></a>11146         set&lt;2&gt;(res, org.i2);
<a name="l11147"></a>11147         set&lt;3&gt;(res, org.i1);
<a name="l11148"></a>11148     }
<a name="l11149"></a>11149 };
<a name="l11150"></a>11150 
<a name="l11151"></a>11151 <span class="comment">/***********************************************************************************************************/</span>
<a name="l11152"></a>11152 
<a name="l11153"></a>11153 <span class="comment">/***********************************************************************************************************/</span>
<a name="l11154"></a>11154 <span class="comment">/* block ***************************************************************************************************/</span>
<a name="l11155"></a>11155 <span class="comment">/***********************************************************************************************************/</span>
<a name="l11156"></a>11156 
<a name="l11157"></a>11157 <span class="preprocessor">#ifdef DOCUMENTATION_ONLY</span>
<a name="l11158"></a>11158 <span class="preprocessor"></span>
<a name="l11257"></a>11257 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> n0_ ..., <span class="keywordtype">int</span> nN_&gt;
<a name="l11258"></a><a class="code" href="classlite_1_1block.html">11258</a> <span class="keyword">class </span><a class="code" href="classlite_1_1block.html" title="This transform can be used to create a reference array that corresponds to a block...">block</a>
<a name="l11259"></a>11259 {
<a name="l11260"></a>11260 <span class="keyword">public</span>:
<a name="l11262"></a><a class="code" href="classlite_1_1block.html#aa2f7f7f9757c59ef715695e4c6301174">11262</a>     <span class="keyword">typedef</span> <a class="code" href="classlite_1_1pack.html" title="This is a general tuple class that can pack together elements of different types...">pack</a>&lt;...&gt; <a class="code" href="classlite_1_1pack.html">size_type</a>;
<a name="l11263"></a>11263 
<a name="l11264"></a>11264     <a class="code" href="classlite_1_1block.html" title="This transform can be used to create a reference array that corresponds to a block...">block</a>() {}
<a name="l11265"></a>11265 
<a name="l11266"></a>11266     <a class="code" href="classlite_1_1block.html" title="This transform can be used to create a reference array that corresponds to a block...">block</a>(<span class="keyword">const</span> <a class="code" href="classlite_1_1block.html" title="This transform can be used to create a reference array that corresponds to a block...">block</a>&amp; other);
<a name="l11267"></a>11267 
<a name="l11275"></a>11275     <a class="code" href="classlite_1_1block.html" title="This transform can be used to create a reference array that corresponds to a block...">block</a>(<span class="keywordtype">int</span> n0, ..., <span class="keywordtype">int</span> nN);
<a name="l11276"></a>11276 
<a name="l11284"></a>11284     <a class="code" href="classlite_1_1block.html" title="This transform can be used to create a reference array that corresponds to a block...">block</a>(<span class="keyword">const</span> <a class="code" href="classlite_1_1block.html#aa2f7f7f9757c59ef715695e4c6301174" title="Size type of the reference array.">size_type</a>&amp; <a class="code" href="classlite_1_1block.html#ada6451928175d2977d4f27ca44e2ef88" title="The size object that specifies the size of the resulting array.">block_size</a>, <span class="keywordtype">int</span> i0 ..., <span class="keywordtype">int</span> iN);
<a name="l11285"></a>11285 
<a name="l11286"></a>11286     <a class="code" href="classlite_1_1block.html" title="This transform can be used to create a reference array that corresponds to a block...">block</a>&amp; operator=(<span class="keyword">const</span> <a class="code" href="classlite_1_1block.html" title="This transform can be used to create a reference array that corresponds to a block...">block</a>&amp; other);
<a name="l11287"></a>11287 
<a name="l11296"></a>11296     <a class="code" href="classlite_1_1block.html" title="This transform can be used to create a reference array that corresponds to a block...">block</a> <a class="code" href="classlite_1_1block.html#a5a914ec2d23a82aaa2c151fccd4926e8" title="Creates a block transform with the same dimension sizes as the current one but starting...">operator()</a>(<span class="keywordtype">int</span> i0 ..., <span class="keywordtype">int</span> iN) <span class="keyword">const</span>;
<a name="l11297"></a>11297 
<a name="l11299"></a><a class="code" href="classlite_1_1block.html#ada6451928175d2977d4f27ca44e2ef88">11299</a>     <a class="code" href="classlite_1_1pack.html">size_type</a> <a class="code" href="classlite_1_1block.html#ada6451928175d2977d4f27ca44e2ef88" title="The size object that specifies the size of the resulting array.">block_size</a>;
<a name="l11300"></a>11300 
<a name="l11302"></a><a class="code" href="classlite_1_1block.html#a7451f69e41b08f56b7679823fcbc6323">11302</a>     <span class="keywordtype">int</span> <a class="code" href="classlite_1_1block.html#a7451f69e41b08f56b7679823fcbc6323" title="For each X in [0,N], iX is the starting index of the block at dimension X.">iX</a>;
<a name="l11303"></a>11303 };
<a name="l11304"></a>11304 
<a name="l11305"></a>11305 <span class="preprocessor">#else // DOCUMENTATION_ONLY</span>
<a name="l11306"></a>11306 <span class="preprocessor"></span>
<a name="l11307"></a>11307 
<a name="l11308"></a>11308 <span class="keyword">template</span>&lt;
<a name="l11309"></a>11309     &gt;
<a name="l11310"></a>11310 <span class="keyword">class </span><a class="code" href="classlite_1_1block.html" title="This transform can be used to create a reference array that corresponds to a block...">block</a>&lt;
<a name="l11311"></a>11311     &gt;
<a name="l11312"></a>11312 {
<a name="l11313"></a>11313 <span class="keyword">public</span>:
<a name="l11314"></a>11314 
<a name="l11315"></a>11315     <span class="keyword">typedef</span> <a class="code" href="classlite_1_1pack.html" title="This is a general tuple class that can pack together elements of different types...">pack</a>&lt;
<a name="l11316"></a>11316         &gt; <a class="code" href="classlite_1_1block.html#aa2f7f7f9757c59ef715695e4c6301174" title="Size type of the reference array.">size_type</a>;
<a name="l11317"></a>11317 
<a name="l11318"></a>11318     LITE_INLINE <a class="code" href="classlite_1_1block.html" title="This transform can be used to create a reference array that corresponds to a block...">block</a>() 
<a name="l11319"></a>11319         : <a class="code" href="classlite_1_1block.html#ada6451928175d2977d4f27ca44e2ef88" title="The size object that specifies the size of the resulting array.">block_size</a>()
<a name="l11320"></a>11320     {}
<a name="l11321"></a>11321 
<a name="l11322"></a>11322     LITE_INLINE block(<span class="keyword">const</span> block&amp; other) 
<a name="l11323"></a>11323         : <a class="code" href="classlite_1_1block.html#ada6451928175d2977d4f27ca44e2ef88" title="The size object that specifies the size of the resulting array.">block_size</a>(other.<a class="code" href="classlite_1_1block.html#ada6451928175d2977d4f27ca44e2ef88" title="The size object that specifies the size of the resulting array.">block_size</a>)
<a name="l11324"></a>11324     {}
<a name="l11325"></a>11325 
<a name="l11326"></a>11326 
<a name="l11327"></a>11327     LITE_INLINE block(<span class="keyword">const</span> <a class="code" href="classlite_1_1block.html#aa2f7f7f9757c59ef715695e4c6301174" title="Size type of the reference array.">size_type</a>&amp; bs )
<a name="l11328"></a>11328         : <a class="code" href="classlite_1_1block.html#ada6451928175d2977d4f27ca44e2ef88" title="The size object that specifies the size of the resulting array.">block_size</a>(bs)
<a name="l11329"></a>11329     {}
<a name="l11330"></a>11330 
<a name="l11331"></a>11331     LITE_INLINE block&amp; operator=(<span class="keyword">const</span> block&amp; other) 
<a name="l11332"></a>11332     {
<a name="l11333"></a>11333         <a class="code" href="classlite_1_1block.html#ada6451928175d2977d4f27ca44e2ef88" title="The size object that specifies the size of the resulting array.">block_size</a> = other.block_size;
<a name="l11334"></a>11334         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l11335"></a>11335     }
<a name="l11336"></a>11336 
<a name="l11337"></a>11337     LITE_INLINE block
<a name="l11338"></a>11338     <a class="code" href="classlite_1_1block.html#a5a914ec2d23a82aaa2c151fccd4926e8" title="Creates a block transform with the same dimension sizes as the current one but starting...">operator()</a>()<span class="keyword"> const</span>
<a name="l11339"></a>11339 <span class="keyword">    </span>{
<a name="l11340"></a>11340         <span class="keywordflow">return</span> block(<a class="code" href="classlite_1_1block.html#ada6451928175d2977d4f27ca44e2ef88" title="The size object that specifies the size of the resulting array.">block_size</a> );
<a name="l11341"></a>11341     }
<a name="l11342"></a>11342 
<a name="l11343"></a>11343     <a class="code" href="classlite_1_1block.html#aa2f7f7f9757c59ef715695e4c6301174" title="Size type of the reference array.">size_type</a> <a class="code" href="classlite_1_1block.html#ada6451928175d2977d4f27ca44e2ef88" title="The size object that specifies the size of the resulting array.">block_size</a>;
<a name="l11344"></a>11344 };
<a name="l11345"></a>11345 
<a name="l11346"></a>11346 <span class="comment">/***********************************************************************************************************/</span>
<a name="l11347"></a>11347 
<a name="l11348"></a>11348 <span class="keyword">template</span>&lt;
<a name="l11349"></a>11349     <span class="keywordtype">int</span> n0_
<a name="l11350"></a>11350     &gt;
<a name="l11351"></a>11351 <span class="keyword">class </span>block&lt;
<a name="l11352"></a>11352     n0_
<a name="l11353"></a>11353     &gt;
<a name="l11354"></a>11354 {
<a name="l11355"></a>11355 <span class="keyword">public</span>:
<a name="l11356"></a>11356 
<a name="l11357"></a>11357     <span class="keyword">typedef</span> pack&lt;
<a name="l11358"></a>11358         <span class="keyword">typename</span> detail::type_if&lt;n0_==1, int, constant&lt;int, n0_&gt; &gt;::type
<a name="l11359"></a>11359         &gt; <a class="code" href="classlite_1_1block.html#aa2f7f7f9757c59ef715695e4c6301174" title="Size type of the reference array.">size_type</a>;
<a name="l11360"></a>11360 
<a name="l11361"></a>11361     LITE_INLINE block() 
<a name="l11362"></a>11362         : <a class="code" href="classlite_1_1block.html#ada6451928175d2977d4f27ca44e2ef88" title="The size object that specifies the size of the resulting array.">block_size</a>(),
<a name="l11363"></a>11363         i0()
<a name="l11364"></a>11364     {}
<a name="l11365"></a>11365 
<a name="l11366"></a>11366     LITE_INLINE block(<span class="keyword">const</span> block&amp; other) 
<a name="l11367"></a>11367         : <a class="code" href="classlite_1_1block.html#ada6451928175d2977d4f27ca44e2ef88" title="The size object that specifies the size of the resulting array.">block_size</a>(other.<a class="code" href="classlite_1_1block.html#ada6451928175d2977d4f27ca44e2ef88" title="The size object that specifies the size of the resulting array.">block_size</a>),
<a name="l11368"></a>11368         i0(other.i0)
<a name="l11369"></a>11369     {}
<a name="l11370"></a>11370 
<a name="l11371"></a>11371     LITE_INLINE block(<span class="keywordtype">int</span> n0)
<a name="l11372"></a>11372         : <a class="code" href="classlite_1_1block.html#ada6451928175d2977d4f27ca44e2ef88" title="The size object that specifies the size of the resulting array.">block_size</a>(n0),
<a name="l11373"></a>11373         i0()
<a name="l11374"></a>11374     {}
<a name="l11375"></a>11375 
<a name="l11376"></a>11376     LITE_INLINE block(<span class="keyword">const</span> <a class="code" href="classlite_1_1block.html#aa2f7f7f9757c59ef715695e4c6301174" title="Size type of the reference array.">size_type</a>&amp; bs, <span class="keywordtype">int</span> i0)
<a name="l11377"></a>11377         : <a class="code" href="classlite_1_1block.html#ada6451928175d2977d4f27ca44e2ef88" title="The size object that specifies the size of the resulting array.">block_size</a>(bs),
<a name="l11378"></a>11378         i0(i0)
<a name="l11379"></a>11379     {}
<a name="l11380"></a>11380 
<a name="l11381"></a>11381     LITE_INLINE block&amp; operator=(<span class="keyword">const</span> block&amp; other) 
<a name="l11382"></a>11382     {
<a name="l11383"></a>11383         <a class="code" href="classlite_1_1block.html#ada6451928175d2977d4f27ca44e2ef88" title="The size object that specifies the size of the resulting array.">block_size</a> = other.block_size;
<a name="l11384"></a>11384         i0 = other.i0;
<a name="l11385"></a>11385         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l11386"></a>11386     }
<a name="l11387"></a>11387 
<a name="l11388"></a>11388     LITE_INLINE block
<a name="l11389"></a>11389     <a class="code" href="classlite_1_1block.html#a5a914ec2d23a82aaa2c151fccd4926e8" title="Creates a block transform with the same dimension sizes as the current one but starting...">operator()</a>(<span class="keywordtype">int</span> i0)<span class="keyword"> const</span>
<a name="l11390"></a>11390 <span class="keyword">    </span>{
<a name="l11391"></a>11391         <span class="keywordflow">return</span> block(<a class="code" href="classlite_1_1block.html#ada6451928175d2977d4f27ca44e2ef88" title="The size object that specifies the size of the resulting array.">block_size</a>, i0);
<a name="l11392"></a>11392     }
<a name="l11393"></a>11393 
<a name="l11394"></a>11394     <a class="code" href="classlite_1_1block.html#aa2f7f7f9757c59ef715695e4c6301174" title="Size type of the reference array.">size_type</a> <a class="code" href="classlite_1_1block.html#ada6451928175d2977d4f27ca44e2ef88" title="The size object that specifies the size of the resulting array.">block_size</a>;
<a name="l11395"></a>11395     <span class="keywordtype">int</span> i0;
<a name="l11396"></a>11396 };
<a name="l11397"></a>11397 
<a name="l11398"></a>11398 <span class="comment">/***********************************************************************************************************/</span>
<a name="l11399"></a>11399 
<a name="l11400"></a>11400 <span class="keyword">template</span>&lt;
<a name="l11401"></a>11401     <span class="keywordtype">int</span> n0_,
<a name="l11402"></a>11402     <span class="keywordtype">int</span> n1_
<a name="l11403"></a>11403     &gt;
<a name="l11404"></a>11404 <span class="keyword">class </span>block&lt;
<a name="l11405"></a>11405     n0_,
<a name="l11406"></a>11406     n1_
<a name="l11407"></a>11407     &gt;
<a name="l11408"></a>11408 {
<a name="l11409"></a>11409 <span class="keyword">public</span>:
<a name="l11410"></a>11410 
<a name="l11411"></a>11411     <span class="keyword">typedef</span> pack&lt;
<a name="l11412"></a>11412         <span class="keyword">typename</span> detail::type_if&lt;n0_==1, int, constant&lt;int, n0_&gt; &gt;::type,
<a name="l11413"></a>11413         <span class="keyword">typename</span> detail::type_if&lt;n1_==1, int, constant&lt;int, n1_&gt; &gt;::type
<a name="l11414"></a>11414         &gt; <a class="code" href="classlite_1_1block.html#aa2f7f7f9757c59ef715695e4c6301174" title="Size type of the reference array.">size_type</a>;
<a name="l11415"></a>11415 
<a name="l11416"></a>11416     LITE_INLINE block() 
<a name="l11417"></a>11417         : <a class="code" href="classlite_1_1block.html#ada6451928175d2977d4f27ca44e2ef88" title="The size object that specifies the size of the resulting array.">block_size</a>(),
<a name="l11418"></a>11418         i0(), 
<a name="l11419"></a>11419         i1()
<a name="l11420"></a>11420     {}
<a name="l11421"></a>11421 
<a name="l11422"></a>11422     LITE_INLINE block(<span class="keyword">const</span> block&amp; other) 
<a name="l11423"></a>11423         : <a class="code" href="classlite_1_1block.html#ada6451928175d2977d4f27ca44e2ef88" title="The size object that specifies the size of the resulting array.">block_size</a>(other.<a class="code" href="classlite_1_1block.html#ada6451928175d2977d4f27ca44e2ef88" title="The size object that specifies the size of the resulting array.">block_size</a>),
<a name="l11424"></a>11424         i0(other.i0), 
<a name="l11425"></a>11425         i1(other.i1)
<a name="l11426"></a>11426     {}
<a name="l11427"></a>11427 
<a name="l11428"></a>11428     LITE_INLINE block(<span class="keywordtype">int</span> n0, <span class="keywordtype">int</span> n1)
<a name="l11429"></a>11429         : <a class="code" href="classlite_1_1block.html#ada6451928175d2977d4f27ca44e2ef88" title="The size object that specifies the size of the resulting array.">block_size</a>(n0, n1),
<a name="l11430"></a>11430         i0(), 
<a name="l11431"></a>11431         i1()
<a name="l11432"></a>11432     {}
<a name="l11433"></a>11433 
<a name="l11434"></a>11434     LITE_INLINE block(<span class="keyword">const</span> <a class="code" href="classlite_1_1block.html#aa2f7f7f9757c59ef715695e4c6301174" title="Size type of the reference array.">size_type</a>&amp; bs, <span class="keywordtype">int</span> i0, <span class="keywordtype">int</span> i1)
<a name="l11435"></a>11435         : <a class="code" href="classlite_1_1block.html#ada6451928175d2977d4f27ca44e2ef88" title="The size object that specifies the size of the resulting array.">block_size</a>(bs),
<a name="l11436"></a>11436         i0(i0), 
<a name="l11437"></a>11437         i1(i1)
<a name="l11438"></a>11438     {}
<a name="l11439"></a>11439 
<a name="l11440"></a>11440     LITE_INLINE block&amp; operator=(<span class="keyword">const</span> block&amp; other) 
<a name="l11441"></a>11441     {
<a name="l11442"></a>11442         <a class="code" href="classlite_1_1block.html#ada6451928175d2977d4f27ca44e2ef88" title="The size object that specifies the size of the resulting array.">block_size</a> = other.block_size;
<a name="l11443"></a>11443         i0 = other.i0;
<a name="l11444"></a>11444         i1 = other.i1;
<a name="l11445"></a>11445         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l11446"></a>11446     }
<a name="l11447"></a>11447 
<a name="l11448"></a>11448     LITE_INLINE block
<a name="l11449"></a>11449     <a class="code" href="classlite_1_1block.html#a5a914ec2d23a82aaa2c151fccd4926e8" title="Creates a block transform with the same dimension sizes as the current one but starting...">operator()</a>(<span class="keywordtype">int</span> i0, <span class="keywordtype">int</span> i1)<span class="keyword"> const</span>
<a name="l11450"></a>11450 <span class="keyword">    </span>{
<a name="l11451"></a>11451         <span class="keywordflow">return</span> block(<a class="code" href="classlite_1_1block.html#ada6451928175d2977d4f27ca44e2ef88" title="The size object that specifies the size of the resulting array.">block_size</a>, i0, i1);
<a name="l11452"></a>11452     }
<a name="l11453"></a>11453 
<a name="l11454"></a>11454     <a class="code" href="classlite_1_1block.html#aa2f7f7f9757c59ef715695e4c6301174" title="Size type of the reference array.">size_type</a> <a class="code" href="classlite_1_1block.html#ada6451928175d2977d4f27ca44e2ef88" title="The size object that specifies the size of the resulting array.">block_size</a>;
<a name="l11455"></a>11455     <span class="keywordtype">int</span> i0;
<a name="l11456"></a>11456     <span class="keywordtype">int</span> i1;
<a name="l11457"></a>11457 };
<a name="l11458"></a>11458 
<a name="l11459"></a>11459 <span class="comment">/***********************************************************************************************************/</span>
<a name="l11460"></a>11460 
<a name="l11461"></a>11461 <span class="keyword">template</span>&lt;
<a name="l11462"></a>11462     <span class="keywordtype">int</span> n0_,
<a name="l11463"></a>11463     <span class="keywordtype">int</span> n1_,
<a name="l11464"></a>11464     <span class="keywordtype">int</span> n2_
<a name="l11465"></a>11465     &gt;
<a name="l11466"></a>11466 <span class="keyword">class </span>block
<a name="l11467"></a>11467 {
<a name="l11468"></a>11468 <span class="keyword">public</span>:
<a name="l11469"></a>11469 
<a name="l11470"></a>11470     <span class="keyword">typedef</span> pack&lt;
<a name="l11471"></a>11471         <span class="keyword">typename</span> detail::type_if&lt;n0_==1, int, constant&lt;int, n0_&gt; &gt;::type,
<a name="l11472"></a>11472         <span class="keyword">typename</span> detail::type_if&lt;n1_==1, int, constant&lt;int, n1_&gt; &gt;::type,
<a name="l11473"></a>11473         <span class="keyword">typename</span> detail::type_if&lt;n2_==1, int, constant&lt;int, n2_&gt; &gt;::type
<a name="l11474"></a>11474         &gt; <a class="code" href="classlite_1_1block.html#aa2f7f7f9757c59ef715695e4c6301174" title="Size type of the reference array.">size_type</a>;
<a name="l11475"></a>11475 
<a name="l11476"></a>11476     LITE_INLINE block() 
<a name="l11477"></a>11477         : <a class="code" href="classlite_1_1block.html#ada6451928175d2977d4f27ca44e2ef88" title="The size object that specifies the size of the resulting array.">block_size</a>(),
<a name="l11478"></a>11478         i0(), 
<a name="l11479"></a>11479         i1(), 
<a name="l11480"></a>11480         i2()
<a name="l11481"></a>11481     {}
<a name="l11482"></a>11482 
<a name="l11483"></a>11483     LITE_INLINE block(<span class="keyword">const</span> block&amp; other) 
<a name="l11484"></a>11484         : <a class="code" href="classlite_1_1block.html#ada6451928175d2977d4f27ca44e2ef88" title="The size object that specifies the size of the resulting array.">block_size</a>(other.<a class="code" href="classlite_1_1block.html#ada6451928175d2977d4f27ca44e2ef88" title="The size object that specifies the size of the resulting array.">block_size</a>),
<a name="l11485"></a>11485         i0(other.i0), 
<a name="l11486"></a>11486         i1(other.i1), 
<a name="l11487"></a>11487         i2(other.i2)
<a name="l11488"></a>11488     {}
<a name="l11489"></a>11489 
<a name="l11490"></a>11490     LITE_INLINE block(<span class="keywordtype">int</span> n0, <span class="keywordtype">int</span> n1, <span class="keywordtype">int</span> n2)
<a name="l11491"></a>11491         : <a class="code" href="classlite_1_1block.html#ada6451928175d2977d4f27ca44e2ef88" title="The size object that specifies the size of the resulting array.">block_size</a>(n0, n1, n2),
<a name="l11492"></a>11492         i0(), 
<a name="l11493"></a>11493         i1(), 
<a name="l11494"></a>11494         i2()
<a name="l11495"></a>11495     {}
<a name="l11496"></a>11496 
<a name="l11497"></a>11497     LITE_INLINE block(<span class="keyword">const</span> <a class="code" href="classlite_1_1block.html#aa2f7f7f9757c59ef715695e4c6301174" title="Size type of the reference array.">size_type</a>&amp; bs, <span class="keywordtype">int</span> i0, <span class="keywordtype">int</span> i1, <span class="keywordtype">int</span> i2)
<a name="l11498"></a>11498         : <a class="code" href="classlite_1_1block.html#ada6451928175d2977d4f27ca44e2ef88" title="The size object that specifies the size of the resulting array.">block_size</a>(bs),
<a name="l11499"></a>11499         i0(i0), 
<a name="l11500"></a>11500         i1(i1), 
<a name="l11501"></a>11501         i2(i2)
<a name="l11502"></a>11502     {}
<a name="l11503"></a>11503 
<a name="l11504"></a>11504     LITE_INLINE block&amp; operator=(<span class="keyword">const</span> block&amp; other) 
<a name="l11505"></a>11505     {
<a name="l11506"></a>11506         <a class="code" href="classlite_1_1block.html#ada6451928175d2977d4f27ca44e2ef88" title="The size object that specifies the size of the resulting array.">block_size</a> = other.block_size;
<a name="l11507"></a>11507         i0 = other.i0;
<a name="l11508"></a>11508         i1 = other.i1;
<a name="l11509"></a>11509         i2 = other.i2;
<a name="l11510"></a>11510         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l11511"></a>11511     }
<a name="l11512"></a>11512 
<a name="l11513"></a>11513     LITE_INLINE block
<a name="l11514"></a>11514     <a class="code" href="classlite_1_1block.html#a5a914ec2d23a82aaa2c151fccd4926e8" title="Creates a block transform with the same dimension sizes as the current one but starting...">operator()</a>(<span class="keywordtype">int</span> i0, <span class="keywordtype">int</span> i1, <span class="keywordtype">int</span> i2)<span class="keyword"> const</span>
<a name="l11515"></a>11515 <span class="keyword">    </span>{
<a name="l11516"></a>11516         <span class="keywordflow">return</span> block(<a class="code" href="classlite_1_1block.html#ada6451928175d2977d4f27ca44e2ef88" title="The size object that specifies the size of the resulting array.">block_size</a>, i0, i1, i2);
<a name="l11517"></a>11517     }
<a name="l11518"></a>11518 
<a name="l11519"></a>11519     <a class="code" href="classlite_1_1block.html#aa2f7f7f9757c59ef715695e4c6301174" title="Size type of the reference array.">size_type</a> <a class="code" href="classlite_1_1block.html#ada6451928175d2977d4f27ca44e2ef88" title="The size object that specifies the size of the resulting array.">block_size</a>;
<a name="l11520"></a>11520     <span class="keywordtype">int</span> i0;
<a name="l11521"></a>11521     <span class="keywordtype">int</span> i1;
<a name="l11522"></a>11522     <span class="keywordtype">int</span> i2;
<a name="l11523"></a>11523 };
<a name="l11524"></a>11524 
<a name="l11525"></a>11525 <span class="comment">/***********************************************************************************************************/</span>
<a name="l11526"></a>11526  
<a name="l11527"></a>11527 <span class="preprocessor">#endif // DOCUMENTATION_ONLY</span>
<a name="l11528"></a>11528 <span class="preprocessor"></span>
<a name="l11529"></a>11529 <span class="comment">/***********************************************************************************************************/</span>
<a name="l11530"></a>11530 <span class="comment">/* size_transformer, block *********************************************************************************/</span>
<a name="l11531"></a>11531 <span class="comment">/***********************************************************************************************************/</span>
<a name="l11532"></a>11532 
<a name="l11533"></a>11533 
<a name="l11534"></a>11534 <span class="keyword">template</span>&lt;
<a name="l11535"></a>11535     &gt;
<a name="l11536"></a>11536 <span class="keyword">struct </span>size_transformer&lt;
<a name="l11537"></a>11537     block&lt;
<a name="l11538"></a>11538     &gt;, 
<a name="l11539"></a>11539     pack&lt;
<a name="l11540"></a>11540     &gt; &gt;
<a name="l11541"></a>11541 {
<a name="l11542"></a>11542     <span class="keyword">typedef</span> block&lt;
<a name="l11543"></a>11543         &gt; transfrom_type;
<a name="l11544"></a>11544 
<a name="l11545"></a>11545     <span class="keyword">typedef</span> pack&lt;
<a name="l11546"></a>11546         &gt; input_size_type;
<a name="l11547"></a>11547 
<a name="l11548"></a>11548     <span class="keyword">typedef</span> pack&lt;
<a name="l11549"></a>11549         &gt; ex_size_type;
<a name="l11550"></a>11550 
<a name="l11551"></a>11551     <span class="keyword">typedef</span> sub_pack&lt;
<a name="l11552"></a>11552         ex_size_type
<a name="l11553"></a>11553         &gt; sub_pack_type;
<a name="l11554"></a>11554 
<a name="l11555"></a>11555 
<a name="l11556"></a>11556     <span class="keyword">typedef</span> sub_pack_type::type <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>;
<a name="l11557"></a>11557 
<a name="l11558"></a>11558     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="structlite_1_1size__transformer.html#a5a5eced0d3d9e624fb1513e036f392bf" title="Apply the transform to the size object org and store the result in res.">transform</a>(<span class="keyword">const</span> transfrom_type&amp;, <span class="keyword">const</span> input_size_type&amp;, <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>&amp;)
<a name="l11559"></a>11559     {}
<a name="l11560"></a>11560 
<a name="l11561"></a>11561 <span class="keyword">private</span>:
<a name="l11562"></a>11562     <span class="keyword">typedef</span> detail::compile_time_assert&lt;transfrom_type::size_type::n == input_size_type::n&gt;
<a name="l11563"></a>11563         ::verified verified;
<a name="l11564"></a>11564 };
<a name="l11565"></a>11565 
<a name="l11566"></a>11566 <span class="comment">/***********************************************************************************************************/</span>
<a name="l11567"></a>11567 
<a name="l11568"></a>11568 <span class="keyword">template</span>&lt;
<a name="l11569"></a>11569     <span class="keywordtype">int</span> n0_,
<a name="l11570"></a>11570     <span class="keyword">typename</span> type0_
<a name="l11571"></a>11571     &gt;
<a name="l11572"></a>11572 <span class="keyword">struct </span>size_transformer&lt;
<a name="l11573"></a>11573     block&lt;
<a name="l11574"></a>11574         n0_
<a name="l11575"></a>11575     &gt;, 
<a name="l11576"></a>11576     pack&lt;
<a name="l11577"></a>11577         type0_
<a name="l11578"></a>11578     &gt; &gt;
<a name="l11579"></a>11579 {
<a name="l11580"></a>11580     <span class="keyword">typedef</span> block&lt;
<a name="l11581"></a>11581         n0_
<a name="l11582"></a>11582         &gt; transfrom_type;
<a name="l11583"></a>11583 
<a name="l11584"></a>11584     <span class="keyword">typedef</span> pack&lt;
<a name="l11585"></a>11585         type0_
<a name="l11586"></a>11586         &gt; input_size_type;
<a name="l11587"></a>11587 
<a name="l11588"></a>11588     <span class="keyword">typedef</span> pack&lt;
<a name="l11589"></a>11589          <span class="keyword">typename</span> detail::type_if&lt;
<a name="l11590"></a>11590             n0_ == -1, 
<a name="l11591"></a>11591             type0_, 
<a name="l11592"></a>11592             <span class="keyword">typename</span> detail::type_if&lt;n0_ == 1, int, constant&lt;int, n0_&gt; &gt;::type
<a name="l11593"></a>11593             &gt;::type
<a name="l11594"></a>11594         &gt; ex_size_type;
<a name="l11595"></a>11595 
<a name="l11596"></a>11596     <span class="keyword">typedef</span> sub_pack&lt;
<a name="l11597"></a>11597         ex_size_type,
<a name="l11598"></a>11598         n0_!=0
<a name="l11599"></a>11599         &gt; sub_pack_type;
<a name="l11600"></a>11600 
<a name="l11601"></a>11601 
<a name="l11602"></a>11602     <span class="keyword">typedef</span> <span class="keyword">typename</span> sub_pack_type::type <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>;
<a name="l11603"></a>11603 
<a name="l11604"></a>11604     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> 
<a name="l11605"></a>11605     <a class="code" href="structlite_1_1size__transformer.html#a5a5eced0d3d9e624fb1513e036f392bf" title="Apply the transform to the size object org and store the result in res.">transform</a>(<span class="keyword">const</span> transfrom_type&amp; trans, <span class="keyword">const</span> input_size_type&amp; org, <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>&amp; res)
<a name="l11606"></a>11606     {
<a name="l11607"></a>11607         <a class="code" href="group__array__tools.html#ga86cbd758c7c991ccb4aac651392c5e84">sub_pack_type::set</a>(
<a name="l11608"></a>11608             res,
<a name="l11609"></a>11609             n0_==-1 ? org.i0 : trans.block_size.i0
<a name="l11610"></a>11610             ); 
<a name="l11611"></a>11611         LITE_ARRAY_USE(trans);
<a name="l11612"></a>11612         LITE_ARRAY_USE(org);
<a name="l11613"></a>11613     }
<a name="l11614"></a>11614 
<a name="l11615"></a>11615 <span class="keyword">private</span>:
<a name="l11616"></a>11616     <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::compile_time_assert&lt;transfrom_type::size_type::n == input_size_type::n&gt;
<a name="l11617"></a>11617         ::verified verified;
<a name="l11618"></a>11618 };
<a name="l11619"></a>11619 
<a name="l11620"></a>11620 <span class="comment">/***********************************************************************************************************/</span>
<a name="l11621"></a>11621 
<a name="l11622"></a>11622 <span class="keyword">template</span>&lt;
<a name="l11623"></a>11623     <span class="keywordtype">int</span> n0_,
<a name="l11624"></a>11624     <span class="keywordtype">int</span> n1_,
<a name="l11625"></a>11625     <span class="keyword">typename</span> type0_,
<a name="l11626"></a>11626     <span class="keyword">typename</span> type1_
<a name="l11627"></a>11627     &gt;
<a name="l11628"></a>11628 <span class="keyword">struct </span>size_transformer&lt;
<a name="l11629"></a>11629     block&lt;
<a name="l11630"></a>11630         n0_,
<a name="l11631"></a>11631         n1_
<a name="l11632"></a>11632     &gt;, 
<a name="l11633"></a>11633     pack&lt;
<a name="l11634"></a>11634         type0_,
<a name="l11635"></a>11635         type1_
<a name="l11636"></a>11636     &gt; &gt;
<a name="l11637"></a>11637 {
<a name="l11638"></a>11638     <span class="keyword">typedef</span> block&lt;
<a name="l11639"></a>11639         n0_,
<a name="l11640"></a>11640         n1_
<a name="l11641"></a>11641         &gt; transfrom_type;
<a name="l11642"></a>11642 
<a name="l11643"></a>11643     <span class="keyword">typedef</span> pack&lt;
<a name="l11644"></a>11644         type0_,
<a name="l11645"></a>11645         type1_
<a name="l11646"></a>11646         &gt; input_size_type;
<a name="l11647"></a>11647 
<a name="l11648"></a>11648     <span class="keyword">typedef</span> pack&lt;
<a name="l11649"></a>11649          <span class="keyword">typename</span> detail::type_if&lt;
<a name="l11650"></a>11650             n0_ == -1, 
<a name="l11651"></a>11651             type0_, 
<a name="l11652"></a>11652             <span class="keyword">typename</span> detail::type_if&lt;n0_ == 1, int, constant&lt;int, n0_&gt; &gt;::type
<a name="l11653"></a>11653             &gt;::type,
<a name="l11654"></a>11654          <span class="keyword">typename</span> detail::type_if&lt;
<a name="l11655"></a>11655             n1_ == -1, 
<a name="l11656"></a>11656             type1_, 
<a name="l11657"></a>11657             <span class="keyword">typename</span> detail::type_if&lt;n1_ == 1, int, constant&lt;int, n1_&gt; &gt;::type
<a name="l11658"></a>11658             &gt;::type
<a name="l11659"></a>11659         &gt; ex_size_type;
<a name="l11660"></a>11660 
<a name="l11661"></a>11661     <span class="keyword">typedef</span> sub_pack&lt;
<a name="l11662"></a>11662         ex_size_type,
<a name="l11663"></a>11663         n0_!=0,
<a name="l11664"></a>11664         n1_!=0
<a name="l11665"></a>11665         &gt; sub_pack_type;
<a name="l11666"></a>11666 
<a name="l11667"></a>11667 
<a name="l11668"></a>11668     <span class="keyword">typedef</span> <span class="keyword">typename</span> sub_pack_type::type <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>;
<a name="l11669"></a>11669 
<a name="l11670"></a>11670     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> 
<a name="l11671"></a>11671     <a class="code" href="structlite_1_1size__transformer.html#a5a5eced0d3d9e624fb1513e036f392bf" title="Apply the transform to the size object org and store the result in res.">transform</a>(<span class="keyword">const</span> transfrom_type&amp; trans, <span class="keyword">const</span> input_size_type&amp; org, <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>&amp; res)
<a name="l11672"></a>11672     {
<a name="l11673"></a>11673         <a class="code" href="group__array__tools.html#ga86cbd758c7c991ccb4aac651392c5e84">sub_pack_type::set</a>(
<a name="l11674"></a>11674             res,
<a name="l11675"></a>11675             n0_==-1 ? org.i0 : trans.block_size.i0, 
<a name="l11676"></a>11676             n1_==-1 ? org.i1 : trans.block_size.i1
<a name="l11677"></a>11677             ); 
<a name="l11678"></a>11678         LITE_ARRAY_USE(trans);
<a name="l11679"></a>11679         LITE_ARRAY_USE(org);
<a name="l11680"></a>11680     }
<a name="l11681"></a>11681 
<a name="l11682"></a>11682 <span class="keyword">private</span>:
<a name="l11683"></a>11683     <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::compile_time_assert&lt;transfrom_type::size_type::n == input_size_type::n&gt;
<a name="l11684"></a>11684         ::verified verified;
<a name="l11685"></a>11685 };
<a name="l11686"></a>11686 
<a name="l11687"></a>11687 <span class="comment">/***********************************************************************************************************/</span>
<a name="l11688"></a>11688 
<a name="l11689"></a>11689 <span class="keyword">template</span>&lt;
<a name="l11690"></a>11690     <span class="keywordtype">int</span> n0_,
<a name="l11691"></a>11691     <span class="keywordtype">int</span> n1_,
<a name="l11692"></a>11692     <span class="keywordtype">int</span> n2_,
<a name="l11693"></a>11693     <span class="keyword">typename</span> type0_,
<a name="l11694"></a>11694     <span class="keyword">typename</span> type1_,
<a name="l11695"></a>11695     <span class="keyword">typename</span> type2_
<a name="l11696"></a>11696     &gt;
<a name="l11697"></a>11697 <span class="keyword">struct </span>size_transformer&lt;
<a name="l11698"></a>11698     block&lt;
<a name="l11699"></a>11699         n0_,
<a name="l11700"></a>11700         n1_,
<a name="l11701"></a>11701         n2_
<a name="l11702"></a>11702     &gt;, 
<a name="l11703"></a>11703     pack&lt;
<a name="l11704"></a>11704         type0_,
<a name="l11705"></a>11705         type1_,
<a name="l11706"></a>11706         type2_
<a name="l11707"></a>11707     &gt; &gt;
<a name="l11708"></a>11708 {
<a name="l11709"></a>11709     <span class="keyword">typedef</span> block&lt;
<a name="l11710"></a>11710         n0_,
<a name="l11711"></a>11711         n1_,
<a name="l11712"></a>11712         n2_
<a name="l11713"></a>11713         &gt; transfrom_type;
<a name="l11714"></a>11714 
<a name="l11715"></a>11715     <span class="keyword">typedef</span> pack&lt;
<a name="l11716"></a>11716         type0_,
<a name="l11717"></a>11717         type1_,
<a name="l11718"></a>11718         type2_
<a name="l11719"></a>11719         &gt; input_size_type;
<a name="l11720"></a>11720 
<a name="l11721"></a>11721     <span class="keyword">typedef</span> pack&lt;
<a name="l11722"></a>11722          <span class="keyword">typename</span> detail::type_if&lt;
<a name="l11723"></a>11723             n0_ == -1, 
<a name="l11724"></a>11724             type0_, 
<a name="l11725"></a>11725             <span class="keyword">typename</span> detail::type_if&lt;n0_ == 1, int, constant&lt;int, n0_&gt; &gt;::type
<a name="l11726"></a>11726             &gt;::type,
<a name="l11727"></a>11727          <span class="keyword">typename</span> detail::type_if&lt;
<a name="l11728"></a>11728             n1_ == -1, 
<a name="l11729"></a>11729             type1_, 
<a name="l11730"></a>11730             <span class="keyword">typename</span> detail::type_if&lt;n1_ == 1, int, constant&lt;int, n1_&gt; &gt;::type
<a name="l11731"></a>11731             &gt;::type,
<a name="l11732"></a>11732          <span class="keyword">typename</span> detail::type_if&lt;
<a name="l11733"></a>11733             n2_ == -1, 
<a name="l11734"></a>11734             type2_, 
<a name="l11735"></a>11735             <span class="keyword">typename</span> detail::type_if&lt;n2_ == 1, int, constant&lt;int, n2_&gt; &gt;::type
<a name="l11736"></a>11736             &gt;::type
<a name="l11737"></a>11737         &gt; ex_size_type;
<a name="l11738"></a>11738 
<a name="l11739"></a>11739     <span class="keyword">typedef</span> sub_pack&lt;
<a name="l11740"></a>11740         ex_size_type,
<a name="l11741"></a>11741         n0_!=0,
<a name="l11742"></a>11742         n1_!=0,
<a name="l11743"></a>11743         n2_!=0
<a name="l11744"></a>11744         &gt; sub_pack_type;
<a name="l11745"></a>11745 
<a name="l11746"></a>11746 
<a name="l11747"></a>11747     <span class="keyword">typedef</span> <span class="keyword">typename</span> sub_pack_type::type <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>;
<a name="l11748"></a>11748 
<a name="l11749"></a>11749     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span> 
<a name="l11750"></a>11750     <a class="code" href="structlite_1_1size__transformer.html#a5a5eced0d3d9e624fb1513e036f392bf" title="Apply the transform to the size object org and store the result in res.">transform</a>(<span class="keyword">const</span> transfrom_type&amp; trans, <span class="keyword">const</span> input_size_type&amp; org, <a class="code" href="structlite_1_1size__transformer.html#a635d7da6bfad61dbb7211708705c4c73" title="The type of the resulting size object after applying the transform.">size_type</a>&amp; res)
<a name="l11751"></a>11751     {
<a name="l11752"></a>11752         <a class="code" href="group__array__tools.html#ga86cbd758c7c991ccb4aac651392c5e84">sub_pack_type::set</a>(
<a name="l11753"></a>11753             res,
<a name="l11754"></a>11754             n0_==-1 ? org.i0 : trans.block_size.i0, 
<a name="l11755"></a>11755             n1_==-1 ? org.i1 : trans.block_size.i1, 
<a name="l11756"></a>11756             n2_==-1 ? org.i2 : trans.block_size.i2
<a name="l11757"></a>11757             ); 
<a name="l11758"></a>11758         LITE_ARRAY_USE(trans);
<a name="l11759"></a>11759         LITE_ARRAY_USE(org);
<a name="l11760"></a>11760     }
<a name="l11761"></a>11761 
<a name="l11762"></a>11762 <span class="keyword">private</span>:
<a name="l11763"></a>11763     <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::compile_time_assert&lt;transfrom_type::size_type::n == input_size_type::n&gt;
<a name="l11764"></a>11764         ::verified verified;
<a name="l11765"></a>11765 };
<a name="l11766"></a>11766 
<a name="l11767"></a>11767 <span class="comment">/***********************************************************************************************************/</span>
<a name="l11768"></a>11768 
<a name="l11769"></a>11769 
<a name="l11770"></a>11770 <span class="comment">/***********************************************************************************************************/</span>
<a name="l11771"></a>11771 <span class="comment">/* iterator_transformer, block *****************************************************************************/</span>
<a name="l11772"></a>11772 <span class="comment">/***********************************************************************************************************/</span>
<a name="l11773"></a>11773 
<a name="l11774"></a>11774 
<a name="l11775"></a>11775 <span class="keyword">template</span>&lt;
<a name="l11776"></a>11776     <span class="keyword">typename</span> base_iterator_type_,
<a name="l11777"></a>11777     <span class="keyword">typename</span> input_size_type_
<a name="l11778"></a>11778     &gt;
<a name="l11779"></a>11779 <span class="keyword">struct </span>iterator_transformer&lt;
<a name="l11780"></a>11780     block&lt;
<a name="l11781"></a>11781     &gt;,
<a name="l11782"></a>11782     pack&lt;
<a name="l11783"></a>11783         base_iterator_type_
<a name="l11784"></a>11784     &gt;,
<a name="l11785"></a>11785     input_size_type_
<a name="l11786"></a>11786     &gt;
<a name="l11787"></a>11787 {
<a name="l11788"></a>11788     <span class="keyword">typedef</span> block&lt;
<a name="l11789"></a>11789         &gt; transfrom_type;
<a name="l11790"></a>11790 
<a name="l11791"></a>11791     <span class="keyword">typedef</span> pack&lt;
<a name="l11792"></a>11792         base_iterator_type_
<a name="l11793"></a>11793         &gt; input_iterator_type;
<a name="l11794"></a>11794 
<a name="l11795"></a>11795     <span class="keyword">typedef</span> sub_pack&lt;
<a name="l11796"></a>11796         input_iterator_type,
<a name="l11797"></a>11797         <span class="keyword">true</span>
<a name="l11798"></a>11798         &gt; sub_pack_type;
<a name="l11799"></a>11799 
<a name="l11800"></a>11800     <span class="keyword">typedef</span> <span class="keyword">typename</span> sub_pack_type::type <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>;
<a name="l11801"></a>11801 
<a name="l11802"></a>11802     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span>
<a name="l11803"></a>11803     <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l11804"></a>11804         <span class="keyword">const</span> transfrom_type&amp; trans, 
<a name="l11805"></a>11805         <span class="keyword">const</span> input_iterator_type&amp; org,
<a name="l11806"></a>11806         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l11807"></a>11807     {
<a name="l11808"></a>11808         <a class="code" href="group__array__tools.html#ga86cbd758c7c991ccb4aac651392c5e84">sub_pack_type::set</a>(res, org.i0
<a name="l11809"></a>11809             
<a name="l11810"></a>11810         );
<a name="l11811"></a>11811         
<a name="l11812"></a>11812         LITE_ARRAY_USE(trans);
<a name="l11813"></a>11813     }
<a name="l11814"></a>11814 
<a name="l11815"></a>11815     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span>
<a name="l11816"></a>11816     <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l11817"></a>11817         <span class="keyword">const</span> transfrom_type&amp; trans, 
<a name="l11818"></a>11818         <span class="keyword">const</span> input_iterator_type&amp; org,
<a name="l11819"></a>11819         <span class="keyword">const</span> input_size_type_&amp;, 
<a name="l11820"></a>11820         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l11821"></a>11821     {
<a name="l11822"></a>11822         <a class="code" href="group__array__tools.html#ga86cbd758c7c991ccb4aac651392c5e84">sub_pack_type::set</a>(res, org.i0
<a name="l11823"></a>11823             
<a name="l11824"></a>11824         );
<a name="l11825"></a>11825         
<a name="l11826"></a>11826         LITE_ARRAY_USE(trans);
<a name="l11827"></a>11827     }
<a name="l11828"></a>11828 
<a name="l11829"></a>11829 <span class="keyword">private</span>:
<a name="l11830"></a>11830     <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::compile_time_assert&lt;transfrom_type::size_type::n == input_size_type_::n&gt;
<a name="l11831"></a>11831         ::verified verified;
<a name="l11832"></a>11832 };
<a name="l11833"></a>11833 
<a name="l11834"></a>11834 <span class="comment">/***********************************************************************************************************/</span>
<a name="l11835"></a>11835 
<a name="l11836"></a>11836 <span class="keyword">template</span>&lt;
<a name="l11837"></a>11837     <span class="keywordtype">int</span> n0_,
<a name="l11838"></a>11838     <span class="keyword">typename</span> base_iterator_type_,
<a name="l11839"></a>11839     <span class="keyword">typename</span> type0_,
<a name="l11840"></a>11840     <span class="keyword">typename</span> input_size_type_
<a name="l11841"></a>11841     &gt;
<a name="l11842"></a>11842 <span class="keyword">struct </span>iterator_transformer&lt;
<a name="l11843"></a>11843     block&lt;
<a name="l11844"></a>11844         n0_
<a name="l11845"></a>11845     &gt;,
<a name="l11846"></a>11846     pack&lt;
<a name="l11847"></a>11847         base_iterator_type_,
<a name="l11848"></a>11848         type0_
<a name="l11849"></a>11849     &gt;,
<a name="l11850"></a>11850     input_size_type_
<a name="l11851"></a>11851     &gt;
<a name="l11852"></a>11852 {
<a name="l11853"></a>11853     <span class="keyword">typedef</span> block&lt;
<a name="l11854"></a>11854         n0_
<a name="l11855"></a>11855         &gt; transfrom_type;
<a name="l11856"></a>11856 
<a name="l11857"></a>11857     <span class="keyword">typedef</span> pack&lt;
<a name="l11858"></a>11858         base_iterator_type_,
<a name="l11859"></a>11859         type0_
<a name="l11860"></a>11860         &gt; input_iterator_type;
<a name="l11861"></a>11861 
<a name="l11862"></a>11862     <span class="keyword">typedef</span> sub_pack&lt;
<a name="l11863"></a>11863         input_iterator_type,
<a name="l11864"></a>11864         <span class="keyword">true</span>,
<a name="l11865"></a>11865         n0_!=0
<a name="l11866"></a>11866         &gt; sub_pack_type;
<a name="l11867"></a>11867 
<a name="l11868"></a>11868     <span class="keyword">typedef</span> <span class="keyword">typename</span> sub_pack_type::type <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>;
<a name="l11869"></a>11869 
<a name="l11870"></a>11870     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span>
<a name="l11871"></a>11871     <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l11872"></a>11872         <span class="keyword">const</span> transfrom_type&amp; trans, 
<a name="l11873"></a>11873         <span class="keyword">const</span> input_iterator_type&amp; org,
<a name="l11874"></a>11874         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l11875"></a>11875     {
<a name="l11876"></a>11876         <a class="code" href="group__array__tools.html#ga86cbd758c7c991ccb4aac651392c5e84">sub_pack_type::set</a>(res, org.i0
<a name="l11877"></a>11877             +(n0_ != -1 ? trans.i0*org.i1 : 0)
<a name="l11878"></a>11878             ,
<a name="l11879"></a>11879             org.i1
<a name="l11880"></a>11880         );
<a name="l11881"></a>11881         
<a name="l11882"></a>11882     }
<a name="l11883"></a>11883 
<a name="l11884"></a>11884     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span>
<a name="l11885"></a>11885     <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l11886"></a>11886         <span class="keyword">const</span> transfrom_type&amp; trans, 
<a name="l11887"></a>11887         <span class="keyword">const</span> input_iterator_type&amp; org,
<a name="l11888"></a>11888         <span class="keyword">const</span> input_size_type_&amp;, 
<a name="l11889"></a>11889         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l11890"></a>11890     {
<a name="l11891"></a>11891         <a class="code" href="group__array__tools.html#ga86cbd758c7c991ccb4aac651392c5e84">sub_pack_type::set</a>(res, org.i0
<a name="l11892"></a>11892             +(n0_ != -1 ? trans.i0*org.i1 : 0)
<a name="l11893"></a>11893             ,
<a name="l11894"></a>11894             org.i1
<a name="l11895"></a>11895         );
<a name="l11896"></a>11896         
<a name="l11897"></a>11897     }
<a name="l11898"></a>11898 
<a name="l11899"></a>11899 <span class="keyword">private</span>:
<a name="l11900"></a>11900     <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::compile_time_assert&lt;transfrom_type::size_type::n == input_size_type_::n&gt;
<a name="l11901"></a>11901         ::verified verified;
<a name="l11902"></a>11902 };
<a name="l11903"></a>11903 
<a name="l11904"></a>11904 <span class="comment">/***********************************************************************************************************/</span>
<a name="l11905"></a>11905 
<a name="l11906"></a>11906 <span class="keyword">template</span>&lt;
<a name="l11907"></a>11907     <span class="keywordtype">int</span> n0_,
<a name="l11908"></a>11908     <span class="keywordtype">int</span> n1_,
<a name="l11909"></a>11909     <span class="keyword">typename</span> base_iterator_type_,
<a name="l11910"></a>11910     <span class="keyword">typename</span> type0_,
<a name="l11911"></a>11911     <span class="keyword">typename</span> type1_,
<a name="l11912"></a>11912     <span class="keyword">typename</span> input_size_type_
<a name="l11913"></a>11913     &gt;
<a name="l11914"></a>11914 <span class="keyword">struct </span>iterator_transformer&lt;
<a name="l11915"></a>11915     block&lt;
<a name="l11916"></a>11916         n0_,
<a name="l11917"></a>11917         n1_
<a name="l11918"></a>11918     &gt;,
<a name="l11919"></a>11919     pack&lt;
<a name="l11920"></a>11920         base_iterator_type_,
<a name="l11921"></a>11921         type0_,
<a name="l11922"></a>11922         type1_
<a name="l11923"></a>11923     &gt;,
<a name="l11924"></a>11924     input_size_type_
<a name="l11925"></a>11925     &gt;
<a name="l11926"></a>11926 {
<a name="l11927"></a>11927     <span class="keyword">typedef</span> block&lt;
<a name="l11928"></a>11928         n0_,
<a name="l11929"></a>11929         n1_
<a name="l11930"></a>11930         &gt; transfrom_type;
<a name="l11931"></a>11931 
<a name="l11932"></a>11932     <span class="keyword">typedef</span> pack&lt;
<a name="l11933"></a>11933         base_iterator_type_,
<a name="l11934"></a>11934         type0_,
<a name="l11935"></a>11935         type1_
<a name="l11936"></a>11936         &gt; input_iterator_type;
<a name="l11937"></a>11937 
<a name="l11938"></a>11938     <span class="keyword">typedef</span> sub_pack&lt;
<a name="l11939"></a>11939         input_iterator_type,
<a name="l11940"></a>11940         <span class="keyword">true</span>,
<a name="l11941"></a>11941         n0_!=0,
<a name="l11942"></a>11942         n1_!=0
<a name="l11943"></a>11943         &gt; sub_pack_type;
<a name="l11944"></a>11944 
<a name="l11945"></a>11945     <span class="keyword">typedef</span> <span class="keyword">typename</span> sub_pack_type::type <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>;
<a name="l11946"></a>11946 
<a name="l11947"></a>11947     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span>
<a name="l11948"></a>11948     <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l11949"></a>11949         <span class="keyword">const</span> transfrom_type&amp; trans, 
<a name="l11950"></a>11950         <span class="keyword">const</span> input_iterator_type&amp; org,
<a name="l11951"></a>11951         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l11952"></a>11952     {
<a name="l11953"></a>11953         <a class="code" href="group__array__tools.html#ga86cbd758c7c991ccb4aac651392c5e84">sub_pack_type::set</a>(res, org.i0
<a name="l11954"></a>11954             +(n0_ != -1 ? trans.i0*org.i1 : 0)
<a name="l11955"></a>11955             +(n1_ != -1 ? trans.i1*org.i2 : 0)
<a name="l11956"></a>11956             ,
<a name="l11957"></a>11957             org.i1,
<a name="l11958"></a>11958             org.i2
<a name="l11959"></a>11959         );
<a name="l11960"></a>11960         
<a name="l11961"></a>11961     }
<a name="l11962"></a>11962 
<a name="l11963"></a>11963     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span>
<a name="l11964"></a>11964     <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l11965"></a>11965         <span class="keyword">const</span> transfrom_type&amp; trans, 
<a name="l11966"></a>11966         <span class="keyword">const</span> input_iterator_type&amp; org,
<a name="l11967"></a>11967         <span class="keyword">const</span> input_size_type_&amp;, 
<a name="l11968"></a>11968         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l11969"></a>11969     {
<a name="l11970"></a>11970         <a class="code" href="group__array__tools.html#ga86cbd758c7c991ccb4aac651392c5e84">sub_pack_type::set</a>(res, org.i0
<a name="l11971"></a>11971             +(n0_ != -1 ? trans.i0*org.i1 : 0)
<a name="l11972"></a>11972             +(n1_ != -1 ? trans.i1*org.i2 : 0)
<a name="l11973"></a>11973             ,
<a name="l11974"></a>11974             org.i1,
<a name="l11975"></a>11975             org.i2
<a name="l11976"></a>11976         );
<a name="l11977"></a>11977         
<a name="l11978"></a>11978     }
<a name="l11979"></a>11979 
<a name="l11980"></a>11980 <span class="keyword">private</span>:
<a name="l11981"></a>11981     <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::compile_time_assert&lt;transfrom_type::size_type::n == input_size_type_::n&gt;
<a name="l11982"></a>11982         ::verified verified;
<a name="l11983"></a>11983 };
<a name="l11984"></a>11984 
<a name="l11985"></a>11985 <span class="comment">/***********************************************************************************************************/</span>
<a name="l11986"></a>11986 
<a name="l11987"></a>11987 <span class="keyword">template</span>&lt;
<a name="l11988"></a>11988     <span class="keywordtype">int</span> n0_,
<a name="l11989"></a>11989     <span class="keywordtype">int</span> n1_,
<a name="l11990"></a>11990     <span class="keywordtype">int</span> n2_,
<a name="l11991"></a>11991     <span class="keyword">typename</span> base_iterator_type_,
<a name="l11992"></a>11992     <span class="keyword">typename</span> type0_,
<a name="l11993"></a>11993     <span class="keyword">typename</span> type1_,
<a name="l11994"></a>11994     <span class="keyword">typename</span> type2_,
<a name="l11995"></a>11995     <span class="keyword">typename</span> input_size_type_
<a name="l11996"></a>11996     &gt;
<a name="l11997"></a>11997 <span class="keyword">struct </span>iterator_transformer&lt;
<a name="l11998"></a>11998     block&lt;
<a name="l11999"></a>11999         n0_,
<a name="l12000"></a>12000         n1_,
<a name="l12001"></a>12001         n2_
<a name="l12002"></a>12002     &gt;,
<a name="l12003"></a>12003     pack&lt;
<a name="l12004"></a>12004         base_iterator_type_,
<a name="l12005"></a>12005         type0_,
<a name="l12006"></a>12006         type1_,
<a name="l12007"></a>12007         type2_
<a name="l12008"></a>12008     &gt;,
<a name="l12009"></a>12009     input_size_type_
<a name="l12010"></a>12010     &gt;
<a name="l12011"></a>12011 {
<a name="l12012"></a>12012     <span class="keyword">typedef</span> block&lt;
<a name="l12013"></a>12013         n0_,
<a name="l12014"></a>12014         n1_,
<a name="l12015"></a>12015         n2_
<a name="l12016"></a>12016         &gt; transfrom_type;
<a name="l12017"></a>12017 
<a name="l12018"></a>12018     <span class="keyword">typedef</span> pack&lt;
<a name="l12019"></a>12019         base_iterator_type_,
<a name="l12020"></a>12020         type0_,
<a name="l12021"></a>12021         type1_,
<a name="l12022"></a>12022         type2_
<a name="l12023"></a>12023         &gt; input_iterator_type;
<a name="l12024"></a>12024 
<a name="l12025"></a>12025     <span class="keyword">typedef</span> sub_pack&lt;
<a name="l12026"></a>12026         input_iterator_type,
<a name="l12027"></a>12027         <span class="keyword">true</span>,
<a name="l12028"></a>12028         n0_!=0,
<a name="l12029"></a>12029         n1_!=0,
<a name="l12030"></a>12030         n2_!=0
<a name="l12031"></a>12031         &gt; sub_pack_type;
<a name="l12032"></a>12032 
<a name="l12033"></a>12033     <span class="keyword">typedef</span> <span class="keyword">typename</span> sub_pack_type::type <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>;
<a name="l12034"></a>12034 
<a name="l12035"></a>12035     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span>
<a name="l12036"></a>12036     <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l12037"></a>12037         <span class="keyword">const</span> transfrom_type&amp; trans, 
<a name="l12038"></a>12038         <span class="keyword">const</span> input_iterator_type&amp; org,
<a name="l12039"></a>12039         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l12040"></a>12040     {
<a name="l12041"></a>12041         <a class="code" href="group__array__tools.html#ga86cbd758c7c991ccb4aac651392c5e84">sub_pack_type::set</a>(res, org.i0
<a name="l12042"></a>12042             +(n0_ != -1 ? trans.i0*org.i1 : 0)
<a name="l12043"></a>12043             +(n1_ != -1 ? trans.i1*org.i2 : 0)
<a name="l12044"></a>12044             +(n2_ != -1 ? trans.i2*org.i3 : 0)
<a name="l12045"></a>12045             ,
<a name="l12046"></a>12046             org.i1,
<a name="l12047"></a>12047             org.i2,
<a name="l12048"></a>12048             org.i3
<a name="l12049"></a>12049         );
<a name="l12050"></a>12050         
<a name="l12051"></a>12051     }
<a name="l12052"></a>12052 
<a name="l12053"></a>12053     <span class="keyword">static</span> LITE_INLINE <span class="keywordtype">void</span>
<a name="l12054"></a>12054     <a class="code" href="structlite_1_1iterator__transformer.html#a371f07043c12cf4908a6a8a4bf6d6651" title="Apply the transform to the iterator object org and store the result in res.">transform</a>(
<a name="l12055"></a>12055         <span class="keyword">const</span> transfrom_type&amp; trans, 
<a name="l12056"></a>12056         <span class="keyword">const</span> input_iterator_type&amp; org,
<a name="l12057"></a>12057         <span class="keyword">const</span> input_size_type_&amp;, 
<a name="l12058"></a>12058         <a class="code" href="structlite_1_1iterator__transformer.html#af28662db0ba0c7e25060b7e47d466ecd" title="The type of the resulting iterator object after applying the transform.">iterator_type</a>&amp; res)
<a name="l12059"></a>12059     {
<a name="l12060"></a>12060         <a class="code" href="group__array__tools.html#ga86cbd758c7c991ccb4aac651392c5e84">sub_pack_type::set</a>(res, org.i0
<a name="l12061"></a>12061             +(n0_ != -1 ? trans.i0*org.i1 : 0)
<a name="l12062"></a>12062             +(n1_ != -1 ? trans.i1*org.i2 : 0)
<a name="l12063"></a>12063             +(n2_ != -1 ? trans.i2*org.i3 : 0)
<a name="l12064"></a>12064             ,
<a name="l12065"></a>12065             org.i1,
<a name="l12066"></a>12066             org.i2,
<a name="l12067"></a>12067             org.i3
<a name="l12068"></a>12068         );
<a name="l12069"></a>12069         
<a name="l12070"></a>12070     }
<a name="l12071"></a>12071 
<a name="l12072"></a>12072 <span class="keyword">private</span>:
<a name="l12073"></a>12073     <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::compile_time_assert&lt;transfrom_type::size_type::n == input_size_type_::n&gt;
<a name="l12074"></a>12074         ::verified verified;
<a name="l12075"></a>12075 };
<a name="l12076"></a>12076 
<a name="l12077"></a>12077 <span class="comment">/***********************************************************************************************************/</span>
<a name="l12078"></a>12078 
<a name="l12079"></a>12079 <span class="comment">/***********************************************************************************************************/</span>
<a name="l12080"></a>12080 <span class="comment">/* array_signature_traits **********************************************************************************/</span>
<a name="l12081"></a>12081 <span class="comment">/***********************************************************************************************************/</span>
<a name="l12082"></a>12082 
<a name="l12083"></a>12083 <span class="preprocessor">#ifdef DOCUMENTATION_ONLY</span>
<a name="l12084"></a>12084 <span class="preprocessor"></span>
<a name="l12091"></a>12091 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> base_iterator_type_&gt;
<a name="l12092"></a><a class="code" href="structlite_1_1array__signature__traits.html">12092</a> <span class="keyword">struct </span><a class="code" href="structlite_1_1array__signature__traits.html" title="This can be used to extract information from array signatures and get the appropriate...">array_signature_traits</a>
<a name="l12093"></a>12093 {
<a name="l12095"></a><a class="code" href="structlite_1_1array__signature__traits.html#a8f5ba955635931e1e39566ca1952a62c">12095</a>     <span class="keyword">typedef</span> ??? <a class="code" href="structlite_1_1array__signature__traits.html#a8f5ba955635931e1e39566ca1952a62c" title="The element type of the array (this may include CV qualifiers).">element_type</a>;
<a name="l12096"></a>12096 
<a name="l12098"></a><a class="code" href="structlite_1_1array__signature__traits.html#ae622ac197c0de01503a09dc242953dde">12098</a>     <span class="keyword">typedef</span> ??? <a class="code" href="structlite_1_1array__signature__traits.html#ae622ac197c0de01503a09dc242953dde" title="The value type of an array.">value_type</a>;
<a name="l12099"></a>12099 
<a name="l12100"></a>12100     <span class="keyword">typedef</span> signature_ signature;
<a name="l12101"></a>12101 
<a name="l12106"></a><a class="code" href="structlite_1_1array__signature__traits.html#a809eda60947db3b87f241bb9213716f1">12106</a>     <span class="keyword">typedef</span> ??? <a class="code" href="structlite_1_1array__signature__traits.html#a809eda60947db3b87f241bb9213716f1" title="element_type* if base_iterator_type_ is not provided otherwise the same as base_iterator_type_...">base_iterator_type</a>;
<a name="l12107"></a>12107 
<a name="l12113"></a><a class="code" href="structlite_1_1array__signature__traits.html#aec3723de0e7c30e35250c71a182f87a4">12113</a>     <span class="keyword">typedef</span> ??? <a class="code" href="structlite_1_1array__signature__traits.html#aec3723de0e7c30e35250c71a182f87a4" title="The appropriate lite::s_iterator type matching the signature signature_ assuming...">default_iterator</a>;
<a name="l12114"></a>12114 
<a name="l12120"></a><a class="code" href="structlite_1_1array__signature__traits.html#aad9aa6a940da8a32c51dc4c88e36b531">12120</a>     <span class="keyword">typedef</span> ??? <a class="code" href="structlite_1_1array__signature__traits.html#aad9aa6a940da8a32c51dc4c88e36b531" title="The appropriate lite::s_iterator type matching the signature signature_ assuming...">default_rev_iterator</a>;
<a name="l12121"></a>12121 
<a name="l12123"></a><a class="code" href="structlite_1_1array__signature__traits.html#ab7d4db55281d431dd779b36bf88b981a">12123</a>     <span class="keyword">typedef</span> ??? <a class="code" href="structlite_1_1array__signature__traits.html#ab7d4db55281d431dd779b36bf88b981a" title="The appropriate size type for the signature signature_.">size_type</a>;
<a name="l12124"></a>12124 
<a name="l12126"></a><a class="code" href="structlite_1_1array__signature__traits.html#a9194d68d88b6cab11b1cca39787be42d">12126</a>     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="structlite_1_1array__signature__traits.html#a9194d68d88b6cab11b1cca39787be42d" title="The number of dimensions in the array signature signature_.">dimensions</a> = ???;
<a name="l12127"></a>12127 
<a name="l12129"></a><a class="code" href="structlite_1_1array__signature__traits.html#af4a2d8c1954fb6fd1614080dbdd657ad">12129</a>     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="structlite_1_1array__signature__traits.html#af4a2d8c1954fb6fd1614080dbdd657ad" title="The total number of elements in an array with the signature signature_.">volume</a> = ???;
<a name="l12130"></a>12130 
<a name="l12132"></a><a class="code" href="structlite_1_1array__signature__traits.html#afd72cf694e5dac368a28d9842743ad1f">12132</a>     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="structlite_1_1array__signature__traits.html#afd72cf694e5dac368a28d9842743ad1f" title="True if the signature has no variable size dimension (i.e. dimension of size 1).">is_fixed_size</a> = ???;
<a name="l12133"></a>12133 };
<a name="l12134"></a>12134 
<a name="l12135"></a>12135 <span class="preprocessor">#else // DOCUMENTATION_ONLY</span>
<a name="l12136"></a>12136 <span class="preprocessor"></span>
<a name="l12137"></a>12137 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> element_type_, <span class="keyword">typename</span> base_iterator_type_&gt;
<a name="l12138"></a>12138 <span class="keyword">struct </span><a class="code" href="structlite_1_1array__signature__traits.html" title="This can be used to extract information from array signatures and get the appropriate...">array_signature_traits</a>
<a name="l12139"></a>12139 {
<a name="l12140"></a>12140     <span class="keyword">typedef</span> element_type_ <a class="code" href="structlite_1_1array__signature__traits.html#a8f5ba955635931e1e39566ca1952a62c" title="The element type of the array (this may include CV qualifiers).">element_type</a>;
<a name="l12141"></a>12141     <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::remove&lt;element_type_, volatile const int&gt;::type <a class="code" href="structlite_1_1array__signature__traits.html#ae622ac197c0de01503a09dc242953dde" title="The value type of an array.">value_type</a>;
<a name="l12142"></a>12142     <span class="keyword">typedef</span> <a class="code" href="structlite_1_1array__signature__traits.html#ae622ac197c0de01503a09dc242953dde" title="The value type of an array.">value_type</a> signature;
<a name="l12143"></a>12143 
<a name="l12144"></a>12144     <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::type_if&lt;
<a name="l12145"></a>12145         detail::same_type&lt;base_iterator_type_, void&gt;::result,
<a name="l12146"></a>12146         element_type_*,
<a name="l12147"></a>12147         base_iterator_type_
<a name="l12148"></a>12148         &gt;::type <a class="code" href="structlite_1_1array__signature__traits.html#a809eda60947db3b87f241bb9213716f1" title="element_type* if base_iterator_type_ is not provided otherwise the same as base_iterator_type_...">base_iterator_type</a>;
<a name="l12149"></a>12149 
<a name="l12150"></a>12150     <span class="keyword">typedef</span> <a class="code" href="classlite_1_1pack.html" title="This is a general tuple class that can pack together elements of different types...">pack&lt;base_iterator_type&gt;</a> <a class="code" href="structlite_1_1array__signature__traits.html#aec3723de0e7c30e35250c71a182f87a4" title="The appropriate lite::s_iterator type matching the signature signature_ assuming...">default_iterator</a>;
<a name="l12151"></a>12151     <span class="keyword">typedef</span> <a class="code" href="classlite_1_1pack.html" title="This is a general tuple class that can pack together elements of different types...">pack&lt;base_iterator_type&gt;</a> <a class="code" href="structlite_1_1array__signature__traits.html#aad9aa6a940da8a32c51dc4c88e36b531" title="The appropriate lite::s_iterator type matching the signature signature_ assuming...">default_rev_iterator</a>;
<a name="l12152"></a>12152     <span class="keyword">typedef</span> <a class="code" href="classlite_1_1pack.html" title="This is a general tuple class that can pack together elements of different types...">pack&lt;&gt;</a> <a class="code" href="structlite_1_1array__signature__traits.html#ab7d4db55281d431dd779b36bf88b981a" title="The appropriate size type for the signature signature_.">size_type</a>;
<a name="l12153"></a>12153 
<a name="l12154"></a>12154     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="structlite_1_1array__signature__traits.html#a9194d68d88b6cab11b1cca39787be42d" title="The number of dimensions in the array signature signature_.">dimensions</a> = 0;
<a name="l12155"></a>12155     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="structlite_1_1array__signature__traits.html#af4a2d8c1954fb6fd1614080dbdd657ad" title="The total number of elements in an array with the signature signature_.">volume</a> = 1;
<a name="l12156"></a>12156     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="structlite_1_1array__signature__traits.html#afd72cf694e5dac368a28d9842743ad1f" title="True if the signature has no variable size dimension (i.e. dimension of size 1).">is_fixed_size</a> = <span class="keyword">true</span>;
<a name="l12157"></a>12157 };
<a name="l12158"></a>12158 
<a name="l12159"></a>12159 <span class="keyword">template</span>&lt;
<a name="l12160"></a>12160     <span class="keyword">typename</span> element_type_,
<a name="l12161"></a>12161     <span class="keywordtype">int</span> n0_, 
<a name="l12162"></a>12162     <span class="keyword">typename</span> base_iterator_type_&gt;
<a name="l12163"></a>12163 <span class="keyword">struct </span>array_signature_traits&lt;
<a name="l12164"></a>12164     element_type_[n0_],
<a name="l12165"></a>12165     base_iterator_type_&gt;
<a name="l12166"></a>12166 {
<a name="l12167"></a>12167     <span class="keyword">typedef</span> element_type_ <a class="code" href="structlite_1_1array__signature__traits.html#a8f5ba955635931e1e39566ca1952a62c" title="The element type of the array (this may include CV qualifiers).">element_type</a>;
<a name="l12168"></a>12168     <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::remove&lt;element_type_, volatile const int&gt;::type <a class="code" href="structlite_1_1array__signature__traits.html#ae622ac197c0de01503a09dc242953dde" title="The value type of an array.">value_type</a>;
<a name="l12169"></a>12169     <span class="keyword">typedef</span> <a class="code" href="structlite_1_1array__signature__traits.html#ae622ac197c0de01503a09dc242953dde" title="The value type of an array.">value_type</a> signature[n0_];
<a name="l12170"></a>12170 
<a name="l12171"></a>12171     <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::type_if&lt;
<a name="l12172"></a>12172         detail::same_type&lt;base_iterator_type_, void&gt;::result,
<a name="l12173"></a>12173         element_type_*,
<a name="l12174"></a>12174         base_iterator_type_
<a name="l12175"></a>12175         &gt;::type <a class="code" href="structlite_1_1array__signature__traits.html#a809eda60947db3b87f241bb9213716f1" title="element_type* if base_iterator_type_ is not provided otherwise the same as base_iterator_type_...">base_iterator_type</a>;
<a name="l12176"></a>12176 
<a name="l12177"></a>12177     <span class="keyword">typedef</span> pack&lt;
<a name="l12178"></a>12178         <a class="code" href="structlite_1_1array__signature__traits.html#a809eda60947db3b87f241bb9213716f1" title="element_type* if base_iterator_type_ is not provided otherwise the same as base_iterator_type_...">base_iterator_type</a>,
<a name="l12179"></a>12179         constant&lt;int, 1&gt;
<a name="l12180"></a>12180         &gt; <a class="code" href="structlite_1_1array__signature__traits.html#aec3723de0e7c30e35250c71a182f87a4" title="The appropriate lite::s_iterator type matching the signature signature_ assuming...">default_iterator</a>;
<a name="l12181"></a>12181 
<a name="l12182"></a>12182     <span class="keyword">typedef</span> pack&lt;
<a name="l12183"></a>12183         <a class="code" href="structlite_1_1array__signature__traits.html#a809eda60947db3b87f241bb9213716f1" title="element_type* if base_iterator_type_ is not provided otherwise the same as base_iterator_type_...">base_iterator_type</a>,
<a name="l12184"></a>12184         constant&lt;int, 1&gt;
<a name="l12185"></a>12185         &gt; <a class="code" href="structlite_1_1array__signature__traits.html#aad9aa6a940da8a32c51dc4c88e36b531" title="The appropriate lite::s_iterator type matching the signature signature_ assuming...">default_rev_iterator</a>;
<a name="l12186"></a>12186 
<a name="l12187"></a>12187     <span class="keyword">typedef</span> pack&lt;
<a name="l12188"></a>12188         <span class="keyword">typename</span> detail::type_if&lt;n0_ == 1, int, constant&lt;int, n0_&gt; &gt;::type
<a name="l12189"></a>12189         &gt; <a class="code" href="structlite_1_1array__signature__traits.html#ab7d4db55281d431dd779b36bf88b981a" title="The appropriate size type for the signature signature_.">size_type</a>;
<a name="l12190"></a>12190 
<a name="l12191"></a>12191     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="structlite_1_1array__signature__traits.html#a9194d68d88b6cab11b1cca39787be42d" title="The number of dimensions in the array signature signature_.">dimensions</a> = 1;
<a name="l12192"></a>12192     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="structlite_1_1array__signature__traits.html#af4a2d8c1954fb6fd1614080dbdd657ad" title="The total number of elements in an array with the signature signature_.">volume</a> = n0_;
<a name="l12193"></a>12193     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="structlite_1_1array__signature__traits.html#afd72cf694e5dac368a28d9842743ad1f" title="True if the signature has no variable size dimension (i.e. dimension of size 1).">is_fixed_size</a> = n0_!=1;
<a name="l12194"></a>12194 };
<a name="l12195"></a>12195 
<a name="l12196"></a>12196 <span class="keyword">template</span>&lt;
<a name="l12197"></a>12197     <span class="keyword">typename</span> element_type_,
<a name="l12198"></a>12198     <span class="keywordtype">int</span> n0_, 
<a name="l12199"></a>12199     <span class="keywordtype">int</span> n1_, 
<a name="l12200"></a>12200     <span class="keyword">typename</span> base_iterator_type_&gt;
<a name="l12201"></a>12201 <span class="keyword">struct </span>array_signature_traits&lt;
<a name="l12202"></a>12202     element_type_[n0_][n1_],
<a name="l12203"></a>12203     base_iterator_type_&gt;
<a name="l12204"></a>12204 {
<a name="l12205"></a>12205     <span class="keyword">typedef</span> element_type_ <a class="code" href="structlite_1_1array__signature__traits.html#a8f5ba955635931e1e39566ca1952a62c" title="The element type of the array (this may include CV qualifiers).">element_type</a>;
<a name="l12206"></a>12206     <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::remove&lt;element_type_, volatile const int&gt;::type <a class="code" href="structlite_1_1array__signature__traits.html#ae622ac197c0de01503a09dc242953dde" title="The value type of an array.">value_type</a>;
<a name="l12207"></a>12207     <span class="keyword">typedef</span> <a class="code" href="structlite_1_1array__signature__traits.html#ae622ac197c0de01503a09dc242953dde" title="The value type of an array.">value_type</a> signature[n0_][n1_];
<a name="l12208"></a>12208 
<a name="l12209"></a>12209     <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::type_if&lt;
<a name="l12210"></a>12210         detail::same_type&lt;base_iterator_type_, void&gt;::result,
<a name="l12211"></a>12211         element_type_*,
<a name="l12212"></a>12212         base_iterator_type_
<a name="l12213"></a>12213         &gt;::type <a class="code" href="structlite_1_1array__signature__traits.html#a809eda60947db3b87f241bb9213716f1" title="element_type* if base_iterator_type_ is not provided otherwise the same as base_iterator_type_...">base_iterator_type</a>;
<a name="l12214"></a>12214 
<a name="l12215"></a>12215     <span class="keyword">typedef</span> pack&lt;
<a name="l12216"></a>12216         <a class="code" href="structlite_1_1array__signature__traits.html#a809eda60947db3b87f241bb9213716f1" title="element_type* if base_iterator_type_ is not provided otherwise the same as base_iterator_type_...">base_iterator_type</a>,
<a name="l12217"></a>12217         <span class="keyword">typename</span> detail::type_if&lt;(n1_==1), int, constant&lt;int, n1_&gt; &gt;::type,
<a name="l12218"></a>12218         constant&lt;int, 1&gt;
<a name="l12219"></a>12219         &gt; <a class="code" href="structlite_1_1array__signature__traits.html#aec3723de0e7c30e35250c71a182f87a4" title="The appropriate lite::s_iterator type matching the signature signature_ assuming...">default_iterator</a>;
<a name="l12220"></a>12220 
<a name="l12221"></a>12221     <span class="keyword">typedef</span> pack&lt;
<a name="l12222"></a>12222         <a class="code" href="structlite_1_1array__signature__traits.html#a809eda60947db3b87f241bb9213716f1" title="element_type* if base_iterator_type_ is not provided otherwise the same as base_iterator_type_...">base_iterator_type</a>,
<a name="l12223"></a>12223         constant&lt;int, 1&gt;,
<a name="l12224"></a>12224         <span class="keyword">typename</span> detail::type_if&lt;(n0_==1), int, constant&lt;int, n0_&gt; &gt;::type
<a name="l12225"></a>12225         &gt; <a class="code" href="structlite_1_1array__signature__traits.html#aad9aa6a940da8a32c51dc4c88e36b531" title="The appropriate lite::s_iterator type matching the signature signature_ assuming...">default_rev_iterator</a>;
<a name="l12226"></a>12226 
<a name="l12227"></a>12227     <span class="keyword">typedef</span> pack&lt;
<a name="l12228"></a>12228         <span class="keyword">typename</span> detail::type_if&lt;n0_ == 1, int, constant&lt;int, n0_&gt; &gt;::type,
<a name="l12229"></a>12229         <span class="keyword">typename</span> detail::type_if&lt;n1_ == 1, int, constant&lt;int, n1_&gt; &gt;::type
<a name="l12230"></a>12230         &gt; <a class="code" href="structlite_1_1array__signature__traits.html#ab7d4db55281d431dd779b36bf88b981a" title="The appropriate size type for the signature signature_.">size_type</a>;
<a name="l12231"></a>12231 
<a name="l12232"></a>12232     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="structlite_1_1array__signature__traits.html#a9194d68d88b6cab11b1cca39787be42d" title="The number of dimensions in the array signature signature_.">dimensions</a> = 2;
<a name="l12233"></a>12233     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="structlite_1_1array__signature__traits.html#af4a2d8c1954fb6fd1614080dbdd657ad" title="The total number of elements in an array with the signature signature_.">volume</a> = n0_ * n1_;
<a name="l12234"></a>12234     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="structlite_1_1array__signature__traits.html#afd72cf694e5dac368a28d9842743ad1f" title="True if the signature has no variable size dimension (i.e. dimension of size 1).">is_fixed_size</a> = n0_!=1 &amp;&amp; n1_!=1;
<a name="l12235"></a>12235 };
<a name="l12236"></a>12236 
<a name="l12237"></a>12237 <span class="keyword">template</span>&lt;
<a name="l12238"></a>12238     <span class="keyword">typename</span> element_type_,
<a name="l12239"></a>12239     <span class="keywordtype">int</span> n0_, 
<a name="l12240"></a>12240     <span class="keywordtype">int</span> n1_, 
<a name="l12241"></a>12241     <span class="keywordtype">int</span> n2_, 
<a name="l12242"></a>12242     <span class="keyword">typename</span> base_iterator_type_&gt;
<a name="l12243"></a>12243 <span class="keyword">struct </span>array_signature_traits&lt;
<a name="l12244"></a>12244     element_type_[n0_][n1_][n2_],
<a name="l12245"></a>12245     base_iterator_type_&gt;
<a name="l12246"></a>12246 {
<a name="l12247"></a>12247     <span class="keyword">typedef</span> element_type_ <a class="code" href="structlite_1_1array__signature__traits.html#a8f5ba955635931e1e39566ca1952a62c" title="The element type of the array (this may include CV qualifiers).">element_type</a>;
<a name="l12248"></a>12248     <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::remove&lt;element_type_, volatile const int&gt;::type <a class="code" href="structlite_1_1array__signature__traits.html#ae622ac197c0de01503a09dc242953dde" title="The value type of an array.">value_type</a>;
<a name="l12249"></a>12249     <span class="keyword">typedef</span> <a class="code" href="structlite_1_1array__signature__traits.html#ae622ac197c0de01503a09dc242953dde" title="The value type of an array.">value_type</a> signature[n0_][n1_][n2_];
<a name="l12250"></a>12250 
<a name="l12251"></a>12251     <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::type_if&lt;
<a name="l12252"></a>12252         detail::same_type&lt;base_iterator_type_, void&gt;::result,
<a name="l12253"></a>12253         element_type_*,
<a name="l12254"></a>12254         base_iterator_type_
<a name="l12255"></a>12255         &gt;::type <a class="code" href="structlite_1_1array__signature__traits.html#a809eda60947db3b87f241bb9213716f1" title="element_type* if base_iterator_type_ is not provided otherwise the same as base_iterator_type_...">base_iterator_type</a>;
<a name="l12256"></a>12256 
<a name="l12257"></a>12257     <span class="keyword">typedef</span> pack&lt;
<a name="l12258"></a>12258         <a class="code" href="structlite_1_1array__signature__traits.html#a809eda60947db3b87f241bb9213716f1" title="element_type* if base_iterator_type_ is not provided otherwise the same as base_iterator_type_...">base_iterator_type</a>,
<a name="l12259"></a>12259         <span class="keyword">typename</span> detail::type_if&lt;(n1_==1||n2_==1), int, constant&lt;int, n1_*n2_&gt; &gt;::type,
<a name="l12260"></a>12260         <span class="keyword">typename</span> detail::type_if&lt;(n2_==1), int, constant&lt;int, n2_&gt; &gt;::type,
<a name="l12261"></a>12261         constant&lt;int, 1&gt;
<a name="l12262"></a>12262         &gt; <a class="code" href="structlite_1_1array__signature__traits.html#aec3723de0e7c30e35250c71a182f87a4" title="The appropriate lite::s_iterator type matching the signature signature_ assuming...">default_iterator</a>;
<a name="l12263"></a>12263 
<a name="l12264"></a>12264     <span class="keyword">typedef</span> pack&lt;
<a name="l12265"></a>12265         <a class="code" href="structlite_1_1array__signature__traits.html#a809eda60947db3b87f241bb9213716f1" title="element_type* if base_iterator_type_ is not provided otherwise the same as base_iterator_type_...">base_iterator_type</a>,
<a name="l12266"></a>12266         constant&lt;int, 1&gt;,
<a name="l12267"></a>12267         <span class="keyword">typename</span> detail::type_if&lt;(n0_==1), int, constant&lt;int, n0_&gt; &gt;::type,
<a name="l12268"></a>12268         <span class="keyword">typename</span> detail::type_if&lt;(n1_==1||n0_==1), int, constant&lt;int, n1_*n0_&gt; &gt;::type
<a name="l12269"></a>12269         &gt; <a class="code" href="structlite_1_1array__signature__traits.html#aad9aa6a940da8a32c51dc4c88e36b531" title="The appropriate lite::s_iterator type matching the signature signature_ assuming...">default_rev_iterator</a>;
<a name="l12270"></a>12270 
<a name="l12271"></a>12271     <span class="keyword">typedef</span> pack&lt;
<a name="l12272"></a>12272         <span class="keyword">typename</span> detail::type_if&lt;n0_ == 1, int, constant&lt;int, n0_&gt; &gt;::type,
<a name="l12273"></a>12273         <span class="keyword">typename</span> detail::type_if&lt;n1_ == 1, int, constant&lt;int, n1_&gt; &gt;::type,
<a name="l12274"></a>12274         <span class="keyword">typename</span> detail::type_if&lt;n2_ == 1, int, constant&lt;int, n2_&gt; &gt;::type
<a name="l12275"></a>12275         &gt; <a class="code" href="structlite_1_1array__signature__traits.html#ab7d4db55281d431dd779b36bf88b981a" title="The appropriate size type for the signature signature_.">size_type</a>;
<a name="l12276"></a>12276 
<a name="l12277"></a>12277     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="structlite_1_1array__signature__traits.html#a9194d68d88b6cab11b1cca39787be42d" title="The number of dimensions in the array signature signature_.">dimensions</a> = 3;
<a name="l12278"></a>12278     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="structlite_1_1array__signature__traits.html#af4a2d8c1954fb6fd1614080dbdd657ad" title="The total number of elements in an array with the signature signature_.">volume</a> = n0_ * n1_ * n2_;
<a name="l12279"></a>12279     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="structlite_1_1array__signature__traits.html#afd72cf694e5dac368a28d9842743ad1f" title="True if the signature has no variable size dimension (i.e. dimension of size 1).">is_fixed_size</a> = n0_!=1 &amp;&amp; n1_!=1 &amp;&amp; n2_!=1;
<a name="l12280"></a>12280 };
<a name="l12281"></a>12281 
<a name="l12282"></a>12282 
<a name="l12283"></a>12283 
<a name="l12284"></a>12284 <span class="keyword">template</span>&lt;
<a name="l12285"></a>12285     <span class="keyword">typename</span> element_type_,
<a name="l12286"></a>12286     <span class="keywordtype">int</span> n0_, 
<a name="l12287"></a>12287     <span class="keywordtype">int</span> n1_, 
<a name="l12288"></a>12288     <span class="keywordtype">int</span> n2_, 
<a name="l12289"></a>12289     <span class="keywordtype">int</span> n3_, 
<a name="l12290"></a>12290     <span class="keyword">typename</span> base_iterator_type_&gt;
<a name="l12291"></a>12291 <span class="keyword">struct </span>array_signature_traits&lt;
<a name="l12292"></a>12292     element_type_[n0_][n1_][n2_][n3_],
<a name="l12293"></a>12293     base_iterator_type_&gt;
<a name="l12294"></a>12294 {
<a name="l12295"></a>12295     <span class="keyword">typedef</span> element_type_ <a class="code" href="structlite_1_1array__signature__traits.html#a8f5ba955635931e1e39566ca1952a62c" title="The element type of the array (this may include CV qualifiers).">element_type</a>;
<a name="l12296"></a>12296     <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::remove&lt;element_type_, volatile const int&gt;::type <a class="code" href="structlite_1_1array__signature__traits.html#ae622ac197c0de01503a09dc242953dde" title="The value type of an array.">value_type</a>;
<a name="l12297"></a>12297     <span class="keyword">typedef</span> <a class="code" href="structlite_1_1array__signature__traits.html#ae622ac197c0de01503a09dc242953dde" title="The value type of an array.">value_type</a> signature[n0_][n1_][n2_][n3_];
<a name="l12298"></a>12298 
<a name="l12299"></a>12299     <span class="comment">// too many dimensions!</span>
<a name="l12300"></a>12300     <span class="comment">//typedef ??? default_iterator;</span>
<a name="l12301"></a>12301     <span class="comment">//typedef ??? default_rev_iterator;</span>
<a name="l12302"></a>12302     <span class="comment">//typedef ??? size_type;</span>
<a name="l12303"></a>12303 
<a name="l12304"></a>12304     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="structlite_1_1array__signature__traits.html#a9194d68d88b6cab11b1cca39787be42d" title="The number of dimensions in the array signature signature_.">dimensions</a> = 3+1;
<a name="l12305"></a>12305     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="structlite_1_1array__signature__traits.html#af4a2d8c1954fb6fd1614080dbdd657ad" title="The total number of elements in an array with the signature signature_.">volume</a> = n0_ * n1_ * n2_ * n3_;
<a name="l12306"></a>12306     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="structlite_1_1array__signature__traits.html#afd72cf694e5dac368a28d9842743ad1f" title="True if the signature has no variable size dimension (i.e. dimension of size 1).">is_fixed_size</a> = n0_!=1 &amp;&amp; n1_!=1 &amp;&amp; n2_!=1 &amp;&amp; n3_!=1;
<a name="l12307"></a>12307 };
<a name="l12308"></a>12308 
<a name="l12309"></a>12309 <span class="preprocessor">#endif // !DOCUMENTATION_ONLY</span>
<a name="l12310"></a>12310 <span class="preprocessor"></span>
<a name="l12311"></a>12311 <span class="comment">/***********************************************************************************************************/</span>
<a name="l12312"></a>12312 <span class="comment">/* array_helper ********************************************************************************************/</span>
<a name="l12313"></a>12313 <span class="comment">/***********************************************************************************************************/</span>
<a name="l12314"></a>12314 
<a name="l12315"></a>12315 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_&gt;
<a name="l12316"></a>12316 <span class="keyword">struct </span>array_helper
<a name="l12317"></a>12317 {
<a name="l12318"></a>12318     <span class="keyword">typedef</span> array&lt;signature_, traits_type_, 
<a name="l12319"></a>12319         <span class="keyword">typename</span> traits_type_::template representation_type&lt;signature_&gt;::temporary_type&gt; 
<a name="l12320"></a>12320         temporary_array;
<a name="l12321"></a>12321 
<a name="l12322"></a>12322     <span class="keyword">typedef</span> array&lt;signature_, traits_type_, 
<a name="l12323"></a>12323         <span class="keyword">typename</span> traits_type_::template representation_type&lt;signature_&gt;::fwd_temporary_type&gt; 
<a name="l12324"></a>12324         fwd_temporary_array;
<a name="l12325"></a>12325 
<a name="l12326"></a>12326     <span class="keyword">typedef</span> array&lt;signature_, traits_type_, 
<a name="l12327"></a>12327         <span class="keyword">typename</span> traits_type_::template representation_type&lt;signature_&gt;::rev_temporary_type&gt; 
<a name="l12328"></a>12328         rev_temporary_array;
<a name="l12329"></a>12329 };
<a name="l12330"></a>12330 
<a name="l12331"></a>12331 <span class="comment">/***********************************************************************************************************/</span>
<a name="l12332"></a>12332 <span class="comment">/* for_each, helpers ***************************************************************************************/</span>
<a name="l12333"></a>12333 <span class="comment">/***********************************************************************************************************/</span>
<a name="l12334"></a>12334 
<a name="l12335"></a>12335 <span class="keyword">namespace </span>detail
<a name="l12336"></a>12336 {
<a name="l12337"></a>12337 
<a name="l12338"></a>12338 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keywordtype">int</span> dim_=0&gt;
<a name="l12339"></a>12339 <span class="keyword">struct </span>g_iterator_traits;
<a name="l12340"></a>12340 
<a name="l12341"></a>12341 <span class="comment">/***********************************************************************************************************/</span>
<a name="l12342"></a>12342 <span class="comment">/* g_iterator_traits, s_iterator ***************************************************************************/</span>
<a name="l12343"></a>12343 <span class="comment">/***********************************************************************************************************/</span>
<a name="l12344"></a>12344 
<a name="l12345"></a>12345 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> base_iterator_type_&gt;
<a name="l12346"></a>12346 <span class="keyword">struct </span>g_iterator_traits&lt;pack&lt;base_iterator_type_&gt;, 0&gt;
<a name="l12347"></a>12347 {
<a name="l12348"></a>12348     <span class="keyword">typedef</span> pack&lt;base_iterator_type_&gt; iterator_type;
<a name="l12349"></a>12349 
<a name="l12350"></a>12350     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> complexity = 1;
<a name="l12351"></a>12351     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> non_unit_strides_count = 0;
<a name="l12352"></a>12352     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> constant_strides_count = 0;
<a name="l12353"></a>12353     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> variable_strides_count = 0;
<a name="l12354"></a>12354 };
<a name="l12355"></a>12355 
<a name="l12356"></a>12356 <span class="keyword">template</span>&lt;
<a name="l12357"></a>12357     <span class="keyword">typename</span> base_iterator_type_,
<a name="l12358"></a>12358     <span class="keyword">typename</span> type0_,
<a name="l12359"></a>12359     <span class="keyword">typename</span> type1_,
<a name="l12360"></a>12360     <span class="keyword">typename</span> type2_
<a name="l12361"></a>12361     &gt;
<a name="l12362"></a>12362 <span class="keyword">struct </span>g_iterator_traits&lt;
<a name="l12363"></a>12363     pack&lt;
<a name="l12364"></a>12364         base_iterator_type_,
<a name="l12365"></a>12365         type0_,
<a name="l12366"></a>12366         type1_,
<a name="l12367"></a>12367         type2_
<a name="l12368"></a>12368     &gt;,
<a name="l12369"></a>12369     0
<a name="l12370"></a>12370     &gt;   
<a name="l12371"></a>12371 {
<a name="l12372"></a>12372     <span class="keyword">typedef</span> pack&lt;
<a name="l12373"></a>12373         base_iterator_type_,
<a name="l12374"></a>12374         type0_,
<a name="l12375"></a>12375         type1_,
<a name="l12376"></a>12376         type2_
<a name="l12377"></a>12377         &gt; iterator_type;
<a name="l12378"></a>12378 
<a name="l12379"></a>12379     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> complexity = 2;
<a name="l12380"></a>12380     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> non_unit_strides_count = 
<a name="l12381"></a>12381         detail::same_type&lt;type0_, constant&lt;int, 1&gt; &gt;::result ? 0 : 1;
<a name="l12382"></a>12382     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> constant_strides_count = iterator_type::is_const1 ? 1 : 0;
<a name="l12383"></a>12383     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> variable_strides_count = iterator_type::is_const1 ? 0 : 1;
<a name="l12384"></a>12384 };
<a name="l12385"></a>12385 <span class="keyword">template</span>&lt;
<a name="l12386"></a>12386     <span class="keyword">typename</span> base_iterator_type_,
<a name="l12387"></a>12387     <span class="keyword">typename</span> type0_,
<a name="l12388"></a>12388     <span class="keyword">typename</span> type1_,
<a name="l12389"></a>12389     <span class="keyword">typename</span> type2_
<a name="l12390"></a>12390     &gt;
<a name="l12391"></a>12391 <span class="keyword">struct </span>g_iterator_traits&lt;
<a name="l12392"></a>12392     pack&lt;
<a name="l12393"></a>12393         base_iterator_type_,
<a name="l12394"></a>12394         type0_,
<a name="l12395"></a>12395         type1_,
<a name="l12396"></a>12396         type2_
<a name="l12397"></a>12397     &gt;,
<a name="l12398"></a>12398     1
<a name="l12399"></a>12399     &gt;   
<a name="l12400"></a>12400 {
<a name="l12401"></a>12401     <span class="keyword">typedef</span> pack&lt;
<a name="l12402"></a>12402         base_iterator_type_,
<a name="l12403"></a>12403         type0_,
<a name="l12404"></a>12404         type1_,
<a name="l12405"></a>12405         type2_
<a name="l12406"></a>12406         &gt; iterator_type;
<a name="l12407"></a>12407 
<a name="l12408"></a>12408     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> complexity = 2;
<a name="l12409"></a>12409     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> non_unit_strides_count = 
<a name="l12410"></a>12410         detail::same_type&lt;type1_, constant&lt;int, 1&gt; &gt;::result ? 0 : 1;
<a name="l12411"></a>12411     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> constant_strides_count = iterator_type::is_const2 ? 1 : 0;
<a name="l12412"></a>12412     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> variable_strides_count = iterator_type::is_const2 ? 0 : 1;
<a name="l12413"></a>12413 };
<a name="l12414"></a>12414 <span class="keyword">template</span>&lt;
<a name="l12415"></a>12415     <span class="keyword">typename</span> base_iterator_type_,
<a name="l12416"></a>12416     <span class="keyword">typename</span> type0_,
<a name="l12417"></a>12417     <span class="keyword">typename</span> type1_,
<a name="l12418"></a>12418     <span class="keyword">typename</span> type2_
<a name="l12419"></a>12419     &gt;
<a name="l12420"></a>12420 <span class="keyword">struct </span>g_iterator_traits&lt;
<a name="l12421"></a>12421     pack&lt;
<a name="l12422"></a>12422         base_iterator_type_,
<a name="l12423"></a>12423         type0_,
<a name="l12424"></a>12424         type1_,
<a name="l12425"></a>12425         type2_
<a name="l12426"></a>12426     &gt;,
<a name="l12427"></a>12427     2
<a name="l12428"></a>12428     &gt;   
<a name="l12429"></a>12429 {
<a name="l12430"></a>12430     <span class="keyword">typedef</span> pack&lt;
<a name="l12431"></a>12431         base_iterator_type_,
<a name="l12432"></a>12432         type0_,
<a name="l12433"></a>12433         type1_,
<a name="l12434"></a>12434         type2_
<a name="l12435"></a>12435         &gt; iterator_type;
<a name="l12436"></a>12436 
<a name="l12437"></a>12437     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> complexity = 2;
<a name="l12438"></a>12438     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> non_unit_strides_count = 
<a name="l12439"></a>12439         detail::same_type&lt;type2_, constant&lt;int, 1&gt; &gt;::result ? 0 : 1;
<a name="l12440"></a>12440     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> constant_strides_count = iterator_type::is_const3 ? 1 : 0;
<a name="l12441"></a>12441     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> variable_strides_count = iterator_type::is_const3 ? 0 : 1;
<a name="l12442"></a>12442 };
<a name="l12443"></a>12443 
<a name="l12444"></a>12444 <span class="comment">/***********************************************************************************************************/</span>
<a name="l12445"></a>12445 <span class="comment">/* g_iterator_traits, c_iterator ***************************************************************************/</span>
<a name="l12446"></a>12446 <span class="comment">/***********************************************************************************************************/</span>
<a name="l12447"></a>12447 
<a name="l12448"></a>12448 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> value_type_, <span class="keywordtype">int</span> dim_&gt;
<a name="l12449"></a>12449 <span class="keyword">struct </span>g_iterator_traits&lt;c_iterator&lt;value_type_&gt;, dim_&gt;
<a name="l12450"></a>12450 {
<a name="l12451"></a>12451     <span class="keyword">typedef</span> c_iterator&lt;value_type_&gt; iterator_type;
<a name="l12452"></a>12452 
<a name="l12453"></a>12453     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> complexity = 1;
<a name="l12454"></a>12454     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> non_unit_strides_count = 0;
<a name="l12455"></a>12455     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> constant_strides_count = 0;
<a name="l12456"></a>12456     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> variable_strides_count = 0;
<a name="l12457"></a>12457 };
<a name="l12458"></a>12458 
<a name="l12459"></a>12459 <span class="comment">/***********************************************************************************************************/</span>
<a name="l12460"></a>12460 <span class="comment">/* g_iterator_traits, u_iterator ***************************************************************************/</span>
<a name="l12461"></a>12461 <span class="comment">/***********************************************************************************************************/</span>
<a name="l12462"></a>12462 
<a name="l12463"></a>12463 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> base_iter_type_, <span class="keyword">typename</span> func_type_, <span class="keywordtype">bool</span> is_static_, <span class="keywordtype">int</span> dim_&gt;
<a name="l12464"></a>12464 <span class="keyword">struct </span>g_iterator_traits&lt;u_iterator&lt;base_iter_type_, func_type_, is_static_&gt;, dim_&gt;
<a name="l12465"></a>12465 {
<a name="l12466"></a>12466     <span class="keyword">typedef</span> u_iterator&lt;base_iter_type_, func_type_, is_static_&gt; iterator_type;
<a name="l12467"></a>12467 
<a name="l12468"></a>12468     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> complexity = 
<a name="l12469"></a>12469         g_iterator_traits&lt;base_iter_type_, dim_&gt;::complexity+1;
<a name="l12470"></a>12470 
<a name="l12471"></a>12471     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> non_unit_strides_count =
<a name="l12472"></a>12472         g_iterator_traits&lt;base_iter_type_, dim_&gt;::non_unit_strides_count;
<a name="l12473"></a>12473 
<a name="l12474"></a>12474     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> constant_strides_count = 
<a name="l12475"></a>12475         g_iterator_traits&lt;base_iter_type_, dim_&gt;::constant_strides_count;
<a name="l12476"></a>12476 
<a name="l12477"></a>12477     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> variable_strides_count = 
<a name="l12478"></a>12478         g_iterator_traits&lt;base_iter_type_, dim_&gt;::variable_strides_count;
<a name="l12479"></a>12479 };
<a name="l12480"></a>12480 
<a name="l12481"></a>12481 <span class="comment">/***********************************************************************************************************/</span>
<a name="l12482"></a>12482 <span class="comment">/* g_iterator_traits, b_iterator ***************************************************************************/</span>
<a name="l12483"></a>12483 <span class="comment">/***********************************************************************************************************/</span>
<a name="l12484"></a>12484 
<a name="l12485"></a>12485 <span class="keyword">template</span>&lt;
<a name="l12486"></a>12486     <span class="keyword">typename</span> left_base_iter_type_, 
<a name="l12487"></a>12487     <span class="keyword">typename</span> right_base_iter_type_, 
<a name="l12488"></a>12488     <span class="keyword">typename</span> func_type_, 
<a name="l12489"></a>12489     <span class="keywordtype">bool</span> is_static_, 
<a name="l12490"></a>12490     <span class="keywordtype">int</span> dim_&gt;
<a name="l12491"></a>12491 <span class="keyword">struct </span>g_iterator_traits&lt;
<a name="l12492"></a>12492     b_iterator&lt;left_base_iter_type_, right_base_iter_type_, func_type_, is_static_&gt;, dim_&gt;
<a name="l12493"></a>12493 {
<a name="l12494"></a>12494     <span class="keyword">typedef</span> b_iterator&lt;left_base_iter_type_, right_base_iter_type_, func_type_, is_static_&gt; iterator_type;
<a name="l12495"></a>12495 
<a name="l12496"></a>12496     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> complexity = 
<a name="l12497"></a>12497         g_iterator_traits&lt;left_base_iter_type_, dim_&gt;::complexity
<a name="l12498"></a>12498         +g_iterator_traits&lt;right_base_iter_type_, dim_&gt;::complexity+1;
<a name="l12499"></a>12499 
<a name="l12500"></a>12500     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> non_unit_strides_count =
<a name="l12501"></a>12501         g_iterator_traits&lt;left_base_iter_type_, dim_&gt;::non_unit_strides_count
<a name="l12502"></a>12502         +g_iterator_traits&lt;right_base_iter_type_, dim_&gt;::non_unit_strides_count;
<a name="l12503"></a>12503 
<a name="l12504"></a>12504     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> constant_strides_count = 
<a name="l12505"></a>12505         g_iterator_traits&lt;left_base_iter_type_, dim_&gt;::constant_strides_count
<a name="l12506"></a>12506         +g_iterator_traits&lt;right_base_iter_type_, dim_&gt;::constant_strides_count;
<a name="l12507"></a>12507 
<a name="l12508"></a>12508     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> variable_strides_count = 
<a name="l12509"></a>12509         g_iterator_traits&lt;left_base_iter_type_, dim_&gt;::variable_strides_count
<a name="l12510"></a>12510         +g_iterator_traits&lt;right_base_iter_type_, dim_&gt;::variable_strides_count;
<a name="l12511"></a>12511 };
<a name="l12512"></a>12512 
<a name="l12513"></a>12513 <span class="comment">/***********************************************************************************************************/</span>
<a name="l12514"></a>12514 <span class="comment">/* g_iterator_policy ***************************************************************************************/</span>
<a name="l12515"></a>12515 <span class="comment">/***********************************************************************************************************/</span>
<a name="l12516"></a>12516 
<a name="l12517"></a>12517 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keywordtype">int</span> dim_=0&gt;
<a name="l12518"></a>12518 <span class="keyword">struct </span>g_iterator_policy
<a name="l12519"></a>12519 {
<a name="l12520"></a>12520     <span class="keyword">typedef</span> g_iterator_traits&lt;iterator_type_, dim_&gt; traits_type;
<a name="l12521"></a>12521 
<a name="l12522"></a>12522     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> use_index = traits_type::constant_strides_count &gt;= traits_type::variable_strides_count;
<a name="l12523"></a>12523     <span class="comment">//?? add other policy</span>
<a name="l12524"></a>12524 };
<a name="l12525"></a>12525 
<a name="l12526"></a>12526 <span class="comment">/***********************************************************************************************************/</span>
<a name="l12527"></a>12527 <span class="comment">/* matrix_policy *******************************************************************************************/</span>
<a name="l12528"></a>12528 <span class="comment">/***********************************************************************************************************/</span>
<a name="l12529"></a>12529 
<a name="l12530"></a>12530 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> array_type_, <span class="keywordtype">int</span> freq_&gt;
<a name="l12531"></a>12531 <span class="keyword">struct </span>matrix_policy
<a name="l12532"></a>12532 {};
<a name="l12533"></a>12533 
<a name="l12534"></a>12534 <span class="comment">/***********************************************************************************************************/</span>
<a name="l12535"></a>12535 
<a name="l12536"></a>12536 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> value_type_, <span class="keywordtype">int</span> n0_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> _rep, <span class="keywordtype">int</span> freq_&gt;
<a name="l12537"></a>12537 <span class="keyword">struct </span>matrix_policy&lt;array&lt;value_type_[n0_], traits_type_, _rep&gt;, freq_&gt;
<a name="l12538"></a>12538 {
<a name="l12539"></a>12539     <span class="keyword">typedef</span> array&lt;value_type_[n0_], traits_type_, _rep&gt; original_array_type;
<a name="l12540"></a>12540 
<a name="l12541"></a>12541     <span class="keyword">typedef</span> g_iterator_traits&lt;typename original_array_type::iterator, 0&gt; g_iterator_traits0;
<a name="l12542"></a>12542 
<a name="l12543"></a>12543     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> should_cache_dim0 = 
<a name="l12544"></a>12544         freq_ &lt;= 1 ? g_iterator_traits0::complexity &gt; 8 :
<a name="l12545"></a>12545         freq_ &lt;= 2 ? g_iterator_traits0::complexity &gt; 2 || g_iterator_traits0::variable_strides_count &gt; 2 :
<a name="l12546"></a>12546         g_iterator_traits0::complexity &gt; 2 
<a name="l12547"></a>12547         || g_iterator_traits0::variable_strides_count &gt; 0 
<a name="l12548"></a>12548         || g_iterator_traits0::non_unit_strides_count &gt; 0;
<a name="l12549"></a>12549 
<a name="l12550"></a>12550     <span class="keyword">typedef</span> <span class="keyword">typename</span> type_if&lt;
<a name="l12551"></a>12551         should_cache_dim0, 
<a name="l12552"></a>12552         <span class="keyword">typename</span> array_helper&lt;value_type_[n0_], traits_type_&gt;::temporary_array,
<a name="l12553"></a>12553         <span class="keyword">const</span> original_array_type&amp;
<a name="l12554"></a>12554         &gt;::type cached_array;
<a name="l12555"></a>12555 };
<a name="l12556"></a>12556 
<a name="l12557"></a>12557 <span class="comment">/***********************************************************************************************************/</span>
<a name="l12558"></a>12558 
<a name="l12559"></a>12559 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> value_type_, <span class="keywordtype">int</span> n0_, <span class="keywordtype">int</span> n1_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> _rep, <span class="keywordtype">int</span> freq_&gt;
<a name="l12560"></a>12560 <span class="keyword">struct </span>matrix_policy&lt;array&lt;value_type_[n0_][n1_], traits_type_, _rep&gt;,  freq_&gt;
<a name="l12561"></a>12561 {
<a name="l12562"></a>12562     <span class="keyword">typedef</span> array&lt;value_type_[n0_][n1_], traits_type_, _rep&gt; original_array_type;
<a name="l12563"></a>12563 
<a name="l12564"></a>12564     <span class="keyword">typedef</span> g_iterator_traits&lt;typename original_array_type::iterator, 0&gt; g_iterator_traits0;
<a name="l12565"></a>12565     <span class="keyword">typedef</span> g_iterator_traits&lt;typename original_array_type::iterator, 1&gt; g_iterator_traits1;
<a name="l12566"></a>12566 
<a name="l12567"></a>12567     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> should_cache_dim0 = 
<a name="l12568"></a>12568         freq_ &lt;= 1 ? g_iterator_traits0::complexity &gt; 8 :
<a name="l12569"></a>12569         freq_ &lt;= 2 ? g_iterator_traits0::complexity &gt; 2 || g_iterator_traits0::variable_strides_count &gt; 2 :
<a name="l12570"></a>12570         g_iterator_traits0::complexity &gt; 2 
<a name="l12571"></a>12571         || g_iterator_traits0::variable_strides_count &gt; 0
<a name="l12572"></a>12572         || g_iterator_traits0::non_unit_strides_count &gt; 0;
<a name="l12573"></a>12573 
<a name="l12574"></a>12574 
<a name="l12575"></a>12575     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> should_cache_dim1 = 
<a name="l12576"></a>12576         freq_ &lt;= 1 ? g_iterator_traits1::complexity &gt; 8 :
<a name="l12577"></a>12577         freq_ &lt;= 2 ? g_iterator_traits1::complexity &gt; 2 || g_iterator_traits1::variable_strides_count &gt; 2 :
<a name="l12578"></a>12578         g_iterator_traits1::complexity &gt; 2 
<a name="l12579"></a>12579         || g_iterator_traits1::variable_strides_count &gt; 0
<a name="l12580"></a>12580         || g_iterator_traits0::non_unit_strides_count &gt; 0;
<a name="l12581"></a>12581 
<a name="l12582"></a>12582     <span class="keyword">typedef</span> <span class="keyword">typename</span> type_if&lt;
<a name="l12583"></a>12583         should_cache_dim0, 
<a name="l12584"></a>12584         <span class="keyword">typename</span> array_helper&lt;value_type_[n0_][n1_], traits_type_&gt;::fwd_temporary_array,
<a name="l12585"></a>12585         <span class="keyword">const</span> original_array_type&amp;
<a name="l12586"></a>12586         &gt;::type cached_fwd_array;
<a name="l12587"></a>12587 
<a name="l12588"></a>12588     <span class="keyword">typedef</span> <span class="keyword">typename</span> type_if&lt;
<a name="l12589"></a>12589         should_cache_dim1, 
<a name="l12590"></a>12590         <span class="keyword">typename</span> array_helper&lt;value_type_[n0_][n1_], traits_type_&gt;::rev_temporary_array,
<a name="l12591"></a>12591         <span class="keyword">const</span> original_array_type&amp;
<a name="l12592"></a>12592         &gt;::type cached_rev_array;
<a name="l12593"></a>12593 };
<a name="l12594"></a>12594 
<a name="l12595"></a>12595 <span class="comment">/***********************************************************************************************************/</span>
<a name="l12596"></a>12596 
<a name="l12597"></a>12597 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> value_type_, <span class="keywordtype">int</span> n0_, <span class="keywordtype">int</span> n1_, <span class="keywordtype">int</span> n2_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> _rep, <span class="keywordtype">int</span> freq_&gt;
<a name="l12598"></a>12598 <span class="keyword">struct </span>matrix_policy&lt;array&lt;value_type_[n0_][n1_][n2_], traits_type_, _rep&gt;, freq_&gt;
<a name="l12599"></a>12599 {};
<a name="l12600"></a>12600 
<a name="l12601"></a>12601 } <span class="comment">// namespace detail</span>
<a name="l12602"></a>12602 
<a name="l12603"></a>12603 <span class="comment">/***********************************************************************************************************/</span>
<a name="l12604"></a>12604 <span class="comment">/* for_each ************************************************************************************************/</span>
<a name="l12605"></a>12605 <span class="comment">/***********************************************************************************************************/</span>
<a name="l12606"></a>12606 
<a name="l12607"></a>12607 <span class="preprocessor">#ifdef DOCUMENTATION_ONLY</span>
<a name="l12608"></a>12608 <span class="preprocessor"></span>
<a name="l12614"></a>12614 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keyword">typename</span> <span class="keywordtype">size_t</span>ype_&gt;
<a name="l12615"></a>12615 LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(<span class="keyword">const</span> iterator_type_&amp; iter, <span class="keyword">const</span> size_type_&amp; size);
<a name="l12616"></a>12616 
<a name="l12623"></a>12623 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keyword">typename</span> function_type_, <span class="keyword">typename</span> <span class="keywordtype">size_t</span>ype_&gt;
<a name="l12624"></a>12624 LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(<span class="keyword">const</span> iterator_type_&amp; iter, function_type_&amp; func, <span class="keyword">const</span> size_type_&amp; size);
<a name="l12625"></a>12625 
<a name="l12633"></a>12633 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keyword">typename</span> <span class="keywordtype">size_t</span>ype_&gt;
<a name="l12634"></a>12634 LITE_INLINE <span class="keywordtype">bool</span> <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(<span class="keyword">const</span> iterator_type_&amp; iter, <span class="keyword">const</span> size_type_&amp; size);
<a name="l12635"></a>12635 
<a name="l12644"></a>12644 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keyword">typename</span> function_type_, <span class="keyword">typename</span> <span class="keywordtype">size_t</span>ype_&gt;
<a name="l12645"></a>12645 LITE_INLINE <span class="keywordtype">bool</span> <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(<span class="keyword">const</span> iterator_type_&amp; iter, function_type_&amp; func, <span class="keyword">const</span> size_type_&amp; size);
<a name="l12646"></a>12646 
<a name="l12647"></a>12647 <span class="preprocessor">#else // DOCUMENTATION_ONLY</span>
<a name="l12648"></a>12648 <span class="preprocessor"></span>
<a name="l12649"></a>12649 <span class="comment">/***********************************************************************************************************/</span>
<a name="l12650"></a>12650 <span class="comment">/* for_each, 0D arrays *************************************************************************************/</span>
<a name="l12651"></a>12651 <span class="comment">/***********************************************************************************************************/</span>
<a name="l12652"></a>12652 
<a name="l12653"></a>12653 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_&gt;
<a name="l12654"></a>12654 LITE_INLINE <span class="keywordtype">void</span>
<a name="l12655"></a>12655 <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(<span class="keyword">const</span> iterator_type_&amp; iter, <span class="keyword">const</span> pack&lt;&gt;&amp;)
<a name="l12656"></a>12656 {
<a name="l12657"></a>12657     at(iter);
<a name="l12658"></a>12658 }
<a name="l12659"></a>12659 
<a name="l12660"></a>12660 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keyword">typename</span> function_type_&gt;
<a name="l12661"></a>12661 LITE_INLINE <span class="keywordtype">void</span>
<a name="l12662"></a>12662 <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(<span class="keyword">const</span> iterator_type_&amp; iter, function_type_&amp; func, <span class="keyword">const</span> pack&lt;&gt;&amp;)
<a name="l12663"></a>12663 {
<a name="l12664"></a>12664     func(at(iter));
<a name="l12665"></a>12665 }
<a name="l12666"></a>12666 
<a name="l12667"></a>12667 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_&gt;
<a name="l12668"></a>12668 LITE_INLINE <span class="keywordtype">bool</span>
<a name="l12669"></a>12669 <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(<span class="keyword">const</span> iterator_type_&amp; iter, <span class="keyword">const</span> pack&lt;&gt;&amp;)
<a name="l12670"></a>12670 {
<a name="l12671"></a>12671     <span class="keywordflow">return</span> at(iter);
<a name="l12672"></a>12672 }
<a name="l12673"></a>12673 
<a name="l12674"></a>12674 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keyword">typename</span> function_type_&gt;
<a name="l12675"></a>12675 LITE_INLINE <span class="keywordtype">bool</span>
<a name="l12676"></a>12676 <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(<span class="keyword">const</span> iterator_type_&amp; iter, function_type_&amp; func, <span class="keyword">const</span> pack&lt;&gt;&amp;)
<a name="l12677"></a>12677 {
<a name="l12678"></a>12678     <span class="keywordflow">return</span> func(at(iter));
<a name="l12679"></a>12679 }
<a name="l12680"></a>12680 
<a name="l12681"></a>12681 <span class="comment">/***********************************************************************************************************/</span>
<a name="l12682"></a>12682 <span class="comment">/* for_each, 1D small arrays, use_index ********************************************************************/</span>
<a name="l12683"></a>12683 <span class="comment">/***********************************************************************************************************/</span>
<a name="l12684"></a>12684 
<a name="l12685"></a>12685 
<a name="l12686"></a>12686 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_&gt;
<a name="l12687"></a>12687 LITE_INLINE 
<a name="l12688"></a>12688 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l12689"></a>12689     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l12690"></a>12690     )&gt;::type 
<a name="l12691"></a>12691 <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(<span class="keyword">const</span> iterator_type_&amp; iter, <span class="keyword">const</span> pack&lt;constant&lt;int, 1&gt; &gt;&amp;)
<a name="l12692"></a>12692 {
<a name="l12693"></a>12693     at(iter, 0);
<a name="l12694"></a>12694 }
<a name="l12695"></a>12695 
<a name="l12696"></a>12696 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keyword">typename</span> function_type_&gt;
<a name="l12697"></a>12697 LITE_INLINE 
<a name="l12698"></a>12698 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l12699"></a>12699     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l12700"></a>12700     )&gt;::type 
<a name="l12701"></a>12701 <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(<span class="keyword">const</span> iterator_type_&amp; iter, function_type_&amp; func, <span class="keyword">const</span> pack&lt;constant&lt;int, 1&gt; &gt;&amp;)
<a name="l12702"></a>12702 {
<a name="l12703"></a>12703     func(at(iter, 0));
<a name="l12704"></a>12704 }
<a name="l12705"></a>12705 
<a name="l12706"></a>12706 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keyword">typename</span> function_type_&gt;
<a name="l12707"></a>12707 LITE_INLINE 
<a name="l12708"></a>12708 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l12709"></a>12709     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l12710"></a>12710     ), <span class="keywordtype">bool</span>&gt;::type 
<a name="l12711"></a>12711 <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(<span class="keyword">const</span> iterator_type_&amp; iter, function_type_&amp; func, <span class="keyword">const</span> pack&lt;constant&lt;int, 1&gt; &gt;&amp;)
<a name="l12712"></a>12712 {
<a name="l12713"></a>12713     <span class="keywordflow">if</span> (!func(at(iter, 0))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l12714"></a>12714     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l12715"></a>12715 }
<a name="l12716"></a>12716 
<a name="l12717"></a>12717 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_&gt;
<a name="l12718"></a>12718 LITE_INLINE 
<a name="l12719"></a>12719 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l12720"></a>12720     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l12721"></a>12721     ), <span class="keywordtype">bool</span>&gt;::type 
<a name="l12722"></a>12722 <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(<span class="keyword">const</span> iterator_type_&amp; iter, <span class="keyword">const</span> pack&lt;constant&lt;int, 1&gt; &gt;&amp;)
<a name="l12723"></a>12723 {
<a name="l12724"></a>12724     <span class="keywordflow">if</span> (!at(iter, 0)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l12725"></a>12725     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l12726"></a>12726 }
<a name="l12727"></a>12727 
<a name="l12728"></a>12728 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_&gt;
<a name="l12729"></a>12729 LITE_INLINE 
<a name="l12730"></a>12730 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l12731"></a>12731     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l12732"></a>12732     )&gt;::type 
<a name="l12733"></a>12733 <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(<span class="keyword">const</span> iterator_type_&amp; iter, <span class="keyword">const</span> pack&lt;constant&lt;int, 2&gt; &gt;&amp;)
<a name="l12734"></a>12734 {
<a name="l12735"></a>12735     at(iter, 0);
<a name="l12736"></a>12736     at(iter, 1);
<a name="l12737"></a>12737 }
<a name="l12738"></a>12738 
<a name="l12739"></a>12739 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keyword">typename</span> function_type_&gt;
<a name="l12740"></a>12740 LITE_INLINE 
<a name="l12741"></a>12741 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l12742"></a>12742     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l12743"></a>12743     )&gt;::type 
<a name="l12744"></a>12744 <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(<span class="keyword">const</span> iterator_type_&amp; iter, function_type_&amp; func, <span class="keyword">const</span> pack&lt;constant&lt;int, 2&gt; &gt;&amp;)
<a name="l12745"></a>12745 {
<a name="l12746"></a>12746     func(at(iter, 0));
<a name="l12747"></a>12747     func(at(iter, 1));
<a name="l12748"></a>12748 }
<a name="l12749"></a>12749 
<a name="l12750"></a>12750 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keyword">typename</span> function_type_&gt;
<a name="l12751"></a>12751 LITE_INLINE 
<a name="l12752"></a>12752 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l12753"></a>12753     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l12754"></a>12754     ), <span class="keywordtype">bool</span>&gt;::type 
<a name="l12755"></a>12755 <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(<span class="keyword">const</span> iterator_type_&amp; iter, function_type_&amp; func, <span class="keyword">const</span> pack&lt;constant&lt;int, 2&gt; &gt;&amp;)
<a name="l12756"></a>12756 {
<a name="l12757"></a>12757     <span class="keywordflow">if</span> (!func(at(iter, 0))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l12758"></a>12758     <span class="keywordflow">if</span> (!func(at(iter, 1))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l12759"></a>12759     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l12760"></a>12760 }
<a name="l12761"></a>12761 
<a name="l12762"></a>12762 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_&gt;
<a name="l12763"></a>12763 LITE_INLINE 
<a name="l12764"></a>12764 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l12765"></a>12765     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l12766"></a>12766     ), <span class="keywordtype">bool</span>&gt;::type 
<a name="l12767"></a>12767 <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(<span class="keyword">const</span> iterator_type_&amp; iter, <span class="keyword">const</span> pack&lt;constant&lt;int, 2&gt; &gt;&amp;)
<a name="l12768"></a>12768 {
<a name="l12769"></a>12769     <span class="keywordflow">if</span> (!at(iter, 0)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l12770"></a>12770     <span class="keywordflow">if</span> (!at(iter, 1)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l12771"></a>12771     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l12772"></a>12772 }
<a name="l12773"></a>12773 
<a name="l12774"></a>12774 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_&gt;
<a name="l12775"></a>12775 LITE_INLINE 
<a name="l12776"></a>12776 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l12777"></a>12777     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l12778"></a>12778     )&gt;::type 
<a name="l12779"></a>12779 <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(<span class="keyword">const</span> iterator_type_&amp; iter, <span class="keyword">const</span> pack&lt;constant&lt;int, 3&gt; &gt;&amp;)
<a name="l12780"></a>12780 {
<a name="l12781"></a>12781     at(iter, 0);
<a name="l12782"></a>12782     at(iter, 1);
<a name="l12783"></a>12783     at(iter, 2);
<a name="l12784"></a>12784 }
<a name="l12785"></a>12785 
<a name="l12786"></a>12786 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keyword">typename</span> function_type_&gt;
<a name="l12787"></a>12787 LITE_INLINE 
<a name="l12788"></a>12788 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l12789"></a>12789     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l12790"></a>12790     )&gt;::type 
<a name="l12791"></a>12791 <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(<span class="keyword">const</span> iterator_type_&amp; iter, function_type_&amp; func, <span class="keyword">const</span> pack&lt;constant&lt;int, 3&gt; &gt;&amp;)
<a name="l12792"></a>12792 {
<a name="l12793"></a>12793     func(at(iter, 0));
<a name="l12794"></a>12794     func(at(iter, 1));
<a name="l12795"></a>12795     func(at(iter, 2));
<a name="l12796"></a>12796 }
<a name="l12797"></a>12797 
<a name="l12798"></a>12798 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keyword">typename</span> function_type_&gt;
<a name="l12799"></a>12799 LITE_INLINE 
<a name="l12800"></a>12800 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l12801"></a>12801     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l12802"></a>12802     ), <span class="keywordtype">bool</span>&gt;::type 
<a name="l12803"></a>12803 <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(<span class="keyword">const</span> iterator_type_&amp; iter, function_type_&amp; func, <span class="keyword">const</span> pack&lt;constant&lt;int, 3&gt; &gt;&amp;)
<a name="l12804"></a>12804 {
<a name="l12805"></a>12805     <span class="keywordflow">if</span> (!func(at(iter, 0))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l12806"></a>12806     <span class="keywordflow">if</span> (!func(at(iter, 1))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l12807"></a>12807     <span class="keywordflow">if</span> (!func(at(iter, 2))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l12808"></a>12808     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l12809"></a>12809 }
<a name="l12810"></a>12810 
<a name="l12811"></a>12811 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_&gt;
<a name="l12812"></a>12812 LITE_INLINE 
<a name="l12813"></a>12813 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l12814"></a>12814     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l12815"></a>12815     ), <span class="keywordtype">bool</span>&gt;::type 
<a name="l12816"></a>12816 <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(<span class="keyword">const</span> iterator_type_&amp; iter, <span class="keyword">const</span> pack&lt;constant&lt;int, 3&gt; &gt;&amp;)
<a name="l12817"></a>12817 {
<a name="l12818"></a>12818     <span class="keywordflow">if</span> (!at(iter, 0)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l12819"></a>12819     <span class="keywordflow">if</span> (!at(iter, 1)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l12820"></a>12820     <span class="keywordflow">if</span> (!at(iter, 2)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l12821"></a>12821     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l12822"></a>12822 }
<a name="l12823"></a>12823 
<a name="l12824"></a>12824 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_&gt;
<a name="l12825"></a>12825 LITE_INLINE 
<a name="l12826"></a>12826 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l12827"></a>12827     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l12828"></a>12828     )&gt;::type 
<a name="l12829"></a>12829 <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(<span class="keyword">const</span> iterator_type_&amp; iter, <span class="keyword">const</span> pack&lt;constant&lt;int, 4&gt; &gt;&amp;)
<a name="l12830"></a>12830 {
<a name="l12831"></a>12831     at(iter, 0);
<a name="l12832"></a>12832     at(iter, 1);
<a name="l12833"></a>12833     at(iter, 2);
<a name="l12834"></a>12834     at(iter, 3);
<a name="l12835"></a>12835 }
<a name="l12836"></a>12836 
<a name="l12837"></a>12837 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keyword">typename</span> function_type_&gt;
<a name="l12838"></a>12838 LITE_INLINE 
<a name="l12839"></a>12839 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l12840"></a>12840     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l12841"></a>12841     )&gt;::type 
<a name="l12842"></a>12842 <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(<span class="keyword">const</span> iterator_type_&amp; iter, function_type_&amp; func, <span class="keyword">const</span> pack&lt;constant&lt;int, 4&gt; &gt;&amp;)
<a name="l12843"></a>12843 {
<a name="l12844"></a>12844     func(at(iter, 0));
<a name="l12845"></a>12845     func(at(iter, 1));
<a name="l12846"></a>12846     func(at(iter, 2));
<a name="l12847"></a>12847     func(at(iter, 3));
<a name="l12848"></a>12848 }
<a name="l12849"></a>12849 
<a name="l12850"></a>12850 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keyword">typename</span> function_type_&gt;
<a name="l12851"></a>12851 LITE_INLINE 
<a name="l12852"></a>12852 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l12853"></a>12853     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l12854"></a>12854     ), <span class="keywordtype">bool</span>&gt;::type 
<a name="l12855"></a>12855 <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(<span class="keyword">const</span> iterator_type_&amp; iter, function_type_&amp; func, <span class="keyword">const</span> pack&lt;constant&lt;int, 4&gt; &gt;&amp;)
<a name="l12856"></a>12856 {
<a name="l12857"></a>12857     <span class="keywordflow">if</span> (!func(at(iter, 0))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l12858"></a>12858     <span class="keywordflow">if</span> (!func(at(iter, 1))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l12859"></a>12859     <span class="keywordflow">if</span> (!func(at(iter, 2))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l12860"></a>12860     <span class="keywordflow">if</span> (!func(at(iter, 3))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l12861"></a>12861     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l12862"></a>12862 }
<a name="l12863"></a>12863 
<a name="l12864"></a>12864 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_&gt;
<a name="l12865"></a>12865 LITE_INLINE 
<a name="l12866"></a>12866 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l12867"></a>12867     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l12868"></a>12868     ), <span class="keywordtype">bool</span>&gt;::type 
<a name="l12869"></a>12869 <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(<span class="keyword">const</span> iterator_type_&amp; iter, <span class="keyword">const</span> pack&lt;constant&lt;int, 4&gt; &gt;&amp;)
<a name="l12870"></a>12870 {
<a name="l12871"></a>12871     <span class="keywordflow">if</span> (!at(iter, 0)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l12872"></a>12872     <span class="keywordflow">if</span> (!at(iter, 1)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l12873"></a>12873     <span class="keywordflow">if</span> (!at(iter, 2)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l12874"></a>12874     <span class="keywordflow">if</span> (!at(iter, 3)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l12875"></a>12875     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l12876"></a>12876 }
<a name="l12877"></a>12877 
<a name="l12878"></a>12878 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_&gt;
<a name="l12879"></a>12879 LITE_INLINE 
<a name="l12880"></a>12880 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l12881"></a>12881     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l12882"></a>12882     )&gt;::type 
<a name="l12883"></a>12883 <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(<span class="keyword">const</span> iterator_type_&amp; iter, <span class="keyword">const</span> pack&lt;constant&lt;int, 5&gt; &gt;&amp;)
<a name="l12884"></a>12884 {
<a name="l12885"></a>12885     at(iter, 0);
<a name="l12886"></a>12886     at(iter, 1);
<a name="l12887"></a>12887     at(iter, 2);
<a name="l12888"></a>12888     at(iter, 3);
<a name="l12889"></a>12889     at(iter, 4);
<a name="l12890"></a>12890 }
<a name="l12891"></a>12891 
<a name="l12892"></a>12892 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keyword">typename</span> function_type_&gt;
<a name="l12893"></a>12893 LITE_INLINE 
<a name="l12894"></a>12894 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l12895"></a>12895     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l12896"></a>12896     )&gt;::type 
<a name="l12897"></a>12897 <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(<span class="keyword">const</span> iterator_type_&amp; iter, function_type_&amp; func, <span class="keyword">const</span> pack&lt;constant&lt;int, 5&gt; &gt;&amp;)
<a name="l12898"></a>12898 {
<a name="l12899"></a>12899     func(at(iter, 0));
<a name="l12900"></a>12900     func(at(iter, 1));
<a name="l12901"></a>12901     func(at(iter, 2));
<a name="l12902"></a>12902     func(at(iter, 3));
<a name="l12903"></a>12903     func(at(iter, 4));
<a name="l12904"></a>12904 }
<a name="l12905"></a>12905 
<a name="l12906"></a>12906 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keyword">typename</span> function_type_&gt;
<a name="l12907"></a>12907 LITE_INLINE 
<a name="l12908"></a>12908 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l12909"></a>12909     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l12910"></a>12910     ), <span class="keywordtype">bool</span>&gt;::type 
<a name="l12911"></a>12911 <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(<span class="keyword">const</span> iterator_type_&amp; iter, function_type_&amp; func, <span class="keyword">const</span> pack&lt;constant&lt;int, 5&gt; &gt;&amp;)
<a name="l12912"></a>12912 {
<a name="l12913"></a>12913     <span class="keywordflow">if</span> (!func(at(iter, 0))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l12914"></a>12914     <span class="keywordflow">if</span> (!func(at(iter, 1))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l12915"></a>12915     <span class="keywordflow">if</span> (!func(at(iter, 2))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l12916"></a>12916     <span class="keywordflow">if</span> (!func(at(iter, 3))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l12917"></a>12917     <span class="keywordflow">if</span> (!func(at(iter, 4))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l12918"></a>12918     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l12919"></a>12919 }
<a name="l12920"></a>12920 
<a name="l12921"></a>12921 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_&gt;
<a name="l12922"></a>12922 LITE_INLINE 
<a name="l12923"></a>12923 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l12924"></a>12924     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l12925"></a>12925     ), <span class="keywordtype">bool</span>&gt;::type 
<a name="l12926"></a>12926 <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(<span class="keyword">const</span> iterator_type_&amp; iter, <span class="keyword">const</span> pack&lt;constant&lt;int, 5&gt; &gt;&amp;)
<a name="l12927"></a>12927 {
<a name="l12928"></a>12928     <span class="keywordflow">if</span> (!at(iter, 0)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l12929"></a>12929     <span class="keywordflow">if</span> (!at(iter, 1)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l12930"></a>12930     <span class="keywordflow">if</span> (!at(iter, 2)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l12931"></a>12931     <span class="keywordflow">if</span> (!at(iter, 3)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l12932"></a>12932     <span class="keywordflow">if</span> (!at(iter, 4)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l12933"></a>12933     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l12934"></a>12934 }
<a name="l12935"></a>12935 
<a name="l12936"></a>12936 <span class="comment">/***********************************************************************************************************/</span>
<a name="l12937"></a>12937 <span class="comment">/* for_each, 1D small arrays, !use_index =*******************************************************************/</span>
<a name="l12938"></a>12938 <span class="comment">/***********************************************************************************************************/</span>
<a name="l12939"></a>12939 
<a name="l12940"></a>12940 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_&gt;
<a name="l12941"></a>12941 LITE_INLINE 
<a name="l12942"></a>12942 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l12943"></a>12943     !detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l12944"></a>12944     )&gt;::type 
<a name="l12945"></a>12945 <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(<span class="keyword">const</span> iterator_type_&amp; iter, <span class="keyword">const</span> pack&lt;constant&lt;int, 6&gt; &gt;&amp;)
<a name="l12946"></a>12946 {
<a name="l12947"></a>12947     iterator_type_ it = iter;
<a name="l12948"></a>12948 
<a name="l12949"></a>12949     at(it, 0); inc&lt;0&gt;(it); 
<a name="l12950"></a>12950     at(it, 1); inc&lt;0&gt;(it); 
<a name="l12951"></a>12951     at(it, 2); inc&lt;0&gt;(it); 
<a name="l12952"></a>12952     at(it, 3); inc&lt;0&gt;(it); 
<a name="l12953"></a>12953     at(it, 4); inc&lt;0&gt;(it); 
<a name="l12954"></a>12954     at(it, 5);
<a name="l12955"></a>12955 }
<a name="l12956"></a>12956 
<a name="l12957"></a>12957 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keyword">typename</span> function_type_&gt;
<a name="l12958"></a>12958 LITE_INLINE 
<a name="l12959"></a>12959 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l12960"></a>12960     !detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l12961"></a>12961     )&gt;::type 
<a name="l12962"></a>12962 <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(<span class="keyword">const</span> iterator_type_&amp; iter, function_type_&amp; func, <span class="keyword">const</span> pack&lt;constant&lt;int, 6&gt; &gt;&amp;)
<a name="l12963"></a>12963 {
<a name="l12964"></a>12964     iterator_type_ it = iter;
<a name="l12965"></a>12965 
<a name="l12966"></a>12966     func(at(it, 0)); inc&lt;0&gt;(it); 
<a name="l12967"></a>12967     func(at(it, 1)); inc&lt;0&gt;(it); 
<a name="l12968"></a>12968     func(at(it, 2)); inc&lt;0&gt;(it); 
<a name="l12969"></a>12969     func(at(it, 3)); inc&lt;0&gt;(it); 
<a name="l12970"></a>12970     func(at(it, 4)); inc&lt;0&gt;(it); 
<a name="l12971"></a>12971     func(at(it, 5));
<a name="l12972"></a>12972 }
<a name="l12973"></a>12973 
<a name="l12974"></a>12974 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_&gt;
<a name="l12975"></a>12975 LITE_INLINE 
<a name="l12976"></a>12976 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l12977"></a>12977     !detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l12978"></a>12978     ), <span class="keywordtype">bool</span>&gt;::type 
<a name="l12979"></a>12979 <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(<span class="keyword">const</span> iterator_type_&amp; iter, <span class="keyword">const</span> pack&lt;constant&lt;int, 6&gt; &gt;&amp;)
<a name="l12980"></a>12980 {
<a name="l12981"></a>12981     iterator_type_ it = iter;
<a name="l12982"></a>12982 
<a name="l12983"></a>12983     <span class="keywordflow">if</span> (!at(iter, 0)) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it); 
<a name="l12984"></a>12984     <span class="keywordflow">if</span> (!at(iter, 1)) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it); 
<a name="l12985"></a>12985     <span class="keywordflow">if</span> (!at(iter, 2)) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it); 
<a name="l12986"></a>12986     <span class="keywordflow">if</span> (!at(iter, 3)) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it); 
<a name="l12987"></a>12987     <span class="keywordflow">if</span> (!at(iter, 4)) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it); 
<a name="l12988"></a>12988     <span class="keywordflow">if</span> (!at(iter, 5)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l12989"></a>12989 
<a name="l12990"></a>12990     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l12991"></a>12991 }
<a name="l12992"></a>12992 
<a name="l12993"></a>12993 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keyword">typename</span> function_type_&gt;
<a name="l12994"></a>12994 LITE_INLINE 
<a name="l12995"></a>12995 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l12996"></a>12996     !detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l12997"></a>12997     ), <span class="keywordtype">bool</span>&gt;::type 
<a name="l12998"></a>12998 <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(<span class="keyword">const</span> iterator_type_&amp; iter, function_type_&amp; func, <span class="keyword">const</span> pack&lt;constant&lt;int, 6&gt; &gt;&amp;)
<a name="l12999"></a>12999 {
<a name="l13000"></a>13000     iterator_type_ it = iter;
<a name="l13001"></a>13001 
<a name="l13002"></a>13002     <span class="keywordflow">if</span> (!func(at(iter, 0))) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it); 
<a name="l13003"></a>13003     <span class="keywordflow">if</span> (!func(at(iter, 1))) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it); 
<a name="l13004"></a>13004     <span class="keywordflow">if</span> (!func(at(iter, 2))) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it); 
<a name="l13005"></a>13005     <span class="keywordflow">if</span> (!func(at(iter, 3))) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it); 
<a name="l13006"></a>13006     <span class="keywordflow">if</span> (!func(at(iter, 4))) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it); 
<a name="l13007"></a>13007     <span class="keywordflow">if</span> (!func(at(iter, 5))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13008"></a>13008 
<a name="l13009"></a>13009     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l13010"></a>13010 }
<a name="l13011"></a>13011 
<a name="l13012"></a>13012 <span class="comment">/***********************************************************************************************************/</span>
<a name="l13013"></a>13013 <span class="comment">/* for_each, 1D arrays, use_index **************************************************************************/</span>
<a name="l13014"></a>13014 <span class="comment">/***********************************************************************************************************/</span>
<a name="l13015"></a>13015 
<a name="l13016"></a>13016 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keyword">typename</span> type_&gt;
<a name="l13017"></a>13017 LITE_INLINE 
<a name="l13018"></a>13018 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l13019"></a>13019     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l13020"></a>13020     )&gt;::type 
<a name="l13021"></a>13021 <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(<span class="keyword">const</span> iterator_type_&amp; iter, <span class="keyword">const</span> pack&lt;type_&gt;&amp; size)
<a name="l13022"></a>13022 {
<a name="l13023"></a>13023     <span class="keyword">const</span> <span class="keywordtype">int</span> n = size.i0;
<a name="l13024"></a>13024     <span class="keywordtype">int</span> j=16;
<a name="l13025"></a>13025     iterator_type_ it = iter;
<a name="l13026"></a>13026 
<a name="l13027"></a>13027     <span class="keywordflow">for</span> (; j&lt;=n; j+=16) {
<a name="l13028"></a>13028         at(it, 0); 
<a name="l13029"></a>13029         at(it, 1); 
<a name="l13030"></a>13030         at(it, 2); 
<a name="l13031"></a>13031         at(it, 3); 
<a name="l13032"></a>13032         at(it, 4); 
<a name="l13033"></a>13033         at(it, 5); 
<a name="l13034"></a>13034         at(it, 6); 
<a name="l13035"></a>13035         at(it, 7); 
<a name="l13036"></a>13036         at(it, 8); 
<a name="l13037"></a>13037         at(it, 9); 
<a name="l13038"></a>13038         at(it, 10); 
<a name="l13039"></a>13039         at(it, 11); 
<a name="l13040"></a>13040         at(it, 12); 
<a name="l13041"></a>13041         at(it, 13); 
<a name="l13042"></a>13042         at(it, 14); 
<a name="l13043"></a>13043         at(it, 15); 
<a name="l13044"></a>13044         shift&lt;0&gt;(it, 16);
<a name="l13045"></a>13045     }
<a name="l13046"></a>13046 
<a name="l13047"></a>13047     <span class="keywordflow">if</span> (n &amp; 8) {
<a name="l13048"></a>13048         at(it, 0);
<a name="l13049"></a>13049         at(it, 1);
<a name="l13050"></a>13050         at(it, 2);
<a name="l13051"></a>13051         at(it, 3);
<a name="l13052"></a>13052         at(it, 4);
<a name="l13053"></a>13053         at(it, 5);
<a name="l13054"></a>13054         at(it, 6);
<a name="l13055"></a>13055         at(it, 7);
<a name="l13056"></a>13056         shift&lt;0&gt;(it, 8);
<a name="l13057"></a>13057     }
<a name="l13058"></a>13058     <span class="keywordflow">if</span> (n &amp; 4) {
<a name="l13059"></a>13059         at(it, 0);
<a name="l13060"></a>13060         at(it, 1);
<a name="l13061"></a>13061         at(it, 2);
<a name="l13062"></a>13062         at(it, 3);
<a name="l13063"></a>13063         shift&lt;0&gt;(it, 4);
<a name="l13064"></a>13064     }
<a name="l13065"></a>13065     <span class="keywordflow">if</span> (n &amp; 2) {
<a name="l13066"></a>13066         at(it, 0);
<a name="l13067"></a>13067         at(it, 1);
<a name="l13068"></a>13068         shift&lt;0&gt;(it, 2);
<a name="l13069"></a>13069     }
<a name="l13070"></a>13070 
<a name="l13071"></a>13071     <span class="keywordflow">if</span> (n &amp; 1)
<a name="l13072"></a>13072         at(it, 0);
<a name="l13073"></a>13073 
<a name="l13074"></a>13074     LITE_ARRAY_USE(size);
<a name="l13075"></a>13075 }
<a name="l13076"></a>13076 
<a name="l13077"></a>13077 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keyword">typename</span> function_type_, <span class="keyword">typename</span> type_&gt;
<a name="l13078"></a>13078 LITE_INLINE 
<a name="l13079"></a>13079 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l13080"></a>13080     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l13081"></a>13081     )&gt;::type 
<a name="l13082"></a>13082 <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(<span class="keyword">const</span> iterator_type_&amp; iter, function_type_&amp; func, <span class="keyword">const</span> pack&lt;type_&gt;&amp; size)
<a name="l13083"></a>13083 {
<a name="l13084"></a>13084     <span class="keyword">const</span> <span class="keywordtype">int</span> n = size.i0;
<a name="l13085"></a>13085     <span class="keywordtype">int</span> j=16;
<a name="l13086"></a>13086     iterator_type_ it = iter;
<a name="l13087"></a>13087 
<a name="l13088"></a>13088     <span class="keywordflow">for</span> (; j&lt;=n; j+=16) {
<a name="l13089"></a>13089         func(at(it, 0)); 
<a name="l13090"></a>13090         func(at(it, 1)); 
<a name="l13091"></a>13091         func(at(it, 2)); 
<a name="l13092"></a>13092         func(at(it, 3)); 
<a name="l13093"></a>13093         func(at(it, 4)); 
<a name="l13094"></a>13094         func(at(it, 5)); 
<a name="l13095"></a>13095         func(at(it, 6)); 
<a name="l13096"></a>13096         func(at(it, 7)); 
<a name="l13097"></a>13097         func(at(it, 8)); 
<a name="l13098"></a>13098         func(at(it, 9)); 
<a name="l13099"></a>13099         func(at(it, 10)); 
<a name="l13100"></a>13100         func(at(it, 11)); 
<a name="l13101"></a>13101         func(at(it, 12)); 
<a name="l13102"></a>13102         func(at(it, 13)); 
<a name="l13103"></a>13103         func(at(it, 14)); 
<a name="l13104"></a>13104         func(at(it, 15)); 
<a name="l13105"></a>13105         shift&lt;0&gt;(it, 16);
<a name="l13106"></a>13106     }
<a name="l13107"></a>13107 
<a name="l13108"></a>13108     <span class="keywordflow">if</span> (n &amp; 8) {
<a name="l13109"></a>13109         func(at(it, 0));
<a name="l13110"></a>13110         func(at(it, 1));
<a name="l13111"></a>13111         func(at(it, 2));
<a name="l13112"></a>13112         func(at(it, 3));
<a name="l13113"></a>13113         func(at(it, 4));
<a name="l13114"></a>13114         func(at(it, 5));
<a name="l13115"></a>13115         func(at(it, 6));
<a name="l13116"></a>13116         func(at(it, 7));
<a name="l13117"></a>13117         shift&lt;0&gt;(it, 8);
<a name="l13118"></a>13118     }
<a name="l13119"></a>13119     <span class="keywordflow">if</span> (n &amp; 4) {
<a name="l13120"></a>13120         func(at(it, 0));
<a name="l13121"></a>13121         func(at(it, 1));
<a name="l13122"></a>13122         func(at(it, 2));
<a name="l13123"></a>13123         func(at(it, 3));
<a name="l13124"></a>13124         shift&lt;0&gt;(it, 4);
<a name="l13125"></a>13125     }
<a name="l13126"></a>13126     <span class="keywordflow">if</span> (n &amp; 2) {
<a name="l13127"></a>13127         func(at(it, 0));
<a name="l13128"></a>13128         func(at(it, 1));
<a name="l13129"></a>13129         shift&lt;0&gt;(it, 2);
<a name="l13130"></a>13130     }
<a name="l13131"></a>13131 
<a name="l13132"></a>13132     <span class="keywordflow">if</span> (n &amp; 1)
<a name="l13133"></a>13133         func(at(it, 0));
<a name="l13134"></a>13134 
<a name="l13135"></a>13135     LITE_ARRAY_USE(size);
<a name="l13136"></a>13136 }
<a name="l13137"></a>13137 
<a name="l13138"></a>13138 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keyword">typename</span> type_&gt;
<a name="l13139"></a>13139 LITE_INLINE 
<a name="l13140"></a>13140 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l13141"></a>13141     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l13142"></a>13142     ), <span class="keywordtype">bool</span>&gt;::type 
<a name="l13143"></a>13143 <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(<span class="keyword">const</span> iterator_type_&amp; iter, <span class="keyword">const</span> pack&lt;type_&gt;&amp; size)
<a name="l13144"></a>13144 {
<a name="l13145"></a>13145     <span class="keyword">const</span> <span class="keywordtype">int</span> n = size.i0;
<a name="l13146"></a>13146     <span class="keywordtype">int</span> j=16;
<a name="l13147"></a>13147     iterator_type_ it = iter;
<a name="l13148"></a>13148 
<a name="l13149"></a>13149     <span class="keywordflow">for</span> (; j&lt;=n; j+=16) {
<a name="l13150"></a>13150         <span class="keywordflow">if</span> (!at(it, 0)) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13151"></a>13151         <span class="keywordflow">if</span> (!at(it, 1)) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13152"></a>13152         <span class="keywordflow">if</span> (!at(it, 2)) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13153"></a>13153         <span class="keywordflow">if</span> (!at(it, 3)) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13154"></a>13154         <span class="keywordflow">if</span> (!at(it, 4)) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13155"></a>13155         <span class="keywordflow">if</span> (!at(it, 5)) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13156"></a>13156         <span class="keywordflow">if</span> (!at(it, 6)) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13157"></a>13157         <span class="keywordflow">if</span> (!at(it, 7)) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13158"></a>13158         <span class="keywordflow">if</span> (!at(it, 8)) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13159"></a>13159         <span class="keywordflow">if</span> (!at(it, 9)) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13160"></a>13160         <span class="keywordflow">if</span> (!at(it, 10)) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13161"></a>13161         <span class="keywordflow">if</span> (!at(it, 11)) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13162"></a>13162         <span class="keywordflow">if</span> (!at(it, 12)) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13163"></a>13163         <span class="keywordflow">if</span> (!at(it, 13)) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13164"></a>13164         <span class="keywordflow">if</span> (!at(it, 14)) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13165"></a>13165         <span class="keywordflow">if</span> (!at(it, 15)) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13166"></a>13166         shift&lt;0&gt;(it, 16);
<a name="l13167"></a>13167     }
<a name="l13168"></a>13168 
<a name="l13169"></a>13169     <span class="keywordflow">if</span> (n &amp; 8) {
<a name="l13170"></a>13170         <span class="keywordflow">if</span> (!at(it, 0)) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13171"></a>13171         <span class="keywordflow">if</span> (!at(it, 1)) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13172"></a>13172         <span class="keywordflow">if</span> (!at(it, 2)) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13173"></a>13173         <span class="keywordflow">if</span> (!at(it, 3)) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13174"></a>13174         <span class="keywordflow">if</span> (!at(it, 4)) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13175"></a>13175         <span class="keywordflow">if</span> (!at(it, 5)) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13176"></a>13176         <span class="keywordflow">if</span> (!at(it, 6)) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13177"></a>13177         <span class="keywordflow">if</span> (!at(it, 7)) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13178"></a>13178         shift&lt;0&gt;(it, 8);
<a name="l13179"></a>13179     }
<a name="l13180"></a>13180     <span class="keywordflow">if</span> (n &amp; 4) {
<a name="l13181"></a>13181         <span class="keywordflow">if</span> (!at(it, 0)) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13182"></a>13182         <span class="keywordflow">if</span> (!at(it, 1)) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13183"></a>13183         <span class="keywordflow">if</span> (!at(it, 2)) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13184"></a>13184         <span class="keywordflow">if</span> (!at(it, 3)) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13185"></a>13185         shift&lt;0&gt;(it, 4);
<a name="l13186"></a>13186     }
<a name="l13187"></a>13187     <span class="keywordflow">if</span> (n &amp; 2) {
<a name="l13188"></a>13188         <span class="keywordflow">if</span> (!at(it, 0)) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13189"></a>13189         <span class="keywordflow">if</span> (!at(it, 1)) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13190"></a>13190         shift&lt;0&gt;(it, 2);
<a name="l13191"></a>13191     }
<a name="l13192"></a>13192 
<a name="l13193"></a>13193     <span class="keywordflow">if</span> (n &amp; 1)
<a name="l13194"></a>13194         <span class="keywordflow">if</span> (!at(it, 0)) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13195"></a>13195 
<a name="l13196"></a>13196     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l13197"></a>13197     LITE_ARRAY_USE(size);
<a name="l13198"></a>13198 }
<a name="l13199"></a>13199 
<a name="l13200"></a>13200 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keyword">typename</span> function_type_, <span class="keyword">typename</span> type_&gt;
<a name="l13201"></a>13201 LITE_INLINE 
<a name="l13202"></a>13202 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l13203"></a>13203     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l13204"></a>13204     ), <span class="keywordtype">bool</span>&gt;::type 
<a name="l13205"></a>13205 <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(<span class="keyword">const</span> iterator_type_&amp; iter, function_type_&amp; func, <span class="keyword">const</span> pack&lt;type_&gt;&amp; size)
<a name="l13206"></a>13206 {
<a name="l13207"></a>13207     <span class="keyword">const</span> <span class="keywordtype">int</span> n = size.i0;
<a name="l13208"></a>13208     <span class="keywordtype">int</span> j=16;
<a name="l13209"></a>13209     iterator_type_ it = iter;
<a name="l13210"></a>13210 
<a name="l13211"></a>13211     <span class="keywordflow">for</span> (; j&lt;=n; j+=16) {
<a name="l13212"></a>13212         <span class="keywordflow">if</span> (!func(at(it, 0))) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13213"></a>13213         <span class="keywordflow">if</span> (!func(at(it, 1))) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13214"></a>13214         <span class="keywordflow">if</span> (!func(at(it, 2))) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13215"></a>13215         <span class="keywordflow">if</span> (!func(at(it, 3))) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13216"></a>13216         <span class="keywordflow">if</span> (!func(at(it, 4))) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13217"></a>13217         <span class="keywordflow">if</span> (!func(at(it, 5))) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13218"></a>13218         <span class="keywordflow">if</span> (!func(at(it, 6))) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13219"></a>13219         <span class="keywordflow">if</span> (!func(at(it, 7))) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13220"></a>13220         <span class="keywordflow">if</span> (!func(at(it, 8))) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13221"></a>13221         <span class="keywordflow">if</span> (!func(at(it, 9))) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13222"></a>13222         <span class="keywordflow">if</span> (!func(at(it, 10))) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13223"></a>13223         <span class="keywordflow">if</span> (!func(at(it, 11))) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13224"></a>13224         <span class="keywordflow">if</span> (!func(at(it, 12))) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13225"></a>13225         <span class="keywordflow">if</span> (!func(at(it, 13))) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13226"></a>13226         <span class="keywordflow">if</span> (!func(at(it, 14))) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13227"></a>13227         <span class="keywordflow">if</span> (!func(at(it, 15))) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13228"></a>13228         shift&lt;0&gt;(it, 16);
<a name="l13229"></a>13229     }
<a name="l13230"></a>13230 
<a name="l13231"></a>13231     <span class="keywordflow">if</span> (n &amp; 8) {
<a name="l13232"></a>13232         <span class="keywordflow">if</span> (!func(at(it, 0))) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13233"></a>13233         <span class="keywordflow">if</span> (!func(at(it, 1))) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13234"></a>13234         <span class="keywordflow">if</span> (!func(at(it, 2))) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13235"></a>13235         <span class="keywordflow">if</span> (!func(at(it, 3))) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13236"></a>13236         <span class="keywordflow">if</span> (!func(at(it, 4))) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13237"></a>13237         <span class="keywordflow">if</span> (!func(at(it, 5))) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13238"></a>13238         <span class="keywordflow">if</span> (!func(at(it, 6))) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13239"></a>13239         <span class="keywordflow">if</span> (!func(at(it, 7))) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13240"></a>13240         shift&lt;0&gt;(it, 8);
<a name="l13241"></a>13241     }
<a name="l13242"></a>13242     <span class="keywordflow">if</span> (n &amp; 4) {
<a name="l13243"></a>13243         <span class="keywordflow">if</span> (!func(at(it, 0))) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13244"></a>13244         <span class="keywordflow">if</span> (!func(at(it, 1))) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13245"></a>13245         <span class="keywordflow">if</span> (!func(at(it, 2))) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13246"></a>13246         <span class="keywordflow">if</span> (!func(at(it, 3))) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13247"></a>13247         shift&lt;0&gt;(it, 4);
<a name="l13248"></a>13248     }
<a name="l13249"></a>13249     <span class="keywordflow">if</span> (n &amp; 2) {
<a name="l13250"></a>13250         <span class="keywordflow">if</span> (!func(at(it, 0))) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13251"></a>13251         <span class="keywordflow">if</span> (!func(at(it, 1))) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13252"></a>13252         shift&lt;0&gt;(it, 2);
<a name="l13253"></a>13253     }
<a name="l13254"></a>13254 
<a name="l13255"></a>13255     <span class="keywordflow">if</span> (n &amp; 1)
<a name="l13256"></a>13256         <span class="keywordflow">if</span> (!func(at(it, 0))) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l13257"></a>13257 
<a name="l13258"></a>13258     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l13259"></a>13259     LITE_ARRAY_USE(size);
<a name="l13260"></a>13260 }
<a name="l13261"></a>13261 
<a name="l13262"></a>13262 <span class="comment">/***********************************************************************************************************/</span>
<a name="l13263"></a>13263 <span class="comment">/* for_each, 1D arrays, !use_index *************************************************************************/</span>
<a name="l13264"></a>13264 <span class="comment">/***********************************************************************************************************/</span>
<a name="l13265"></a>13265 
<a name="l13266"></a>13266 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keyword">typename</span> type_&gt;
<a name="l13267"></a>13267 LITE_INLINE 
<a name="l13268"></a>13268 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l13269"></a>13269     !detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l13270"></a>13270     )&gt;::type 
<a name="l13271"></a>13271 <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(<span class="keyword">const</span> iterator_type_&amp; iter, <span class="keyword">const</span> pack&lt;type_&gt;&amp; size)
<a name="l13272"></a>13272 {
<a name="l13273"></a>13273     <span class="keyword">const</span> <span class="keywordtype">int</span> n = size.i0;
<a name="l13274"></a>13274     <span class="keywordtype">int</span> j=16;
<a name="l13275"></a>13275     iterator_type_ it = iter;
<a name="l13276"></a>13276 
<a name="l13277"></a>13277     <span class="keywordflow">for</span> (; j&lt;=n; j+=16) {
<a name="l13278"></a>13278         at(it); inc&lt;0&gt;(it);
<a name="l13279"></a>13279         at(it); inc&lt;0&gt;(it);
<a name="l13280"></a>13280         at(it); inc&lt;0&gt;(it);
<a name="l13281"></a>13281         at(it); inc&lt;0&gt;(it);
<a name="l13282"></a>13282         at(it); inc&lt;0&gt;(it);
<a name="l13283"></a>13283         at(it); inc&lt;0&gt;(it);
<a name="l13284"></a>13284         at(it); inc&lt;0&gt;(it);
<a name="l13285"></a>13285         at(it); inc&lt;0&gt;(it);
<a name="l13286"></a>13286         at(it); inc&lt;0&gt;(it);
<a name="l13287"></a>13287         at(it); inc&lt;0&gt;(it);
<a name="l13288"></a>13288         at(it); inc&lt;0&gt;(it);
<a name="l13289"></a>13289         at(it); inc&lt;0&gt;(it);
<a name="l13290"></a>13290         at(it); inc&lt;0&gt;(it);
<a name="l13291"></a>13291         at(it); inc&lt;0&gt;(it);
<a name="l13292"></a>13292         at(it); inc&lt;0&gt;(it);
<a name="l13293"></a>13293         at(it); inc&lt;0&gt;(it);
<a name="l13294"></a>13294     }
<a name="l13295"></a>13295 
<a name="l13296"></a>13296     <span class="keywordflow">if</span> (n &amp; 8) {
<a name="l13297"></a>13297         at(it); inc&lt;0&gt;(it);
<a name="l13298"></a>13298         at(it); inc&lt;0&gt;(it);
<a name="l13299"></a>13299         at(it); inc&lt;0&gt;(it);
<a name="l13300"></a>13300         at(it); inc&lt;0&gt;(it);
<a name="l13301"></a>13301         at(it); inc&lt;0&gt;(it);
<a name="l13302"></a>13302         at(it); inc&lt;0&gt;(it);
<a name="l13303"></a>13303         at(it); inc&lt;0&gt;(it);
<a name="l13304"></a>13304         at(it); inc&lt;0&gt;(it);
<a name="l13305"></a>13305     }
<a name="l13306"></a>13306     <span class="keywordflow">if</span> (n &amp; 4) {
<a name="l13307"></a>13307         at(it); inc&lt;0&gt;(it);
<a name="l13308"></a>13308         at(it); inc&lt;0&gt;(it);
<a name="l13309"></a>13309         at(it); inc&lt;0&gt;(it);
<a name="l13310"></a>13310         at(it); inc&lt;0&gt;(it);
<a name="l13311"></a>13311     }
<a name="l13312"></a>13312     <span class="keywordflow">if</span> (n &amp; 2) {
<a name="l13313"></a>13313         at(it); inc&lt;0&gt;(it);
<a name="l13314"></a>13314         at(it); inc&lt;0&gt;(it);
<a name="l13315"></a>13315     }
<a name="l13316"></a>13316 
<a name="l13317"></a>13317     <span class="keywordflow">if</span> (n &amp; 1)
<a name="l13318"></a>13318         at(it);
<a name="l13319"></a>13319     LITE_ARRAY_USE(size);
<a name="l13320"></a>13320 }
<a name="l13321"></a>13321 
<a name="l13322"></a>13322 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keyword">typename</span> function_type_, <span class="keyword">typename</span> type_&gt;
<a name="l13323"></a>13323 LITE_INLINE 
<a name="l13324"></a>13324 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l13325"></a>13325     !detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l13326"></a>13326     )&gt;::type 
<a name="l13327"></a>13327 <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(<span class="keyword">const</span> iterator_type_&amp; iter, function_type_&amp; func, <span class="keyword">const</span> pack&lt;type_&gt;&amp; size)
<a name="l13328"></a>13328 {
<a name="l13329"></a>13329     <span class="keyword">const</span> <span class="keywordtype">int</span> n = size.i0;
<a name="l13330"></a>13330     <span class="keywordtype">int</span> j=16;
<a name="l13331"></a>13331     iterator_type_ it = iter;
<a name="l13332"></a>13332 
<a name="l13333"></a>13333     <span class="keywordflow">for</span> (; j&lt;=n; j+=16) {
<a name="l13334"></a>13334         func(at(it)); inc&lt;0&gt;(it);
<a name="l13335"></a>13335         func(at(it)); inc&lt;0&gt;(it);
<a name="l13336"></a>13336         func(at(it)); inc&lt;0&gt;(it);
<a name="l13337"></a>13337         func(at(it)); inc&lt;0&gt;(it);
<a name="l13338"></a>13338         func(at(it)); inc&lt;0&gt;(it);
<a name="l13339"></a>13339         func(at(it)); inc&lt;0&gt;(it);
<a name="l13340"></a>13340         func(at(it)); inc&lt;0&gt;(it);
<a name="l13341"></a>13341         func(at(it)); inc&lt;0&gt;(it);
<a name="l13342"></a>13342         func(at(it)); inc&lt;0&gt;(it);
<a name="l13343"></a>13343         func(at(it)); inc&lt;0&gt;(it);
<a name="l13344"></a>13344         func(at(it)); inc&lt;0&gt;(it);
<a name="l13345"></a>13345         func(at(it)); inc&lt;0&gt;(it);
<a name="l13346"></a>13346         func(at(it)); inc&lt;0&gt;(it);
<a name="l13347"></a>13347         func(at(it)); inc&lt;0&gt;(it);
<a name="l13348"></a>13348         func(at(it)); inc&lt;0&gt;(it);
<a name="l13349"></a>13349         func(at(it)); inc&lt;0&gt;(it);
<a name="l13350"></a>13350     }
<a name="l13351"></a>13351 
<a name="l13352"></a>13352     <span class="keywordflow">if</span> (n &amp; 8) {
<a name="l13353"></a>13353         func(at(it)); inc&lt;0&gt;(it);
<a name="l13354"></a>13354         func(at(it)); inc&lt;0&gt;(it);
<a name="l13355"></a>13355         func(at(it)); inc&lt;0&gt;(it);
<a name="l13356"></a>13356         func(at(it)); inc&lt;0&gt;(it);
<a name="l13357"></a>13357         func(at(it)); inc&lt;0&gt;(it);
<a name="l13358"></a>13358         func(at(it)); inc&lt;0&gt;(it);
<a name="l13359"></a>13359         func(at(it)); inc&lt;0&gt;(it);
<a name="l13360"></a>13360         func(at(it)); inc&lt;0&gt;(it);
<a name="l13361"></a>13361     }
<a name="l13362"></a>13362     <span class="keywordflow">if</span> (n &amp; 4) {
<a name="l13363"></a>13363         func(at(it)); inc&lt;0&gt;(it);
<a name="l13364"></a>13364         func(at(it)); inc&lt;0&gt;(it);
<a name="l13365"></a>13365         func(at(it)); inc&lt;0&gt;(it);
<a name="l13366"></a>13366         func(at(it)); inc&lt;0&gt;(it);
<a name="l13367"></a>13367     }
<a name="l13368"></a>13368     <span class="keywordflow">if</span> (n &amp; 2) {
<a name="l13369"></a>13369         func(at(it)); inc&lt;0&gt;(it);
<a name="l13370"></a>13370         func(at(it)); inc&lt;0&gt;(it);
<a name="l13371"></a>13371     }
<a name="l13372"></a>13372 
<a name="l13373"></a>13373     <span class="keywordflow">if</span> (n &amp; 1)
<a name="l13374"></a>13374         func(at(it));
<a name="l13375"></a>13375     LITE_ARRAY_USE(size);
<a name="l13376"></a>13376 }
<a name="l13377"></a>13377 
<a name="l13378"></a>13378 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keyword">typename</span> type_&gt;
<a name="l13379"></a>13379 LITE_INLINE 
<a name="l13380"></a>13380 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l13381"></a>13381     !detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l13382"></a>13382     ), <span class="keywordtype">bool</span>&gt;::type 
<a name="l13383"></a>13383 <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(<span class="keyword">const</span> iterator_type_&amp; iter, <span class="keyword">const</span> pack&lt;type_&gt;&amp; size)
<a name="l13384"></a>13384 {
<a name="l13385"></a>13385     <span class="keyword">const</span> <span class="keywordtype">int</span> n = size.i0;
<a name="l13386"></a>13386     <span class="keywordtype">int</span> j=16;
<a name="l13387"></a>13387     iterator_type_ it = iter;
<a name="l13388"></a>13388 
<a name="l13389"></a>13389     <span class="keywordflow">for</span> (; j&lt;=n; j+=16) {
<a name="l13390"></a>13390         <span class="keywordflow">if</span>(!at(it)) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13391"></a>13391         <span class="keywordflow">if</span>(!at(it)) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13392"></a>13392         <span class="keywordflow">if</span>(!at(it)) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13393"></a>13393         <span class="keywordflow">if</span>(!at(it)) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13394"></a>13394         <span class="keywordflow">if</span>(!at(it)) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13395"></a>13395         <span class="keywordflow">if</span>(!at(it)) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13396"></a>13396         <span class="keywordflow">if</span>(!at(it)) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13397"></a>13397         <span class="keywordflow">if</span>(!at(it)) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13398"></a>13398         <span class="keywordflow">if</span>(!at(it)) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13399"></a>13399         <span class="keywordflow">if</span>(!at(it)) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13400"></a>13400         <span class="keywordflow">if</span>(!at(it)) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13401"></a>13401         <span class="keywordflow">if</span>(!at(it)) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13402"></a>13402         <span class="keywordflow">if</span>(!at(it)) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13403"></a>13403         <span class="keywordflow">if</span>(!at(it)) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13404"></a>13404         <span class="keywordflow">if</span>(!at(it)) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13405"></a>13405         <span class="keywordflow">if</span>(!at(it)) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13406"></a>13406     }
<a name="l13407"></a>13407 
<a name="l13408"></a>13408     <span class="keywordflow">if</span> (n &amp; 8) {
<a name="l13409"></a>13409         <span class="keywordflow">if</span>(!at(it)) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13410"></a>13410         <span class="keywordflow">if</span>(!at(it)) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13411"></a>13411         <span class="keywordflow">if</span>(!at(it)) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13412"></a>13412         <span class="keywordflow">if</span>(!at(it)) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13413"></a>13413         <span class="keywordflow">if</span>(!at(it)) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13414"></a>13414         <span class="keywordflow">if</span>(!at(it)) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13415"></a>13415         <span class="keywordflow">if</span>(!at(it)) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13416"></a>13416         <span class="keywordflow">if</span>(!at(it)) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13417"></a>13417     }
<a name="l13418"></a>13418     <span class="keywordflow">if</span> (n &amp; 4) {
<a name="l13419"></a>13419         <span class="keywordflow">if</span>(!at(it)) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13420"></a>13420         <span class="keywordflow">if</span>(!at(it)) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13421"></a>13421         <span class="keywordflow">if</span>(!at(it)) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13422"></a>13422         <span class="keywordflow">if</span>(!at(it)) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13423"></a>13423     }
<a name="l13424"></a>13424     <span class="keywordflow">if</span> (n &amp; 2) {
<a name="l13425"></a>13425         <span class="keywordflow">if</span>(!at(it)) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13426"></a>13426         <span class="keywordflow">if</span>(!at(it)) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13427"></a>13427     }
<a name="l13428"></a>13428 
<a name="l13429"></a>13429     <span class="keywordflow">if</span> (n &amp; 1)
<a name="l13430"></a>13430         <span class="keywordflow">if</span>(!at(it)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13431"></a>13431 
<a name="l13432"></a>13432     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l13433"></a>13433     LITE_ARRAY_USE(size);
<a name="l13434"></a>13434 }
<a name="l13435"></a>13435 
<a name="l13436"></a>13436 
<a name="l13437"></a>13437 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keyword">typename</span> function_type_, <span class="keyword">typename</span> type_&gt;
<a name="l13438"></a>13438 LITE_INLINE 
<a name="l13439"></a>13439 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l13440"></a>13440     !detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l13441"></a>13441     ), <span class="keywordtype">bool</span>&gt;::type 
<a name="l13442"></a>13442 <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(<span class="keyword">const</span> iterator_type_&amp; iter, function_type_&amp; func, <span class="keyword">const</span> pack&lt;type_&gt;&amp; size)
<a name="l13443"></a>13443 {
<a name="l13444"></a>13444     <span class="keyword">const</span> <span class="keywordtype">int</span> n = size.i0;
<a name="l13445"></a>13445     <span class="keywordtype">int</span> j=16;
<a name="l13446"></a>13446     iterator_type_ it = iter;
<a name="l13447"></a>13447 
<a name="l13448"></a>13448     <span class="keywordflow">for</span> (; j&lt;=n; j+=16) {
<a name="l13449"></a>13449         <span class="keywordflow">if</span>(!func(at(it))) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13450"></a>13450         <span class="keywordflow">if</span>(!func(at(it))) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13451"></a>13451         <span class="keywordflow">if</span>(!func(at(it))) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13452"></a>13452         <span class="keywordflow">if</span>(!func(at(it))) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13453"></a>13453         <span class="keywordflow">if</span>(!func(at(it))) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13454"></a>13454         <span class="keywordflow">if</span>(!func(at(it))) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13455"></a>13455         <span class="keywordflow">if</span>(!func(at(it))) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13456"></a>13456         <span class="keywordflow">if</span>(!func(at(it))) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13457"></a>13457         <span class="keywordflow">if</span>(!func(at(it))) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13458"></a>13458         <span class="keywordflow">if</span>(!func(at(it))) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13459"></a>13459         <span class="keywordflow">if</span>(!func(at(it))) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13460"></a>13460         <span class="keywordflow">if</span>(!func(at(it))) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13461"></a>13461         <span class="keywordflow">if</span>(!func(at(it))) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13462"></a>13462         <span class="keywordflow">if</span>(!func(at(it))) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13463"></a>13463         <span class="keywordflow">if</span>(!func(at(it))) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13464"></a>13464         <span class="keywordflow">if</span>(!func(at(it))) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13465"></a>13465     }
<a name="l13466"></a>13466 
<a name="l13467"></a>13467     <span class="keywordflow">if</span> (n &amp; 8) {
<a name="l13468"></a>13468         <span class="keywordflow">if</span>(!func(at(it))) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13469"></a>13469         <span class="keywordflow">if</span>(!func(at(it))) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13470"></a>13470         <span class="keywordflow">if</span>(!func(at(it))) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13471"></a>13471         <span class="keywordflow">if</span>(!func(at(it))) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13472"></a>13472         <span class="keywordflow">if</span>(!func(at(it))) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13473"></a>13473         <span class="keywordflow">if</span>(!func(at(it))) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13474"></a>13474         <span class="keywordflow">if</span>(!func(at(it))) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13475"></a>13475         <span class="keywordflow">if</span>(!func(at(it))) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13476"></a>13476     }
<a name="l13477"></a>13477     <span class="keywordflow">if</span> (n &amp; 4) {
<a name="l13478"></a>13478         <span class="keywordflow">if</span>(!func(at(it))) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13479"></a>13479         <span class="keywordflow">if</span>(!func(at(it))) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13480"></a>13480         <span class="keywordflow">if</span>(!func(at(it))) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13481"></a>13481         <span class="keywordflow">if</span>(!func(at(it))) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13482"></a>13482     }
<a name="l13483"></a>13483     <span class="keywordflow">if</span> (n &amp; 2) {
<a name="l13484"></a>13484         <span class="keywordflow">if</span>(!func(at(it))) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13485"></a>13485         <span class="keywordflow">if</span>(!func(at(it))) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13486"></a>13486     }
<a name="l13487"></a>13487 
<a name="l13488"></a>13488     <span class="keywordflow">if</span> (n &amp; 1)
<a name="l13489"></a>13489         <span class="keywordflow">if</span>(!func(at(it))) <span class="keywordflow">return</span> <span class="keyword">false</span>; inc&lt;0&gt;(it);
<a name="l13490"></a>13490 
<a name="l13491"></a>13491     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l13492"></a>13492     LITE_ARRAY_USE(size);
<a name="l13493"></a>13493 }
<a name="l13494"></a>13494 
<a name="l13495"></a>13495 <span class="comment">/***********************************************************************************************************/</span>
<a name="l13496"></a>13496 <span class="comment">/* for_each, small square 2D arrays, use_index *************************************************************/</span>
<a name="l13497"></a>13497 <span class="comment">/***********************************************************************************************************/</span>
<a name="l13498"></a>13498 
<a name="l13499"></a>13499 
<a name="l13500"></a>13500 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_&gt;
<a name="l13501"></a>13501 LITE_INLINE 
<a name="l13502"></a>13502 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l13503"></a>13503     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l13504"></a>13504     )&gt;::type 
<a name="l13505"></a>13505 <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(<span class="keyword">const</span> iterator_type_&amp; iter, <span class="keyword">const</span> pack&lt;constant&lt;int, 1&gt;, constant&lt;int, 1&gt; &gt;&amp;)
<a name="l13506"></a>13506 {
<a name="l13507"></a>13507     at(iter, 0, 0);
<a name="l13508"></a>13508 }
<a name="l13509"></a>13509 
<a name="l13510"></a>13510 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keyword">typename</span> function_type_&gt;
<a name="l13511"></a>13511 LITE_INLINE 
<a name="l13512"></a>13512 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l13513"></a>13513     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l13514"></a>13514     )&gt;::type 
<a name="l13515"></a>13515 <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(
<a name="l13516"></a>13516     <span class="keyword">const</span> iterator_type_&amp; iter, 
<a name="l13517"></a>13517     function_type_&amp; func, 
<a name="l13518"></a>13518     <span class="keyword">const</span> pack&lt;constant&lt;int, 1&gt;, constant&lt;int, 1&gt; &gt;&amp;)
<a name="l13519"></a>13519 {
<a name="l13520"></a>13520     func(at(iter, 0, 0));
<a name="l13521"></a>13521 }
<a name="l13522"></a>13522 
<a name="l13523"></a>13523 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_&gt;
<a name="l13524"></a>13524 LITE_INLINE 
<a name="l13525"></a>13525 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l13526"></a>13526     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l13527"></a>13527     ), <span class="keywordtype">bool</span>&gt;::type 
<a name="l13528"></a>13528 <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(
<a name="l13529"></a>13529     <span class="keyword">const</span> iterator_type_&amp; iter, 
<a name="l13530"></a>13530     <span class="keyword">const</span> pack&lt;constant&lt;int, 1&gt;, constant&lt;int, 1&gt; &gt;&amp;)
<a name="l13531"></a>13531 {
<a name="l13532"></a>13532     <span class="keywordflow">if</span> (!at(iter, 0, 0)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13533"></a>13533     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l13534"></a>13534 }
<a name="l13535"></a>13535 
<a name="l13536"></a>13536 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keyword">typename</span> function_type_&gt;
<a name="l13537"></a>13537 LITE_INLINE 
<a name="l13538"></a>13538 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l13539"></a>13539     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l13540"></a>13540     ), <span class="keywordtype">bool</span>&gt;::type 
<a name="l13541"></a>13541 <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(
<a name="l13542"></a>13542     <span class="keyword">const</span> iterator_type_&amp; iter, 
<a name="l13543"></a>13543     function_type_&amp; func, 
<a name="l13544"></a>13544     <span class="keyword">const</span> pack&lt;constant&lt;int, 1&gt;, constant&lt;int, 1&gt; &gt;&amp;)
<a name="l13545"></a>13545 {
<a name="l13546"></a>13546     <span class="keywordflow">if</span> (!func(at(iter, 0, 0))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13547"></a>13547     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l13548"></a>13548 }
<a name="l13549"></a>13549 
<a name="l13550"></a>13550 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_&gt;
<a name="l13551"></a>13551 LITE_INLINE 
<a name="l13552"></a>13552 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l13553"></a>13553     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l13554"></a>13554     )&gt;::type 
<a name="l13555"></a>13555 <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(<span class="keyword">const</span> iterator_type_&amp; iter, <span class="keyword">const</span> pack&lt;constant&lt;int, 2&gt;, constant&lt;int, 2&gt; &gt;&amp;)
<a name="l13556"></a>13556 {
<a name="l13557"></a>13557     at(iter, 0, 0);
<a name="l13558"></a>13558     at(iter, 0, 1);
<a name="l13559"></a>13559     at(iter, 1, 0);
<a name="l13560"></a>13560     at(iter, 1, 1);
<a name="l13561"></a>13561 }
<a name="l13562"></a>13562 
<a name="l13563"></a>13563 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keyword">typename</span> function_type_&gt;
<a name="l13564"></a>13564 LITE_INLINE 
<a name="l13565"></a>13565 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l13566"></a>13566     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l13567"></a>13567     )&gt;::type 
<a name="l13568"></a>13568 <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(
<a name="l13569"></a>13569     <span class="keyword">const</span> iterator_type_&amp; iter, 
<a name="l13570"></a>13570     function_type_&amp; func, 
<a name="l13571"></a>13571     <span class="keyword">const</span> pack&lt;constant&lt;int, 2&gt;, constant&lt;int, 2&gt; &gt;&amp;)
<a name="l13572"></a>13572 {
<a name="l13573"></a>13573     func(at(iter, 0, 0));
<a name="l13574"></a>13574     func(at(iter, 0, 1));
<a name="l13575"></a>13575     func(at(iter, 1, 0));
<a name="l13576"></a>13576     func(at(iter, 1, 1));
<a name="l13577"></a>13577 }
<a name="l13578"></a>13578 
<a name="l13579"></a>13579 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_&gt;
<a name="l13580"></a>13580 LITE_INLINE 
<a name="l13581"></a>13581 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l13582"></a>13582     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l13583"></a>13583     ), <span class="keywordtype">bool</span>&gt;::type 
<a name="l13584"></a>13584 <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(
<a name="l13585"></a>13585     <span class="keyword">const</span> iterator_type_&amp; iter, 
<a name="l13586"></a>13586     <span class="keyword">const</span> pack&lt;constant&lt;int, 2&gt;, constant&lt;int, 2&gt; &gt;&amp;)
<a name="l13587"></a>13587 {
<a name="l13588"></a>13588     <span class="keywordflow">if</span> (!at(iter, 0, 0)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13589"></a>13589     <span class="keywordflow">if</span> (!at(iter, 0, 1)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13590"></a>13590     <span class="keywordflow">if</span> (!at(iter, 1, 0)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13591"></a>13591     <span class="keywordflow">if</span> (!at(iter, 1, 1)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13592"></a>13592     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l13593"></a>13593 }
<a name="l13594"></a>13594 
<a name="l13595"></a>13595 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keyword">typename</span> function_type_&gt;
<a name="l13596"></a>13596 LITE_INLINE 
<a name="l13597"></a>13597 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l13598"></a>13598     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l13599"></a>13599     ), <span class="keywordtype">bool</span>&gt;::type 
<a name="l13600"></a>13600 <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(
<a name="l13601"></a>13601     <span class="keyword">const</span> iterator_type_&amp; iter, 
<a name="l13602"></a>13602     function_type_&amp; func, 
<a name="l13603"></a>13603     <span class="keyword">const</span> pack&lt;constant&lt;int, 2&gt;, constant&lt;int, 2&gt; &gt;&amp;)
<a name="l13604"></a>13604 {
<a name="l13605"></a>13605     <span class="keywordflow">if</span> (!func(at(iter, 0, 0))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13606"></a>13606     <span class="keywordflow">if</span> (!func(at(iter, 0, 1))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13607"></a>13607     <span class="keywordflow">if</span> (!func(at(iter, 1, 0))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13608"></a>13608     <span class="keywordflow">if</span> (!func(at(iter, 1, 1))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13609"></a>13609     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l13610"></a>13610 }
<a name="l13611"></a>13611 
<a name="l13612"></a>13612 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_&gt;
<a name="l13613"></a>13613 LITE_INLINE 
<a name="l13614"></a>13614 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l13615"></a>13615     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l13616"></a>13616     )&gt;::type 
<a name="l13617"></a>13617 <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(<span class="keyword">const</span> iterator_type_&amp; iter, <span class="keyword">const</span> pack&lt;constant&lt;int, 3&gt;, constant&lt;int, 3&gt; &gt;&amp;)
<a name="l13618"></a>13618 {
<a name="l13619"></a>13619     at(iter, 0, 0);
<a name="l13620"></a>13620     at(iter, 0, 1);
<a name="l13621"></a>13621     at(iter, 0, 2);
<a name="l13622"></a>13622     at(iter, 1, 0);
<a name="l13623"></a>13623     at(iter, 1, 1);
<a name="l13624"></a>13624     at(iter, 1, 2);
<a name="l13625"></a>13625     at(iter, 2, 0);
<a name="l13626"></a>13626     at(iter, 2, 1);
<a name="l13627"></a>13627     at(iter, 2, 2);
<a name="l13628"></a>13628 }
<a name="l13629"></a>13629 
<a name="l13630"></a>13630 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keyword">typename</span> function_type_&gt;
<a name="l13631"></a>13631 LITE_INLINE 
<a name="l13632"></a>13632 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l13633"></a>13633     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l13634"></a>13634     )&gt;::type 
<a name="l13635"></a>13635 <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(
<a name="l13636"></a>13636     <span class="keyword">const</span> iterator_type_&amp; iter, 
<a name="l13637"></a>13637     function_type_&amp; func, 
<a name="l13638"></a>13638     <span class="keyword">const</span> pack&lt;constant&lt;int, 3&gt;, constant&lt;int, 3&gt; &gt;&amp;)
<a name="l13639"></a>13639 {
<a name="l13640"></a>13640     func(at(iter, 0, 0));
<a name="l13641"></a>13641     func(at(iter, 0, 1));
<a name="l13642"></a>13642     func(at(iter, 0, 2));
<a name="l13643"></a>13643     func(at(iter, 1, 0));
<a name="l13644"></a>13644     func(at(iter, 1, 1));
<a name="l13645"></a>13645     func(at(iter, 1, 2));
<a name="l13646"></a>13646     func(at(iter, 2, 0));
<a name="l13647"></a>13647     func(at(iter, 2, 1));
<a name="l13648"></a>13648     func(at(iter, 2, 2));
<a name="l13649"></a>13649 }
<a name="l13650"></a>13650 
<a name="l13651"></a>13651 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_&gt;
<a name="l13652"></a>13652 LITE_INLINE 
<a name="l13653"></a>13653 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l13654"></a>13654     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l13655"></a>13655     ), <span class="keywordtype">bool</span>&gt;::type 
<a name="l13656"></a>13656 <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(
<a name="l13657"></a>13657     <span class="keyword">const</span> iterator_type_&amp; iter, 
<a name="l13658"></a>13658     <span class="keyword">const</span> pack&lt;constant&lt;int, 3&gt;, constant&lt;int, 3&gt; &gt;&amp;)
<a name="l13659"></a>13659 {
<a name="l13660"></a>13660     <span class="keywordflow">if</span> (!at(iter, 0, 0)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13661"></a>13661     <span class="keywordflow">if</span> (!at(iter, 0, 1)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13662"></a>13662     <span class="keywordflow">if</span> (!at(iter, 0, 2)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13663"></a>13663     <span class="keywordflow">if</span> (!at(iter, 1, 0)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13664"></a>13664     <span class="keywordflow">if</span> (!at(iter, 1, 1)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13665"></a>13665     <span class="keywordflow">if</span> (!at(iter, 1, 2)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13666"></a>13666     <span class="keywordflow">if</span> (!at(iter, 2, 0)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13667"></a>13667     <span class="keywordflow">if</span> (!at(iter, 2, 1)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13668"></a>13668     <span class="keywordflow">if</span> (!at(iter, 2, 2)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13669"></a>13669     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l13670"></a>13670 }
<a name="l13671"></a>13671 
<a name="l13672"></a>13672 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keyword">typename</span> function_type_&gt;
<a name="l13673"></a>13673 LITE_INLINE 
<a name="l13674"></a>13674 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l13675"></a>13675     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l13676"></a>13676     ), <span class="keywordtype">bool</span>&gt;::type 
<a name="l13677"></a>13677 <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(
<a name="l13678"></a>13678     <span class="keyword">const</span> iterator_type_&amp; iter, 
<a name="l13679"></a>13679     function_type_&amp; func, 
<a name="l13680"></a>13680     <span class="keyword">const</span> pack&lt;constant&lt;int, 3&gt;, constant&lt;int, 3&gt; &gt;&amp;)
<a name="l13681"></a>13681 {
<a name="l13682"></a>13682     <span class="keywordflow">if</span> (!func(at(iter, 0, 0))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13683"></a>13683     <span class="keywordflow">if</span> (!func(at(iter, 0, 1))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13684"></a>13684     <span class="keywordflow">if</span> (!func(at(iter, 0, 2))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13685"></a>13685     <span class="keywordflow">if</span> (!func(at(iter, 1, 0))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13686"></a>13686     <span class="keywordflow">if</span> (!func(at(iter, 1, 1))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13687"></a>13687     <span class="keywordflow">if</span> (!func(at(iter, 1, 2))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13688"></a>13688     <span class="keywordflow">if</span> (!func(at(iter, 2, 0))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13689"></a>13689     <span class="keywordflow">if</span> (!func(at(iter, 2, 1))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13690"></a>13690     <span class="keywordflow">if</span> (!func(at(iter, 2, 2))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13691"></a>13691     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l13692"></a>13692 }
<a name="l13693"></a>13693 
<a name="l13694"></a>13694 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_&gt;
<a name="l13695"></a>13695 LITE_INLINE 
<a name="l13696"></a>13696 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l13697"></a>13697     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l13698"></a>13698     )&gt;::type 
<a name="l13699"></a>13699 <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(<span class="keyword">const</span> iterator_type_&amp; iter, <span class="keyword">const</span> pack&lt;constant&lt;int, 4&gt;, constant&lt;int, 4&gt; &gt;&amp;)
<a name="l13700"></a>13700 {
<a name="l13701"></a>13701     at(iter, 0, 0);
<a name="l13702"></a>13702     at(iter, 0, 1);
<a name="l13703"></a>13703     at(iter, 0, 2);
<a name="l13704"></a>13704     at(iter, 0, 3);
<a name="l13705"></a>13705     at(iter, 1, 0);
<a name="l13706"></a>13706     at(iter, 1, 1);
<a name="l13707"></a>13707     at(iter, 1, 2);
<a name="l13708"></a>13708     at(iter, 1, 3);
<a name="l13709"></a>13709     at(iter, 2, 0);
<a name="l13710"></a>13710     at(iter, 2, 1);
<a name="l13711"></a>13711     at(iter, 2, 2);
<a name="l13712"></a>13712     at(iter, 2, 3);
<a name="l13713"></a>13713     at(iter, 3, 0);
<a name="l13714"></a>13714     at(iter, 3, 1);
<a name="l13715"></a>13715     at(iter, 3, 2);
<a name="l13716"></a>13716     at(iter, 3, 3);
<a name="l13717"></a>13717 }
<a name="l13718"></a>13718 
<a name="l13719"></a>13719 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keyword">typename</span> function_type_&gt;
<a name="l13720"></a>13720 LITE_INLINE 
<a name="l13721"></a>13721 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l13722"></a>13722     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l13723"></a>13723     )&gt;::type 
<a name="l13724"></a>13724 <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(
<a name="l13725"></a>13725     <span class="keyword">const</span> iterator_type_&amp; iter, 
<a name="l13726"></a>13726     function_type_&amp; func, 
<a name="l13727"></a>13727     <span class="keyword">const</span> pack&lt;constant&lt;int, 4&gt;, constant&lt;int, 4&gt; &gt;&amp;)
<a name="l13728"></a>13728 {
<a name="l13729"></a>13729     func(at(iter, 0, 0));
<a name="l13730"></a>13730     func(at(iter, 0, 1));
<a name="l13731"></a>13731     func(at(iter, 0, 2));
<a name="l13732"></a>13732     func(at(iter, 0, 3));
<a name="l13733"></a>13733     func(at(iter, 1, 0));
<a name="l13734"></a>13734     func(at(iter, 1, 1));
<a name="l13735"></a>13735     func(at(iter, 1, 2));
<a name="l13736"></a>13736     func(at(iter, 1, 3));
<a name="l13737"></a>13737     func(at(iter, 2, 0));
<a name="l13738"></a>13738     func(at(iter, 2, 1));
<a name="l13739"></a>13739     func(at(iter, 2, 2));
<a name="l13740"></a>13740     func(at(iter, 2, 3));
<a name="l13741"></a>13741     func(at(iter, 3, 0));
<a name="l13742"></a>13742     func(at(iter, 3, 1));
<a name="l13743"></a>13743     func(at(iter, 3, 2));
<a name="l13744"></a>13744     func(at(iter, 3, 3));
<a name="l13745"></a>13745 }
<a name="l13746"></a>13746 
<a name="l13747"></a>13747 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_&gt;
<a name="l13748"></a>13748 LITE_INLINE 
<a name="l13749"></a>13749 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l13750"></a>13750     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l13751"></a>13751     ), <span class="keywordtype">bool</span>&gt;::type 
<a name="l13752"></a>13752 <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(
<a name="l13753"></a>13753     <span class="keyword">const</span> iterator_type_&amp; iter, 
<a name="l13754"></a>13754     <span class="keyword">const</span> pack&lt;constant&lt;int, 4&gt;, constant&lt;int, 4&gt; &gt;&amp;)
<a name="l13755"></a>13755 {
<a name="l13756"></a>13756     <span class="keywordflow">if</span> (!at(iter, 0, 0)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13757"></a>13757     <span class="keywordflow">if</span> (!at(iter, 0, 1)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13758"></a>13758     <span class="keywordflow">if</span> (!at(iter, 0, 2)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13759"></a>13759     <span class="keywordflow">if</span> (!at(iter, 0, 3)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13760"></a>13760     <span class="keywordflow">if</span> (!at(iter, 1, 0)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13761"></a>13761     <span class="keywordflow">if</span> (!at(iter, 1, 1)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13762"></a>13762     <span class="keywordflow">if</span> (!at(iter, 1, 2)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13763"></a>13763     <span class="keywordflow">if</span> (!at(iter, 1, 3)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13764"></a>13764     <span class="keywordflow">if</span> (!at(iter, 2, 0)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13765"></a>13765     <span class="keywordflow">if</span> (!at(iter, 2, 1)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13766"></a>13766     <span class="keywordflow">if</span> (!at(iter, 2, 2)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13767"></a>13767     <span class="keywordflow">if</span> (!at(iter, 2, 3)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13768"></a>13768     <span class="keywordflow">if</span> (!at(iter, 3, 0)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13769"></a>13769     <span class="keywordflow">if</span> (!at(iter, 3, 1)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13770"></a>13770     <span class="keywordflow">if</span> (!at(iter, 3, 2)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13771"></a>13771     <span class="keywordflow">if</span> (!at(iter, 3, 3)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13772"></a>13772     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l13773"></a>13773 }
<a name="l13774"></a>13774 
<a name="l13775"></a>13775 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keyword">typename</span> function_type_&gt;
<a name="l13776"></a>13776 LITE_INLINE 
<a name="l13777"></a>13777 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l13778"></a>13778     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l13779"></a>13779     ), <span class="keywordtype">bool</span>&gt;::type 
<a name="l13780"></a>13780 <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(
<a name="l13781"></a>13781     <span class="keyword">const</span> iterator_type_&amp; iter, 
<a name="l13782"></a>13782     function_type_&amp; func, 
<a name="l13783"></a>13783     <span class="keyword">const</span> pack&lt;constant&lt;int, 4&gt;, constant&lt;int, 4&gt; &gt;&amp;)
<a name="l13784"></a>13784 {
<a name="l13785"></a>13785     <span class="keywordflow">if</span> (!func(at(iter, 0, 0))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13786"></a>13786     <span class="keywordflow">if</span> (!func(at(iter, 0, 1))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13787"></a>13787     <span class="keywordflow">if</span> (!func(at(iter, 0, 2))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13788"></a>13788     <span class="keywordflow">if</span> (!func(at(iter, 0, 3))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13789"></a>13789     <span class="keywordflow">if</span> (!func(at(iter, 1, 0))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13790"></a>13790     <span class="keywordflow">if</span> (!func(at(iter, 1, 1))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13791"></a>13791     <span class="keywordflow">if</span> (!func(at(iter, 1, 2))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13792"></a>13792     <span class="keywordflow">if</span> (!func(at(iter, 1, 3))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13793"></a>13793     <span class="keywordflow">if</span> (!func(at(iter, 2, 0))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13794"></a>13794     <span class="keywordflow">if</span> (!func(at(iter, 2, 1))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13795"></a>13795     <span class="keywordflow">if</span> (!func(at(iter, 2, 2))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13796"></a>13796     <span class="keywordflow">if</span> (!func(at(iter, 2, 3))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13797"></a>13797     <span class="keywordflow">if</span> (!func(at(iter, 3, 0))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13798"></a>13798     <span class="keywordflow">if</span> (!func(at(iter, 3, 1))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13799"></a>13799     <span class="keywordflow">if</span> (!func(at(iter, 3, 2))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13800"></a>13800     <span class="keywordflow">if</span> (!func(at(iter, 3, 3))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13801"></a>13801     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l13802"></a>13802 }
<a name="l13803"></a>13803 
<a name="l13804"></a>13804 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_&gt;
<a name="l13805"></a>13805 LITE_INLINE 
<a name="l13806"></a>13806 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l13807"></a>13807     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l13808"></a>13808     )&gt;::type 
<a name="l13809"></a>13809 <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(<span class="keyword">const</span> iterator_type_&amp; iter, <span class="keyword">const</span> pack&lt;constant&lt;int, 5&gt;, constant&lt;int, 5&gt; &gt;&amp;)
<a name="l13810"></a>13810 {
<a name="l13811"></a>13811     at(iter, 0, 0);
<a name="l13812"></a>13812     at(iter, 0, 1);
<a name="l13813"></a>13813     at(iter, 0, 2);
<a name="l13814"></a>13814     at(iter, 0, 3);
<a name="l13815"></a>13815     at(iter, 0, 4);
<a name="l13816"></a>13816     at(iter, 1, 0);
<a name="l13817"></a>13817     at(iter, 1, 1);
<a name="l13818"></a>13818     at(iter, 1, 2);
<a name="l13819"></a>13819     at(iter, 1, 3);
<a name="l13820"></a>13820     at(iter, 1, 4);
<a name="l13821"></a>13821     at(iter, 2, 0);
<a name="l13822"></a>13822     at(iter, 2, 1);
<a name="l13823"></a>13823     at(iter, 2, 2);
<a name="l13824"></a>13824     at(iter, 2, 3);
<a name="l13825"></a>13825     at(iter, 2, 4);
<a name="l13826"></a>13826     at(iter, 3, 0);
<a name="l13827"></a>13827     at(iter, 3, 1);
<a name="l13828"></a>13828     at(iter, 3, 2);
<a name="l13829"></a>13829     at(iter, 3, 3);
<a name="l13830"></a>13830     at(iter, 3, 4);
<a name="l13831"></a>13831     at(iter, 4, 0);
<a name="l13832"></a>13832     at(iter, 4, 1);
<a name="l13833"></a>13833     at(iter, 4, 2);
<a name="l13834"></a>13834     at(iter, 4, 3);
<a name="l13835"></a>13835     at(iter, 4, 4);
<a name="l13836"></a>13836 }
<a name="l13837"></a>13837 
<a name="l13838"></a>13838 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keyword">typename</span> function_type_&gt;
<a name="l13839"></a>13839 LITE_INLINE 
<a name="l13840"></a>13840 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l13841"></a>13841     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l13842"></a>13842     )&gt;::type 
<a name="l13843"></a>13843 <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(
<a name="l13844"></a>13844     <span class="keyword">const</span> iterator_type_&amp; iter, 
<a name="l13845"></a>13845     function_type_&amp; func, 
<a name="l13846"></a>13846     <span class="keyword">const</span> pack&lt;constant&lt;int, 5&gt;, constant&lt;int, 5&gt; &gt;&amp;)
<a name="l13847"></a>13847 {
<a name="l13848"></a>13848     func(at(iter, 0, 0));
<a name="l13849"></a>13849     func(at(iter, 0, 1));
<a name="l13850"></a>13850     func(at(iter, 0, 2));
<a name="l13851"></a>13851     func(at(iter, 0, 3));
<a name="l13852"></a>13852     func(at(iter, 0, 4));
<a name="l13853"></a>13853     func(at(iter, 1, 0));
<a name="l13854"></a>13854     func(at(iter, 1, 1));
<a name="l13855"></a>13855     func(at(iter, 1, 2));
<a name="l13856"></a>13856     func(at(iter, 1, 3));
<a name="l13857"></a>13857     func(at(iter, 1, 4));
<a name="l13858"></a>13858     func(at(iter, 2, 0));
<a name="l13859"></a>13859     func(at(iter, 2, 1));
<a name="l13860"></a>13860     func(at(iter, 2, 2));
<a name="l13861"></a>13861     func(at(iter, 2, 3));
<a name="l13862"></a>13862     func(at(iter, 2, 4));
<a name="l13863"></a>13863     func(at(iter, 3, 0));
<a name="l13864"></a>13864     func(at(iter, 3, 1));
<a name="l13865"></a>13865     func(at(iter, 3, 2));
<a name="l13866"></a>13866     func(at(iter, 3, 3));
<a name="l13867"></a>13867     func(at(iter, 3, 4));
<a name="l13868"></a>13868     func(at(iter, 4, 0));
<a name="l13869"></a>13869     func(at(iter, 4, 1));
<a name="l13870"></a>13870     func(at(iter, 4, 2));
<a name="l13871"></a>13871     func(at(iter, 4, 3));
<a name="l13872"></a>13872     func(at(iter, 4, 4));
<a name="l13873"></a>13873 }
<a name="l13874"></a>13874 
<a name="l13875"></a>13875 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_&gt;
<a name="l13876"></a>13876 LITE_INLINE 
<a name="l13877"></a>13877 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l13878"></a>13878     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l13879"></a>13879     ), <span class="keywordtype">bool</span>&gt;::type 
<a name="l13880"></a>13880 <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(
<a name="l13881"></a>13881     <span class="keyword">const</span> iterator_type_&amp; iter, 
<a name="l13882"></a>13882     <span class="keyword">const</span> pack&lt;constant&lt;int, 5&gt;, constant&lt;int, 5&gt; &gt;&amp;)
<a name="l13883"></a>13883 {
<a name="l13884"></a>13884     <span class="keywordflow">if</span> (!at(iter, 0, 0)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13885"></a>13885     <span class="keywordflow">if</span> (!at(iter, 0, 1)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13886"></a>13886     <span class="keywordflow">if</span> (!at(iter, 0, 2)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13887"></a>13887     <span class="keywordflow">if</span> (!at(iter, 0, 3)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13888"></a>13888     <span class="keywordflow">if</span> (!at(iter, 0, 4)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13889"></a>13889     <span class="keywordflow">if</span> (!at(iter, 1, 0)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13890"></a>13890     <span class="keywordflow">if</span> (!at(iter, 1, 1)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13891"></a>13891     <span class="keywordflow">if</span> (!at(iter, 1, 2)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13892"></a>13892     <span class="keywordflow">if</span> (!at(iter, 1, 3)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13893"></a>13893     <span class="keywordflow">if</span> (!at(iter, 1, 4)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13894"></a>13894     <span class="keywordflow">if</span> (!at(iter, 2, 0)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13895"></a>13895     <span class="keywordflow">if</span> (!at(iter, 2, 1)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13896"></a>13896     <span class="keywordflow">if</span> (!at(iter, 2, 2)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13897"></a>13897     <span class="keywordflow">if</span> (!at(iter, 2, 3)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13898"></a>13898     <span class="keywordflow">if</span> (!at(iter, 2, 4)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13899"></a>13899     <span class="keywordflow">if</span> (!at(iter, 3, 0)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13900"></a>13900     <span class="keywordflow">if</span> (!at(iter, 3, 1)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13901"></a>13901     <span class="keywordflow">if</span> (!at(iter, 3, 2)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13902"></a>13902     <span class="keywordflow">if</span> (!at(iter, 3, 3)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13903"></a>13903     <span class="keywordflow">if</span> (!at(iter, 3, 4)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13904"></a>13904     <span class="keywordflow">if</span> (!at(iter, 4, 0)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13905"></a>13905     <span class="keywordflow">if</span> (!at(iter, 4, 1)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13906"></a>13906     <span class="keywordflow">if</span> (!at(iter, 4, 2)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13907"></a>13907     <span class="keywordflow">if</span> (!at(iter, 4, 3)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13908"></a>13908     <span class="keywordflow">if</span> (!at(iter, 4, 4)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13909"></a>13909     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l13910"></a>13910 }
<a name="l13911"></a>13911 
<a name="l13912"></a>13912 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keyword">typename</span> function_type_&gt;
<a name="l13913"></a>13913 LITE_INLINE 
<a name="l13914"></a>13914 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l13915"></a>13915     detail::g_iterator_policy&lt;iterator_type_&gt;::use_index
<a name="l13916"></a>13916     ), <span class="keywordtype">bool</span>&gt;::type 
<a name="l13917"></a>13917 <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(
<a name="l13918"></a>13918     <span class="keyword">const</span> iterator_type_&amp; iter, 
<a name="l13919"></a>13919     function_type_&amp; func, 
<a name="l13920"></a>13920     <span class="keyword">const</span> pack&lt;constant&lt;int, 5&gt;, constant&lt;int, 5&gt; &gt;&amp;)
<a name="l13921"></a>13921 {
<a name="l13922"></a>13922     <span class="keywordflow">if</span> (!func(at(iter, 0, 0))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13923"></a>13923     <span class="keywordflow">if</span> (!func(at(iter, 0, 1))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13924"></a>13924     <span class="keywordflow">if</span> (!func(at(iter, 0, 2))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13925"></a>13925     <span class="keywordflow">if</span> (!func(at(iter, 0, 3))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13926"></a>13926     <span class="keywordflow">if</span> (!func(at(iter, 0, 4))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13927"></a>13927     <span class="keywordflow">if</span> (!func(at(iter, 1, 0))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13928"></a>13928     <span class="keywordflow">if</span> (!func(at(iter, 1, 1))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13929"></a>13929     <span class="keywordflow">if</span> (!func(at(iter, 1, 2))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13930"></a>13930     <span class="keywordflow">if</span> (!func(at(iter, 1, 3))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13931"></a>13931     <span class="keywordflow">if</span> (!func(at(iter, 1, 4))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13932"></a>13932     <span class="keywordflow">if</span> (!func(at(iter, 2, 0))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13933"></a>13933     <span class="keywordflow">if</span> (!func(at(iter, 2, 1))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13934"></a>13934     <span class="keywordflow">if</span> (!func(at(iter, 2, 2))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13935"></a>13935     <span class="keywordflow">if</span> (!func(at(iter, 2, 3))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13936"></a>13936     <span class="keywordflow">if</span> (!func(at(iter, 2, 4))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13937"></a>13937     <span class="keywordflow">if</span> (!func(at(iter, 3, 0))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13938"></a>13938     <span class="keywordflow">if</span> (!func(at(iter, 3, 1))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13939"></a>13939     <span class="keywordflow">if</span> (!func(at(iter, 3, 2))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13940"></a>13940     <span class="keywordflow">if</span> (!func(at(iter, 3, 3))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13941"></a>13941     <span class="keywordflow">if</span> (!func(at(iter, 3, 4))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13942"></a>13942     <span class="keywordflow">if</span> (!func(at(iter, 4, 0))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13943"></a>13943     <span class="keywordflow">if</span> (!func(at(iter, 4, 1))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13944"></a>13944     <span class="keywordflow">if</span> (!func(at(iter, 4, 2))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13945"></a>13945     <span class="keywordflow">if</span> (!func(at(iter, 4, 3))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13946"></a>13946     <span class="keywordflow">if</span> (!func(at(iter, 4, 4))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l13947"></a>13947     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l13948"></a>13948 }
<a name="l13949"></a>13949 
<a name="l13950"></a>13950 <span class="comment">/***********************************************************************************************************/</span>
<a name="l13951"></a>13951 <span class="comment">/* for_each, nD arrays *************************************************************************************/</span>
<a name="l13952"></a>13952 <span class="comment">/***********************************************************************************************************/</span>
<a name="l13953"></a>13953 
<a name="l13954"></a>13954 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keyword">typename</span> <span class="keywordtype">size_t</span>ype_&gt;
<a name="l13955"></a>13955 LITE_INLINE 
<a name="l13956"></a>13956 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l13957"></a>13957     size_type_::n &gt; 1
<a name="l13958"></a>13958     )&gt;::type 
<a name="l13959"></a>13959 <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(<span class="keyword">const</span> iterator_type_&amp; iter, <span class="keyword">const</span> size_type_&amp; size)
<a name="l13960"></a>13960 {
<a name="l13961"></a>13961     <span class="keyword">typedef</span> size_transformer&lt;plane&lt;0&gt;, size_type_&gt; s_transformer;
<a name="l13962"></a>13962     <span class="keyword">typedef</span> iterator_transformer&lt;plane&lt;0&gt;, iterator_type_, size_type_&gt; i_transformer;
<a name="l13963"></a>13963 
<a name="l13964"></a>13964     iterator_type_ it = iter;
<a name="l13965"></a>13965     <span class="keyword">typename</span> s_transformer::size_type new_size;
<a name="l13966"></a>13966     <span class="keyword">typename</span> i_transformer::iterator_type new_it;
<a name="l13967"></a>13967     <span class="keyword">const</span> <span class="keywordtype">int</span> n = size.i0;
<a name="l13968"></a>13968 
<a name="l13969"></a>13969     s_transformer::transform(size, new_size);
<a name="l13970"></a>13970 
<a name="l13971"></a>13971     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; i++) {
<a name="l13972"></a>13972         i_transformer::transform(it, new_it);
<a name="l13973"></a>13973         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(new_it, new_size);
<a name="l13974"></a>13974         inc&lt;0&gt;(it);
<a name="l13975"></a>13975     }
<a name="l13976"></a>13976 }
<a name="l13977"></a>13977 
<a name="l13978"></a>13978 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keyword">typename</span> function_type_, <span class="keyword">typename</span> <span class="keywordtype">size_t</span>ype_&gt;
<a name="l13979"></a>13979 LITE_INLINE 
<a name="l13980"></a>13980 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l13981"></a>13981     size_type_::n &gt; 1
<a name="l13982"></a>13982     )&gt;::type 
<a name="l13983"></a>13983 <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(<span class="keyword">const</span> iterator_type_&amp; iter, function_type_&amp; func, <span class="keyword">const</span> size_type_&amp; size)
<a name="l13984"></a>13984 {
<a name="l13985"></a>13985     <span class="keyword">typedef</span> size_transformer&lt;plane&lt;0&gt;, size_type_&gt; s_transformer;
<a name="l13986"></a>13986     <span class="keyword">typedef</span> iterator_transformer&lt;plane&lt;0&gt;, iterator_type_, size_type_&gt; i_transformer;
<a name="l13987"></a>13987 
<a name="l13988"></a>13988     iterator_type_ it = iter;
<a name="l13989"></a>13989     <span class="keyword">typename</span> s_transformer::size_type new_size;
<a name="l13990"></a>13990     <span class="keyword">typename</span> i_transformer::iterator_type new_it;
<a name="l13991"></a>13991     <span class="keyword">const</span> <span class="keywordtype">int</span> n = size.i0;
<a name="l13992"></a>13992 
<a name="l13993"></a>13993     s_transformer::transform(size, new_size);
<a name="l13994"></a>13994 
<a name="l13995"></a>13995     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; i++) {
<a name="l13996"></a>13996         i_transformer::transform(it, new_it);
<a name="l13997"></a>13997         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(new_it, func, new_size);
<a name="l13998"></a>13998         inc&lt;0&gt;(it);
<a name="l13999"></a>13999     }
<a name="l14000"></a>14000 }
<a name="l14001"></a>14001 
<a name="l14002"></a>14002 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keyword">typename</span> <span class="keywordtype">size_t</span>ype_&gt;
<a name="l14003"></a>14003 LITE_INLINE 
<a name="l14004"></a>14004 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l14005"></a>14005     size_type_::n &gt; 1
<a name="l14006"></a>14006     ), <span class="keywordtype">bool</span>&gt;::type 
<a name="l14007"></a>14007 <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(<span class="keyword">const</span> iterator_type_&amp; iter, <span class="keyword">const</span> size_type_&amp; size)
<a name="l14008"></a>14008 {
<a name="l14009"></a>14009     <span class="keyword">typedef</span> size_transformer&lt;plane&lt;0&gt;, size_type_&gt; s_transformer;
<a name="l14010"></a>14010     <span class="keyword">typedef</span> iterator_transformer&lt;plane&lt;0&gt;, iterator_type_, size_type_&gt; i_transformer;
<a name="l14011"></a>14011 
<a name="l14012"></a>14012     iterator_type_ it = iter;
<a name="l14013"></a>14013     <span class="keyword">typename</span> s_transformer::size_type new_size;
<a name="l14014"></a>14014     <span class="keyword">typename</span> i_transformer::iterator_type new_it;
<a name="l14015"></a>14015     <span class="keyword">const</span> <span class="keywordtype">int</span> n = size.i0;
<a name="l14016"></a>14016 
<a name="l14017"></a>14017     s_transformer::transform(size, new_size);
<a name="l14018"></a>14018 
<a name="l14019"></a>14019     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; i++) {
<a name="l14020"></a>14020         i_transformer::transform(it, new_it);
<a name="l14021"></a>14021         <span class="keywordflow">if</span> (!<a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(new_it, new_size))
<a name="l14022"></a>14022             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l14023"></a>14023         inc&lt;0&gt;(it);
<a name="l14024"></a>14024     }
<a name="l14025"></a>14025     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l14026"></a>14026 }
<a name="l14027"></a>14027 
<a name="l14028"></a>14028 
<a name="l14029"></a>14029 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keyword">typename</span> function_type_, <span class="keyword">typename</span> <span class="keywordtype">size_t</span>ype_&gt;
<a name="l14030"></a>14030 LITE_INLINE 
<a name="l14031"></a>14031 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l14032"></a>14032     size_type_::n &gt; 1
<a name="l14033"></a>14033     ), <span class="keywordtype">bool</span>&gt;::type 
<a name="l14034"></a>14034 <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(<span class="keyword">const</span> iterator_type_&amp; iter, function_type_&amp; func, <span class="keyword">const</span> size_type_&amp; size)
<a name="l14035"></a>14035 {
<a name="l14036"></a>14036     <span class="keyword">typedef</span> size_transformer&lt;plane&lt;0&gt;, size_type_&gt; s_transformer;
<a name="l14037"></a>14037     <span class="keyword">typedef</span> iterator_transformer&lt;plane&lt;0&gt;, iterator_type_, size_type_&gt; i_transformer;
<a name="l14038"></a>14038 
<a name="l14039"></a>14039     iterator_type_ it = iter;
<a name="l14040"></a>14040     <span class="keyword">typename</span> s_transformer::size_type new_size;
<a name="l14041"></a>14041     <span class="keyword">typename</span> i_transformer::iterator_type new_it;
<a name="l14042"></a>14042     <span class="keyword">const</span> <span class="keywordtype">int</span> n = size.i0;
<a name="l14043"></a>14043 
<a name="l14044"></a>14044     s_transformer::transform(size, new_size);
<a name="l14045"></a>14045 
<a name="l14046"></a>14046     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; i++) {
<a name="l14047"></a>14047         i_transformer::transform(it, new_it);
<a name="l14048"></a>14048         <span class="keywordflow">if</span> (!<a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(new_it, func, new_size))
<a name="l14049"></a>14049             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l14050"></a>14050         inc&lt;0&gt;(it);
<a name="l14051"></a>14051     }
<a name="l14052"></a>14052     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l14053"></a>14053 }
<a name="l14054"></a>14054 
<a name="l14055"></a>14055 <span class="preprocessor">#endif // !DOCUMENTATION_ONLY</span>
<a name="l14056"></a>14056 <span class="preprocessor"></span>
<a name="l14057"></a>14057 <span class="comment">/***********************************************************************************************************/</span>
<a name="l14058"></a>14058 <span class="comment">/* for_each ************************************************************************************************/</span>
<a name="l14059"></a>14059 <span class="comment">/***********************************************************************************************************/</span>
<a name="l14060"></a>14060 
<a name="l14066"></a>14066 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> rep_&gt;
<a name="l14067"></a><a class="code" href="group__array__advanced.html#gae4c4d93cf48d887d0631808c5363e811">14067</a> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(<span class="keyword">const</span> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array&lt;signature_, traits_type_, rep_&gt;</a>&amp; a)
<a name="l14068"></a>14068 {
<a name="l14069"></a>14069     <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(a.<a class="code" href="classlite_1_1array.html#a3bd433b68e11c186a7ada3f1243da8e7" title="Returns a const iterator pointing to the start of the array.">begin</a>(), a.<a class="code" href="classlite_1_1array.html#a59ff65a488e4c6900d4359bcc7725fdf" title="Returns a size object containing the dimension sizes of the array.">size</a>());
<a name="l14070"></a>14070 }
<a name="l14071"></a>14071 
<a name="l14077"></a>14077 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> rep_&gt;
<a name="l14078"></a><a class="code" href="group__array__advanced.html#ga869f2a4f0d0db22d30f917953422cca4">14078</a> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(<a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array&lt;signature_, traits_type_, rep_&gt;</a>&amp; a)
<a name="l14079"></a>14079 {
<a name="l14080"></a>14080     <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(a.<a class="code" href="classlite_1_1array.html#a3bd433b68e11c186a7ada3f1243da8e7" title="Returns a const iterator pointing to the start of the array.">begin</a>(), a.<a class="code" href="classlite_1_1array.html#a59ff65a488e4c6900d4359bcc7725fdf" title="Returns a size object containing the dimension sizes of the array.">size</a>());
<a name="l14081"></a>14081 }
<a name="l14082"></a>14082 
<a name="l14089"></a>14089 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> rep_, <span class="keyword">typename</span> function_type_&gt;
<a name="l14090"></a><a class="code" href="group__array__advanced.html#gaeec716d4a871ade50986b09a0bcee5e3">14090</a> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(<span class="keyword">const</span> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array&lt;signature_, traits_type_, rep_&gt;</a>&amp; a, function_type_&amp; func)
<a name="l14091"></a>14091 {
<a name="l14092"></a>14092     <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(a.<a class="code" href="classlite_1_1array.html#a3bd433b68e11c186a7ada3f1243da8e7" title="Returns a const iterator pointing to the start of the array.">begin</a>(), func, a.<a class="code" href="classlite_1_1array.html#a59ff65a488e4c6900d4359bcc7725fdf" title="Returns a size object containing the dimension sizes of the array.">size</a>());
<a name="l14093"></a>14093 }
<a name="l14094"></a>14094 
<a name="l14101"></a>14101 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> rep_, <span class="keyword">typename</span> function_type_&gt;
<a name="l14102"></a><a class="code" href="group__array__advanced.html#ga5a02857b5f1087fd848c950e383ef78b">14102</a> LITE_INLINE <span class="keywordtype">void</span> <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(<a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array&lt;signature_, traits_type_, rep_&gt;</a>&amp; a, function_type_&amp; func)
<a name="l14103"></a>14103 {
<a name="l14104"></a>14104     <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(a.<a class="code" href="classlite_1_1array.html#a3bd433b68e11c186a7ada3f1243da8e7" title="Returns a const iterator pointing to the start of the array.">begin</a>(), func, a.<a class="code" href="classlite_1_1array.html#a59ff65a488e4c6900d4359bcc7725fdf" title="Returns a size object containing the dimension sizes of the array.">size</a>());
<a name="l14105"></a>14105 }
<a name="l14106"></a>14106 
<a name="l14114"></a>14114 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> rep_&gt;
<a name="l14115"></a><a class="code" href="group__array__advanced.html#gadbfa18f6b6deaeec17a9b7af8d8823c9">14115</a> LITE_INLINE <span class="keywordtype">bool</span> <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(<span class="keyword">const</span> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array&lt;signature_, traits_type_, rep_&gt;</a>&amp; a)
<a name="l14116"></a>14116 {
<a name="l14117"></a>14117     <span class="keywordflow">return</span> <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(a.<a class="code" href="classlite_1_1array.html#a3bd433b68e11c186a7ada3f1243da8e7" title="Returns a const iterator pointing to the start of the array.">begin</a>(), a.<a class="code" href="classlite_1_1array.html#a59ff65a488e4c6900d4359bcc7725fdf" title="Returns a size object containing the dimension sizes of the array.">size</a>());
<a name="l14118"></a>14118 }
<a name="l14119"></a>14119 
<a name="l14127"></a>14127 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> rep_&gt;
<a name="l14128"></a><a class="code" href="group__array__advanced.html#ga16a9897094cfe85dc560540d919866c0">14128</a> LITE_INLINE <span class="keywordtype">bool</span> <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(<a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array&lt;signature_, traits_type_, rep_&gt;</a>&amp; a)
<a name="l14129"></a>14129 {
<a name="l14130"></a>14130     <span class="keywordflow">return</span> <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(a.<a class="code" href="classlite_1_1array.html#a3bd433b68e11c186a7ada3f1243da8e7" title="Returns a const iterator pointing to the start of the array.">begin</a>(), a.<a class="code" href="classlite_1_1array.html#a59ff65a488e4c6900d4359bcc7725fdf" title="Returns a size object containing the dimension sizes of the array.">size</a>());
<a name="l14131"></a>14131 }
<a name="l14132"></a>14132 
<a name="l14141"></a>14141 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> rep_, <span class="keyword">typename</span> function_type_&gt;
<a name="l14142"></a><a class="code" href="group__array__advanced.html#ga8bee7c5910cadbc08e99ed4b170fe54c">14142</a> LITE_INLINE <span class="keywordtype">bool</span> <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(<span class="keyword">const</span> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array&lt;signature_, traits_type_, rep_&gt;</a>&amp; a, function_type_&amp; func)
<a name="l14143"></a>14143 {
<a name="l14144"></a>14144     <span class="keywordflow">return</span> <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(a.<a class="code" href="classlite_1_1array.html#a3bd433b68e11c186a7ada3f1243da8e7" title="Returns a const iterator pointing to the start of the array.">begin</a>(), func, a.<a class="code" href="classlite_1_1array.html#a59ff65a488e4c6900d4359bcc7725fdf" title="Returns a size object containing the dimension sizes of the array.">size</a>());
<a name="l14145"></a>14145 }
<a name="l14146"></a>14146 
<a name="l14155"></a>14155 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> rep_, <span class="keyword">typename</span> function_type_&gt;
<a name="l14156"></a><a class="code" href="group__array__advanced.html#gaabe64179bd450168e3afdab57dcfc197">14156</a> LITE_INLINE <span class="keywordtype">bool</span> <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(<a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array&lt;signature_, traits_type_, rep_&gt;</a>&amp; a, function_type_&amp; func)
<a name="l14157"></a>14157 {
<a name="l14158"></a>14158     <span class="keywordflow">return</span> <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(a.<a class="code" href="classlite_1_1array.html#a3bd433b68e11c186a7ada3f1243da8e7" title="Returns a const iterator pointing to the start of the array.">begin</a>(), func, a.<a class="code" href="classlite_1_1array.html#a59ff65a488e4c6900d4359bcc7725fdf" title="Returns a size object containing the dimension sizes of the array.">size</a>());
<a name="l14159"></a>14159 }
<a name="l14160"></a>14160 
<a name="l14161"></a>14161 <span class="comment">/***********************************************************************************************************/</span>
<a name="l14162"></a>14162 <span class="comment">/* default_array_traits ************************************************************************************/</span>
<a name="l14163"></a>14163 <span class="comment">/***********************************************************************************************************/</span>
<a name="l14164"></a>14164 
<a name="l14171"></a><a class="code" href="structlite_1_1default__array__traits.html">14171</a> <span class="keyword">struct </span><a class="code" href="structlite_1_1default__array__traits.html" title="This is the default array traits type used by the class lite::array.See Array Traits...">default_array_traits</a>
<a name="l14172"></a>14172 {
<a name="l14173"></a>14173     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_&gt;
<a name="l14174"></a>14174     <span class="keyword">struct </span>representation_type
<a name="l14175"></a>14175     {
<a name="l14176"></a>14176         <span class="keyword">typedef</span> <a class="code" href="structlite_1_1array__signature__traits.html" title="This can be used to extract information from array signatures and get the appropriate...">array_signature_traits&lt;signature_&gt;</a> array_details;
<a name="l14177"></a>14177 
<a name="l14178"></a>14178         <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::type_if&lt;
<a name="l14179"></a>14179             (<a class="code" href="group__array__operations.html#gae75c2a405afffef6e4b64e7ea1831372" title="Returns the total volume of an array of the size sz.">array_details::volume</a> &lt;= 4096 &amp;&amp; array_details::is_fixed_size), 
<a name="l14180"></a>14180             <a class="code" href="classlite_1_1internal__rep.html" title="This is a tag type that can be used to specify internal representation for an array...">internal_rep&lt;false&gt;</a>,
<a name="l14181"></a>14181             <a class="code" href="classlite_1_1hybrid__rep.html" title="This is a tag type that can be used to specify hybrid representation for an array...">hybrid_rep</a>&lt;<span class="keyword">false</span>, (<a class="code" href="group__array__operations.html#gae75c2a405afffef6e4b64e7ea1831372" title="Returns the total volume of an array of the size sz.">array_details::volume</a> &lt;= 64 ? 64 : 1)&gt;
<a name="l14182"></a>14182             &gt;::type type;
<a name="l14183"></a>14183 
<a name="l14184"></a>14184         <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::type_if&lt;
<a name="l14185"></a>14185             (<a class="code" href="group__array__operations.html#gae75c2a405afffef6e4b64e7ea1831372" title="Returns the total volume of an array of the size sz.">array_details::volume</a> &lt;= 4096 &amp;&amp; array_details::is_fixed_size), 
<a name="l14186"></a>14186             <a class="code" href="classlite_1_1internal__rep.html" title="This is a tag type that can be used to specify internal representation for an array...">internal_rep&lt;false&gt;</a>,
<a name="l14187"></a>14187             <a class="code" href="classlite_1_1hybrid__rep.html" title="This is a tag type that can be used to specify hybrid representation for an array...">hybrid_rep</a>&lt;<span class="keyword">false</span>, (<a class="code" href="group__array__operations.html#gae75c2a405afffef6e4b64e7ea1831372" title="Returns the total volume of an array of the size sz.">array_details::volume</a> &lt;= 4096 ? 4096 : 1)&gt;
<a name="l14188"></a>14188             &gt;::type temporary_type;
<a name="l14189"></a>14189 
<a name="l14190"></a>14190         <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::type_if&lt;
<a name="l14191"></a>14191             (<a class="code" href="group__array__operations.html#gae75c2a405afffef6e4b64e7ea1831372" title="Returns the total volume of an array of the size sz.">array_details::volume</a> &lt;= 4096 &amp;&amp; array_details::is_fixed_size), 
<a name="l14192"></a>14192             <a class="code" href="classlite_1_1internal__rep.html" title="This is a tag type that can be used to specify internal representation for an array...">internal_rep&lt;false&gt;</a>,
<a name="l14193"></a>14193             <a class="code" href="classlite_1_1hybrid__rep.html" title="This is a tag type that can be used to specify hybrid representation for an array...">hybrid_rep</a>&lt;<span class="keyword">false</span>, (<a class="code" href="group__array__operations.html#gae75c2a405afffef6e4b64e7ea1831372" title="Returns the total volume of an array of the size sz.">array_details::volume</a> &lt;= 4096 ? 4096 : 1)&gt;
<a name="l14194"></a>14194             &gt;::type fwd_temporary_type;
<a name="l14195"></a>14195 
<a name="l14196"></a>14196         <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::type_if&lt;
<a name="l14197"></a>14197             (<a class="code" href="group__array__operations.html#gae75c2a405afffef6e4b64e7ea1831372" title="Returns the total volume of an array of the size sz.">array_details::volume</a> &lt;= 4096 &amp;&amp; array_details::is_fixed_size), 
<a name="l14198"></a>14198             <a class="code" href="classlite_1_1internal__rep.html" title="This is a tag type that can be used to specify internal representation for an array...">internal_rep&lt;true&gt;</a>,
<a name="l14199"></a>14199             <a class="code" href="classlite_1_1hybrid__rep.html" title="This is a tag type that can be used to specify hybrid representation for an array...">hybrid_rep</a>&lt;<span class="keyword">true</span>, (<a class="code" href="group__array__operations.html#gae75c2a405afffef6e4b64e7ea1831372" title="Returns the total volume of an array of the size sz.">array_details::volume</a> &lt;= 4096 ? 4096 : 1)&gt;
<a name="l14200"></a>14200             &gt;::type rev_temporary_type;
<a name="l14201"></a>14201     };
<a name="l14202"></a>14202 };
<a name="l14203"></a>14203 
<a name="l14204"></a>14204 <span class="comment">/***********************************************************************************************************/</span>
<a name="l14205"></a>14205 <span class="comment">/* copy ****************************************************************************************************/</span>
<a name="l14206"></a>14206 <span class="comment">/***********************************************************************************************************/</span>
<a name="l14207"></a>14207 
<a name="l14208"></a>14208 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> src_rep_&gt;
<a name="l14209"></a>14209 LITE_INLINE 
<a name="l14210"></a>14210 <span class="keyword">typename</span> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array&lt;signature_, traits_type_, src_rep_&gt;::temporary_array</a>
<a name="l14211"></a>14211 copy(<span class="keyword">const</span> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array&lt;signature_, traits_type_, src_rep_&gt;</a>&amp; src)
<a name="l14212"></a>14212 {
<a name="l14213"></a>14213     <span class="keywordflow">return</span> src;
<a name="l14214"></a>14214 }
<a name="l14215"></a>14215 
<a name="l14216"></a>14216 <span class="comment">/***********************************************************************************************************/</span>
<a name="l14217"></a>14217 <span class="comment">/* volume **************************************************************************************************/</span>
<a name="l14218"></a>14218 <span class="comment">/***********************************************************************************************************/</span>
<a name="l14219"></a>14219 
<a name="l14220"></a>14220 <span class="preprocessor">#ifdef DOCUMENTATION_ONLY</span>
<a name="l14221"></a>14221 <span class="preprocessor"></span>
<a name="l14239"></a>14239 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="keywordtype">size_t</span>ype_&gt;
<a name="l14240"></a>14240 <span class="keywordtype">int</span> <a class="code" href="group__array__operations.html#gae75c2a405afffef6e4b64e7ea1831372" title="Returns the total volume of an array of the size sz.">volume</a>(<span class="keyword">const</span> size_type_&amp; sz);
<a name="l14241"></a>14241 
<a name="l14242"></a>14242 <span class="preprocessor">#else // DOCUMENTATION_ONLY</span>
<a name="l14243"></a>14243 <span class="preprocessor"></span>
<a name="l14244"></a>14244 LITE_INLINE <span class="keywordtype">int</span> <a class="code" href="group__array__operations.html#gae75c2a405afffef6e4b64e7ea1831372" title="Returns the total volume of an array of the size sz.">volume</a>(<span class="keyword">const</span> pack&lt;&gt;&amp;)
<a name="l14245"></a>14245 {
<a name="l14246"></a>14246     <span class="keywordflow">return</span> 1;
<a name="l14247"></a>14247 }
<a name="l14248"></a>14248 
<a name="l14249"></a>14249 <span class="keyword">template</span>&lt;
<a name="l14250"></a>14250     <span class="keyword">typename</span> type0_
<a name="l14251"></a>14251     &gt;
<a name="l14252"></a>14252 LITE_INLINE <span class="keywordtype">int</span> 
<a name="l14253"></a>14253 <a class="code" href="group__array__operations.html#gae75c2a405afffef6e4b64e7ea1831372" title="Returns the total volume of an array of the size sz.">volume</a>(
<a name="l14254"></a>14254     <span class="keyword">const</span> pack&lt;
<a name="l14255"></a>14255         type0_
<a name="l14256"></a>14256     &gt;&amp; size)
<a name="l14257"></a>14257 {        
<a name="l14258"></a>14258     <span class="keywordflow">return</span> size.i0;
<a name="l14259"></a>14259     LITE_ARRAY_USE(size);
<a name="l14260"></a>14260 }
<a name="l14261"></a>14261 
<a name="l14262"></a>14262 <span class="keyword">template</span>&lt;
<a name="l14263"></a>14263     <span class="keyword">typename</span> type0_,
<a name="l14264"></a>14264     <span class="keyword">typename</span> type1_
<a name="l14265"></a>14265     &gt;
<a name="l14266"></a>14266 LITE_INLINE <span class="keywordtype">int</span> 
<a name="l14267"></a>14267 <a class="code" href="group__array__operations.html#gae75c2a405afffef6e4b64e7ea1831372" title="Returns the total volume of an array of the size sz.">volume</a>(
<a name="l14268"></a>14268     <span class="keyword">const</span> pack&lt;
<a name="l14269"></a>14269         type0_,
<a name="l14270"></a>14270         type1_
<a name="l14271"></a>14271     &gt;&amp; size)
<a name="l14272"></a>14272 {        
<a name="l14273"></a>14273     <span class="keywordflow">return</span> size.i0*size.i1;
<a name="l14274"></a>14274     LITE_ARRAY_USE(size);
<a name="l14275"></a>14275 }
<a name="l14276"></a>14276 
<a name="l14277"></a>14277 <span class="keyword">template</span>&lt;
<a name="l14278"></a>14278     <span class="keyword">typename</span> type0_,
<a name="l14279"></a>14279     <span class="keyword">typename</span> type1_,
<a name="l14280"></a>14280     <span class="keyword">typename</span> type2_
<a name="l14281"></a>14281     &gt;
<a name="l14282"></a>14282 LITE_INLINE <span class="keywordtype">int</span> 
<a name="l14283"></a>14283 <a class="code" href="group__array__operations.html#gae75c2a405afffef6e4b64e7ea1831372" title="Returns the total volume of an array of the size sz.">volume</a>(
<a name="l14284"></a>14284     <span class="keyword">const</span> pack&lt;
<a name="l14285"></a>14285         type0_,
<a name="l14286"></a>14286         type1_,
<a name="l14287"></a>14287         type2_
<a name="l14288"></a>14288     &gt;&amp; size)
<a name="l14289"></a>14289 {        
<a name="l14290"></a>14290     <span class="keywordflow">return</span> size.i0*size.i1*size.i2;
<a name="l14291"></a>14291     LITE_ARRAY_USE(size);
<a name="l14292"></a>14292 }
<a name="l14293"></a>14293 
<a name="l14294"></a>14294 
<a name="l14295"></a>14295 
<a name="l14296"></a>14296 <span class="preprocessor">#endif // DOCUMENTATION_ONLY</span>
<a name="l14297"></a>14297 <span class="preprocessor"></span>
<a name="l14298"></a>14298 <span class="comment">/***********************************************************************************************************/</span>
<a name="l14299"></a>14299 <span class="comment">/* array ***************************************************************************************************/</span>
<a name="l14300"></a>14300 <span class="comment">/***********************************************************************************************************/</span>
<a name="l14301"></a>14301 
<a name="l14302"></a>14302 <span class="comment">// forward declaration</span>
<a name="l14303"></a>14303 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_&gt;
<a name="l14304"></a>14304 <span class="keyword">class </span>assign;
<a name="l14305"></a>14305 
<a name="l14306"></a>14306 <span class="comment">// forward declaration</span>
<a name="l14307"></a>14307 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_&gt;
<a name="l14308"></a>14308 <span class="keyword">class </span>swapper;
<a name="l14309"></a>14309 
<a name="l14310"></a>14310 <span class="preprocessor">#ifdef DOCUMENTATION_ONLY</span>
<a name="l14311"></a>14311 <span class="preprocessor"></span>
<a name="l14322"></a>14322 <span class="keyword">template</span>&lt;
<a name="l14323"></a>14323     <span class="keyword">typename</span> signature_, 
<a name="l14324"></a>14324     <span class="keyword">typename</span> traits_type_ = default_array_traits, 
<a name="l14325"></a>14325     <span class="keyword">typename</span> rep_ = <span class="keyword">typename</span> traits_type_::template representation_type&lt;signature_&gt;::type&gt;
<a name="l14326"></a><a class="code" href="classlite_1_1array.html">14326</a> <span class="keyword">class </span><a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a>
<a name="l14327"></a>14327 {
<a name="l14328"></a>14328 <span class="keyword">public</span>:
<a name="l14329"></a><a class="code" href="classlite_1_1array.html#a06ad30fb952ce1b569efd05762e93849">14329</a>     <span class="keyword">typedef</span> signature_ signature; 
<a name="l14330"></a><a class="code" href="classlite_1_1array.html#a45c94a5e822cf077d4f7e1a7e89a58b6">14330</a>     <span class="keyword">typedef</span> traits_type_ traits_type; 
<a name="l14331"></a><a class="code" href="classlite_1_1array.html#a17e6210b1a5bd149859d576161b003d0">14331</a>     <span class="keyword">typedef</span> ... value_type; 
<a name="l14332"></a><a class="code" href="classlite_1_1array.html#ab7513a2d61e6a748207ec5747ebc2577">14332</a>     <span class="keyword">typedef</span> ... iterator; 
<a name="l14333"></a><a class="code" href="classlite_1_1array.html#a3ff0dd55bb10c774ca9a434334ee3ce4">14333</a>     <span class="keyword">typedef</span> ... const_iterator; 
<a name="l14334"></a><a class="code" href="classlite_1_1array.html#ad62659cbafc198aa9913cf95208b8ae7">14334</a>     <span class="keyword">typedef</span> ... reference; 
<a name="l14335"></a><a class="code" href="classlite_1_1array.html#a0fe3a795e15077267abf5b7745496b3c">14335</a>     <span class="keyword">typedef</span> ... const_reference; 
<a name="l14336"></a>14336 
<a name="l14337"></a>14337 
<a name="l14343"></a><a class="code" href="classlite_1_1array.html#a4cf511c2877fa4da43b3c02fb65b4049">14343</a>     <span class="keyword">typedef</span> ... temporary_array; 
<a name="l14344"></a>14344 
<a name="l14350"></a><a class="code" href="classlite_1_1array.html#a9a2ead9c8dd8bc8519a55f6e8a6fa0fc">14350</a>     <span class="keyword">typedef</span> ... fwd_temporary_array; 
<a name="l14351"></a>14351 
<a name="l14357"></a><a class="code" href="classlite_1_1array.html#a80a23aef085023ecf07a96e5216ae330">14357</a>     <span class="keyword">typedef</span> ... rev_temporary_array;
<a name="l14358"></a>14358 
<a name="l14360"></a><a class="code" href="classlite_1_1array.html#a513bd28803d6a8e27d81dec6705ec3f7">14360</a>     <span class="keyword">typedef</span> ... size_type;
<a name="l14361"></a>14361 
<a name="l14363"></a><a class="code" href="classlite_1_1array.html#a218e16a11a9f3e6c92942da0d6879b74">14363</a>     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> dimensions = ...; 
<a name="l14364"></a>14364 
<a name="l14369"></a><a class="code" href="classlite_1_1array.html#a30e508a875c85e36135a63906fd3d0e7">14369</a>     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_reverse = ...; 
<a name="l14370"></a>14370 
<a name="l14379"></a>14379     <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a>();
<a name="l14380"></a>14380 
<a name="l14385"></a>14385     <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a>(<span class="keyword">const</span> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a>&amp; other);
<a name="l14386"></a>14386 
<a name="l14397"></a>14397     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l14398"></a>14398     <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a>(<span class="keyword">const</span> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array&lt;signature_, traits_type_, other_rep_&gt;</a>&amp; other);
<a name="l14399"></a>14399 
<a name="l14408"></a>14408     <span class="keyword">explicit</span> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a>(<span class="keywordtype">int</span> n0, ..., <span class="keywordtype">int</span> nN);
<a name="l14409"></a>14409 
<a name="l14416"></a>14416     <span class="keyword">explicit</span> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a>(<span class="keyword">const</span> size_type&amp; size);
<a name="l14417"></a>14417 
<a name="l14434"></a>14434     <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a>(<span class="keyword">const</span> value_type&amp; a0, ..., <span class="keyword">const</span> value_type&amp; aT);
<a name="l14435"></a>14435 
<a name="l14448"></a>14448     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> arg_type0_, ..., <span class="keyword">typename</span> arg_typeK_&gt;
<a name="l14449"></a>14449     <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a>(<span class="keyword">const</span> arg_type0_&amp; arg0, ..., <span class="keyword">const</span> arg_typeK_&amp; argK, <span class="keyword">const</span> size_type&amp; sz);
<a name="l14450"></a>14450 
<a name="l14461"></a>14461     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_iterator_type_, <span class="keyword">typename</span> other_<span class="keywordtype">size_t</span>ype_, <span class="keyword">typename</span> transform_type_&gt;
<a name="l14462"></a>14462     <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a>(
<a name="l14463"></a>14463         <span class="keyword">const</span> other_iterator_type_&amp; it, 
<a name="l14464"></a>14464         <span class="keyword">const</span> other_size_type_&amp; sz, 
<a name="l14465"></a>14465         <span class="keyword">const</span> transform_type_&amp; trans);
<a name="l14466"></a>14466 
<a name="l14467"></a>14467 
<a name="l14475"></a>14475     <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a>&amp; operator=(<span class="keyword">const</span> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a>&amp; other);
<a name="l14476"></a>14476 
<a name="l14486"></a>14486     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l14487"></a>14487     <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a>&amp; operator=(<span class="keyword">const</span> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array&lt;signature_, traits_type_, other_rep_&gt;</a>&amp; other);
<a name="l14488"></a>14488 
<a name="l14490"></a>14490     const_iterator begin() <span class="keyword">const</span>;
<a name="l14491"></a>14491 
<a name="l14493"></a>14493     iterator begin();
<a name="l14494"></a>14494 
<a name="l14496"></a>14496     size_type size() <span class="keyword">const</span>;
<a name="l14497"></a>14497 
<a name="l14499"></a>14499     const_reference operator()(<span class="keywordtype">int</span> i0, ..., <span class="keywordtype">int</span> iN) <span class="keyword">const</span>;
<a name="l14500"></a>14500 
<a name="l14502"></a>14502     reference operator()(<span class="keywordtype">int</span> i0, ..., <span class="keywordtype">int</span> iN);
<a name="l14503"></a>14503 
<a name="l14509"></a>14509     const_reference operator[](<span class="keywordtype">int</span> i0) <span class="keyword">const</span>;
<a name="l14510"></a>14510 
<a name="l14516"></a>14516     reference operator[](<span class="keywordtype">int</span> i0);
<a name="l14517"></a>14517 
<a name="l14525"></a>14525     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_&gt;
<a name="l14526"></a>14526     <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">transform_traits&lt;array, transform_type_&gt;::const_array</a>
<a name="l14527"></a>14527     operator[](<span class="keyword">const</span> transform_type_&amp; trans) <span class="keyword">const</span>;
<a name="l14528"></a>14528 
<a name="l14536"></a>14536     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_&gt;
<a name="l14537"></a>14537     <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">transform_traits&lt;array, transform_type_&gt;::array</a>
<a name="l14538"></a>14538     operator[](<span class="keyword">const</span> transform_type_&amp; trans);
<a name="l14539"></a>14539 
<a name="l14549"></a>14549     <span class="keyword">const</span> value_type* data() <span class="keyword">const</span>;
<a name="l14550"></a>14550 
<a name="l14560"></a>14560     value_type* data();
<a name="l14561"></a>14561 
<a name="l14577"></a>14577     <span class="keywordtype">void</span> resize(<span class="keywordtype">int</span> n0, ..., <span class="keywordtype">int</span> nN);
<a name="l14578"></a>14578 
<a name="l14592"></a>14592     <span class="keywordtype">void</span> resize(<span class="keyword">const</span> size_type&amp; sz);
<a name="l14593"></a>14593 
<a name="l14602"></a>14602     <span class="keywordtype">void</span> release();
<a name="l14603"></a>14603 };
<a name="l14604"></a>14604 
<a name="l14605"></a>14605 <span class="preprocessor">#endif // DOCUMENTATION_ONLY</span>
<a name="l14606"></a>14606 <span class="preprocessor"></span>
<a name="l14607"></a>14607 <span class="comment">/***********************************************************************************************************/</span>
<a name="l14608"></a>14608 <span class="comment">/* array, reference_rep ************************************************************************************/</span>
<a name="l14609"></a>14609 <span class="comment">/***********************************************************************************************************/</span>
<a name="l14610"></a>14610 
<a name="l14618"></a>14618 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_&gt;
<a name="l14619"></a><a class="code" href="classlite_1_1reference__rep.html">14619</a> <span class="keyword">class </span><a class="code" href="classlite_1_1reference__rep.html" title="This is a tag type that can be used to specify reference representation for an array...">reference_rep</a> {};
<a name="l14620"></a>14620 
<a name="l14621"></a>14621 
<a name="l14622"></a>14622 <span class="keyword">template</span>&lt;
<a name="l14623"></a>14623     <span class="keyword">typename</span> value_type_,
<a name="l14624"></a>14624     <span class="keyword">typename</span> traits_type_,
<a name="l14625"></a>14625     <span class="keyword">typename</span> iterator_
<a name="l14626"></a>14626     &gt;
<a name="l14627"></a>14627 <span class="keyword">class </span><a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a>&lt;
<a name="l14628"></a>14628     value_type_,
<a name="l14629"></a>14629     traits_type_,
<a name="l14630"></a>14630     <a class="code" href="classlite_1_1reference__rep.html" title="This is a tag type that can be used to specify reference representation for an array...">reference_rep</a>&lt;iterator_&gt;
<a name="l14631"></a>14631     &gt;
<a name="l14632"></a>14632 {
<a name="l14633"></a>14633 <span class="keyword">public</span>:
<a name="l14634"></a>14634     <span class="keyword">typedef</span> value_type_ signature;
<a name="l14635"></a>14635     <span class="keyword">typedef</span> traits_type_ traits_type;
<a name="l14636"></a>14636     <span class="keyword">typedef</span> value_type_ value_type;
<a name="l14637"></a>14637     <span class="keyword">typedef</span> iterator_ iterator;
<a name="l14638"></a>14638     <span class="keyword">typedef</span> iterator_ const_iterator;
<a name="l14639"></a>14639     <span class="keyword">typedef</span> <span class="keyword">typename</span> std::iterator_traits&lt;iterator&gt;::reference reference;
<a name="l14640"></a>14640     <span class="keyword">typedef</span> reference const_reference;
<a name="l14641"></a>14641 
<a name="l14642"></a>14642     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array_helper&lt;signature, traits_type_&gt;::temporary_array</a> temporary_array;
<a name="l14643"></a>14643     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array_helper&lt;signature, traits_type_&gt;::fwd_temporary_array</a> fwd_temporary_array;
<a name="l14644"></a>14644     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array_helper&lt;signature, traits_type_&gt;::rev_temporary_array</a> rev_temporary_array;
<a name="l14645"></a>14645 
<a name="l14646"></a>14646     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structlite_1_1array__signature__traits.html" title="This can be used to extract information from array signatures and get the appropriate...">array_signature_traits&lt;signature&gt;::size_type</a> size_type;
<a name="l14647"></a>14647 
<a name="l14648"></a>14648     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> dimensions = 0;
<a name="l14649"></a>14649 
<a name="l14650"></a>14650     LITE_INLINE <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a>(<span class="keyword">const</span> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a>&amp; other) 
<a name="l14651"></a>14651         : m_iterator(other.m_iterator), m_size(other.m_size)
<a name="l14652"></a>14652     {}
<a name="l14653"></a>14653 
<a name="l14654"></a>14654     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l14655"></a>14655     LITE_INLINE array(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l14656"></a>14656         : m_iterator(other.begin()), m_size(other.size())
<a name="l14657"></a>14657     {}
<a name="l14658"></a>14658 
<a name="l14659"></a>14659     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l14660"></a>14660     LITE_INLINE array(array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l14661"></a>14661         : m_iterator(other.begin()), m_size(other.size())
<a name="l14662"></a>14662     {}
<a name="l14663"></a>14663 
<a name="l14664"></a>14664     <span class="keyword">template</span>&lt;
<a name="l14665"></a>14665         <span class="keyword">typename</span> arg_type0_    
<a name="l14666"></a>14666         &gt;
<a name="l14667"></a>14667     LITE_INLINE array(
<a name="l14668"></a>14668         <span class="keyword">const</span> arg_type0_&amp; arg0,
<a name="l14669"></a>14669         <span class="keyword">const</span> size_type&amp; sz)
<a name="l14670"></a>14670         : m_iterator(arg0),
<a name="l14671"></a>14671           m_size(sz)
<a name="l14672"></a>14672     {}
<a name="l14673"></a>14673 
<a name="l14674"></a>14674     <span class="keyword">template</span>&lt;
<a name="l14675"></a>14675         <span class="keyword">typename</span> arg_type0_,    
<a name="l14676"></a>14676         <span class="keyword">typename</span> arg_type1_    
<a name="l14677"></a>14677         &gt;
<a name="l14678"></a>14678     LITE_INLINE array(
<a name="l14679"></a>14679         <span class="keyword">const</span> arg_type0_&amp; arg0,
<a name="l14680"></a>14680         <span class="keyword">const</span> arg_type1_&amp; arg1,
<a name="l14681"></a>14681         <span class="keyword">const</span> size_type&amp; sz)
<a name="l14682"></a>14682         : m_iterator(arg0, arg1),
<a name="l14683"></a>14683           m_size(sz)
<a name="l14684"></a>14684     {}
<a name="l14685"></a>14685 
<a name="l14686"></a>14686     <span class="keyword">template</span>&lt;
<a name="l14687"></a>14687         <span class="keyword">typename</span> arg_type0_,    
<a name="l14688"></a>14688         <span class="keyword">typename</span> arg_type1_,    
<a name="l14689"></a>14689         <span class="keyword">typename</span> arg_type2_    
<a name="l14690"></a>14690         &gt;
<a name="l14691"></a>14691     LITE_INLINE array(
<a name="l14692"></a>14692         <span class="keyword">const</span> arg_type0_&amp; arg0,
<a name="l14693"></a>14693         <span class="keyword">const</span> arg_type1_&amp; arg1,
<a name="l14694"></a>14694         <span class="keyword">const</span> arg_type2_&amp; arg2,
<a name="l14695"></a>14695         <span class="keyword">const</span> size_type&amp; sz)
<a name="l14696"></a>14696         : m_iterator(arg0, arg1, arg2),
<a name="l14697"></a>14697           m_size(sz)
<a name="l14698"></a>14698     {}
<a name="l14699"></a>14699 
<a name="l14700"></a>14700 
<a name="l14701"></a>14701     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_iterator_type_, <span class="keyword">typename</span> other_<span class="keywordtype">size_t</span>ype_, <span class="keyword">typename</span> transform_type_&gt;
<a name="l14702"></a>14702     LITE_INLINE array(
<a name="l14703"></a>14703         <span class="keyword">const</span> other_iterator_type_&amp; it, 
<a name="l14704"></a>14704         <span class="keyword">const</span> other_size_type_&amp; sz, 
<a name="l14705"></a>14705         <span class="keyword">const</span> transform_type_&amp; trans)
<a name="l14706"></a>14706     {
<a name="l14707"></a>14707         iterator_transformer&lt;transform_type_, other_iterator_type_, other_size_type_&gt;
<a name="l14708"></a>14708             ::transform(trans, it, sz, m_iterator);
<a name="l14709"></a>14709 
<a name="l14710"></a>14710         size_transformer&lt;transform_type_, other_size_type_&gt;
<a name="l14711"></a>14711             ::transform(trans, sz, m_size);
<a name="l14712"></a>14712     }
<a name="l14713"></a>14713 
<a name="l14714"></a>14714     LITE_INLINE <span class="keyword">const</span> array&amp; operator=(<span class="keyword">const</span> array&amp; other)<span class="keyword"> const</span>
<a name="l14715"></a>14715 <span class="keyword">    </span>{
<a name="l14716"></a>14716         <span class="keyword">typedef</span> b_iterator&lt;iterator, iterator, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l14717"></a>14717 
<a name="l14718"></a>14718         LITE_ARRAY_SIZE_CHECK(m_size, other.m_size, <span class="stringliteral">&quot;operator=(): array sizes do not match&quot;</span>);
<a name="l14719"></a>14719 
<a name="l14720"></a>14720         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.m_iterator), m_size);
<a name="l14721"></a>14721         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l14722"></a>14722     }
<a name="l14723"></a>14723 
<a name="l14724"></a>14724     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l14725"></a>14725     LITE_INLINE <span class="keyword">const</span> array&amp; operator=(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other)<span class="keyword"> const</span>
<a name="l14726"></a>14726 <span class="keyword">    </span>{
<a name="l14727"></a>14727         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l14728"></a>14728             iterator, 
<a name="l14729"></a>14729             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l14730"></a>14730             assign&lt;value_type&gt; &gt; 
<a name="l14731"></a>14731             iterator_type;
<a name="l14732"></a>14732 
<a name="l14733"></a>14733         LITE_ARRAY_SIZE_CHECK(m_size, other.size(), <span class="stringliteral">&quot;operator=(): array sizes do not match&quot;</span>);
<a name="l14734"></a>14734 
<a name="l14735"></a>14735         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.begin()), m_size);
<a name="l14736"></a>14736         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l14737"></a>14737     }
<a name="l14738"></a>14738 
<a name="l14739"></a>14739     LITE_INLINE <span class="keyword">const</span> array&amp; operator=(<span class="keyword">const</span> value_type&amp; value)<span class="keyword"> const</span>
<a name="l14740"></a>14740 <span class="keyword">    </span>{
<a name="l14741"></a>14741         <span class="keyword">typedef</span> b_iterator&lt;iterator, c_iterator&lt;value_type&gt;, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l14742"></a>14742 
<a name="l14743"></a>14743         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, value), m_size);
<a name="l14744"></a>14744         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l14745"></a>14745     }
<a name="l14746"></a>14746 
<a name="l14747"></a>14747     LITE_INLINE <span class="keyword">const</span> iterator&amp; begin()<span class="keyword"> const</span>
<a name="l14748"></a>14748 <span class="keyword">    </span>{
<a name="l14749"></a>14749         <span class="keywordflow">return</span> m_iterator;
<a name="l14750"></a>14750     }
<a name="l14751"></a>14751 
<a name="l14752"></a>14752     LITE_INLINE <span class="keyword">const</span> size_type&amp; size()<span class="keyword"> const</span>
<a name="l14753"></a>14753 <span class="keyword">    </span>{
<a name="l14754"></a>14754         <span class="keywordflow">return</span> m_size;
<a name="l14755"></a>14755     }
<a name="l14756"></a>14756 
<a name="l14757"></a>14757     LITE_INLINE reference 
<a name="l14758"></a>14758     operator()()<span class="keyword"> const</span>
<a name="l14759"></a>14759 <span class="keyword">    </span>{
<a name="l14760"></a>14760         <span class="keywordflow">return</span> at(m_iterator);
<a name="l14761"></a>14761     }
<a name="l14762"></a>14762 
<a name="l14763"></a>14763     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_&gt;
<a name="l14764"></a>14764     LITE_INLINE <span class="keyword">const</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::array
<a name="l14765"></a>14765     operator[](<span class="keyword">const</span> transform_type_&amp; trans)<span class="keyword"> const</span>
<a name="l14766"></a>14766 <span class="keyword">    </span>{
<a name="l14767"></a>14767         <span class="keyword">typedef</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::array result_type;
<a name="l14768"></a>14768 
<a name="l14769"></a>14769         <span class="keywordflow">return</span> result_type(m_iterator, m_size, trans);
<a name="l14770"></a>14770     }
<a name="l14771"></a>14771 
<a name="l14772"></a>14772     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l14773"></a>14773     LITE_INLINE <span class="keywordtype">void</span> swap(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other)<span class="keyword"> const</span>
<a name="l14774"></a>14774 <span class="keyword">    </span>{
<a name="l14775"></a>14775         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l14776"></a>14776             iterator, 
<a name="l14777"></a>14777             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l14778"></a>14778             swapper&lt;value_type&gt; &gt; 
<a name="l14779"></a>14779             iterator_type;
<a name="l14780"></a>14780 
<a name="l14781"></a>14781         LITE_ARRAY_SIZE_CHECK(m_size, other.size(), <span class="stringliteral">&quot;swap(): array sizes do not match&quot;</span>);
<a name="l14782"></a>14782 
<a name="l14783"></a>14783         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.begin()), m_size);
<a name="l14784"></a>14784     }
<a name="l14785"></a>14785 
<a name="l14786"></a>14786     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l14787"></a>14787     LITE_INLINE <span class="keywordtype">void</span> swap(array&lt;signature, traits_type_, other_rep_&gt;&amp; other)<span class="keyword"> const</span>
<a name="l14788"></a>14788 <span class="keyword">    </span>{
<a name="l14789"></a>14789         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l14790"></a>14790             iterator, 
<a name="l14791"></a>14791             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::iterator, 
<a name="l14792"></a>14792             swapper&lt;value_type&gt; &gt; 
<a name="l14793"></a>14793             iterator_type;
<a name="l14794"></a>14794 
<a name="l14795"></a>14795         LITE_ARRAY_SIZE_CHECK(m_size, other.size(), <span class="stringliteral">&quot;swap(): array sizes do not match&quot;</span>);
<a name="l14796"></a>14796 
<a name="l14797"></a>14797         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.begin()), m_size);
<a name="l14798"></a>14798     }
<a name="l14799"></a>14799 
<a name="l14800"></a>14800 <span class="keyword">private</span>:
<a name="l14801"></a>14801     iterator m_iterator;
<a name="l14802"></a>14802     size_type m_size;
<a name="l14803"></a>14803 };
<a name="l14804"></a>14804 
<a name="l14805"></a>14805 <span class="comment">/***********************************************************************************************************/</span>
<a name="l14806"></a>14806 
<a name="l14807"></a>14807 <span class="keyword">template</span>&lt;
<a name="l14808"></a>14808     <span class="keyword">typename</span> value_type_,
<a name="l14809"></a>14809     <span class="keywordtype">int</span> n0_, 
<a name="l14810"></a>14810     <span class="keyword">typename</span> traits_type_,
<a name="l14811"></a>14811     <span class="keyword">typename</span> iterator_
<a name="l14812"></a>14812     &gt;
<a name="l14813"></a>14813 <span class="keyword">class </span>array&lt;
<a name="l14814"></a>14814     value_type_[n0_],
<a name="l14815"></a>14815     traits_type_,
<a name="l14816"></a>14816     reference_rep&lt;iterator_&gt;
<a name="l14817"></a>14817     &gt;
<a name="l14818"></a>14818 {
<a name="l14819"></a>14819 <span class="keyword">public</span>:
<a name="l14820"></a>14820     <span class="keyword">typedef</span> value_type_ signature[n0_];
<a name="l14821"></a>14821     <span class="keyword">typedef</span> traits_type_ traits_type;
<a name="l14822"></a>14822     <span class="keyword">typedef</span> value_type_ value_type;
<a name="l14823"></a>14823     <span class="keyword">typedef</span> iterator_ iterator;
<a name="l14824"></a>14824     <span class="keyword">typedef</span> iterator_ const_iterator;
<a name="l14825"></a>14825     <span class="keyword">typedef</span> <span class="keyword">typename</span> std::iterator_traits&lt;iterator&gt;::reference reference;
<a name="l14826"></a>14826     <span class="keyword">typedef</span> reference const_reference;
<a name="l14827"></a>14827 
<a name="l14828"></a>14828     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::temporary_array temporary_array;
<a name="l14829"></a>14829     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::fwd_temporary_array fwd_temporary_array;
<a name="l14830"></a>14830     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::rev_temporary_array rev_temporary_array;
<a name="l14831"></a>14831 
<a name="l14832"></a>14832     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;signature&gt;::size_type size_type;
<a name="l14833"></a>14833 
<a name="l14834"></a>14834     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> dimensions = 1;
<a name="l14835"></a>14835 
<a name="l14836"></a>14836     LITE_INLINE array(<span class="keyword">const</span> array&amp; other) 
<a name="l14837"></a>14837         : m_iterator(other.m_iterator), m_size(other.m_size)
<a name="l14838"></a>14838     {}
<a name="l14839"></a>14839 
<a name="l14840"></a>14840     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l14841"></a>14841     LITE_INLINE array(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l14842"></a>14842         : m_iterator(other.begin()), m_size(other.size())
<a name="l14843"></a>14843     {}
<a name="l14844"></a>14844 
<a name="l14845"></a>14845     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l14846"></a>14846     LITE_INLINE array(array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l14847"></a>14847         : m_iterator(other.begin()), m_size(other.size())
<a name="l14848"></a>14848     {}
<a name="l14849"></a>14849 
<a name="l14850"></a>14850     <span class="keyword">template</span>&lt;
<a name="l14851"></a>14851         <span class="keyword">typename</span> arg_type0_    
<a name="l14852"></a>14852         &gt;
<a name="l14853"></a>14853     LITE_INLINE array(
<a name="l14854"></a>14854         <span class="keyword">const</span> arg_type0_&amp; arg0,
<a name="l14855"></a>14855         <span class="keyword">const</span> size_type&amp; sz)
<a name="l14856"></a>14856         : m_iterator(arg0),
<a name="l14857"></a>14857           m_size(sz)
<a name="l14858"></a>14858     {}
<a name="l14859"></a>14859 
<a name="l14860"></a>14860     <span class="keyword">template</span>&lt;
<a name="l14861"></a>14861         <span class="keyword">typename</span> arg_type0_,    
<a name="l14862"></a>14862         <span class="keyword">typename</span> arg_type1_    
<a name="l14863"></a>14863         &gt;
<a name="l14864"></a>14864     LITE_INLINE array(
<a name="l14865"></a>14865         <span class="keyword">const</span> arg_type0_&amp; arg0,
<a name="l14866"></a>14866         <span class="keyword">const</span> arg_type1_&amp; arg1,
<a name="l14867"></a>14867         <span class="keyword">const</span> size_type&amp; sz)
<a name="l14868"></a>14868         : m_iterator(arg0, arg1),
<a name="l14869"></a>14869           m_size(sz)
<a name="l14870"></a>14870     {}
<a name="l14871"></a>14871 
<a name="l14872"></a>14872     <span class="keyword">template</span>&lt;
<a name="l14873"></a>14873         <span class="keyword">typename</span> arg_type0_,    
<a name="l14874"></a>14874         <span class="keyword">typename</span> arg_type1_,    
<a name="l14875"></a>14875         <span class="keyword">typename</span> arg_type2_    
<a name="l14876"></a>14876         &gt;
<a name="l14877"></a>14877     LITE_INLINE array(
<a name="l14878"></a>14878         <span class="keyword">const</span> arg_type0_&amp; arg0,
<a name="l14879"></a>14879         <span class="keyword">const</span> arg_type1_&amp; arg1,
<a name="l14880"></a>14880         <span class="keyword">const</span> arg_type2_&amp; arg2,
<a name="l14881"></a>14881         <span class="keyword">const</span> size_type&amp; sz)
<a name="l14882"></a>14882         : m_iterator(arg0, arg1, arg2),
<a name="l14883"></a>14883           m_size(sz)
<a name="l14884"></a>14884     {}
<a name="l14885"></a>14885 
<a name="l14886"></a>14886 
<a name="l14887"></a>14887     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_iterator_type_, <span class="keyword">typename</span> other_<span class="keywordtype">size_t</span>ype_, <span class="keyword">typename</span> transform_type_&gt;
<a name="l14888"></a>14888     LITE_INLINE array(
<a name="l14889"></a>14889         <span class="keyword">const</span> other_iterator_type_&amp; it, 
<a name="l14890"></a>14890         <span class="keyword">const</span> other_size_type_&amp; sz, 
<a name="l14891"></a>14891         <span class="keyword">const</span> transform_type_&amp; trans)
<a name="l14892"></a>14892     {
<a name="l14893"></a>14893         iterator_transformer&lt;transform_type_, other_iterator_type_, other_size_type_&gt;
<a name="l14894"></a>14894             ::transform(trans, it, sz, m_iterator);
<a name="l14895"></a>14895 
<a name="l14896"></a>14896         size_transformer&lt;transform_type_, other_size_type_&gt;
<a name="l14897"></a>14897             ::transform(trans, sz, m_size);
<a name="l14898"></a>14898     }
<a name="l14899"></a>14899 
<a name="l14900"></a>14900     LITE_INLINE <span class="keyword">const</span> array&amp; operator=(<span class="keyword">const</span> array&amp; other)<span class="keyword"> const</span>
<a name="l14901"></a>14901 <span class="keyword">    </span>{
<a name="l14902"></a>14902         <span class="keyword">typedef</span> b_iterator&lt;iterator, iterator, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l14903"></a>14903 
<a name="l14904"></a>14904         LITE_ARRAY_SIZE_CHECK(m_size, other.m_size, <span class="stringliteral">&quot;operator=(): array sizes do not match&quot;</span>);
<a name="l14905"></a>14905 
<a name="l14906"></a>14906         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.m_iterator), m_size);
<a name="l14907"></a>14907         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l14908"></a>14908     }
<a name="l14909"></a>14909 
<a name="l14910"></a>14910     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l14911"></a>14911     LITE_INLINE <span class="keyword">const</span> array&amp; operator=(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other)<span class="keyword"> const</span>
<a name="l14912"></a>14912 <span class="keyword">    </span>{
<a name="l14913"></a>14913         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l14914"></a>14914             iterator, 
<a name="l14915"></a>14915             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l14916"></a>14916             assign&lt;value_type&gt; &gt; 
<a name="l14917"></a>14917             iterator_type;
<a name="l14918"></a>14918 
<a name="l14919"></a>14919         LITE_ARRAY_SIZE_CHECK(m_size, other.size(), <span class="stringliteral">&quot;operator=(): array sizes do not match&quot;</span>);
<a name="l14920"></a>14920 
<a name="l14921"></a>14921         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.begin()), m_size);
<a name="l14922"></a>14922         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l14923"></a>14923     }
<a name="l14924"></a>14924 
<a name="l14925"></a>14925     LITE_INLINE <span class="keyword">const</span> array&amp; operator=(<span class="keyword">const</span> value_type&amp; value)<span class="keyword"> const</span>
<a name="l14926"></a>14926 <span class="keyword">    </span>{
<a name="l14927"></a>14927         <span class="keyword">typedef</span> b_iterator&lt;iterator, c_iterator&lt;value_type&gt;, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l14928"></a>14928 
<a name="l14929"></a>14929         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, value), m_size);
<a name="l14930"></a>14930         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l14931"></a>14931     }
<a name="l14932"></a>14932 
<a name="l14933"></a>14933     LITE_INLINE <span class="keyword">const</span> iterator&amp; begin()<span class="keyword"> const</span>
<a name="l14934"></a>14934 <span class="keyword">    </span>{
<a name="l14935"></a>14935         <span class="keywordflow">return</span> m_iterator;
<a name="l14936"></a>14936     }
<a name="l14937"></a>14937 
<a name="l14938"></a>14938     LITE_INLINE <span class="keyword">const</span> size_type&amp; size()<span class="keyword"> const</span>
<a name="l14939"></a>14939 <span class="keyword">    </span>{
<a name="l14940"></a>14940         <span class="keywordflow">return</span> m_size;
<a name="l14941"></a>14941     }
<a name="l14942"></a>14942 
<a name="l14943"></a>14943     LITE_INLINE reference 
<a name="l14944"></a>14944     operator()(<span class="keywordtype">int</span> i0)<span class="keyword"> const</span>
<a name="l14945"></a>14945 <span class="keyword">    </span>{
<a name="l14946"></a>14946         <span class="keywordflow">return</span> at(m_iterator, i0);
<a name="l14947"></a>14947     }
<a name="l14948"></a>14948 
<a name="l14949"></a>14949     LITE_INLINE reference 
<a name="l14950"></a>14950     operator[](<span class="keywordtype">int</span> i0)<span class="keyword"> const</span>
<a name="l14951"></a>14951 <span class="keyword">    </span>{
<a name="l14952"></a>14952         <span class="keywordflow">return</span> at(m_iterator, i0);
<a name="l14953"></a>14953     }
<a name="l14954"></a>14954 
<a name="l14955"></a>14955     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_&gt;
<a name="l14956"></a>14956     LITE_INLINE <span class="keyword">const</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::array
<a name="l14957"></a>14957     operator[](<span class="keyword">const</span> transform_type_&amp; trans)<span class="keyword"> const</span>
<a name="l14958"></a>14958 <span class="keyword">    </span>{
<a name="l14959"></a>14959         <span class="keyword">typedef</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::array result_type;
<a name="l14960"></a>14960 
<a name="l14961"></a>14961         <span class="keywordflow">return</span> result_type(m_iterator, m_size, trans);
<a name="l14962"></a>14962     }
<a name="l14963"></a>14963 
<a name="l14964"></a>14964     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l14965"></a>14965     LITE_INLINE <span class="keywordtype">void</span> swap(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other)<span class="keyword"> const</span>
<a name="l14966"></a>14966 <span class="keyword">    </span>{
<a name="l14967"></a>14967         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l14968"></a>14968             iterator, 
<a name="l14969"></a>14969             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l14970"></a>14970             swapper&lt;value_type&gt; &gt; 
<a name="l14971"></a>14971             iterator_type;
<a name="l14972"></a>14972 
<a name="l14973"></a>14973         LITE_ARRAY_SIZE_CHECK(m_size, other.size(), <span class="stringliteral">&quot;swap(): array sizes do not match&quot;</span>);
<a name="l14974"></a>14974 
<a name="l14975"></a>14975         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.begin()), m_size);
<a name="l14976"></a>14976     }
<a name="l14977"></a>14977 
<a name="l14978"></a>14978     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l14979"></a>14979     LITE_INLINE <span class="keywordtype">void</span> swap(array&lt;signature, traits_type_, other_rep_&gt;&amp; other)<span class="keyword"> const</span>
<a name="l14980"></a>14980 <span class="keyword">    </span>{
<a name="l14981"></a>14981         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l14982"></a>14982             iterator, 
<a name="l14983"></a>14983             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::iterator, 
<a name="l14984"></a>14984             swapper&lt;value_type&gt; &gt; 
<a name="l14985"></a>14985             iterator_type;
<a name="l14986"></a>14986 
<a name="l14987"></a>14987         LITE_ARRAY_SIZE_CHECK(m_size, other.size(), <span class="stringliteral">&quot;swap(): array sizes do not match&quot;</span>);
<a name="l14988"></a>14988 
<a name="l14989"></a>14989         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.begin()), m_size);
<a name="l14990"></a>14990     }
<a name="l14991"></a>14991 
<a name="l14992"></a>14992 <span class="keyword">private</span>:
<a name="l14993"></a>14993     iterator m_iterator;
<a name="l14994"></a>14994     size_type m_size;
<a name="l14995"></a>14995 };
<a name="l14996"></a>14996 
<a name="l14997"></a>14997 <span class="comment">/***********************************************************************************************************/</span>
<a name="l14998"></a>14998 
<a name="l14999"></a>14999 <span class="keyword">template</span>&lt;
<a name="l15000"></a>15000     <span class="keyword">typename</span> value_type_,
<a name="l15001"></a>15001     <span class="keywordtype">int</span> n0_, 
<a name="l15002"></a>15002     <span class="keywordtype">int</span> n1_, 
<a name="l15003"></a>15003     <span class="keyword">typename</span> traits_type_,
<a name="l15004"></a>15004     <span class="keyword">typename</span> iterator_
<a name="l15005"></a>15005     &gt;
<a name="l15006"></a>15006 <span class="keyword">class </span>array&lt;
<a name="l15007"></a>15007     value_type_[n0_][n1_],
<a name="l15008"></a>15008     traits_type_,
<a name="l15009"></a>15009     reference_rep&lt;iterator_&gt;
<a name="l15010"></a>15010     &gt;
<a name="l15011"></a>15011 {
<a name="l15012"></a>15012 <span class="keyword">public</span>:
<a name="l15013"></a>15013     <span class="keyword">typedef</span> value_type_ signature[n0_][n1_];
<a name="l15014"></a>15014     <span class="keyword">typedef</span> traits_type_ traits_type;
<a name="l15015"></a>15015     <span class="keyword">typedef</span> value_type_ value_type;
<a name="l15016"></a>15016     <span class="keyword">typedef</span> iterator_ iterator;
<a name="l15017"></a>15017     <span class="keyword">typedef</span> iterator_ const_iterator;
<a name="l15018"></a>15018     <span class="keyword">typedef</span> <span class="keyword">typename</span> std::iterator_traits&lt;iterator&gt;::reference reference;
<a name="l15019"></a>15019     <span class="keyword">typedef</span> reference const_reference;
<a name="l15020"></a>15020 
<a name="l15021"></a>15021     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::temporary_array temporary_array;
<a name="l15022"></a>15022     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::fwd_temporary_array fwd_temporary_array;
<a name="l15023"></a>15023     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::rev_temporary_array rev_temporary_array;
<a name="l15024"></a>15024 
<a name="l15025"></a>15025     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;signature&gt;::size_type size_type;
<a name="l15026"></a>15026 
<a name="l15027"></a>15027     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> dimensions = 2;
<a name="l15028"></a>15028 
<a name="l15029"></a>15029     LITE_INLINE array(<span class="keyword">const</span> array&amp; other) 
<a name="l15030"></a>15030         : m_iterator(other.m_iterator), m_size(other.m_size)
<a name="l15031"></a>15031     {}
<a name="l15032"></a>15032 
<a name="l15033"></a>15033     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l15034"></a>15034     LITE_INLINE array(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l15035"></a>15035         : m_iterator(other.begin()), m_size(other.size())
<a name="l15036"></a>15036     {}
<a name="l15037"></a>15037 
<a name="l15038"></a>15038     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l15039"></a>15039     LITE_INLINE array(array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l15040"></a>15040         : m_iterator(other.begin()), m_size(other.size())
<a name="l15041"></a>15041     {}
<a name="l15042"></a>15042 
<a name="l15043"></a>15043     <span class="keyword">template</span>&lt;
<a name="l15044"></a>15044         <span class="keyword">typename</span> arg_type0_    
<a name="l15045"></a>15045         &gt;
<a name="l15046"></a>15046     LITE_INLINE array(
<a name="l15047"></a>15047         <span class="keyword">const</span> arg_type0_&amp; arg0,
<a name="l15048"></a>15048         <span class="keyword">const</span> size_type&amp; sz)
<a name="l15049"></a>15049         : m_iterator(arg0),
<a name="l15050"></a>15050           m_size(sz)
<a name="l15051"></a>15051     {}
<a name="l15052"></a>15052 
<a name="l15053"></a>15053     <span class="keyword">template</span>&lt;
<a name="l15054"></a>15054         <span class="keyword">typename</span> arg_type0_,    
<a name="l15055"></a>15055         <span class="keyword">typename</span> arg_type1_    
<a name="l15056"></a>15056         &gt;
<a name="l15057"></a>15057     LITE_INLINE array(
<a name="l15058"></a>15058         <span class="keyword">const</span> arg_type0_&amp; arg0,
<a name="l15059"></a>15059         <span class="keyword">const</span> arg_type1_&amp; arg1,
<a name="l15060"></a>15060         <span class="keyword">const</span> size_type&amp; sz)
<a name="l15061"></a>15061         : m_iterator(arg0, arg1),
<a name="l15062"></a>15062           m_size(sz)
<a name="l15063"></a>15063     {}
<a name="l15064"></a>15064 
<a name="l15065"></a>15065     <span class="keyword">template</span>&lt;
<a name="l15066"></a>15066         <span class="keyword">typename</span> arg_type0_,    
<a name="l15067"></a>15067         <span class="keyword">typename</span> arg_type1_,    
<a name="l15068"></a>15068         <span class="keyword">typename</span> arg_type2_    
<a name="l15069"></a>15069         &gt;
<a name="l15070"></a>15070     LITE_INLINE array(
<a name="l15071"></a>15071         <span class="keyword">const</span> arg_type0_&amp; arg0,
<a name="l15072"></a>15072         <span class="keyword">const</span> arg_type1_&amp; arg1,
<a name="l15073"></a>15073         <span class="keyword">const</span> arg_type2_&amp; arg2,
<a name="l15074"></a>15074         <span class="keyword">const</span> size_type&amp; sz)
<a name="l15075"></a>15075         : m_iterator(arg0, arg1, arg2),
<a name="l15076"></a>15076           m_size(sz)
<a name="l15077"></a>15077     {}
<a name="l15078"></a>15078 
<a name="l15079"></a>15079 
<a name="l15080"></a>15080     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_iterator_type_, <span class="keyword">typename</span> other_<span class="keywordtype">size_t</span>ype_, <span class="keyword">typename</span> transform_type_&gt;
<a name="l15081"></a>15081     LITE_INLINE array(
<a name="l15082"></a>15082         <span class="keyword">const</span> other_iterator_type_&amp; it, 
<a name="l15083"></a>15083         <span class="keyword">const</span> other_size_type_&amp; sz, 
<a name="l15084"></a>15084         <span class="keyword">const</span> transform_type_&amp; trans)
<a name="l15085"></a>15085     {
<a name="l15086"></a>15086         iterator_transformer&lt;transform_type_, other_iterator_type_, other_size_type_&gt;
<a name="l15087"></a>15087             ::transform(trans, it, sz, m_iterator);
<a name="l15088"></a>15088 
<a name="l15089"></a>15089         size_transformer&lt;transform_type_, other_size_type_&gt;
<a name="l15090"></a>15090             ::transform(trans, sz, m_size);
<a name="l15091"></a>15091     }
<a name="l15092"></a>15092 
<a name="l15093"></a>15093     LITE_INLINE <span class="keyword">const</span> array&amp; operator=(<span class="keyword">const</span> array&amp; other)<span class="keyword"> const</span>
<a name="l15094"></a>15094 <span class="keyword">    </span>{
<a name="l15095"></a>15095         <span class="keyword">typedef</span> b_iterator&lt;iterator, iterator, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l15096"></a>15096 
<a name="l15097"></a>15097         LITE_ARRAY_SIZE_CHECK(m_size, other.m_size, <span class="stringliteral">&quot;operator=(): array sizes do not match&quot;</span>);
<a name="l15098"></a>15098 
<a name="l15099"></a>15099         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.m_iterator), m_size);
<a name="l15100"></a>15100         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l15101"></a>15101     }
<a name="l15102"></a>15102 
<a name="l15103"></a>15103     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l15104"></a>15104     LITE_INLINE <span class="keyword">const</span> array&amp; operator=(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other)<span class="keyword"> const</span>
<a name="l15105"></a>15105 <span class="keyword">    </span>{
<a name="l15106"></a>15106         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l15107"></a>15107             iterator, 
<a name="l15108"></a>15108             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l15109"></a>15109             assign&lt;value_type&gt; &gt; 
<a name="l15110"></a>15110             iterator_type;
<a name="l15111"></a>15111 
<a name="l15112"></a>15112         LITE_ARRAY_SIZE_CHECK(m_size, other.size(), <span class="stringliteral">&quot;operator=(): array sizes do not match&quot;</span>);
<a name="l15113"></a>15113 
<a name="l15114"></a>15114         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.begin()), m_size);
<a name="l15115"></a>15115         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l15116"></a>15116     }
<a name="l15117"></a>15117 
<a name="l15118"></a>15118     LITE_INLINE <span class="keyword">const</span> array&amp; operator=(<span class="keyword">const</span> value_type&amp; value)<span class="keyword"> const</span>
<a name="l15119"></a>15119 <span class="keyword">    </span>{
<a name="l15120"></a>15120         <span class="keyword">typedef</span> b_iterator&lt;iterator, c_iterator&lt;value_type&gt;, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l15121"></a>15121 
<a name="l15122"></a>15122         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, value), m_size);
<a name="l15123"></a>15123         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l15124"></a>15124     }
<a name="l15125"></a>15125 
<a name="l15126"></a>15126     LITE_INLINE <span class="keyword">const</span> iterator&amp; begin()<span class="keyword"> const</span>
<a name="l15127"></a>15127 <span class="keyword">    </span>{
<a name="l15128"></a>15128         <span class="keywordflow">return</span> m_iterator;
<a name="l15129"></a>15129     }
<a name="l15130"></a>15130 
<a name="l15131"></a>15131     LITE_INLINE <span class="keyword">const</span> size_type&amp; size()<span class="keyword"> const</span>
<a name="l15132"></a>15132 <span class="keyword">    </span>{
<a name="l15133"></a>15133         <span class="keywordflow">return</span> m_size;
<a name="l15134"></a>15134     }
<a name="l15135"></a>15135 
<a name="l15136"></a>15136     LITE_INLINE reference 
<a name="l15137"></a>15137     operator()(<span class="keywordtype">int</span> i0, <span class="keywordtype">int</span> i1)<span class="keyword"> const</span>
<a name="l15138"></a>15138 <span class="keyword">    </span>{
<a name="l15139"></a>15139         <span class="keywordflow">return</span> at(m_iterator, i0, i1);
<a name="l15140"></a>15140     }
<a name="l15141"></a>15141 
<a name="l15142"></a>15142     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_&gt;
<a name="l15143"></a>15143     LITE_INLINE <span class="keyword">const</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::array
<a name="l15144"></a>15144     operator[](<span class="keyword">const</span> transform_type_&amp; trans)<span class="keyword"> const</span>
<a name="l15145"></a>15145 <span class="keyword">    </span>{
<a name="l15146"></a>15146         <span class="keyword">typedef</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::array result_type;
<a name="l15147"></a>15147 
<a name="l15148"></a>15148         <span class="keywordflow">return</span> result_type(m_iterator, m_size, trans);
<a name="l15149"></a>15149     }
<a name="l15150"></a>15150 
<a name="l15151"></a>15151     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l15152"></a>15152     LITE_INLINE <span class="keywordtype">void</span> swap(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other)<span class="keyword"> const</span>
<a name="l15153"></a>15153 <span class="keyword">    </span>{
<a name="l15154"></a>15154         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l15155"></a>15155             iterator, 
<a name="l15156"></a>15156             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l15157"></a>15157             swapper&lt;value_type&gt; &gt; 
<a name="l15158"></a>15158             iterator_type;
<a name="l15159"></a>15159 
<a name="l15160"></a>15160         LITE_ARRAY_SIZE_CHECK(m_size, other.size(), <span class="stringliteral">&quot;swap(): array sizes do not match&quot;</span>);
<a name="l15161"></a>15161 
<a name="l15162"></a>15162         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.begin()), m_size);
<a name="l15163"></a>15163     }
<a name="l15164"></a>15164 
<a name="l15165"></a>15165     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l15166"></a>15166     LITE_INLINE <span class="keywordtype">void</span> swap(array&lt;signature, traits_type_, other_rep_&gt;&amp; other)<span class="keyword"> const</span>
<a name="l15167"></a>15167 <span class="keyword">    </span>{
<a name="l15168"></a>15168         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l15169"></a>15169             iterator, 
<a name="l15170"></a>15170             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::iterator, 
<a name="l15171"></a>15171             swapper&lt;value_type&gt; &gt; 
<a name="l15172"></a>15172             iterator_type;
<a name="l15173"></a>15173 
<a name="l15174"></a>15174         LITE_ARRAY_SIZE_CHECK(m_size, other.size(), <span class="stringliteral">&quot;swap(): array sizes do not match&quot;</span>);
<a name="l15175"></a>15175 
<a name="l15176"></a>15176         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.begin()), m_size);
<a name="l15177"></a>15177     }
<a name="l15178"></a>15178 
<a name="l15179"></a>15179 <span class="keyword">private</span>:
<a name="l15180"></a>15180     iterator m_iterator;
<a name="l15181"></a>15181     size_type m_size;
<a name="l15182"></a>15182 };
<a name="l15183"></a>15183 
<a name="l15184"></a>15184 <span class="comment">/***********************************************************************************************************/</span>
<a name="l15185"></a>15185 
<a name="l15186"></a>15186 <span class="keyword">template</span>&lt;
<a name="l15187"></a>15187     <span class="keyword">typename</span> value_type_,
<a name="l15188"></a>15188     <span class="keywordtype">int</span> n0_, 
<a name="l15189"></a>15189     <span class="keywordtype">int</span> n1_, 
<a name="l15190"></a>15190     <span class="keywordtype">int</span> n2_, 
<a name="l15191"></a>15191     <span class="keyword">typename</span> traits_type_,
<a name="l15192"></a>15192     <span class="keyword">typename</span> iterator_
<a name="l15193"></a>15193     &gt;
<a name="l15194"></a>15194 <span class="keyword">class </span>array&lt;
<a name="l15195"></a>15195     value_type_[n0_][n1_][n2_],
<a name="l15196"></a>15196     traits_type_,
<a name="l15197"></a>15197     reference_rep&lt;iterator_&gt;
<a name="l15198"></a>15198     &gt;
<a name="l15199"></a>15199 {
<a name="l15200"></a>15200 <span class="keyword">public</span>:
<a name="l15201"></a>15201     <span class="keyword">typedef</span> value_type_ signature[n0_][n1_][n2_];
<a name="l15202"></a>15202     <span class="keyword">typedef</span> traits_type_ traits_type;
<a name="l15203"></a>15203     <span class="keyword">typedef</span> value_type_ value_type;
<a name="l15204"></a>15204     <span class="keyword">typedef</span> iterator_ iterator;
<a name="l15205"></a>15205     <span class="keyword">typedef</span> iterator_ const_iterator;
<a name="l15206"></a>15206     <span class="keyword">typedef</span> <span class="keyword">typename</span> std::iterator_traits&lt;iterator&gt;::reference reference;
<a name="l15207"></a>15207     <span class="keyword">typedef</span> reference const_reference;
<a name="l15208"></a>15208 
<a name="l15209"></a>15209     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::temporary_array temporary_array;
<a name="l15210"></a>15210     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::fwd_temporary_array fwd_temporary_array;
<a name="l15211"></a>15211     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::rev_temporary_array rev_temporary_array;
<a name="l15212"></a>15212 
<a name="l15213"></a>15213     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;signature&gt;::size_type size_type;
<a name="l15214"></a>15214 
<a name="l15215"></a>15215     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> dimensions = 3;
<a name="l15216"></a>15216 
<a name="l15217"></a>15217     LITE_INLINE array(<span class="keyword">const</span> array&amp; other) 
<a name="l15218"></a>15218         : m_iterator(other.m_iterator), m_size(other.m_size)
<a name="l15219"></a>15219     {}
<a name="l15220"></a>15220 
<a name="l15221"></a>15221     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l15222"></a>15222     LITE_INLINE array(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l15223"></a>15223         : m_iterator(other.begin()), m_size(other.size())
<a name="l15224"></a>15224     {}
<a name="l15225"></a>15225 
<a name="l15226"></a>15226     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l15227"></a>15227     LITE_INLINE array(array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l15228"></a>15228         : m_iterator(other.begin()), m_size(other.size())
<a name="l15229"></a>15229     {}
<a name="l15230"></a>15230 
<a name="l15231"></a>15231     <span class="keyword">template</span>&lt;
<a name="l15232"></a>15232         <span class="keyword">typename</span> arg_type0_    
<a name="l15233"></a>15233         &gt;
<a name="l15234"></a>15234     LITE_INLINE array(
<a name="l15235"></a>15235         <span class="keyword">const</span> arg_type0_&amp; arg0,
<a name="l15236"></a>15236         <span class="keyword">const</span> size_type&amp; sz)
<a name="l15237"></a>15237         : m_iterator(arg0),
<a name="l15238"></a>15238           m_size(sz)
<a name="l15239"></a>15239     {}
<a name="l15240"></a>15240 
<a name="l15241"></a>15241     <span class="keyword">template</span>&lt;
<a name="l15242"></a>15242         <span class="keyword">typename</span> arg_type0_,    
<a name="l15243"></a>15243         <span class="keyword">typename</span> arg_type1_    
<a name="l15244"></a>15244         &gt;
<a name="l15245"></a>15245     LITE_INLINE array(
<a name="l15246"></a>15246         <span class="keyword">const</span> arg_type0_&amp; arg0,
<a name="l15247"></a>15247         <span class="keyword">const</span> arg_type1_&amp; arg1,
<a name="l15248"></a>15248         <span class="keyword">const</span> size_type&amp; sz)
<a name="l15249"></a>15249         : m_iterator(arg0, arg1),
<a name="l15250"></a>15250           m_size(sz)
<a name="l15251"></a>15251     {}
<a name="l15252"></a>15252 
<a name="l15253"></a>15253     <span class="keyword">template</span>&lt;
<a name="l15254"></a>15254         <span class="keyword">typename</span> arg_type0_,    
<a name="l15255"></a>15255         <span class="keyword">typename</span> arg_type1_,    
<a name="l15256"></a>15256         <span class="keyword">typename</span> arg_type2_    
<a name="l15257"></a>15257         &gt;
<a name="l15258"></a>15258     LITE_INLINE array(
<a name="l15259"></a>15259         <span class="keyword">const</span> arg_type0_&amp; arg0,
<a name="l15260"></a>15260         <span class="keyword">const</span> arg_type1_&amp; arg1,
<a name="l15261"></a>15261         <span class="keyword">const</span> arg_type2_&amp; arg2,
<a name="l15262"></a>15262         <span class="keyword">const</span> size_type&amp; sz)
<a name="l15263"></a>15263         : m_iterator(arg0, arg1, arg2),
<a name="l15264"></a>15264           m_size(sz)
<a name="l15265"></a>15265     {}
<a name="l15266"></a>15266 
<a name="l15267"></a>15267 
<a name="l15268"></a>15268     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_iterator_type_, <span class="keyword">typename</span> other_<span class="keywordtype">size_t</span>ype_, <span class="keyword">typename</span> transform_type_&gt;
<a name="l15269"></a>15269     LITE_INLINE array(
<a name="l15270"></a>15270         <span class="keyword">const</span> other_iterator_type_&amp; it, 
<a name="l15271"></a>15271         <span class="keyword">const</span> other_size_type_&amp; sz, 
<a name="l15272"></a>15272         <span class="keyword">const</span> transform_type_&amp; trans)
<a name="l15273"></a>15273     {
<a name="l15274"></a>15274         iterator_transformer&lt;transform_type_, other_iterator_type_, other_size_type_&gt;
<a name="l15275"></a>15275             ::transform(trans, it, sz, m_iterator);
<a name="l15276"></a>15276 
<a name="l15277"></a>15277         size_transformer&lt;transform_type_, other_size_type_&gt;
<a name="l15278"></a>15278             ::transform(trans, sz, m_size);
<a name="l15279"></a>15279     }
<a name="l15280"></a>15280 
<a name="l15281"></a>15281     LITE_INLINE <span class="keyword">const</span> array&amp; operator=(<span class="keyword">const</span> array&amp; other)<span class="keyword"> const</span>
<a name="l15282"></a>15282 <span class="keyword">    </span>{
<a name="l15283"></a>15283         <span class="keyword">typedef</span> b_iterator&lt;iterator, iterator, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l15284"></a>15284 
<a name="l15285"></a>15285         LITE_ARRAY_SIZE_CHECK(m_size, other.m_size, <span class="stringliteral">&quot;operator=(): array sizes do not match&quot;</span>);
<a name="l15286"></a>15286 
<a name="l15287"></a>15287         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.m_iterator), m_size);
<a name="l15288"></a>15288         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l15289"></a>15289     }
<a name="l15290"></a>15290 
<a name="l15291"></a>15291     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l15292"></a>15292     LITE_INLINE <span class="keyword">const</span> array&amp; operator=(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other)<span class="keyword"> const</span>
<a name="l15293"></a>15293 <span class="keyword">    </span>{
<a name="l15294"></a>15294         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l15295"></a>15295             iterator, 
<a name="l15296"></a>15296             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l15297"></a>15297             assign&lt;value_type&gt; &gt; 
<a name="l15298"></a>15298             iterator_type;
<a name="l15299"></a>15299 
<a name="l15300"></a>15300         LITE_ARRAY_SIZE_CHECK(m_size, other.size(), <span class="stringliteral">&quot;operator=(): array sizes do not match&quot;</span>);
<a name="l15301"></a>15301 
<a name="l15302"></a>15302         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.begin()), m_size);
<a name="l15303"></a>15303         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l15304"></a>15304     }
<a name="l15305"></a>15305 
<a name="l15306"></a>15306     LITE_INLINE <span class="keyword">const</span> array&amp; operator=(<span class="keyword">const</span> value_type&amp; value)<span class="keyword"> const</span>
<a name="l15307"></a>15307 <span class="keyword">    </span>{
<a name="l15308"></a>15308         <span class="keyword">typedef</span> b_iterator&lt;iterator, c_iterator&lt;value_type&gt;, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l15309"></a>15309 
<a name="l15310"></a>15310         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, value), m_size);
<a name="l15311"></a>15311         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l15312"></a>15312     }
<a name="l15313"></a>15313 
<a name="l15314"></a>15314     LITE_INLINE <span class="keyword">const</span> iterator&amp; begin()<span class="keyword"> const</span>
<a name="l15315"></a>15315 <span class="keyword">    </span>{
<a name="l15316"></a>15316         <span class="keywordflow">return</span> m_iterator;
<a name="l15317"></a>15317     }
<a name="l15318"></a>15318 
<a name="l15319"></a>15319     LITE_INLINE <span class="keyword">const</span> size_type&amp; size()<span class="keyword"> const</span>
<a name="l15320"></a>15320 <span class="keyword">    </span>{
<a name="l15321"></a>15321         <span class="keywordflow">return</span> m_size;
<a name="l15322"></a>15322     }
<a name="l15323"></a>15323 
<a name="l15324"></a>15324     LITE_INLINE reference 
<a name="l15325"></a>15325     operator()(<span class="keywordtype">int</span> i0, <span class="keywordtype">int</span> i1, <span class="keywordtype">int</span> i2)<span class="keyword"> const</span>
<a name="l15326"></a>15326 <span class="keyword">    </span>{
<a name="l15327"></a>15327         <span class="keywordflow">return</span> at(m_iterator, i0, i1, i2);
<a name="l15328"></a>15328     }
<a name="l15329"></a>15329 
<a name="l15330"></a>15330     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_&gt;
<a name="l15331"></a>15331     LITE_INLINE <span class="keyword">const</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::array
<a name="l15332"></a>15332     operator[](<span class="keyword">const</span> transform_type_&amp; trans)<span class="keyword"> const</span>
<a name="l15333"></a>15333 <span class="keyword">    </span>{
<a name="l15334"></a>15334         <span class="keyword">typedef</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::array result_type;
<a name="l15335"></a>15335 
<a name="l15336"></a>15336         <span class="keywordflow">return</span> result_type(m_iterator, m_size, trans);
<a name="l15337"></a>15337     }
<a name="l15338"></a>15338 
<a name="l15339"></a>15339     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l15340"></a>15340     LITE_INLINE <span class="keywordtype">void</span> swap(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other)<span class="keyword"> const</span>
<a name="l15341"></a>15341 <span class="keyword">    </span>{
<a name="l15342"></a>15342         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l15343"></a>15343             iterator, 
<a name="l15344"></a>15344             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l15345"></a>15345             swapper&lt;value_type&gt; &gt; 
<a name="l15346"></a>15346             iterator_type;
<a name="l15347"></a>15347 
<a name="l15348"></a>15348         LITE_ARRAY_SIZE_CHECK(m_size, other.size(), <span class="stringliteral">&quot;swap(): array sizes do not match&quot;</span>);
<a name="l15349"></a>15349 
<a name="l15350"></a>15350         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.begin()), m_size);
<a name="l15351"></a>15351     }
<a name="l15352"></a>15352 
<a name="l15353"></a>15353     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l15354"></a>15354     LITE_INLINE <span class="keywordtype">void</span> swap(array&lt;signature, traits_type_, other_rep_&gt;&amp; other)<span class="keyword"> const</span>
<a name="l15355"></a>15355 <span class="keyword">    </span>{
<a name="l15356"></a>15356         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l15357"></a>15357             iterator, 
<a name="l15358"></a>15358             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::iterator, 
<a name="l15359"></a>15359             swapper&lt;value_type&gt; &gt; 
<a name="l15360"></a>15360             iterator_type;
<a name="l15361"></a>15361 
<a name="l15362"></a>15362         LITE_ARRAY_SIZE_CHECK(m_size, other.size(), <span class="stringliteral">&quot;swap(): array sizes do not match&quot;</span>);
<a name="l15363"></a>15363 
<a name="l15364"></a>15364         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.begin()), m_size);
<a name="l15365"></a>15365     }
<a name="l15366"></a>15366 
<a name="l15367"></a>15367 <span class="keyword">private</span>:
<a name="l15368"></a>15368     iterator m_iterator;
<a name="l15369"></a>15369     size_type m_size;
<a name="l15370"></a>15370 };
<a name="l15371"></a>15371 
<a name="l15372"></a>15372 <span class="comment">/***********************************************************************************************************/</span>
<a name="l15373"></a>15373 
<a name="l15374"></a>15374 
<a name="l15375"></a>15375 <span class="comment">/***********************************************************************************************************/</span>
<a name="l15376"></a>15376 <span class="comment">/* array, internal_rep *************************************************************************************/</span>
<a name="l15377"></a>15377 <span class="comment">/***********************************************************************************************************/</span>
<a name="l15378"></a>15378 
<a name="l15386"></a>15386 <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> reversed_&gt;
<a name="l15387"></a><a class="code" href="classlite_1_1internal__rep.html">15387</a> <span class="keyword">class </span><a class="code" href="classlite_1_1internal__rep.html" title="This is a tag type that can be used to specify internal representation for an array...">internal_rep</a> {};
<a name="l15388"></a>15388 
<a name="l15389"></a>15389 <span class="comment">// forward declaration</span>
<a name="l15390"></a>15390 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_&gt;
<a name="l15391"></a>15391 <span class="keyword">class </span>swapper;
<a name="l15392"></a>15392 
<a name="l15393"></a>15393 <span class="keyword">template</span>&lt;
<a name="l15394"></a>15394     <span class="keyword">typename</span> value_type_,
<a name="l15395"></a>15395     <span class="keyword">typename</span> traits_type_
<a name="l15396"></a>15396     &gt;
<a name="l15397"></a>15397 <span class="keyword">class </span><a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a>&lt;
<a name="l15398"></a>15398     value_type_,
<a name="l15399"></a>15399     traits_type_,
<a name="l15400"></a>15400     <a class="code" href="classlite_1_1internal__rep.html" title="This is a tag type that can be used to specify internal representation for an array...">internal_rep</a>&lt;false&gt;
<a name="l15401"></a>15401     &gt;
<a name="l15402"></a>15402 {
<a name="l15403"></a>15403 <span class="keyword">public</span>:
<a name="l15404"></a>15404     <span class="keyword">typedef</span> value_type_ signature;
<a name="l15405"></a>15405     <span class="keyword">typedef</span> traits_type_ traits_type;
<a name="l15406"></a>15406     <span class="keyword">typedef</span> value_type_ value_type;
<a name="l15407"></a>15407     <span class="keyword">typedef</span> <span class="keyword">const</span> value_type_&amp; const_reference;
<a name="l15408"></a>15408     <span class="keyword">typedef</span> value_type_&amp; reference;
<a name="l15409"></a>15409 
<a name="l15410"></a>15410     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structlite_1_1array__signature__traits.html" title="This can be used to extract information from array signatures and get the appropriate...">array_signature_traits&lt;const signature&gt;::default_iterator</a> const_iterator;
<a name="l15411"></a>15411     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structlite_1_1array__signature__traits.html" title="This can be used to extract information from array signatures and get the appropriate...">array_signature_traits&lt;signature&gt;::default_iterator</a> iterator;
<a name="l15412"></a>15412     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structlite_1_1array__signature__traits.html" title="This can be used to extract information from array signatures and get the appropriate...">array_signature_traits&lt;signature&gt;::size_type</a> size_type;
<a name="l15413"></a>15413 
<a name="l15414"></a>15414     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array_helper&lt;signature, traits_type_&gt;::temporary_array</a> temporary_array;
<a name="l15415"></a>15415     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array_helper&lt;signature, traits_type_&gt;::fwd_temporary_array</a> fwd_temporary_array;
<a name="l15416"></a>15416     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array_helper&lt;signature, traits_type_&gt;::rev_temporary_array</a> rev_temporary_array;
<a name="l15417"></a>15417 
<a name="l15418"></a>15418     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_reverse = <span class="keyword">false</span>;
<a name="l15419"></a>15419     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> dimensions = 0;
<a name="l15420"></a>15420 
<a name="l15421"></a>15421     LITE_INLINE <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a>() 
<a name="l15422"></a>15422     {}
<a name="l15423"></a>15423 
<a name="l15424"></a>15424 
<a name="l15425"></a>15425     <span class="keyword">explicit</span> LITE_INLINE array(<span class="keyword">const</span> size_type&amp;)
<a name="l15426"></a>15426     {}
<a name="l15427"></a>15427 
<a name="l15428"></a>15428     LITE_INLINE array(<span class="keyword">const</span> array&amp; other) 
<a name="l15429"></a>15429     {
<a name="l15430"></a>15430         <span class="keyword">typedef</span> b_iterator&lt;iterator, const_iterator, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l15431"></a>15431 
<a name="l15432"></a>15432         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(
<a name="l15433"></a>15433             &amp;m_data, 
<a name="l15434"></a>15434             &amp;other.m_data), 
<a name="l15435"></a>15435             size_type());
<a name="l15436"></a>15436     }
<a name="l15437"></a>15437 
<a name="l15438"></a>15438     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l15439"></a>15439     LITE_INLINE array(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l15440"></a>15440     {
<a name="l15441"></a>15441         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l15442"></a>15442             iterator, 
<a name="l15443"></a>15443             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l15444"></a>15444             assign&lt;value_type&gt; &gt; 
<a name="l15445"></a>15445             iterator_type;
<a name="l15446"></a>15446 
<a name="l15447"></a>15447         LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), <span class="stringliteral">&quot;array(): array sizes do not match&quot;</span>);
<a name="l15448"></a>15448 
<a name="l15449"></a>15449         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data, other.begin()), size_type());
<a name="l15450"></a>15450     }
<a name="l15451"></a>15451 
<a name="l15452"></a>15452     LITE_INLINE array(<span class="keyword">const</span> value_type&amp; value) 
<a name="l15453"></a>15453     {
<a name="l15454"></a>15454         <span class="keyword">typedef</span> b_iterator&lt;iterator, c_iterator&lt;value_type&gt;, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l15455"></a>15455 
<a name="l15456"></a>15456         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data, value), size_type());
<a name="l15457"></a>15457     }
<a name="l15458"></a>15458 
<a name="l15459"></a>15459 
<a name="l15460"></a>15460     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> array&amp; other) 
<a name="l15461"></a>15461     {
<a name="l15462"></a>15462         <span class="keyword">typedef</span> b_iterator&lt;iterator, const_iterator, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l15463"></a>15463 
<a name="l15464"></a>15464         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(
<a name="l15465"></a>15465             &amp;m_data, 
<a name="l15466"></a>15466             &amp;other.m_data), 
<a name="l15467"></a>15467             size_type());
<a name="l15468"></a>15468         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l15469"></a>15469     }
<a name="l15470"></a>15470 
<a name="l15471"></a>15471     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l15472"></a>15472     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l15473"></a>15473     {
<a name="l15474"></a>15474         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l15475"></a>15475             iterator, 
<a name="l15476"></a>15476             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l15477"></a>15477             assign&lt;value_type&gt; &gt; 
<a name="l15478"></a>15478             iterator_type;
<a name="l15479"></a>15479 
<a name="l15480"></a>15480         LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), <span class="stringliteral">&quot;array(): array sizes do not match&quot;</span>);
<a name="l15481"></a>15481 
<a name="l15482"></a>15482         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data, other.begin()), size_type());
<a name="l15483"></a>15483         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l15484"></a>15484     }
<a name="l15485"></a>15485 
<a name="l15486"></a>15486     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> value_type&amp; value)
<a name="l15487"></a>15487     {
<a name="l15488"></a>15488         <span class="keyword">typedef</span> b_iterator&lt;iterator, c_iterator&lt;value_type&gt;, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l15489"></a>15489 
<a name="l15490"></a>15490         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data, value), size_type());
<a name="l15491"></a>15491         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l15492"></a>15492     }
<a name="l15493"></a>15493 
<a name="l15494"></a>15494     LITE_INLINE const_iterator begin()<span class="keyword"> const</span>
<a name="l15495"></a>15495 <span class="keyword">    </span>{
<a name="l15496"></a>15496         <span class="keywordflow">return</span> const_iterator(&amp;m_data);
<a name="l15497"></a>15497     }
<a name="l15498"></a>15498 
<a name="l15499"></a>15499     LITE_INLINE iterator begin()
<a name="l15500"></a>15500     {
<a name="l15501"></a>15501         <span class="keywordflow">return</span> iterator(&amp;m_data);
<a name="l15502"></a>15502     }
<a name="l15503"></a>15503 
<a name="l15504"></a>15504     LITE_INLINE size_type size()<span class="keyword"> const</span>
<a name="l15505"></a>15505 <span class="keyword">    </span>{
<a name="l15506"></a>15506         <span class="keywordflow">return</span> size_type();
<a name="l15507"></a>15507     }
<a name="l15508"></a>15508 
<a name="l15509"></a>15509     LITE_INLINE const_reference 
<a name="l15510"></a>15510     operator()()<span class="keyword"> const</span>
<a name="l15511"></a>15511 <span class="keyword">    </span>{
<a name="l15512"></a>15512         <span class="keywordflow">return</span> m_data;
<a name="l15513"></a>15513     }
<a name="l15514"></a>15514 
<a name="l15515"></a>15515     LITE_INLINE reference 
<a name="l15516"></a>15516     operator()() 
<a name="l15517"></a>15517     {
<a name="l15518"></a>15518         <span class="keywordflow">return</span> m_data;
<a name="l15519"></a>15519     }
<a name="l15520"></a>15520 
<a name="l15521"></a>15521 
<a name="l15522"></a>15522     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_&gt;
<a name="l15523"></a>15523     LITE_INLINE <span class="keyword">const</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::const_array
<a name="l15524"></a>15524     operator[](<span class="keyword">const</span> transform_type_&amp; trans)<span class="keyword"> const</span>
<a name="l15525"></a>15525 <span class="keyword">    </span>{
<a name="l15526"></a>15526         <span class="keyword">typedef</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::const_array result_type;
<a name="l15527"></a>15527 
<a name="l15528"></a>15528         <span class="keywordflow">return</span> result_type(begin(), size(), trans);
<a name="l15529"></a>15529     }
<a name="l15530"></a>15530 
<a name="l15531"></a>15531     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_&gt;
<a name="l15532"></a>15532     LITE_INLINE <span class="keyword">const</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::array
<a name="l15533"></a>15533     operator[](<span class="keyword">const</span> transform_type_&amp; trans)
<a name="l15534"></a>15534     {
<a name="l15535"></a>15535         <span class="keyword">typedef</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::array result_type;
<a name="l15536"></a>15536 
<a name="l15537"></a>15537         <span class="keywordflow">return</span> result_type(begin(), size(), trans);
<a name="l15538"></a>15538     }
<a name="l15539"></a>15539 
<a name="l15540"></a>15540     LITE_INLINE <span class="keyword">const</span> value_type* data()<span class="keyword"> const</span>
<a name="l15541"></a>15541 <span class="keyword">    </span>{
<a name="l15542"></a>15542         <span class="keywordflow">return</span> &amp;m_data;
<a name="l15543"></a>15543     }
<a name="l15544"></a>15544 
<a name="l15545"></a>15545     LITE_INLINE value_type* data()
<a name="l15546"></a>15546     {
<a name="l15547"></a>15547         <span class="keywordflow">return</span> &amp;m_data;
<a name="l15548"></a>15548     }
<a name="l15549"></a>15549 
<a name="l15550"></a>15550     LITE_INLINE <span class="keywordtype">void</span> release() 
<a name="l15551"></a>15551     {}
<a name="l15552"></a>15552 
<a name="l15553"></a>15553     LITE_INLINE <span class="keywordtype">void</span> resize()
<a name="l15554"></a>15554     {}
<a name="l15555"></a>15555 
<a name="l15556"></a>15556     LITE_INLINE <span class="keywordtype">void</span> resize(<span class="keyword">const</span> size_type&amp;)
<a name="l15557"></a>15557     {}
<a name="l15558"></a>15558 
<a name="l15559"></a>15559     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l15560"></a>15560     LITE_INLINE <span class="keywordtype">void</span> swap(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l15561"></a>15561     {
<a name="l15562"></a>15562         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l15563"></a>15563             iterator, 
<a name="l15564"></a>15564             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l15565"></a>15565             swapper&lt;value_type&gt; &gt; 
<a name="l15566"></a>15566             iterator_type;
<a name="l15567"></a>15567 
<a name="l15568"></a>15568         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data, other.begin()), size_type());
<a name="l15569"></a>15569     }
<a name="l15570"></a>15570 
<a name="l15571"></a>15571     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l15572"></a>15572     LITE_INLINE <span class="keywordtype">void</span> swap(array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l15573"></a>15573     {
<a name="l15574"></a>15574         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l15575"></a>15575             iterator, 
<a name="l15576"></a>15576             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::iterator, 
<a name="l15577"></a>15577             swapper&lt;value_type&gt; &gt; 
<a name="l15578"></a>15578             iterator_type;
<a name="l15579"></a>15579 
<a name="l15580"></a>15580         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data, other.begin()), size_type());
<a name="l15581"></a>15581     }
<a name="l15582"></a>15582 
<a name="l15583"></a>15583 <span class="keyword">private</span>:
<a name="l15584"></a>15584     value_type m_data;
<a name="l15585"></a>15585 };
<a name="l15586"></a>15586 
<a name="l15587"></a>15587 <span class="comment">/***********************************************************************************************************/</span>
<a name="l15588"></a>15588 
<a name="l15589"></a>15589 <span class="keyword">template</span>&lt;
<a name="l15590"></a>15590     <span class="keyword">typename</span> value_type_,
<a name="l15591"></a>15591     <span class="keywordtype">int</span> n0_, 
<a name="l15592"></a>15592     <span class="keyword">typename</span> traits_type_
<a name="l15593"></a>15593     &gt;
<a name="l15594"></a>15594 <span class="keyword">class </span>array&lt;
<a name="l15595"></a>15595     value_type_[n0_],
<a name="l15596"></a>15596     traits_type_,
<a name="l15597"></a>15597     internal_rep&lt;false&gt;
<a name="l15598"></a>15598     &gt;
<a name="l15599"></a>15599 {
<a name="l15600"></a>15600 <span class="keyword">public</span>:
<a name="l15601"></a>15601     <span class="keyword">typedef</span> value_type_ signature[n0_];
<a name="l15602"></a>15602     <span class="keyword">typedef</span> traits_type_ traits_type;
<a name="l15603"></a>15603     <span class="keyword">typedef</span> value_type_ value_type;
<a name="l15604"></a>15604     <span class="keyword">typedef</span> <span class="keyword">const</span> value_type_&amp; const_reference;
<a name="l15605"></a>15605     <span class="keyword">typedef</span> value_type_&amp; reference;
<a name="l15606"></a>15606 
<a name="l15607"></a>15607     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;const signature&gt;::default_iterator const_iterator;
<a name="l15608"></a>15608     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;signature&gt;::default_iterator iterator;
<a name="l15609"></a>15609     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;signature&gt;::size_type size_type;
<a name="l15610"></a>15610 
<a name="l15611"></a>15611     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::temporary_array temporary_array;
<a name="l15612"></a>15612     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::fwd_temporary_array fwd_temporary_array;
<a name="l15613"></a>15613     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::rev_temporary_array rev_temporary_array;
<a name="l15614"></a>15614 
<a name="l15615"></a>15615     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_reverse = <span class="keyword">false</span>;
<a name="l15616"></a>15616     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> dimensions = 1;
<a name="l15617"></a>15617 
<a name="l15618"></a>15618     LITE_INLINE array() 
<a name="l15619"></a>15619     {}
<a name="l15620"></a>15620 
<a name="l15621"></a>15621     <span class="keyword">explicit</span> LITE_INLINE array(<span class="keywordtype">int</span>)
<a name="l15622"></a>15622     {}
<a name="l15623"></a>15623 
<a name="l15624"></a>15624     <span class="keyword">explicit</span> LITE_INLINE array(<span class="keyword">const</span> size_type&amp;)
<a name="l15625"></a>15625     {}
<a name="l15626"></a>15626 
<a name="l15627"></a>15627     LITE_INLINE array(<span class="keyword">const</span> array&amp; other) 
<a name="l15628"></a>15628     {
<a name="l15629"></a>15629         <span class="keyword">typedef</span> b_iterator&lt;iterator, const_iterator, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l15630"></a>15630 
<a name="l15631"></a>15631         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(
<a name="l15632"></a>15632             &amp;m_data[0], 
<a name="l15633"></a>15633             &amp;other.m_data[0]), 
<a name="l15634"></a>15634             size_type());
<a name="l15635"></a>15635     }
<a name="l15636"></a>15636 
<a name="l15637"></a>15637     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l15638"></a>15638     LITE_INLINE array(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l15639"></a>15639     {
<a name="l15640"></a>15640         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l15641"></a>15641             iterator, 
<a name="l15642"></a>15642             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l15643"></a>15643             assign&lt;value_type&gt; &gt; 
<a name="l15644"></a>15644             iterator_type;
<a name="l15645"></a>15645 
<a name="l15646"></a>15646         LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), <span class="stringliteral">&quot;array(): array sizes do not match&quot;</span>);
<a name="l15647"></a>15647 
<a name="l15648"></a>15648         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data[0], other.begin()), size_type());
<a name="l15649"></a>15649     }
<a name="l15650"></a>15650 
<a name="l15651"></a>15651     LITE_INLINE array(<span class="keyword">const</span> value_type&amp; value) 
<a name="l15652"></a>15652     {
<a name="l15653"></a>15653         <span class="keyword">typedef</span> b_iterator&lt;iterator, c_iterator&lt;value_type&gt;, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l15654"></a>15654 
<a name="l15655"></a>15655         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data[0], value), size_type());
<a name="l15656"></a>15656     }
<a name="l15657"></a>15657 
<a name="l15658"></a>15658 
<a name="l15659"></a>15659     LITE_INLINE array(
<a name="l15660"></a>15660         <span class="keyword">typename</span> detail::type_if&lt;n0_==2, const value_type&amp;, detail::invalid_argument&gt;::type a0,
<a name="l15661"></a>15661         <span class="keyword">const</span> value_type&amp; a1 
<a name="l15662"></a>15662         )
<a name="l15663"></a>15663     {
<a name="l15664"></a>15664         m_data[0] = a0;
<a name="l15665"></a>15665         m_data[1] = a1;
<a name="l15666"></a>15666     }
<a name="l15667"></a>15667 
<a name="l15668"></a>15668     LITE_INLINE array(
<a name="l15669"></a>15669         <span class="keyword">typename</span> detail::type_if&lt;n0_==3, const value_type&amp;, detail::invalid_argument&gt;::type a0,
<a name="l15670"></a>15670         <span class="keyword">const</span> value_type&amp; a1, 
<a name="l15671"></a>15671         <span class="keyword">const</span> value_type&amp; a2 
<a name="l15672"></a>15672         )
<a name="l15673"></a>15673     {
<a name="l15674"></a>15674         m_data[0] = a0;
<a name="l15675"></a>15675         m_data[1] = a1;
<a name="l15676"></a>15676         m_data[2] = a2;
<a name="l15677"></a>15677     }
<a name="l15678"></a>15678 
<a name="l15679"></a>15679     LITE_INLINE array(
<a name="l15680"></a>15680         <span class="keyword">typename</span> detail::type_if&lt;n0_==4, const value_type&amp;, detail::invalid_argument&gt;::type a0,
<a name="l15681"></a>15681         <span class="keyword">const</span> value_type&amp; a1, 
<a name="l15682"></a>15682         <span class="keyword">const</span> value_type&amp; a2, 
<a name="l15683"></a>15683         <span class="keyword">const</span> value_type&amp; a3 
<a name="l15684"></a>15684         )
<a name="l15685"></a>15685     {
<a name="l15686"></a>15686         m_data[0] = a0;
<a name="l15687"></a>15687         m_data[1] = a1;
<a name="l15688"></a>15688         m_data[2] = a2;
<a name="l15689"></a>15689         m_data[3] = a3;
<a name="l15690"></a>15690     }
<a name="l15691"></a>15691 
<a name="l15692"></a>15692     LITE_INLINE array(
<a name="l15693"></a>15693         <span class="keyword">typename</span> detail::type_if&lt;n0_==5, const value_type&amp;, detail::invalid_argument&gt;::type a0,
<a name="l15694"></a>15694         <span class="keyword">const</span> value_type&amp; a1, 
<a name="l15695"></a>15695         <span class="keyword">const</span> value_type&amp; a2, 
<a name="l15696"></a>15696         <span class="keyword">const</span> value_type&amp; a3, 
<a name="l15697"></a>15697         <span class="keyword">const</span> value_type&amp; a4 
<a name="l15698"></a>15698         )
<a name="l15699"></a>15699     {
<a name="l15700"></a>15700         m_data[0] = a0;
<a name="l15701"></a>15701         m_data[1] = a1;
<a name="l15702"></a>15702         m_data[2] = a2;
<a name="l15703"></a>15703         m_data[3] = a3;
<a name="l15704"></a>15704         m_data[4] = a4;
<a name="l15705"></a>15705     }
<a name="l15706"></a>15706 
<a name="l15707"></a>15707     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> array&amp; other) 
<a name="l15708"></a>15708     {
<a name="l15709"></a>15709         <span class="keyword">typedef</span> b_iterator&lt;iterator, const_iterator, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l15710"></a>15710 
<a name="l15711"></a>15711         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(
<a name="l15712"></a>15712             &amp;m_data[0], 
<a name="l15713"></a>15713             &amp;other.m_data[0]), 
<a name="l15714"></a>15714             size_type());
<a name="l15715"></a>15715         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l15716"></a>15716     }
<a name="l15717"></a>15717 
<a name="l15718"></a>15718     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l15719"></a>15719     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l15720"></a>15720     {
<a name="l15721"></a>15721         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l15722"></a>15722             iterator, 
<a name="l15723"></a>15723             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l15724"></a>15724             assign&lt;value_type&gt; &gt; 
<a name="l15725"></a>15725             iterator_type;
<a name="l15726"></a>15726 
<a name="l15727"></a>15727         LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), <span class="stringliteral">&quot;array(): array sizes do not match&quot;</span>);
<a name="l15728"></a>15728 
<a name="l15729"></a>15729         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data[0], other.begin()), size_type());
<a name="l15730"></a>15730         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l15731"></a>15731     }
<a name="l15732"></a>15732 
<a name="l15733"></a>15733     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> value_type&amp; value)
<a name="l15734"></a>15734     {
<a name="l15735"></a>15735         <span class="keyword">typedef</span> b_iterator&lt;iterator, c_iterator&lt;value_type&gt;, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l15736"></a>15736 
<a name="l15737"></a>15737         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data[0], value), size_type());
<a name="l15738"></a>15738         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l15739"></a>15739     }
<a name="l15740"></a>15740 
<a name="l15741"></a>15741     LITE_INLINE const_iterator begin()<span class="keyword"> const</span>
<a name="l15742"></a>15742 <span class="keyword">    </span>{
<a name="l15743"></a>15743         <span class="keywordflow">return</span> const_iterator(&amp;m_data[0]);
<a name="l15744"></a>15744     }
<a name="l15745"></a>15745 
<a name="l15746"></a>15746     LITE_INLINE iterator begin()
<a name="l15747"></a>15747     {
<a name="l15748"></a>15748         <span class="keywordflow">return</span> iterator(&amp;m_data[0]);
<a name="l15749"></a>15749     }
<a name="l15750"></a>15750 
<a name="l15751"></a>15751     LITE_INLINE size_type size()<span class="keyword"> const</span>
<a name="l15752"></a>15752 <span class="keyword">    </span>{
<a name="l15753"></a>15753         <span class="keywordflow">return</span> size_type();
<a name="l15754"></a>15754     }
<a name="l15755"></a>15755 
<a name="l15756"></a>15756     LITE_INLINE const_reference 
<a name="l15757"></a>15757     operator()(<span class="keywordtype">int</span> i0)<span class="keyword"> const</span>
<a name="l15758"></a>15758 <span class="keyword">    </span>{
<a name="l15759"></a>15759         <span class="keywordflow">return</span> m_data[i0];
<a name="l15760"></a>15760     }
<a name="l15761"></a>15761 
<a name="l15762"></a>15762     LITE_INLINE reference 
<a name="l15763"></a>15763     operator()(<span class="keywordtype">int</span> i0) 
<a name="l15764"></a>15764     {
<a name="l15765"></a>15765         <span class="keywordflow">return</span> m_data[i0];
<a name="l15766"></a>15766     }
<a name="l15767"></a>15767 
<a name="l15768"></a>15768     LITE_INLINE const_reference 
<a name="l15769"></a>15769     operator[](<span class="keywordtype">int</span> i0)<span class="keyword"> const</span>
<a name="l15770"></a>15770 <span class="keyword">    </span>{
<a name="l15771"></a>15771         <span class="keywordflow">return</span> m_data[i0];
<a name="l15772"></a>15772     }
<a name="l15773"></a>15773 
<a name="l15774"></a>15774     LITE_INLINE reference 
<a name="l15775"></a>15775     operator[](<span class="keywordtype">int</span> i0)
<a name="l15776"></a>15776     {
<a name="l15777"></a>15777         <span class="keywordflow">return</span> m_data[i0];
<a name="l15778"></a>15778     }
<a name="l15779"></a>15779 
<a name="l15780"></a>15780 
<a name="l15781"></a>15781     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_&gt;
<a name="l15782"></a>15782     LITE_INLINE <span class="keyword">const</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::const_array
<a name="l15783"></a>15783     operator[](<span class="keyword">const</span> transform_type_&amp; trans)<span class="keyword"> const</span>
<a name="l15784"></a>15784 <span class="keyword">    </span>{
<a name="l15785"></a>15785         <span class="keyword">typedef</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::const_array result_type;
<a name="l15786"></a>15786 
<a name="l15787"></a>15787         <span class="keywordflow">return</span> result_type(begin(), size(), trans);
<a name="l15788"></a>15788     }
<a name="l15789"></a>15789 
<a name="l15790"></a>15790     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_&gt;
<a name="l15791"></a>15791     LITE_INLINE <span class="keyword">const</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::array
<a name="l15792"></a>15792     operator[](<span class="keyword">const</span> transform_type_&amp; trans)
<a name="l15793"></a>15793     {
<a name="l15794"></a>15794         <span class="keyword">typedef</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::array result_type;
<a name="l15795"></a>15795 
<a name="l15796"></a>15796         <span class="keywordflow">return</span> result_type(begin(), size(), trans);
<a name="l15797"></a>15797     }
<a name="l15798"></a>15798 
<a name="l15799"></a>15799     LITE_INLINE <span class="keyword">const</span> value_type* data()<span class="keyword"> const</span>
<a name="l15800"></a>15800 <span class="keyword">    </span>{
<a name="l15801"></a>15801         <span class="keywordflow">return</span> &amp;m_data[0];
<a name="l15802"></a>15802     }
<a name="l15803"></a>15803 
<a name="l15804"></a>15804     LITE_INLINE value_type* data()
<a name="l15805"></a>15805     {
<a name="l15806"></a>15806         <span class="keywordflow">return</span> &amp;m_data[0];
<a name="l15807"></a>15807     }
<a name="l15808"></a>15808 
<a name="l15809"></a>15809     LITE_INLINE <span class="keywordtype">void</span> release() 
<a name="l15810"></a>15810     {}
<a name="l15811"></a>15811 
<a name="l15812"></a>15812     LITE_INLINE <span class="keywordtype">void</span> resize(<span class="keywordtype">int</span>)
<a name="l15813"></a>15813     {}
<a name="l15814"></a>15814 
<a name="l15815"></a>15815     LITE_INLINE <span class="keywordtype">void</span> resize(<span class="keyword">const</span> size_type&amp;)
<a name="l15816"></a>15816     {}
<a name="l15817"></a>15817 
<a name="l15818"></a>15818     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l15819"></a>15819     LITE_INLINE <span class="keywordtype">void</span> swap(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l15820"></a>15820     {
<a name="l15821"></a>15821         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l15822"></a>15822             iterator, 
<a name="l15823"></a>15823             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l15824"></a>15824             swapper&lt;value_type&gt; &gt; 
<a name="l15825"></a>15825             iterator_type;
<a name="l15826"></a>15826 
<a name="l15827"></a>15827         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data[0], other.begin()), size_type());
<a name="l15828"></a>15828     }
<a name="l15829"></a>15829 
<a name="l15830"></a>15830     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l15831"></a>15831     LITE_INLINE <span class="keywordtype">void</span> swap(array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l15832"></a>15832     {
<a name="l15833"></a>15833         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l15834"></a>15834             iterator, 
<a name="l15835"></a>15835             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::iterator, 
<a name="l15836"></a>15836             swapper&lt;value_type&gt; &gt; 
<a name="l15837"></a>15837             iterator_type;
<a name="l15838"></a>15838 
<a name="l15839"></a>15839         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data[0], other.begin()), size_type());
<a name="l15840"></a>15840     }
<a name="l15841"></a>15841 
<a name="l15842"></a>15842 <span class="keyword">private</span>:
<a name="l15843"></a>15843     value_type m_data[n0_];
<a name="l15844"></a>15844 };
<a name="l15845"></a>15845 
<a name="l15846"></a>15846 <span class="comment">/***********************************************************************************************************/</span>
<a name="l15847"></a>15847 
<a name="l15848"></a>15848 <span class="keyword">template</span>&lt;
<a name="l15849"></a>15849     <span class="keyword">typename</span> value_type_,
<a name="l15850"></a>15850     <span class="keywordtype">int</span> n0_, 
<a name="l15851"></a>15851     <span class="keywordtype">int</span> n1_, 
<a name="l15852"></a>15852     <span class="keyword">typename</span> traits_type_
<a name="l15853"></a>15853     &gt;
<a name="l15854"></a>15854 <span class="keyword">class </span>array&lt;
<a name="l15855"></a>15855     value_type_[n0_][n1_],
<a name="l15856"></a>15856     traits_type_,
<a name="l15857"></a>15857     internal_rep&lt;false&gt;
<a name="l15858"></a>15858     &gt;
<a name="l15859"></a>15859 {
<a name="l15860"></a>15860 <span class="keyword">public</span>:
<a name="l15861"></a>15861     <span class="keyword">typedef</span> value_type_ signature[n0_][n1_];
<a name="l15862"></a>15862     <span class="keyword">typedef</span> traits_type_ traits_type;
<a name="l15863"></a>15863     <span class="keyword">typedef</span> value_type_ value_type;
<a name="l15864"></a>15864     <span class="keyword">typedef</span> <span class="keyword">const</span> value_type_&amp; const_reference;
<a name="l15865"></a>15865     <span class="keyword">typedef</span> value_type_&amp; reference;
<a name="l15866"></a>15866 
<a name="l15867"></a>15867     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;const signature&gt;::default_iterator const_iterator;
<a name="l15868"></a>15868     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;signature&gt;::default_iterator iterator;
<a name="l15869"></a>15869     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;signature&gt;::size_type size_type;
<a name="l15870"></a>15870 
<a name="l15871"></a>15871     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::temporary_array temporary_array;
<a name="l15872"></a>15872     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::fwd_temporary_array fwd_temporary_array;
<a name="l15873"></a>15873     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::rev_temporary_array rev_temporary_array;
<a name="l15874"></a>15874 
<a name="l15875"></a>15875     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_reverse = <span class="keyword">false</span>;
<a name="l15876"></a>15876     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> dimensions = 2;
<a name="l15877"></a>15877 
<a name="l15878"></a>15878     LITE_INLINE array() 
<a name="l15879"></a>15879     {}
<a name="l15880"></a>15880 
<a name="l15881"></a>15881     <span class="keyword">explicit</span> LITE_INLINE array(<span class="keywordtype">int</span>, <span class="keywordtype">int</span>)
<a name="l15882"></a>15882     {}
<a name="l15883"></a>15883 
<a name="l15884"></a>15884     <span class="keyword">explicit</span> LITE_INLINE array(<span class="keyword">const</span> size_type&amp;)
<a name="l15885"></a>15885     {}
<a name="l15886"></a>15886 
<a name="l15887"></a>15887     LITE_INLINE array(<span class="keyword">const</span> array&amp; other) 
<a name="l15888"></a>15888     {
<a name="l15889"></a>15889         <span class="keyword">typedef</span> b_iterator&lt;iterator, const_iterator, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l15890"></a>15890 
<a name="l15891"></a>15891         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(
<a name="l15892"></a>15892             &amp;m_data[0][0], 
<a name="l15893"></a>15893             &amp;other.m_data[0][0]), 
<a name="l15894"></a>15894             size_type());
<a name="l15895"></a>15895     }
<a name="l15896"></a>15896 
<a name="l15897"></a>15897     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l15898"></a>15898     LITE_INLINE array(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l15899"></a>15899     {
<a name="l15900"></a>15900         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l15901"></a>15901             iterator, 
<a name="l15902"></a>15902             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l15903"></a>15903             assign&lt;value_type&gt; &gt; 
<a name="l15904"></a>15904             iterator_type;
<a name="l15905"></a>15905 
<a name="l15906"></a>15906         LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), <span class="stringliteral">&quot;array(): array sizes do not match&quot;</span>);
<a name="l15907"></a>15907 
<a name="l15908"></a>15908         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data[0][0], other.begin()), size_type());
<a name="l15909"></a>15909     }
<a name="l15910"></a>15910 
<a name="l15911"></a>15911     LITE_INLINE array(<span class="keyword">const</span> value_type&amp; value) 
<a name="l15912"></a>15912     {
<a name="l15913"></a>15913         <span class="keyword">typedef</span> b_iterator&lt;iterator, c_iterator&lt;value_type&gt;, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l15914"></a>15914 
<a name="l15915"></a>15915         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data[0][0], value), size_type());
<a name="l15916"></a>15916     }
<a name="l15917"></a>15917 
<a name="l15918"></a>15918 
<a name="l15919"></a>15919     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> array&amp; other) 
<a name="l15920"></a>15920     {
<a name="l15921"></a>15921         <span class="keyword">typedef</span> b_iterator&lt;iterator, const_iterator, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l15922"></a>15922 
<a name="l15923"></a>15923         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(
<a name="l15924"></a>15924             &amp;m_data[0][0], 
<a name="l15925"></a>15925             &amp;other.m_data[0][0]), 
<a name="l15926"></a>15926             size_type());
<a name="l15927"></a>15927         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l15928"></a>15928     }
<a name="l15929"></a>15929 
<a name="l15930"></a>15930     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l15931"></a>15931     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l15932"></a>15932     {
<a name="l15933"></a>15933         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l15934"></a>15934             iterator, 
<a name="l15935"></a>15935             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l15936"></a>15936             assign&lt;value_type&gt; &gt; 
<a name="l15937"></a>15937             iterator_type;
<a name="l15938"></a>15938 
<a name="l15939"></a>15939         LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), <span class="stringliteral">&quot;array(): array sizes do not match&quot;</span>);
<a name="l15940"></a>15940 
<a name="l15941"></a>15941         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data[0][0], other.begin()), size_type());
<a name="l15942"></a>15942         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l15943"></a>15943     }
<a name="l15944"></a>15944 
<a name="l15945"></a>15945     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> value_type&amp; value)
<a name="l15946"></a>15946     {
<a name="l15947"></a>15947         <span class="keyword">typedef</span> b_iterator&lt;iterator, c_iterator&lt;value_type&gt;, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l15948"></a>15948 
<a name="l15949"></a>15949         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data[0][0], value), size_type());
<a name="l15950"></a>15950         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l15951"></a>15951     }
<a name="l15952"></a>15952 
<a name="l15953"></a>15953     LITE_INLINE const_iterator begin()<span class="keyword"> const</span>
<a name="l15954"></a>15954 <span class="keyword">    </span>{
<a name="l15955"></a>15955         <span class="keywordflow">return</span> const_iterator(&amp;m_data[0][0]);
<a name="l15956"></a>15956     }
<a name="l15957"></a>15957 
<a name="l15958"></a>15958     LITE_INLINE iterator begin()
<a name="l15959"></a>15959     {
<a name="l15960"></a>15960         <span class="keywordflow">return</span> iterator(&amp;m_data[0][0]);
<a name="l15961"></a>15961     }
<a name="l15962"></a>15962 
<a name="l15963"></a>15963     LITE_INLINE size_type size()<span class="keyword"> const</span>
<a name="l15964"></a>15964 <span class="keyword">    </span>{
<a name="l15965"></a>15965         <span class="keywordflow">return</span> size_type();
<a name="l15966"></a>15966     }
<a name="l15967"></a>15967 
<a name="l15968"></a>15968     LITE_INLINE const_reference 
<a name="l15969"></a>15969     operator()(<span class="keywordtype">int</span> i0, <span class="keywordtype">int</span> i1)<span class="keyword"> const</span>
<a name="l15970"></a>15970 <span class="keyword">    </span>{
<a name="l15971"></a>15971         <span class="keywordflow">return</span> m_data[i0][i1];
<a name="l15972"></a>15972     }
<a name="l15973"></a>15973 
<a name="l15974"></a>15974     LITE_INLINE reference 
<a name="l15975"></a>15975     operator()(<span class="keywordtype">int</span> i0, <span class="keywordtype">int</span> i1) 
<a name="l15976"></a>15976     {
<a name="l15977"></a>15977         <span class="keywordflow">return</span> m_data[i0][i1];
<a name="l15978"></a>15978     }
<a name="l15979"></a>15979 
<a name="l15980"></a>15980 
<a name="l15981"></a>15981     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_&gt;
<a name="l15982"></a>15982     LITE_INLINE <span class="keyword">const</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::const_array
<a name="l15983"></a>15983     operator[](<span class="keyword">const</span> transform_type_&amp; trans)<span class="keyword"> const</span>
<a name="l15984"></a>15984 <span class="keyword">    </span>{
<a name="l15985"></a>15985         <span class="keyword">typedef</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::const_array result_type;
<a name="l15986"></a>15986 
<a name="l15987"></a>15987         <span class="keywordflow">return</span> result_type(begin(), size(), trans);
<a name="l15988"></a>15988     }
<a name="l15989"></a>15989 
<a name="l15990"></a>15990     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_&gt;
<a name="l15991"></a>15991     LITE_INLINE <span class="keyword">const</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::array
<a name="l15992"></a>15992     operator[](<span class="keyword">const</span> transform_type_&amp; trans)
<a name="l15993"></a>15993     {
<a name="l15994"></a>15994         <span class="keyword">typedef</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::array result_type;
<a name="l15995"></a>15995 
<a name="l15996"></a>15996         <span class="keywordflow">return</span> result_type(begin(), size(), trans);
<a name="l15997"></a>15997     }
<a name="l15998"></a>15998 
<a name="l15999"></a>15999     LITE_INLINE <span class="keyword">const</span> value_type* data()<span class="keyword"> const</span>
<a name="l16000"></a>16000 <span class="keyword">    </span>{
<a name="l16001"></a>16001         <span class="keywordflow">return</span> &amp;m_data[0][0];
<a name="l16002"></a>16002     }
<a name="l16003"></a>16003 
<a name="l16004"></a>16004     LITE_INLINE value_type* data()
<a name="l16005"></a>16005     {
<a name="l16006"></a>16006         <span class="keywordflow">return</span> &amp;m_data[0][0];
<a name="l16007"></a>16007     }
<a name="l16008"></a>16008 
<a name="l16009"></a>16009     LITE_INLINE <span class="keywordtype">void</span> release() 
<a name="l16010"></a>16010     {}
<a name="l16011"></a>16011 
<a name="l16012"></a>16012     LITE_INLINE <span class="keywordtype">void</span> resize(<span class="keywordtype">int</span>, <span class="keywordtype">int</span>)
<a name="l16013"></a>16013     {}
<a name="l16014"></a>16014 
<a name="l16015"></a>16015     LITE_INLINE <span class="keywordtype">void</span> resize(<span class="keyword">const</span> size_type&amp;)
<a name="l16016"></a>16016     {}
<a name="l16017"></a>16017 
<a name="l16018"></a>16018     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l16019"></a>16019     LITE_INLINE <span class="keywordtype">void</span> swap(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l16020"></a>16020     {
<a name="l16021"></a>16021         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l16022"></a>16022             iterator, 
<a name="l16023"></a>16023             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l16024"></a>16024             swapper&lt;value_type&gt; &gt; 
<a name="l16025"></a>16025             iterator_type;
<a name="l16026"></a>16026 
<a name="l16027"></a>16027         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data[0][0], other.begin()), size_type());
<a name="l16028"></a>16028     }
<a name="l16029"></a>16029 
<a name="l16030"></a>16030     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l16031"></a>16031     LITE_INLINE <span class="keywordtype">void</span> swap(array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l16032"></a>16032     {
<a name="l16033"></a>16033         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l16034"></a>16034             iterator, 
<a name="l16035"></a>16035             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::iterator, 
<a name="l16036"></a>16036             swapper&lt;value_type&gt; &gt; 
<a name="l16037"></a>16037             iterator_type;
<a name="l16038"></a>16038 
<a name="l16039"></a>16039         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data[0][0], other.begin()), size_type());
<a name="l16040"></a>16040     }
<a name="l16041"></a>16041 
<a name="l16042"></a>16042 <span class="keyword">private</span>:
<a name="l16043"></a>16043     value_type m_data[n0_][n1_];
<a name="l16044"></a>16044 };
<a name="l16045"></a>16045 
<a name="l16046"></a>16046 <span class="comment">/***********************************************************************************************************/</span>
<a name="l16047"></a>16047 
<a name="l16048"></a>16048 <span class="keyword">template</span>&lt;
<a name="l16049"></a>16049     <span class="keyword">typename</span> value_type_,
<a name="l16050"></a>16050     <span class="keywordtype">int</span> n0_, 
<a name="l16051"></a>16051     <span class="keywordtype">int</span> n1_, 
<a name="l16052"></a>16052     <span class="keywordtype">int</span> n2_, 
<a name="l16053"></a>16053     <span class="keyword">typename</span> traits_type_
<a name="l16054"></a>16054     &gt;
<a name="l16055"></a>16055 <span class="keyword">class </span>array&lt;
<a name="l16056"></a>16056     value_type_[n0_][n1_][n2_],
<a name="l16057"></a>16057     traits_type_,
<a name="l16058"></a>16058     internal_rep&lt;false&gt;
<a name="l16059"></a>16059     &gt;
<a name="l16060"></a>16060 {
<a name="l16061"></a>16061 <span class="keyword">public</span>:
<a name="l16062"></a>16062     <span class="keyword">typedef</span> value_type_ signature[n0_][n1_][n2_];
<a name="l16063"></a>16063     <span class="keyword">typedef</span> traits_type_ traits_type;
<a name="l16064"></a>16064     <span class="keyword">typedef</span> value_type_ value_type;
<a name="l16065"></a>16065     <span class="keyword">typedef</span> <span class="keyword">const</span> value_type_&amp; const_reference;
<a name="l16066"></a>16066     <span class="keyword">typedef</span> value_type_&amp; reference;
<a name="l16067"></a>16067 
<a name="l16068"></a>16068     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;const signature&gt;::default_iterator const_iterator;
<a name="l16069"></a>16069     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;signature&gt;::default_iterator iterator;
<a name="l16070"></a>16070     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;signature&gt;::size_type size_type;
<a name="l16071"></a>16071 
<a name="l16072"></a>16072     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::temporary_array temporary_array;
<a name="l16073"></a>16073     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::fwd_temporary_array fwd_temporary_array;
<a name="l16074"></a>16074     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::rev_temporary_array rev_temporary_array;
<a name="l16075"></a>16075 
<a name="l16076"></a>16076     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_reverse = <span class="keyword">false</span>;
<a name="l16077"></a>16077     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> dimensions = 3;
<a name="l16078"></a>16078 
<a name="l16079"></a>16079     LITE_INLINE array() 
<a name="l16080"></a>16080     {}
<a name="l16081"></a>16081 
<a name="l16082"></a>16082     <span class="keyword">explicit</span> LITE_INLINE array(<span class="keywordtype">int</span>, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>)
<a name="l16083"></a>16083     {}
<a name="l16084"></a>16084 
<a name="l16085"></a>16085     <span class="keyword">explicit</span> LITE_INLINE array(<span class="keyword">const</span> size_type&amp;)
<a name="l16086"></a>16086     {}
<a name="l16087"></a>16087 
<a name="l16088"></a>16088     LITE_INLINE array(<span class="keyword">const</span> array&amp; other) 
<a name="l16089"></a>16089     {
<a name="l16090"></a>16090         <span class="keyword">typedef</span> b_iterator&lt;iterator, const_iterator, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l16091"></a>16091 
<a name="l16092"></a>16092         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(
<a name="l16093"></a>16093             &amp;m_data[0][0][0], 
<a name="l16094"></a>16094             &amp;other.m_data[0][0][0]), 
<a name="l16095"></a>16095             size_type());
<a name="l16096"></a>16096     }
<a name="l16097"></a>16097 
<a name="l16098"></a>16098     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l16099"></a>16099     LITE_INLINE array(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l16100"></a>16100     {
<a name="l16101"></a>16101         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l16102"></a>16102             iterator, 
<a name="l16103"></a>16103             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l16104"></a>16104             assign&lt;value_type&gt; &gt; 
<a name="l16105"></a>16105             iterator_type;
<a name="l16106"></a>16106 
<a name="l16107"></a>16107         LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), <span class="stringliteral">&quot;array(): array sizes do not match&quot;</span>);
<a name="l16108"></a>16108 
<a name="l16109"></a>16109         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data[0][0][0], other.begin()), size_type());
<a name="l16110"></a>16110     }
<a name="l16111"></a>16111 
<a name="l16112"></a>16112     LITE_INLINE array(<span class="keyword">const</span> value_type&amp; value) 
<a name="l16113"></a>16113     {
<a name="l16114"></a>16114         <span class="keyword">typedef</span> b_iterator&lt;iterator, c_iterator&lt;value_type&gt;, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l16115"></a>16115 
<a name="l16116"></a>16116         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data[0][0][0], value), size_type());
<a name="l16117"></a>16117     }
<a name="l16118"></a>16118 
<a name="l16119"></a>16119 
<a name="l16120"></a>16120     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> array&amp; other) 
<a name="l16121"></a>16121     {
<a name="l16122"></a>16122         <span class="keyword">typedef</span> b_iterator&lt;iterator, const_iterator, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l16123"></a>16123 
<a name="l16124"></a>16124         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(
<a name="l16125"></a>16125             &amp;m_data[0][0][0], 
<a name="l16126"></a>16126             &amp;other.m_data[0][0][0]), 
<a name="l16127"></a>16127             size_type());
<a name="l16128"></a>16128         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l16129"></a>16129     }
<a name="l16130"></a>16130 
<a name="l16131"></a>16131     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l16132"></a>16132     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l16133"></a>16133     {
<a name="l16134"></a>16134         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l16135"></a>16135             iterator, 
<a name="l16136"></a>16136             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l16137"></a>16137             assign&lt;value_type&gt; &gt; 
<a name="l16138"></a>16138             iterator_type;
<a name="l16139"></a>16139 
<a name="l16140"></a>16140         LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), <span class="stringliteral">&quot;array(): array sizes do not match&quot;</span>);
<a name="l16141"></a>16141 
<a name="l16142"></a>16142         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data[0][0][0], other.begin()), size_type());
<a name="l16143"></a>16143         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l16144"></a>16144     }
<a name="l16145"></a>16145 
<a name="l16146"></a>16146     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> value_type&amp; value)
<a name="l16147"></a>16147     {
<a name="l16148"></a>16148         <span class="keyword">typedef</span> b_iterator&lt;iterator, c_iterator&lt;value_type&gt;, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l16149"></a>16149 
<a name="l16150"></a>16150         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data[0][0][0], value), size_type());
<a name="l16151"></a>16151         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l16152"></a>16152     }
<a name="l16153"></a>16153 
<a name="l16154"></a>16154     LITE_INLINE const_iterator begin()<span class="keyword"> const</span>
<a name="l16155"></a>16155 <span class="keyword">    </span>{
<a name="l16156"></a>16156         <span class="keywordflow">return</span> const_iterator(&amp;m_data[0][0][0]);
<a name="l16157"></a>16157     }
<a name="l16158"></a>16158 
<a name="l16159"></a>16159     LITE_INLINE iterator begin()
<a name="l16160"></a>16160     {
<a name="l16161"></a>16161         <span class="keywordflow">return</span> iterator(&amp;m_data[0][0][0]);
<a name="l16162"></a>16162     }
<a name="l16163"></a>16163 
<a name="l16164"></a>16164     LITE_INLINE size_type size()<span class="keyword"> const</span>
<a name="l16165"></a>16165 <span class="keyword">    </span>{
<a name="l16166"></a>16166         <span class="keywordflow">return</span> size_type();
<a name="l16167"></a>16167     }
<a name="l16168"></a>16168 
<a name="l16169"></a>16169     LITE_INLINE const_reference 
<a name="l16170"></a>16170     operator()(<span class="keywordtype">int</span> i0, <span class="keywordtype">int</span> i1, <span class="keywordtype">int</span> i2)<span class="keyword"> const</span>
<a name="l16171"></a>16171 <span class="keyword">    </span>{
<a name="l16172"></a>16172         <span class="keywordflow">return</span> m_data[i0][i1][i2];
<a name="l16173"></a>16173     }
<a name="l16174"></a>16174 
<a name="l16175"></a>16175     LITE_INLINE reference 
<a name="l16176"></a>16176     operator()(<span class="keywordtype">int</span> i0, <span class="keywordtype">int</span> i1, <span class="keywordtype">int</span> i2) 
<a name="l16177"></a>16177     {
<a name="l16178"></a>16178         <span class="keywordflow">return</span> m_data[i0][i1][i2];
<a name="l16179"></a>16179     }
<a name="l16180"></a>16180 
<a name="l16181"></a>16181 
<a name="l16182"></a>16182     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_&gt;
<a name="l16183"></a>16183     LITE_INLINE <span class="keyword">const</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::const_array
<a name="l16184"></a>16184     operator[](<span class="keyword">const</span> transform_type_&amp; trans)<span class="keyword"> const</span>
<a name="l16185"></a>16185 <span class="keyword">    </span>{
<a name="l16186"></a>16186         <span class="keyword">typedef</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::const_array result_type;
<a name="l16187"></a>16187 
<a name="l16188"></a>16188         <span class="keywordflow">return</span> result_type(begin(), size(), trans);
<a name="l16189"></a>16189     }
<a name="l16190"></a>16190 
<a name="l16191"></a>16191     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_&gt;
<a name="l16192"></a>16192     LITE_INLINE <span class="keyword">const</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::array
<a name="l16193"></a>16193     operator[](<span class="keyword">const</span> transform_type_&amp; trans)
<a name="l16194"></a>16194     {
<a name="l16195"></a>16195         <span class="keyword">typedef</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::array result_type;
<a name="l16196"></a>16196 
<a name="l16197"></a>16197         <span class="keywordflow">return</span> result_type(begin(), size(), trans);
<a name="l16198"></a>16198     }
<a name="l16199"></a>16199 
<a name="l16200"></a>16200     LITE_INLINE <span class="keyword">const</span> value_type* data()<span class="keyword"> const</span>
<a name="l16201"></a>16201 <span class="keyword">    </span>{
<a name="l16202"></a>16202         <span class="keywordflow">return</span> &amp;m_data[0][0][0];
<a name="l16203"></a>16203     }
<a name="l16204"></a>16204 
<a name="l16205"></a>16205     LITE_INLINE value_type* data()
<a name="l16206"></a>16206     {
<a name="l16207"></a>16207         <span class="keywordflow">return</span> &amp;m_data[0][0][0];
<a name="l16208"></a>16208     }
<a name="l16209"></a>16209 
<a name="l16210"></a>16210     LITE_INLINE <span class="keywordtype">void</span> release() 
<a name="l16211"></a>16211     {}
<a name="l16212"></a>16212 
<a name="l16213"></a>16213     LITE_INLINE <span class="keywordtype">void</span> resize(<span class="keywordtype">int</span>, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>)
<a name="l16214"></a>16214     {}
<a name="l16215"></a>16215 
<a name="l16216"></a>16216     LITE_INLINE <span class="keywordtype">void</span> resize(<span class="keyword">const</span> size_type&amp;)
<a name="l16217"></a>16217     {}
<a name="l16218"></a>16218 
<a name="l16219"></a>16219     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l16220"></a>16220     LITE_INLINE <span class="keywordtype">void</span> swap(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l16221"></a>16221     {
<a name="l16222"></a>16222         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l16223"></a>16223             iterator, 
<a name="l16224"></a>16224             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l16225"></a>16225             swapper&lt;value_type&gt; &gt; 
<a name="l16226"></a>16226             iterator_type;
<a name="l16227"></a>16227 
<a name="l16228"></a>16228         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data[0][0][0], other.begin()), size_type());
<a name="l16229"></a>16229     }
<a name="l16230"></a>16230 
<a name="l16231"></a>16231     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l16232"></a>16232     LITE_INLINE <span class="keywordtype">void</span> swap(array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l16233"></a>16233     {
<a name="l16234"></a>16234         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l16235"></a>16235             iterator, 
<a name="l16236"></a>16236             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::iterator, 
<a name="l16237"></a>16237             swapper&lt;value_type&gt; &gt; 
<a name="l16238"></a>16238             iterator_type;
<a name="l16239"></a>16239 
<a name="l16240"></a>16240         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data[0][0][0], other.begin()), size_type());
<a name="l16241"></a>16241     }
<a name="l16242"></a>16242 
<a name="l16243"></a>16243 <span class="keyword">private</span>:
<a name="l16244"></a>16244     value_type m_data[n0_][n1_][n2_];
<a name="l16245"></a>16245 };
<a name="l16246"></a>16246 
<a name="l16247"></a>16247 <span class="comment">/***********************************************************************************************************/</span>
<a name="l16248"></a>16248 
<a name="l16249"></a>16249 <span class="keyword">template</span>&lt;
<a name="l16250"></a>16250     <span class="keyword">typename</span> value_type_,
<a name="l16251"></a>16251     <span class="keyword">typename</span> traits_type_
<a name="l16252"></a>16252     &gt;
<a name="l16253"></a>16253 <span class="keyword">class </span>array&lt;
<a name="l16254"></a>16254     value_type_,
<a name="l16255"></a>16255     traits_type_,
<a name="l16256"></a>16256     internal_rep&lt;true&gt;
<a name="l16257"></a>16257     &gt;
<a name="l16258"></a>16258 {
<a name="l16259"></a>16259 <span class="keyword">public</span>:
<a name="l16260"></a>16260     <span class="keyword">typedef</span> value_type_ signature;
<a name="l16261"></a>16261     <span class="keyword">typedef</span> traits_type_ traits_type;
<a name="l16262"></a>16262     <span class="keyword">typedef</span> value_type_ value_type;
<a name="l16263"></a>16263     <span class="keyword">typedef</span> <span class="keyword">const</span> value_type_&amp; const_reference;
<a name="l16264"></a>16264     <span class="keyword">typedef</span> value_type_&amp; reference;
<a name="l16265"></a>16265 
<a name="l16266"></a>16266     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;const signature&gt;::default_rev_iterator const_iterator;
<a name="l16267"></a>16267     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;signature&gt;::default_rev_iterator iterator;
<a name="l16268"></a>16268     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;signature&gt;::size_type size_type;
<a name="l16269"></a>16269 
<a name="l16270"></a>16270     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::temporary_array temporary_array;
<a name="l16271"></a>16271     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::fwd_temporary_array fwd_temporary_array;
<a name="l16272"></a>16272     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::rev_temporary_array rev_temporary_array;
<a name="l16273"></a>16273 
<a name="l16274"></a>16274     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_reverse = <span class="keyword">true</span>;
<a name="l16275"></a>16275     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> dimensions = 0;
<a name="l16276"></a>16276 
<a name="l16277"></a>16277     LITE_INLINE array() 
<a name="l16278"></a>16278     {}
<a name="l16279"></a>16279 
<a name="l16280"></a>16280 
<a name="l16281"></a>16281     <span class="keyword">explicit</span> LITE_INLINE array(<span class="keyword">const</span> size_type&amp;)
<a name="l16282"></a>16282     {}
<a name="l16283"></a>16283 
<a name="l16284"></a>16284     LITE_INLINE array(<span class="keyword">const</span> array&amp; other) 
<a name="l16285"></a>16285     {
<a name="l16286"></a>16286         <span class="keyword">typedef</span> b_iterator&lt;iterator, const_iterator, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l16287"></a>16287 
<a name="l16288"></a>16288         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(
<a name="l16289"></a>16289             &amp;m_data, 
<a name="l16290"></a>16290             &amp;other.m_data), 
<a name="l16291"></a>16291             size_type());
<a name="l16292"></a>16292     }
<a name="l16293"></a>16293 
<a name="l16294"></a>16294     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l16295"></a>16295     LITE_INLINE array(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l16296"></a>16296     {
<a name="l16297"></a>16297         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l16298"></a>16298             iterator, 
<a name="l16299"></a>16299             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l16300"></a>16300             assign&lt;value_type&gt; &gt; 
<a name="l16301"></a>16301             iterator_type;
<a name="l16302"></a>16302 
<a name="l16303"></a>16303         LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), <span class="stringliteral">&quot;array(): array sizes do not match&quot;</span>);
<a name="l16304"></a>16304 
<a name="l16305"></a>16305         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data, other.begin()), size_type());
<a name="l16306"></a>16306     }
<a name="l16307"></a>16307 
<a name="l16308"></a>16308     LITE_INLINE array(<span class="keyword">const</span> value_type&amp; value) 
<a name="l16309"></a>16309     {
<a name="l16310"></a>16310         <span class="keyword">typedef</span> b_iterator&lt;iterator, c_iterator&lt;value_type&gt;, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l16311"></a>16311 
<a name="l16312"></a>16312         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data, value), size_type());
<a name="l16313"></a>16313     }
<a name="l16314"></a>16314 
<a name="l16315"></a>16315 
<a name="l16316"></a>16316     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> array&amp; other) 
<a name="l16317"></a>16317     {
<a name="l16318"></a>16318         <span class="keyword">typedef</span> b_iterator&lt;iterator, const_iterator, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l16319"></a>16319 
<a name="l16320"></a>16320         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(
<a name="l16321"></a>16321             &amp;m_data, 
<a name="l16322"></a>16322             &amp;other.m_data), 
<a name="l16323"></a>16323             size_type());
<a name="l16324"></a>16324         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l16325"></a>16325     }
<a name="l16326"></a>16326 
<a name="l16327"></a>16327     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l16328"></a>16328     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l16329"></a>16329     {
<a name="l16330"></a>16330         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l16331"></a>16331             iterator, 
<a name="l16332"></a>16332             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l16333"></a>16333             assign&lt;value_type&gt; &gt; 
<a name="l16334"></a>16334             iterator_type;
<a name="l16335"></a>16335 
<a name="l16336"></a>16336         LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), <span class="stringliteral">&quot;array(): array sizes do not match&quot;</span>);
<a name="l16337"></a>16337 
<a name="l16338"></a>16338         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data, other.begin()), size_type());
<a name="l16339"></a>16339         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l16340"></a>16340     }
<a name="l16341"></a>16341 
<a name="l16342"></a>16342     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> value_type&amp; value)
<a name="l16343"></a>16343     {
<a name="l16344"></a>16344         <span class="keyword">typedef</span> b_iterator&lt;iterator, c_iterator&lt;value_type&gt;, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l16345"></a>16345 
<a name="l16346"></a>16346         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data, value), size_type());
<a name="l16347"></a>16347         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l16348"></a>16348     }
<a name="l16349"></a>16349 
<a name="l16350"></a>16350     LITE_INLINE const_iterator begin()<span class="keyword"> const</span>
<a name="l16351"></a>16351 <span class="keyword">    </span>{
<a name="l16352"></a>16352         <span class="keywordflow">return</span> const_iterator(&amp;m_data);
<a name="l16353"></a>16353     }
<a name="l16354"></a>16354 
<a name="l16355"></a>16355     LITE_INLINE iterator begin()
<a name="l16356"></a>16356     {
<a name="l16357"></a>16357         <span class="keywordflow">return</span> iterator(&amp;m_data);
<a name="l16358"></a>16358     }
<a name="l16359"></a>16359 
<a name="l16360"></a>16360     LITE_INLINE size_type size()<span class="keyword"> const</span>
<a name="l16361"></a>16361 <span class="keyword">    </span>{
<a name="l16362"></a>16362         <span class="keywordflow">return</span> size_type();
<a name="l16363"></a>16363     }
<a name="l16364"></a>16364 
<a name="l16365"></a>16365     LITE_INLINE const_reference 
<a name="l16366"></a>16366     operator()()<span class="keyword"> const</span>
<a name="l16367"></a>16367 <span class="keyword">    </span>{
<a name="l16368"></a>16368         <span class="keywordflow">return</span> m_data; 
<a name="l16369"></a>16369     }
<a name="l16370"></a>16370 
<a name="l16371"></a>16371     LITE_INLINE reference 
<a name="l16372"></a>16372     operator()() 
<a name="l16373"></a>16373     {
<a name="l16374"></a>16374         <span class="keywordflow">return</span> m_data;
<a name="l16375"></a>16375     }
<a name="l16376"></a>16376 
<a name="l16377"></a>16377 
<a name="l16378"></a>16378     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_&gt;
<a name="l16379"></a>16379     LITE_INLINE <span class="keyword">const</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::const_array
<a name="l16380"></a>16380     operator[](<span class="keyword">const</span> transform_type_&amp; trans)<span class="keyword"> const</span>
<a name="l16381"></a>16381 <span class="keyword">    </span>{
<a name="l16382"></a>16382         <span class="keyword">typedef</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::const_array result_type;
<a name="l16383"></a>16383 
<a name="l16384"></a>16384         <span class="keywordflow">return</span> result_type(begin(), size(), trans);
<a name="l16385"></a>16385     }
<a name="l16386"></a>16386 
<a name="l16387"></a>16387     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_&gt;
<a name="l16388"></a>16388     LITE_INLINE <span class="keyword">const</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::array
<a name="l16389"></a>16389     operator[](<span class="keyword">const</span> transform_type_&amp; trans)
<a name="l16390"></a>16390     {
<a name="l16391"></a>16391         <span class="keyword">typedef</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::array result_type;
<a name="l16392"></a>16392 
<a name="l16393"></a>16393         <span class="keywordflow">return</span> result_type(begin(), size(), trans);
<a name="l16394"></a>16394     }
<a name="l16395"></a>16395 
<a name="l16396"></a>16396     LITE_INLINE <span class="keyword">const</span> value_type* data()<span class="keyword"> const</span>
<a name="l16397"></a>16397 <span class="keyword">    </span>{
<a name="l16398"></a>16398         <span class="keywordflow">return</span> &amp;m_data;
<a name="l16399"></a>16399     }
<a name="l16400"></a>16400 
<a name="l16401"></a>16401     LITE_INLINE value_type* data()
<a name="l16402"></a>16402     {
<a name="l16403"></a>16403         <span class="keywordflow">return</span> &amp;m_data;
<a name="l16404"></a>16404     }
<a name="l16405"></a>16405 
<a name="l16406"></a>16406     LITE_INLINE <span class="keywordtype">void</span> release() 
<a name="l16407"></a>16407     {}
<a name="l16408"></a>16408 
<a name="l16409"></a>16409     LITE_INLINE <span class="keywordtype">void</span> resize()
<a name="l16410"></a>16410     {}
<a name="l16411"></a>16411 
<a name="l16412"></a>16412     LITE_INLINE <span class="keywordtype">void</span> resize(<span class="keyword">const</span> size_type&amp;)
<a name="l16413"></a>16413     {}
<a name="l16414"></a>16414 
<a name="l16415"></a>16415     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l16416"></a>16416     LITE_INLINE <span class="keywordtype">void</span> swap(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l16417"></a>16417     {
<a name="l16418"></a>16418         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l16419"></a>16419             iterator, 
<a name="l16420"></a>16420             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l16421"></a>16421             swapper&lt;value_type&gt; &gt; 
<a name="l16422"></a>16422             iterator_type;
<a name="l16423"></a>16423 
<a name="l16424"></a>16424         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data, other.begin()), size_type());
<a name="l16425"></a>16425     }
<a name="l16426"></a>16426 
<a name="l16427"></a>16427     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l16428"></a>16428     LITE_INLINE <span class="keywordtype">void</span> swap(array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l16429"></a>16429     {
<a name="l16430"></a>16430         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l16431"></a>16431             iterator, 
<a name="l16432"></a>16432             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::iterator, 
<a name="l16433"></a>16433             swapper&lt;value_type&gt; &gt; 
<a name="l16434"></a>16434             iterator_type;
<a name="l16435"></a>16435 
<a name="l16436"></a>16436         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data, other.begin()), size_type());
<a name="l16437"></a>16437     }
<a name="l16438"></a>16438 
<a name="l16439"></a>16439 <span class="keyword">private</span>:
<a name="l16440"></a>16440     value_type m_data;
<a name="l16441"></a>16441 };
<a name="l16442"></a>16442 
<a name="l16443"></a>16443 <span class="comment">/***********************************************************************************************************/</span>
<a name="l16444"></a>16444 
<a name="l16445"></a>16445 <span class="keyword">template</span>&lt;
<a name="l16446"></a>16446     <span class="keyword">typename</span> value_type_,
<a name="l16447"></a>16447     <span class="keywordtype">int</span> n0_, 
<a name="l16448"></a>16448     <span class="keyword">typename</span> traits_type_
<a name="l16449"></a>16449     &gt;
<a name="l16450"></a>16450 <span class="keyword">class </span>array&lt;
<a name="l16451"></a>16451     value_type_[n0_],
<a name="l16452"></a>16452     traits_type_,
<a name="l16453"></a>16453     internal_rep&lt;true&gt;
<a name="l16454"></a>16454     &gt;
<a name="l16455"></a>16455 {
<a name="l16456"></a>16456 <span class="keyword">public</span>:
<a name="l16457"></a>16457     <span class="keyword">typedef</span> value_type_ signature[n0_];
<a name="l16458"></a>16458     <span class="keyword">typedef</span> traits_type_ traits_type;
<a name="l16459"></a>16459     <span class="keyword">typedef</span> value_type_ value_type;
<a name="l16460"></a>16460     <span class="keyword">typedef</span> <span class="keyword">const</span> value_type_&amp; const_reference;
<a name="l16461"></a>16461     <span class="keyword">typedef</span> value_type_&amp; reference;
<a name="l16462"></a>16462 
<a name="l16463"></a>16463     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;const signature&gt;::default_rev_iterator const_iterator;
<a name="l16464"></a>16464     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;signature&gt;::default_rev_iterator iterator;
<a name="l16465"></a>16465     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;signature&gt;::size_type size_type;
<a name="l16466"></a>16466 
<a name="l16467"></a>16467     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::temporary_array temporary_array;
<a name="l16468"></a>16468     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::fwd_temporary_array fwd_temporary_array;
<a name="l16469"></a>16469     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::rev_temporary_array rev_temporary_array;
<a name="l16470"></a>16470 
<a name="l16471"></a>16471     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_reverse = <span class="keyword">true</span>;
<a name="l16472"></a>16472     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> dimensions = 1;
<a name="l16473"></a>16473 
<a name="l16474"></a>16474     LITE_INLINE array() 
<a name="l16475"></a>16475     {}
<a name="l16476"></a>16476 
<a name="l16477"></a>16477     <span class="keyword">explicit</span> LITE_INLINE array(<span class="keywordtype">int</span>)
<a name="l16478"></a>16478     {}
<a name="l16479"></a>16479 
<a name="l16480"></a>16480     <span class="keyword">explicit</span> LITE_INLINE array(<span class="keyword">const</span> size_type&amp;)
<a name="l16481"></a>16481     {}
<a name="l16482"></a>16482 
<a name="l16483"></a>16483     LITE_INLINE array(<span class="keyword">const</span> array&amp; other) 
<a name="l16484"></a>16484     {
<a name="l16485"></a>16485         <span class="keyword">typedef</span> b_iterator&lt;iterator, const_iterator, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l16486"></a>16486 
<a name="l16487"></a>16487         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(
<a name="l16488"></a>16488             &amp;m_data[0], 
<a name="l16489"></a>16489             &amp;other.m_data[0]), 
<a name="l16490"></a>16490             size_type());
<a name="l16491"></a>16491     }
<a name="l16492"></a>16492 
<a name="l16493"></a>16493     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l16494"></a>16494     LITE_INLINE array(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l16495"></a>16495     {
<a name="l16496"></a>16496         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l16497"></a>16497             iterator, 
<a name="l16498"></a>16498             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l16499"></a>16499             assign&lt;value_type&gt; &gt; 
<a name="l16500"></a>16500             iterator_type;
<a name="l16501"></a>16501 
<a name="l16502"></a>16502         LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), <span class="stringliteral">&quot;array(): array sizes do not match&quot;</span>);
<a name="l16503"></a>16503 
<a name="l16504"></a>16504         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data[0], other.begin()), size_type());
<a name="l16505"></a>16505     }
<a name="l16506"></a>16506 
<a name="l16507"></a>16507     LITE_INLINE array(<span class="keyword">const</span> value_type&amp; value) 
<a name="l16508"></a>16508     {
<a name="l16509"></a>16509         <span class="keyword">typedef</span> b_iterator&lt;iterator, c_iterator&lt;value_type&gt;, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l16510"></a>16510 
<a name="l16511"></a>16511         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data[0], value), size_type());
<a name="l16512"></a>16512     }
<a name="l16513"></a>16513 
<a name="l16514"></a>16514 
<a name="l16515"></a>16515     LITE_INLINE array(
<a name="l16516"></a>16516         <span class="keyword">typename</span> detail::type_if&lt;n0_==2, const value_type&amp;, detail::invalid_argument&gt;::type a0,
<a name="l16517"></a>16517         <span class="keyword">const</span> value_type&amp; a1 
<a name="l16518"></a>16518         )
<a name="l16519"></a>16519     {
<a name="l16520"></a>16520         m_data[0] = a0;
<a name="l16521"></a>16521         m_data[1] = a1;
<a name="l16522"></a>16522     }
<a name="l16523"></a>16523 
<a name="l16524"></a>16524     LITE_INLINE array(
<a name="l16525"></a>16525         <span class="keyword">typename</span> detail::type_if&lt;n0_==3, const value_type&amp;, detail::invalid_argument&gt;::type a0,
<a name="l16526"></a>16526         <span class="keyword">const</span> value_type&amp; a1, 
<a name="l16527"></a>16527         <span class="keyword">const</span> value_type&amp; a2 
<a name="l16528"></a>16528         )
<a name="l16529"></a>16529     {
<a name="l16530"></a>16530         m_data[0] = a0;
<a name="l16531"></a>16531         m_data[1] = a1;
<a name="l16532"></a>16532         m_data[2] = a2;
<a name="l16533"></a>16533     }
<a name="l16534"></a>16534 
<a name="l16535"></a>16535     LITE_INLINE array(
<a name="l16536"></a>16536         <span class="keyword">typename</span> detail::type_if&lt;n0_==4, const value_type&amp;, detail::invalid_argument&gt;::type a0,
<a name="l16537"></a>16537         <span class="keyword">const</span> value_type&amp; a1, 
<a name="l16538"></a>16538         <span class="keyword">const</span> value_type&amp; a2, 
<a name="l16539"></a>16539         <span class="keyword">const</span> value_type&amp; a3 
<a name="l16540"></a>16540         )
<a name="l16541"></a>16541     {
<a name="l16542"></a>16542         m_data[0] = a0;
<a name="l16543"></a>16543         m_data[1] = a1;
<a name="l16544"></a>16544         m_data[2] = a2;
<a name="l16545"></a>16545         m_data[3] = a3;
<a name="l16546"></a>16546     }
<a name="l16547"></a>16547 
<a name="l16548"></a>16548     LITE_INLINE array(
<a name="l16549"></a>16549         <span class="keyword">typename</span> detail::type_if&lt;n0_==5, const value_type&amp;, detail::invalid_argument&gt;::type a0,
<a name="l16550"></a>16550         <span class="keyword">const</span> value_type&amp; a1, 
<a name="l16551"></a>16551         <span class="keyword">const</span> value_type&amp; a2, 
<a name="l16552"></a>16552         <span class="keyword">const</span> value_type&amp; a3, 
<a name="l16553"></a>16553         <span class="keyword">const</span> value_type&amp; a4 
<a name="l16554"></a>16554         )
<a name="l16555"></a>16555     {
<a name="l16556"></a>16556         m_data[0] = a0;
<a name="l16557"></a>16557         m_data[1] = a1;
<a name="l16558"></a>16558         m_data[2] = a2;
<a name="l16559"></a>16559         m_data[3] = a3;
<a name="l16560"></a>16560         m_data[4] = a4;
<a name="l16561"></a>16561     }
<a name="l16562"></a>16562 
<a name="l16563"></a>16563     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> array&amp; other) 
<a name="l16564"></a>16564     {
<a name="l16565"></a>16565         <span class="keyword">typedef</span> b_iterator&lt;iterator, const_iterator, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l16566"></a>16566 
<a name="l16567"></a>16567         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(
<a name="l16568"></a>16568             &amp;m_data[0], 
<a name="l16569"></a>16569             &amp;other.m_data[0]), 
<a name="l16570"></a>16570             size_type());
<a name="l16571"></a>16571         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l16572"></a>16572     }
<a name="l16573"></a>16573 
<a name="l16574"></a>16574     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l16575"></a>16575     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l16576"></a>16576     {
<a name="l16577"></a>16577         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l16578"></a>16578             iterator, 
<a name="l16579"></a>16579             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l16580"></a>16580             assign&lt;value_type&gt; &gt; 
<a name="l16581"></a>16581             iterator_type;
<a name="l16582"></a>16582 
<a name="l16583"></a>16583         LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), <span class="stringliteral">&quot;array(): array sizes do not match&quot;</span>);
<a name="l16584"></a>16584 
<a name="l16585"></a>16585         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data[0], other.begin()), size_type());
<a name="l16586"></a>16586         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l16587"></a>16587     }
<a name="l16588"></a>16588 
<a name="l16589"></a>16589     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> value_type&amp; value)
<a name="l16590"></a>16590     {
<a name="l16591"></a>16591         <span class="keyword">typedef</span> b_iterator&lt;iterator, c_iterator&lt;value_type&gt;, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l16592"></a>16592 
<a name="l16593"></a>16593         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data[0], value), size_type());
<a name="l16594"></a>16594         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l16595"></a>16595     }
<a name="l16596"></a>16596 
<a name="l16597"></a>16597     LITE_INLINE const_iterator begin()<span class="keyword"> const</span>
<a name="l16598"></a>16598 <span class="keyword">    </span>{
<a name="l16599"></a>16599         <span class="keywordflow">return</span> const_iterator(&amp;m_data[0]);
<a name="l16600"></a>16600     }
<a name="l16601"></a>16601 
<a name="l16602"></a>16602     LITE_INLINE iterator begin()
<a name="l16603"></a>16603     {
<a name="l16604"></a>16604         <span class="keywordflow">return</span> iterator(&amp;m_data[0]);
<a name="l16605"></a>16605     }
<a name="l16606"></a>16606 
<a name="l16607"></a>16607     LITE_INLINE size_type size()<span class="keyword"> const</span>
<a name="l16608"></a>16608 <span class="keyword">    </span>{
<a name="l16609"></a>16609         <span class="keywordflow">return</span> size_type();
<a name="l16610"></a>16610     }
<a name="l16611"></a>16611 
<a name="l16612"></a>16612     LITE_INLINE const_reference 
<a name="l16613"></a>16613     operator()(<span class="keywordtype">int</span> i0)<span class="keyword"> const</span>
<a name="l16614"></a>16614 <span class="keyword">    </span>{
<a name="l16615"></a>16615         <span class="keywordflow">return</span> m_data[i0]; 
<a name="l16616"></a>16616     }
<a name="l16617"></a>16617 
<a name="l16618"></a>16618     LITE_INLINE reference 
<a name="l16619"></a>16619     operator()(<span class="keywordtype">int</span> i0) 
<a name="l16620"></a>16620     {
<a name="l16621"></a>16621         <span class="keywordflow">return</span> m_data[i0];
<a name="l16622"></a>16622     }
<a name="l16623"></a>16623 
<a name="l16624"></a>16624     LITE_INLINE const_reference 
<a name="l16625"></a>16625     operator[](<span class="keywordtype">int</span> i0)<span class="keyword"> const</span>
<a name="l16626"></a>16626 <span class="keyword">    </span>{
<a name="l16627"></a>16627         <span class="keywordflow">return</span> m_data[i0];
<a name="l16628"></a>16628     }
<a name="l16629"></a>16629 
<a name="l16630"></a>16630     LITE_INLINE reference 
<a name="l16631"></a>16631     operator[](<span class="keywordtype">int</span> i0)
<a name="l16632"></a>16632     {
<a name="l16633"></a>16633         <span class="keywordflow">return</span> m_data[i0];
<a name="l16634"></a>16634     }
<a name="l16635"></a>16635 
<a name="l16636"></a>16636 
<a name="l16637"></a>16637     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_&gt;
<a name="l16638"></a>16638     LITE_INLINE <span class="keyword">const</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::const_array
<a name="l16639"></a>16639     operator[](<span class="keyword">const</span> transform_type_&amp; trans)<span class="keyword"> const</span>
<a name="l16640"></a>16640 <span class="keyword">    </span>{
<a name="l16641"></a>16641         <span class="keyword">typedef</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::const_array result_type;
<a name="l16642"></a>16642 
<a name="l16643"></a>16643         <span class="keywordflow">return</span> result_type(begin(), size(), trans);
<a name="l16644"></a>16644     }
<a name="l16645"></a>16645 
<a name="l16646"></a>16646     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_&gt;
<a name="l16647"></a>16647     LITE_INLINE <span class="keyword">const</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::array
<a name="l16648"></a>16648     operator[](<span class="keyword">const</span> transform_type_&amp; trans)
<a name="l16649"></a>16649     {
<a name="l16650"></a>16650         <span class="keyword">typedef</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::array result_type;
<a name="l16651"></a>16651 
<a name="l16652"></a>16652         <span class="keywordflow">return</span> result_type(begin(), size(), trans);
<a name="l16653"></a>16653     }
<a name="l16654"></a>16654 
<a name="l16655"></a>16655     LITE_INLINE <span class="keyword">const</span> value_type* data()<span class="keyword"> const</span>
<a name="l16656"></a>16656 <span class="keyword">    </span>{
<a name="l16657"></a>16657         <span class="keywordflow">return</span> &amp;m_data[0];
<a name="l16658"></a>16658     }
<a name="l16659"></a>16659 
<a name="l16660"></a>16660     LITE_INLINE value_type* data()
<a name="l16661"></a>16661     {
<a name="l16662"></a>16662         <span class="keywordflow">return</span> &amp;m_data[0];
<a name="l16663"></a>16663     }
<a name="l16664"></a>16664 
<a name="l16665"></a>16665     LITE_INLINE <span class="keywordtype">void</span> release() 
<a name="l16666"></a>16666     {}
<a name="l16667"></a>16667 
<a name="l16668"></a>16668     LITE_INLINE <span class="keywordtype">void</span> resize(<span class="keywordtype">int</span>)
<a name="l16669"></a>16669     {}
<a name="l16670"></a>16670 
<a name="l16671"></a>16671     LITE_INLINE <span class="keywordtype">void</span> resize(<span class="keyword">const</span> size_type&amp;)
<a name="l16672"></a>16672     {}
<a name="l16673"></a>16673 
<a name="l16674"></a>16674     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l16675"></a>16675     LITE_INLINE <span class="keywordtype">void</span> swap(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l16676"></a>16676     {
<a name="l16677"></a>16677         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l16678"></a>16678             iterator, 
<a name="l16679"></a>16679             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l16680"></a>16680             swapper&lt;value_type&gt; &gt; 
<a name="l16681"></a>16681             iterator_type;
<a name="l16682"></a>16682 
<a name="l16683"></a>16683         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data[0], other.begin()), size_type());
<a name="l16684"></a>16684     }
<a name="l16685"></a>16685 
<a name="l16686"></a>16686     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l16687"></a>16687     LITE_INLINE <span class="keywordtype">void</span> swap(array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l16688"></a>16688     {
<a name="l16689"></a>16689         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l16690"></a>16690             iterator, 
<a name="l16691"></a>16691             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::iterator, 
<a name="l16692"></a>16692             swapper&lt;value_type&gt; &gt; 
<a name="l16693"></a>16693             iterator_type;
<a name="l16694"></a>16694 
<a name="l16695"></a>16695         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data[0], other.begin()), size_type());
<a name="l16696"></a>16696     }
<a name="l16697"></a>16697 
<a name="l16698"></a>16698 <span class="keyword">private</span>:
<a name="l16699"></a>16699     value_type m_data[n0_];
<a name="l16700"></a>16700 };
<a name="l16701"></a>16701 
<a name="l16702"></a>16702 <span class="comment">/***********************************************************************************************************/</span>
<a name="l16703"></a>16703 
<a name="l16704"></a>16704 <span class="keyword">template</span>&lt;
<a name="l16705"></a>16705     <span class="keyword">typename</span> value_type_,
<a name="l16706"></a>16706     <span class="keywordtype">int</span> n0_, 
<a name="l16707"></a>16707     <span class="keywordtype">int</span> n1_, 
<a name="l16708"></a>16708     <span class="keyword">typename</span> traits_type_
<a name="l16709"></a>16709     &gt;
<a name="l16710"></a>16710 <span class="keyword">class </span>array&lt;
<a name="l16711"></a>16711     value_type_[n0_][n1_],
<a name="l16712"></a>16712     traits_type_,
<a name="l16713"></a>16713     internal_rep&lt;true&gt;
<a name="l16714"></a>16714     &gt;
<a name="l16715"></a>16715 {
<a name="l16716"></a>16716 <span class="keyword">public</span>:
<a name="l16717"></a>16717     <span class="keyword">typedef</span> value_type_ signature[n0_][n1_];
<a name="l16718"></a>16718     <span class="keyword">typedef</span> traits_type_ traits_type;
<a name="l16719"></a>16719     <span class="keyword">typedef</span> value_type_ value_type;
<a name="l16720"></a>16720     <span class="keyword">typedef</span> <span class="keyword">const</span> value_type_&amp; const_reference;
<a name="l16721"></a>16721     <span class="keyword">typedef</span> value_type_&amp; reference;
<a name="l16722"></a>16722 
<a name="l16723"></a>16723     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;const signature&gt;::default_rev_iterator const_iterator;
<a name="l16724"></a>16724     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;signature&gt;::default_rev_iterator iterator;
<a name="l16725"></a>16725     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;signature&gt;::size_type size_type;
<a name="l16726"></a>16726 
<a name="l16727"></a>16727     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::temporary_array temporary_array;
<a name="l16728"></a>16728     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::fwd_temporary_array fwd_temporary_array;
<a name="l16729"></a>16729     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::rev_temporary_array rev_temporary_array;
<a name="l16730"></a>16730 
<a name="l16731"></a>16731     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_reverse = <span class="keyword">true</span>;
<a name="l16732"></a>16732     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> dimensions = 2;
<a name="l16733"></a>16733 
<a name="l16734"></a>16734     LITE_INLINE array() 
<a name="l16735"></a>16735     {}
<a name="l16736"></a>16736 
<a name="l16737"></a>16737     <span class="keyword">explicit</span> LITE_INLINE array(<span class="keywordtype">int</span>, <span class="keywordtype">int</span>)
<a name="l16738"></a>16738     {}
<a name="l16739"></a>16739 
<a name="l16740"></a>16740     <span class="keyword">explicit</span> LITE_INLINE array(<span class="keyword">const</span> size_type&amp;)
<a name="l16741"></a>16741     {}
<a name="l16742"></a>16742 
<a name="l16743"></a>16743     LITE_INLINE array(<span class="keyword">const</span> array&amp; other) 
<a name="l16744"></a>16744     {
<a name="l16745"></a>16745         <span class="keyword">typedef</span> b_iterator&lt;iterator, const_iterator, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l16746"></a>16746 
<a name="l16747"></a>16747         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(
<a name="l16748"></a>16748             &amp;m_data[0][0], 
<a name="l16749"></a>16749             &amp;other.m_data[0][0]), 
<a name="l16750"></a>16750             size_type());
<a name="l16751"></a>16751     }
<a name="l16752"></a>16752 
<a name="l16753"></a>16753     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l16754"></a>16754     LITE_INLINE array(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l16755"></a>16755     {
<a name="l16756"></a>16756         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l16757"></a>16757             iterator, 
<a name="l16758"></a>16758             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l16759"></a>16759             assign&lt;value_type&gt; &gt; 
<a name="l16760"></a>16760             iterator_type;
<a name="l16761"></a>16761 
<a name="l16762"></a>16762         LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), <span class="stringliteral">&quot;array(): array sizes do not match&quot;</span>);
<a name="l16763"></a>16763 
<a name="l16764"></a>16764         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data[0][0], other.begin()), size_type());
<a name="l16765"></a>16765     }
<a name="l16766"></a>16766 
<a name="l16767"></a>16767     LITE_INLINE array(<span class="keyword">const</span> value_type&amp; value) 
<a name="l16768"></a>16768     {
<a name="l16769"></a>16769         <span class="keyword">typedef</span> b_iterator&lt;iterator, c_iterator&lt;value_type&gt;, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l16770"></a>16770 
<a name="l16771"></a>16771         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data[0][0], value), size_type());
<a name="l16772"></a>16772     }
<a name="l16773"></a>16773 
<a name="l16774"></a>16774 
<a name="l16775"></a>16775     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> array&amp; other) 
<a name="l16776"></a>16776     {
<a name="l16777"></a>16777         <span class="keyword">typedef</span> b_iterator&lt;iterator, const_iterator, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l16778"></a>16778 
<a name="l16779"></a>16779         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(
<a name="l16780"></a>16780             &amp;m_data[0][0], 
<a name="l16781"></a>16781             &amp;other.m_data[0][0]), 
<a name="l16782"></a>16782             size_type());
<a name="l16783"></a>16783         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l16784"></a>16784     }
<a name="l16785"></a>16785 
<a name="l16786"></a>16786     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l16787"></a>16787     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l16788"></a>16788     {
<a name="l16789"></a>16789         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l16790"></a>16790             iterator, 
<a name="l16791"></a>16791             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l16792"></a>16792             assign&lt;value_type&gt; &gt; 
<a name="l16793"></a>16793             iterator_type;
<a name="l16794"></a>16794 
<a name="l16795"></a>16795         LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), <span class="stringliteral">&quot;array(): array sizes do not match&quot;</span>);
<a name="l16796"></a>16796 
<a name="l16797"></a>16797         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data[0][0], other.begin()), size_type());
<a name="l16798"></a>16798         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l16799"></a>16799     }
<a name="l16800"></a>16800 
<a name="l16801"></a>16801     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> value_type&amp; value)
<a name="l16802"></a>16802     {
<a name="l16803"></a>16803         <span class="keyword">typedef</span> b_iterator&lt;iterator, c_iterator&lt;value_type&gt;, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l16804"></a>16804 
<a name="l16805"></a>16805         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data[0][0], value), size_type());
<a name="l16806"></a>16806         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l16807"></a>16807     }
<a name="l16808"></a>16808 
<a name="l16809"></a>16809     LITE_INLINE const_iterator begin()<span class="keyword"> const</span>
<a name="l16810"></a>16810 <span class="keyword">    </span>{
<a name="l16811"></a>16811         <span class="keywordflow">return</span> const_iterator(&amp;m_data[0][0]);
<a name="l16812"></a>16812     }
<a name="l16813"></a>16813 
<a name="l16814"></a>16814     LITE_INLINE iterator begin()
<a name="l16815"></a>16815     {
<a name="l16816"></a>16816         <span class="keywordflow">return</span> iterator(&amp;m_data[0][0]);
<a name="l16817"></a>16817     }
<a name="l16818"></a>16818 
<a name="l16819"></a>16819     LITE_INLINE size_type size()<span class="keyword"> const</span>
<a name="l16820"></a>16820 <span class="keyword">    </span>{
<a name="l16821"></a>16821         <span class="keywordflow">return</span> size_type();
<a name="l16822"></a>16822     }
<a name="l16823"></a>16823 
<a name="l16824"></a>16824     LITE_INLINE const_reference 
<a name="l16825"></a>16825     operator()(<span class="keywordtype">int</span> i0, <span class="keywordtype">int</span> i1)<span class="keyword"> const</span>
<a name="l16826"></a>16826 <span class="keyword">    </span>{
<a name="l16827"></a>16827         <span class="keywordflow">return</span> m_data[i1][i0]; 
<a name="l16828"></a>16828     }
<a name="l16829"></a>16829 
<a name="l16830"></a>16830     LITE_INLINE reference 
<a name="l16831"></a>16831     operator()(<span class="keywordtype">int</span> i0, <span class="keywordtype">int</span> i1) 
<a name="l16832"></a>16832     {
<a name="l16833"></a>16833         <span class="keywordflow">return</span> m_data[i1][i0];
<a name="l16834"></a>16834     }
<a name="l16835"></a>16835 
<a name="l16836"></a>16836 
<a name="l16837"></a>16837     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_&gt;
<a name="l16838"></a>16838     LITE_INLINE <span class="keyword">const</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::const_array
<a name="l16839"></a>16839     operator[](<span class="keyword">const</span> transform_type_&amp; trans)<span class="keyword"> const</span>
<a name="l16840"></a>16840 <span class="keyword">    </span>{
<a name="l16841"></a>16841         <span class="keyword">typedef</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::const_array result_type;
<a name="l16842"></a>16842 
<a name="l16843"></a>16843         <span class="keywordflow">return</span> result_type(begin(), size(), trans);
<a name="l16844"></a>16844     }
<a name="l16845"></a>16845 
<a name="l16846"></a>16846     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_&gt;
<a name="l16847"></a>16847     LITE_INLINE <span class="keyword">const</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::array
<a name="l16848"></a>16848     operator[](<span class="keyword">const</span> transform_type_&amp; trans)
<a name="l16849"></a>16849     {
<a name="l16850"></a>16850         <span class="keyword">typedef</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::array result_type;
<a name="l16851"></a>16851 
<a name="l16852"></a>16852         <span class="keywordflow">return</span> result_type(begin(), size(), trans);
<a name="l16853"></a>16853     }
<a name="l16854"></a>16854 
<a name="l16855"></a>16855     LITE_INLINE <span class="keyword">const</span> value_type* data()<span class="keyword"> const</span>
<a name="l16856"></a>16856 <span class="keyword">    </span>{
<a name="l16857"></a>16857         <span class="keywordflow">return</span> &amp;m_data[0][0];
<a name="l16858"></a>16858     }
<a name="l16859"></a>16859 
<a name="l16860"></a>16860     LITE_INLINE value_type* data()
<a name="l16861"></a>16861     {
<a name="l16862"></a>16862         <span class="keywordflow">return</span> &amp;m_data[0][0];
<a name="l16863"></a>16863     }
<a name="l16864"></a>16864 
<a name="l16865"></a>16865     LITE_INLINE <span class="keywordtype">void</span> release() 
<a name="l16866"></a>16866     {}
<a name="l16867"></a>16867 
<a name="l16868"></a>16868     LITE_INLINE <span class="keywordtype">void</span> resize(<span class="keywordtype">int</span>, <span class="keywordtype">int</span>)
<a name="l16869"></a>16869     {}
<a name="l16870"></a>16870 
<a name="l16871"></a>16871     LITE_INLINE <span class="keywordtype">void</span> resize(<span class="keyword">const</span> size_type&amp;)
<a name="l16872"></a>16872     {}
<a name="l16873"></a>16873 
<a name="l16874"></a>16874     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l16875"></a>16875     LITE_INLINE <span class="keywordtype">void</span> swap(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l16876"></a>16876     {
<a name="l16877"></a>16877         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l16878"></a>16878             iterator, 
<a name="l16879"></a>16879             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l16880"></a>16880             swapper&lt;value_type&gt; &gt; 
<a name="l16881"></a>16881             iterator_type;
<a name="l16882"></a>16882 
<a name="l16883"></a>16883         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data[0][0], other.begin()), size_type());
<a name="l16884"></a>16884     }
<a name="l16885"></a>16885 
<a name="l16886"></a>16886     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l16887"></a>16887     LITE_INLINE <span class="keywordtype">void</span> swap(array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l16888"></a>16888     {
<a name="l16889"></a>16889         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l16890"></a>16890             iterator, 
<a name="l16891"></a>16891             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::iterator, 
<a name="l16892"></a>16892             swapper&lt;value_type&gt; &gt; 
<a name="l16893"></a>16893             iterator_type;
<a name="l16894"></a>16894 
<a name="l16895"></a>16895         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data[0][0], other.begin()), size_type());
<a name="l16896"></a>16896     }
<a name="l16897"></a>16897 
<a name="l16898"></a>16898 <span class="keyword">private</span>:
<a name="l16899"></a>16899     value_type m_data[n1_][n0_];
<a name="l16900"></a>16900 };
<a name="l16901"></a>16901 
<a name="l16902"></a>16902 <span class="comment">/***********************************************************************************************************/</span>
<a name="l16903"></a>16903 
<a name="l16904"></a>16904 <span class="keyword">template</span>&lt;
<a name="l16905"></a>16905     <span class="keyword">typename</span> value_type_,
<a name="l16906"></a>16906     <span class="keywordtype">int</span> n0_, 
<a name="l16907"></a>16907     <span class="keywordtype">int</span> n1_, 
<a name="l16908"></a>16908     <span class="keywordtype">int</span> n2_, 
<a name="l16909"></a>16909     <span class="keyword">typename</span> traits_type_
<a name="l16910"></a>16910     &gt;
<a name="l16911"></a>16911 <span class="keyword">class </span>array&lt;
<a name="l16912"></a>16912     value_type_[n0_][n1_][n2_],
<a name="l16913"></a>16913     traits_type_,
<a name="l16914"></a>16914     internal_rep&lt;true&gt;
<a name="l16915"></a>16915     &gt;
<a name="l16916"></a>16916 {
<a name="l16917"></a>16917 <span class="keyword">public</span>:
<a name="l16918"></a>16918     <span class="keyword">typedef</span> value_type_ signature[n0_][n1_][n2_];
<a name="l16919"></a>16919     <span class="keyword">typedef</span> traits_type_ traits_type;
<a name="l16920"></a>16920     <span class="keyword">typedef</span> value_type_ value_type;
<a name="l16921"></a>16921     <span class="keyword">typedef</span> <span class="keyword">const</span> value_type_&amp; const_reference;
<a name="l16922"></a>16922     <span class="keyword">typedef</span> value_type_&amp; reference;
<a name="l16923"></a>16923 
<a name="l16924"></a>16924     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;const signature&gt;::default_rev_iterator const_iterator;
<a name="l16925"></a>16925     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;signature&gt;::default_rev_iterator iterator;
<a name="l16926"></a>16926     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;signature&gt;::size_type size_type;
<a name="l16927"></a>16927 
<a name="l16928"></a>16928     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::temporary_array temporary_array;
<a name="l16929"></a>16929     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::fwd_temporary_array fwd_temporary_array;
<a name="l16930"></a>16930     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::rev_temporary_array rev_temporary_array;
<a name="l16931"></a>16931 
<a name="l16932"></a>16932     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_reverse = <span class="keyword">true</span>;
<a name="l16933"></a>16933     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> dimensions = 3;
<a name="l16934"></a>16934 
<a name="l16935"></a>16935     LITE_INLINE array() 
<a name="l16936"></a>16936     {}
<a name="l16937"></a>16937 
<a name="l16938"></a>16938     <span class="keyword">explicit</span> LITE_INLINE array(<span class="keywordtype">int</span>, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>)
<a name="l16939"></a>16939     {}
<a name="l16940"></a>16940 
<a name="l16941"></a>16941     <span class="keyword">explicit</span> LITE_INLINE array(<span class="keyword">const</span> size_type&amp;)
<a name="l16942"></a>16942     {}
<a name="l16943"></a>16943 
<a name="l16944"></a>16944     LITE_INLINE array(<span class="keyword">const</span> array&amp; other) 
<a name="l16945"></a>16945     {
<a name="l16946"></a>16946         <span class="keyword">typedef</span> b_iterator&lt;iterator, const_iterator, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l16947"></a>16947 
<a name="l16948"></a>16948         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(
<a name="l16949"></a>16949             &amp;m_data[0][0][0], 
<a name="l16950"></a>16950             &amp;other.m_data[0][0][0]), 
<a name="l16951"></a>16951             size_type());
<a name="l16952"></a>16952     }
<a name="l16953"></a>16953 
<a name="l16954"></a>16954     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l16955"></a>16955     LITE_INLINE array(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l16956"></a>16956     {
<a name="l16957"></a>16957         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l16958"></a>16958             iterator, 
<a name="l16959"></a>16959             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l16960"></a>16960             assign&lt;value_type&gt; &gt; 
<a name="l16961"></a>16961             iterator_type;
<a name="l16962"></a>16962 
<a name="l16963"></a>16963         LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), <span class="stringliteral">&quot;array(): array sizes do not match&quot;</span>);
<a name="l16964"></a>16964 
<a name="l16965"></a>16965         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data[0][0][0], other.begin()), size_type());
<a name="l16966"></a>16966     }
<a name="l16967"></a>16967 
<a name="l16968"></a>16968     LITE_INLINE array(<span class="keyword">const</span> value_type&amp; value) 
<a name="l16969"></a>16969     {
<a name="l16970"></a>16970         <span class="keyword">typedef</span> b_iterator&lt;iterator, c_iterator&lt;value_type&gt;, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l16971"></a>16971 
<a name="l16972"></a>16972         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data[0][0][0], value), size_type());
<a name="l16973"></a>16973     }
<a name="l16974"></a>16974 
<a name="l16975"></a>16975 
<a name="l16976"></a>16976     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> array&amp; other) 
<a name="l16977"></a>16977     {
<a name="l16978"></a>16978         <span class="keyword">typedef</span> b_iterator&lt;iterator, const_iterator, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l16979"></a>16979 
<a name="l16980"></a>16980         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(
<a name="l16981"></a>16981             &amp;m_data[0][0][0], 
<a name="l16982"></a>16982             &amp;other.m_data[0][0][0]), 
<a name="l16983"></a>16983             size_type());
<a name="l16984"></a>16984         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l16985"></a>16985     }
<a name="l16986"></a>16986 
<a name="l16987"></a>16987     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l16988"></a>16988     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l16989"></a>16989     {
<a name="l16990"></a>16990         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l16991"></a>16991             iterator, 
<a name="l16992"></a>16992             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l16993"></a>16993             assign&lt;value_type&gt; &gt; 
<a name="l16994"></a>16994             iterator_type;
<a name="l16995"></a>16995 
<a name="l16996"></a>16996         LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), <span class="stringliteral">&quot;array(): array sizes do not match&quot;</span>);
<a name="l16997"></a>16997 
<a name="l16998"></a>16998         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data[0][0][0], other.begin()), size_type());
<a name="l16999"></a>16999         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l17000"></a>17000     }
<a name="l17001"></a>17001 
<a name="l17002"></a>17002     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> value_type&amp; value)
<a name="l17003"></a>17003     {
<a name="l17004"></a>17004         <span class="keyword">typedef</span> b_iterator&lt;iterator, c_iterator&lt;value_type&gt;, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l17005"></a>17005 
<a name="l17006"></a>17006         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data[0][0][0], value), size_type());
<a name="l17007"></a>17007         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l17008"></a>17008     }
<a name="l17009"></a>17009 
<a name="l17010"></a>17010     LITE_INLINE const_iterator begin()<span class="keyword"> const</span>
<a name="l17011"></a>17011 <span class="keyword">    </span>{
<a name="l17012"></a>17012         <span class="keywordflow">return</span> const_iterator(&amp;m_data[0][0][0]);
<a name="l17013"></a>17013     }
<a name="l17014"></a>17014 
<a name="l17015"></a>17015     LITE_INLINE iterator begin()
<a name="l17016"></a>17016     {
<a name="l17017"></a>17017         <span class="keywordflow">return</span> iterator(&amp;m_data[0][0][0]);
<a name="l17018"></a>17018     }
<a name="l17019"></a>17019 
<a name="l17020"></a>17020     LITE_INLINE size_type size()<span class="keyword"> const</span>
<a name="l17021"></a>17021 <span class="keyword">    </span>{
<a name="l17022"></a>17022         <span class="keywordflow">return</span> size_type();
<a name="l17023"></a>17023     }
<a name="l17024"></a>17024 
<a name="l17025"></a>17025     LITE_INLINE const_reference 
<a name="l17026"></a>17026     operator()(<span class="keywordtype">int</span> i0, <span class="keywordtype">int</span> i1, <span class="keywordtype">int</span> i2)<span class="keyword"> const</span>
<a name="l17027"></a>17027 <span class="keyword">    </span>{
<a name="l17028"></a>17028         <span class="keywordflow">return</span> m_data[i2][i1][i0]; 
<a name="l17029"></a>17029     }
<a name="l17030"></a>17030 
<a name="l17031"></a>17031     LITE_INLINE reference 
<a name="l17032"></a>17032     operator()(<span class="keywordtype">int</span> i0, <span class="keywordtype">int</span> i1, <span class="keywordtype">int</span> i2) 
<a name="l17033"></a>17033     {
<a name="l17034"></a>17034         <span class="keywordflow">return</span> m_data[i2][i1][i0];
<a name="l17035"></a>17035     }
<a name="l17036"></a>17036 
<a name="l17037"></a>17037 
<a name="l17038"></a>17038     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_&gt;
<a name="l17039"></a>17039     LITE_INLINE <span class="keyword">const</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::const_array
<a name="l17040"></a>17040     operator[](<span class="keyword">const</span> transform_type_&amp; trans)<span class="keyword"> const</span>
<a name="l17041"></a>17041 <span class="keyword">    </span>{
<a name="l17042"></a>17042         <span class="keyword">typedef</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::const_array result_type;
<a name="l17043"></a>17043 
<a name="l17044"></a>17044         <span class="keywordflow">return</span> result_type(begin(), size(), trans);
<a name="l17045"></a>17045     }
<a name="l17046"></a>17046 
<a name="l17047"></a>17047     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_&gt;
<a name="l17048"></a>17048     LITE_INLINE <span class="keyword">const</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::array
<a name="l17049"></a>17049     operator[](<span class="keyword">const</span> transform_type_&amp; trans)
<a name="l17050"></a>17050     {
<a name="l17051"></a>17051         <span class="keyword">typedef</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::array result_type;
<a name="l17052"></a>17052 
<a name="l17053"></a>17053         <span class="keywordflow">return</span> result_type(begin(), size(), trans);
<a name="l17054"></a>17054     }
<a name="l17055"></a>17055 
<a name="l17056"></a>17056     LITE_INLINE <span class="keyword">const</span> value_type* data()<span class="keyword"> const</span>
<a name="l17057"></a>17057 <span class="keyword">    </span>{
<a name="l17058"></a>17058         <span class="keywordflow">return</span> &amp;m_data[0][0][0];
<a name="l17059"></a>17059     }
<a name="l17060"></a>17060 
<a name="l17061"></a>17061     LITE_INLINE value_type* data()
<a name="l17062"></a>17062     {
<a name="l17063"></a>17063         <span class="keywordflow">return</span> &amp;m_data[0][0][0];
<a name="l17064"></a>17064     }
<a name="l17065"></a>17065 
<a name="l17066"></a>17066     LITE_INLINE <span class="keywordtype">void</span> release() 
<a name="l17067"></a>17067     {}
<a name="l17068"></a>17068 
<a name="l17069"></a>17069     LITE_INLINE <span class="keywordtype">void</span> resize(<span class="keywordtype">int</span>, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>)
<a name="l17070"></a>17070     {}
<a name="l17071"></a>17071 
<a name="l17072"></a>17072     LITE_INLINE <span class="keywordtype">void</span> resize(<span class="keyword">const</span> size_type&amp;)
<a name="l17073"></a>17073     {}
<a name="l17074"></a>17074 
<a name="l17075"></a>17075     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l17076"></a>17076     LITE_INLINE <span class="keywordtype">void</span> swap(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l17077"></a>17077     {
<a name="l17078"></a>17078         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l17079"></a>17079             iterator, 
<a name="l17080"></a>17080             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l17081"></a>17081             swapper&lt;value_type&gt; &gt; 
<a name="l17082"></a>17082             iterator_type;
<a name="l17083"></a>17083 
<a name="l17084"></a>17084         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data[0][0][0], other.begin()), size_type());
<a name="l17085"></a>17085     }
<a name="l17086"></a>17086 
<a name="l17087"></a>17087     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l17088"></a>17088     LITE_INLINE <span class="keywordtype">void</span> swap(array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l17089"></a>17089     {
<a name="l17090"></a>17090         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l17091"></a>17091             iterator, 
<a name="l17092"></a>17092             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::iterator, 
<a name="l17093"></a>17093             swapper&lt;value_type&gt; &gt; 
<a name="l17094"></a>17094             iterator_type;
<a name="l17095"></a>17095 
<a name="l17096"></a>17096         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(&amp;m_data[0][0][0], other.begin()), size_type());
<a name="l17097"></a>17097     }
<a name="l17098"></a>17098 
<a name="l17099"></a>17099 <span class="keyword">private</span>:
<a name="l17100"></a>17100     value_type m_data[n2_][n1_][n0_];
<a name="l17101"></a>17101 };
<a name="l17102"></a>17102 
<a name="l17103"></a>17103 <span class="comment">/***********************************************************************************************************/</span>
<a name="l17104"></a>17104 
<a name="l17105"></a>17105 
<a name="l17106"></a>17106 <span class="comment">/***********************************************************************************************************/</span>
<a name="l17107"></a>17107 <span class="comment">/* array, hybrid_rep ***************************************************************************************/</span>
<a name="l17108"></a>17108 <span class="comment">/***********************************************************************************************************/</span>
<a name="l17109"></a>17109 
<a name="l17117"></a>17117 <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> reversed_, <span class="keywordtype">int</span> <span class="keywordtype">int</span>ernal_buf_size_&gt;
<a name="l17118"></a><a class="code" href="classlite_1_1hybrid__rep.html">17118</a> <span class="keyword">class </span><a class="code" href="classlite_1_1hybrid__rep.html" title="This is a tag type that can be used to specify hybrid representation for an array...">hybrid_rep</a> 
<a name="l17119"></a>17119 {};
<a name="l17120"></a>17120 
<a name="l17121"></a>17121 
<a name="l17122"></a>17122 <span class="keyword">template</span>&lt;
<a name="l17123"></a>17123     <span class="keyword">typename</span> value_type_,
<a name="l17124"></a>17124     <span class="keyword">typename</span> traits_type_,
<a name="l17125"></a>17125     <span class="keywordtype">int</span> internal_buf_size_
<a name="l17126"></a>17126     &gt;
<a name="l17127"></a>17127 <span class="keyword">class </span><a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a>&lt;
<a name="l17128"></a>17128     value_type_,
<a name="l17129"></a>17129     traits_type_,
<a name="l17130"></a>17130     <a class="code" href="classlite_1_1hybrid__rep.html" title="This is a tag type that can be used to specify hybrid representation for an array...">hybrid_rep</a>&lt;false, internal_buf_size_&gt;
<a name="l17131"></a>17131     &gt;
<a name="l17132"></a>17132 {
<a name="l17133"></a>17133 <span class="keyword">public</span>:
<a name="l17134"></a>17134     <span class="keyword">typedef</span> value_type_ signature;
<a name="l17135"></a>17135     <span class="keyword">typedef</span> traits_type_ traits_type;
<a name="l17136"></a>17136     <span class="keyword">typedef</span> value_type_ value_type;
<a name="l17137"></a>17137     <span class="keyword">typedef</span> <span class="keyword">const</span> value_type_&amp; const_reference;
<a name="l17138"></a>17138     <span class="keyword">typedef</span> value_type_&amp; reference;
<a name="l17139"></a>17139 
<a name="l17140"></a>17140     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structlite_1_1array__signature__traits.html" title="This can be used to extract information from array signatures and get the appropriate...">array_signature_traits&lt;const signature&gt;::default_iterator</a> const_iterator;
<a name="l17141"></a>17141     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structlite_1_1array__signature__traits.html" title="This can be used to extract information from array signatures and get the appropriate...">array_signature_traits&lt;signature&gt;::default_iterator</a> iterator;
<a name="l17142"></a>17142     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structlite_1_1array__signature__traits.html" title="This can be used to extract information from array signatures and get the appropriate...">array_signature_traits&lt;signature&gt;::size_type</a> size_type;
<a name="l17143"></a>17143 
<a name="l17144"></a>17144     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array_helper&lt;signature, traits_type_&gt;::temporary_array</a> temporary_array;
<a name="l17145"></a>17145     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array_helper&lt;signature, traits_type_&gt;::fwd_temporary_array</a> fwd_temporary_array;
<a name="l17146"></a>17146     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array_helper&lt;signature, traits_type_&gt;::rev_temporary_array</a> rev_temporary_array;
<a name="l17147"></a>17147 
<a name="l17148"></a>17148     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> dimensions = 0;
<a name="l17149"></a>17149     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_reverse = <span class="keyword">false</span>;
<a name="l17150"></a>17150     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> internal_buffer_size = internal_buf_size_;
<a name="l17151"></a>17151 
<a name="l17152"></a>17152 
<a name="l17153"></a>17153 
<a name="l17154"></a>17154     <span class="keyword">explicit</span> LITE_INLINE <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a>(<span class="keyword">const</span> size_type&amp; sz)
<a name="l17155"></a>17155     {
<a name="l17156"></a>17156         init();
<a name="l17157"></a>17157         resize(sz);
<a name="l17158"></a>17158     }
<a name="l17159"></a>17159 
<a name="l17160"></a>17160     LITE_INLINE array(<span class="keyword">const</span> array&amp; other) 
<a name="l17161"></a>17161     {
<a name="l17162"></a>17162         <span class="keyword">typedef</span> b_iterator&lt;iterator, const_iterator, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l17163"></a>17163 
<a name="l17164"></a>17164         init();
<a name="l17165"></a>17165         resize(other.size());
<a name="l17166"></a>17166         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.m_iterator), m_size);
<a name="l17167"></a>17167     }
<a name="l17168"></a>17168 
<a name="l17169"></a>17169     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l17170"></a>17170     LITE_INLINE array(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l17171"></a>17171     {
<a name="l17172"></a>17172         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l17173"></a>17173             iterator, 
<a name="l17174"></a>17174             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l17175"></a>17175             assign&lt;value_type&gt; &gt; 
<a name="l17176"></a>17176             iterator_type;
<a name="l17177"></a>17177 
<a name="l17178"></a>17178         init();
<a name="l17179"></a>17179         resize(other.size());
<a name="l17180"></a>17180         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.begin()), m_size);
<a name="l17181"></a>17181     }
<a name="l17182"></a>17182 
<a name="l17183"></a>17183     LITE_INLINE array(<span class="keyword">const</span> value_type&amp; value) 
<a name="l17184"></a>17184     {
<a name="l17185"></a>17185         <span class="keyword">typedef</span> b_iterator&lt;iterator, c_iterator&lt;value_type&gt;, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l17186"></a>17186 
<a name="l17187"></a>17187         init();
<a name="l17188"></a>17188         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, value), m_size);
<a name="l17189"></a>17189     }
<a name="l17190"></a>17190 
<a name="l17191"></a>17191     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> array&amp; other) 
<a name="l17192"></a>17192     {
<a name="l17193"></a>17193         <span class="keyword">typedef</span> b_iterator&lt;iterator, const_iterator, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l17194"></a>17194 
<a name="l17195"></a>17195         resize(other.size());
<a name="l17196"></a>17196         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.m_iterator), m_size);
<a name="l17197"></a>17197         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l17198"></a>17198     }
<a name="l17199"></a>17199 
<a name="l17200"></a>17200     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l17201"></a>17201     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l17202"></a>17202     {
<a name="l17203"></a>17203         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l17204"></a>17204             iterator, 
<a name="l17205"></a>17205             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l17206"></a>17206             assign&lt;value_type&gt; &gt; 
<a name="l17207"></a>17207             iterator_type;
<a name="l17208"></a>17208 
<a name="l17209"></a>17209         resize(other.size());
<a name="l17210"></a>17210         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.begin()), m_size);
<a name="l17211"></a>17211         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l17212"></a>17212     }
<a name="l17213"></a>17213 
<a name="l17214"></a>17214     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> value_type&amp; value)
<a name="l17215"></a>17215     {
<a name="l17216"></a>17216         <span class="keyword">typedef</span> b_iterator&lt;iterator, c_iterator&lt;value_type&gt;, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l17217"></a>17217 
<a name="l17218"></a>17218         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, value), m_size);
<a name="l17219"></a>17219         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l17220"></a>17220     }
<a name="l17221"></a>17221 
<a name="l17222"></a>17222     LITE_INLINE const_iterator begin()<span class="keyword"> const</span>
<a name="l17223"></a>17223 <span class="keyword">    </span>{
<a name="l17224"></a>17224         <span class="keywordflow">return</span> m_iterator;
<a name="l17225"></a>17225     }
<a name="l17226"></a>17226 
<a name="l17227"></a>17227     LITE_INLINE iterator begin()
<a name="l17228"></a>17228     {
<a name="l17229"></a>17229         <span class="keywordflow">return</span> m_iterator;
<a name="l17230"></a>17230     }
<a name="l17231"></a>17231 
<a name="l17232"></a>17232     LITE_INLINE size_type size()<span class="keyword"> const</span>
<a name="l17233"></a>17233 <span class="keyword">    </span>{
<a name="l17234"></a>17234         <span class="keywordflow">return</span> m_size;
<a name="l17235"></a>17235     }
<a name="l17236"></a>17236 
<a name="l17237"></a>17237     LITE_INLINE const_reference 
<a name="l17238"></a>17238     operator()()<span class="keyword"> const</span>
<a name="l17239"></a>17239 <span class="keyword">    </span>{
<a name="l17240"></a>17240         <span class="keywordflow">return</span> *(m_iterator.i0);
<a name="l17241"></a>17241     }
<a name="l17242"></a>17242 
<a name="l17243"></a>17243     LITE_INLINE reference 
<a name="l17244"></a>17244     operator()() 
<a name="l17245"></a>17245     {
<a name="l17246"></a>17246         <span class="keywordflow">return</span> *(m_iterator.i0);
<a name="l17247"></a>17247     }
<a name="l17248"></a>17248 
<a name="l17249"></a>17249 
<a name="l17250"></a>17250     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_&gt;
<a name="l17251"></a>17251     LITE_INLINE <span class="keyword">const</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::const_array
<a name="l17252"></a>17252     operator[](<span class="keyword">const</span> transform_type_&amp; trans)<span class="keyword"> const</span>
<a name="l17253"></a>17253 <span class="keyword">    </span>{
<a name="l17254"></a>17254         <span class="keyword">typedef</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::const_array result_type;
<a name="l17255"></a>17255 
<a name="l17256"></a>17256         <span class="keywordflow">return</span> result_type(begin(), size(), trans);
<a name="l17257"></a>17257     }
<a name="l17258"></a>17258 
<a name="l17259"></a>17259     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_&gt;
<a name="l17260"></a>17260     LITE_INLINE <span class="keyword">const</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::array
<a name="l17261"></a>17261     operator[](<span class="keyword">const</span> transform_type_&amp; trans)
<a name="l17262"></a>17262     {
<a name="l17263"></a>17263         <span class="keyword">typedef</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::array result_type;
<a name="l17264"></a>17264 
<a name="l17265"></a>17265         <span class="keywordflow">return</span> result_type(begin(), size(), trans);
<a name="l17266"></a>17266     }
<a name="l17267"></a>17267 
<a name="l17268"></a>17268     LITE_INLINE <span class="keyword">const</span> value_type* data()<span class="keyword"> const</span>
<a name="l17269"></a>17269 <span class="keyword">    </span>{
<a name="l17270"></a>17270         <span class="keywordflow">return</span> m_iterator.i0;
<a name="l17271"></a>17271     }
<a name="l17272"></a>17272 
<a name="l17273"></a>17273     LITE_INLINE value_type* data()
<a name="l17274"></a>17274     {
<a name="l17275"></a>17275         <span class="keywordflow">return</span> m_iterator.i0;
<a name="l17276"></a>17276     }
<a name="l17277"></a>17277 
<a name="l17278"></a>17278     LITE_INLINE <span class="keywordtype">void</span> release() 
<a name="l17279"></a>17279     {
<a name="l17280"></a>17280         <span class="keywordflow">if</span> (m_iterator.i0 &amp;&amp; m_iterator.i0 != m_buffer)
<a name="l17281"></a>17281             <span class="keyword">delete</span>[] m_iterator.i0;
<a name="l17282"></a>17282 
<a name="l17283"></a>17283         m_iterator.i0 = 0;
<a name="l17284"></a>17284         m_size.set();
<a name="l17285"></a>17285     }
<a name="l17286"></a>17286 
<a name="l17287"></a>17287     LITE_INLINE <span class="keywordtype">void</span> resize()
<a name="l17288"></a>17288     {
<a name="l17289"></a>17289         resize(size_type());
<a name="l17290"></a>17290     }
<a name="l17291"></a>17291 
<a name="l17292"></a>17292     LITE_INLINE <span class="keywordtype">void</span> resize(<span class="keyword">const</span> size_type&amp; new_size)
<a name="l17293"></a>17293     {
<a name="l17294"></a>17294         <span class="keywordtype">int</span> old_volumne = <a class="code" href="group__array__operations.html#gae75c2a405afffef6e4b64e7ea1831372" title="Returns the total volume of an array of the size sz.">volume</a>(m_size);
<a name="l17295"></a>17295         <span class="keywordtype">int</span> new_volume = <a class="code" href="group__array__operations.html#gae75c2a405afffef6e4b64e7ea1831372" title="Returns the total volume of an array of the size sz.">volume</a>(new_size);
<a name="l17296"></a>17296 
<a name="l17297"></a>17297         <span class="keywordflow">if</span> (old_volumne != new_volume || m_iterator.i0==0) {
<a name="l17298"></a>17298             <span class="keywordflow">if</span> (m_iterator.i0 &amp;&amp; m_iterator.i0 != m_buffer)
<a name="l17299"></a>17299                 <span class="keyword">delete</span>[] m_iterator.i0;
<a name="l17300"></a>17300             m_iterator.i0 = 0;
<a name="l17301"></a>17301             m_size.set();
<a name="l17302"></a>17302 
<a name="l17303"></a>17303             <span class="keywordflow">if</span> (new_volume == 0)
<a name="l17304"></a>17304                 <span class="keywordflow">return</span>;
<a name="l17305"></a>17305 
<a name="l17306"></a>17306             m_iterator.i0 = new_volume &lt;= internal_buffer_size ? m_buffer : <span class="keyword">new</span> value_type[new_volume];
<a name="l17307"></a>17307         }
<a name="l17308"></a>17308         m_size = new_size;
<a name="l17309"></a>17309         m_iterator.set(
<a name="l17310"></a>17310             m_iterator.i0
<a name="l17311"></a>17311         );
<a name="l17312"></a>17312     }
<a name="l17313"></a>17313 
<a name="l17314"></a>17314     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l17315"></a>17315     LITE_INLINE <span class="keywordtype">void</span> swap(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l17316"></a>17316     {
<a name="l17317"></a>17317         regular_swap(other);
<a name="l17318"></a>17318     }
<a name="l17319"></a>17319 
<a name="l17320"></a>17320     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l17321"></a>17321     LITE_INLINE <span class="keywordtype">void</span> swap(array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l17322"></a>17322     {
<a name="l17323"></a>17323         regular_swap(other);
<a name="l17324"></a>17324     }
<a name="l17325"></a>17325 
<a name="l17326"></a>17326     LITE_INLINE <span class="keywordtype">void</span> swap(array&amp; other)
<a name="l17327"></a>17327     {
<a name="l17328"></a>17328         <span class="comment">// fast swap</span>
<a name="l17329"></a>17329         <span class="keywordflow">if</span> (m_iterator.i0 != m_buffer &amp;&amp; other.m_iterator.i0 != other.m_buffer) {
<a name="l17330"></a>17330             iterator tmp_iter = other.m_iterator;
<a name="l17331"></a>17331             size_type tmp_size = other.m_size;
<a name="l17332"></a>17332 
<a name="l17333"></a>17333             other.m_iterator = m_iterator;
<a name="l17334"></a>17334             other.m_size = m_size;
<a name="l17335"></a>17335 
<a name="l17336"></a>17336             m_iterator = tmp_iter;
<a name="l17337"></a>17337             m_size = tmp_size;
<a name="l17338"></a>17338         }
<a name="l17339"></a>17339         <span class="keywordflow">else</span>
<a name="l17340"></a>17340             regular_swap(other);
<a name="l17341"></a>17341     }
<a name="l17342"></a>17342 
<a name="l17343"></a>17343 
<a name="l17344"></a>17344     LITE_INLINE ~array() 
<a name="l17345"></a>17345     {
<a name="l17346"></a>17346         <span class="keywordflow">if</span> (m_iterator.i0 &amp;&amp; m_iterator.i0 != m_buffer)
<a name="l17347"></a>17347             <span class="keyword">delete</span>[] m_iterator.i0;
<a name="l17348"></a>17348     }
<a name="l17349"></a>17349 
<a name="l17350"></a>17350 <span class="keyword">private</span>:
<a name="l17351"></a>17351 
<a name="l17352"></a>17352     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_array_&gt;
<a name="l17353"></a>17353     LITE_INLINE <span class="keywordtype">void</span> regular_swap(other_array_&amp; other)
<a name="l17354"></a>17354     {
<a name="l17355"></a>17355         <span class="keyword">typedef</span> b_iterator&lt;iterator, typename other_array_::iterator, swapper&lt;value_type&gt; &gt; iterator_type;
<a name="l17356"></a>17356 
<a name="l17357"></a>17357         <span class="keywordflow">if</span> (m_size == other.size()) 
<a name="l17358"></a>17358             <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.begin()), m_size);
<a name="l17359"></a>17359         <span class="keywordflow">else</span> {
<a name="l17360"></a>17360             <span class="keyword">typename</span> other_array_::temporary_array tmp = other;
<a name="l17361"></a>17361 
<a name="l17362"></a>17362             other = *<span class="keyword">this</span>;
<a name="l17363"></a>17363             *<span class="keyword">this</span> = tmp;
<a name="l17364"></a>17364         }
<a name="l17365"></a>17365     }
<a name="l17366"></a>17366 
<a name="l17367"></a>17367     <span class="comment">//template&lt;typename other_signature_, typename other_traits_type_, typename other_rep_&gt;</span>
<a name="l17368"></a>17368     <span class="comment">//friend class array;</span>
<a name="l17369"></a>17369 
<a name="l17370"></a>17370     LITE_INLINE <span class="keywordtype">void</span> init()
<a name="l17371"></a>17371     {
<a name="l17372"></a>17372         m_iterator.i0 = 0;
<a name="l17373"></a>17373         m_size.set();
<a name="l17374"></a>17374         resize(m_size);
<a name="l17375"></a>17375     }
<a name="l17376"></a>17376 
<a name="l17377"></a>17377     iterator m_iterator;
<a name="l17378"></a>17378     size_type m_size;
<a name="l17379"></a>17379     value_type m_buffer[internal_buffer_size &gt;= 1 ? internal_buffer_size : 1];
<a name="l17380"></a>17380 };
<a name="l17381"></a>17381 
<a name="l17382"></a>17382 <span class="comment">/***********************************************************************************************************/</span>
<a name="l17383"></a>17383 
<a name="l17384"></a>17384 <span class="keyword">template</span>&lt;
<a name="l17385"></a>17385     <span class="keyword">typename</span> value_type_,
<a name="l17386"></a>17386     <span class="keywordtype">int</span> n0_, 
<a name="l17387"></a>17387     <span class="keyword">typename</span> traits_type_,
<a name="l17388"></a>17388     <span class="keywordtype">int</span> internal_buf_size_
<a name="l17389"></a>17389     &gt;
<a name="l17390"></a>17390 <span class="keyword">class </span>array&lt;
<a name="l17391"></a>17391     value_type_[n0_],
<a name="l17392"></a>17392     traits_type_,
<a name="l17393"></a>17393     hybrid_rep&lt;false, internal_buf_size_&gt;
<a name="l17394"></a>17394     &gt;
<a name="l17395"></a>17395 {
<a name="l17396"></a>17396 <span class="keyword">public</span>:
<a name="l17397"></a>17397     <span class="keyword">typedef</span> value_type_ signature[n0_];
<a name="l17398"></a>17398     <span class="keyword">typedef</span> traits_type_ traits_type;
<a name="l17399"></a>17399     <span class="keyword">typedef</span> value_type_ value_type;
<a name="l17400"></a>17400     <span class="keyword">typedef</span> <span class="keyword">const</span> value_type_&amp; const_reference;
<a name="l17401"></a>17401     <span class="keyword">typedef</span> value_type_&amp; reference;
<a name="l17402"></a>17402 
<a name="l17403"></a>17403     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;const signature&gt;::default_iterator const_iterator;
<a name="l17404"></a>17404     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;signature&gt;::default_iterator iterator;
<a name="l17405"></a>17405     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;signature&gt;::size_type size_type;
<a name="l17406"></a>17406 
<a name="l17407"></a>17407     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::temporary_array temporary_array;
<a name="l17408"></a>17408     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::fwd_temporary_array fwd_temporary_array;
<a name="l17409"></a>17409     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::rev_temporary_array rev_temporary_array;
<a name="l17410"></a>17410 
<a name="l17411"></a>17411     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> dimensions = 1;
<a name="l17412"></a>17412     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_reverse = <span class="keyword">false</span>;
<a name="l17413"></a>17413     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> internal_buffer_size = internal_buf_size_;
<a name="l17414"></a>17414 
<a name="l17415"></a>17415     LITE_INLINE array() 
<a name="l17416"></a>17416     {
<a name="l17417"></a>17417         init();
<a name="l17418"></a>17418         resize(size_type());
<a name="l17419"></a>17419     }
<a name="l17420"></a>17420 
<a name="l17421"></a>17421     <span class="keyword">explicit</span> LITE_INLINE array(<span class="keywordtype">int</span> n0)
<a name="l17422"></a>17422     {
<a name="l17423"></a>17423         init();
<a name="l17424"></a>17424         resize(size_type(n0));
<a name="l17425"></a>17425     }
<a name="l17426"></a>17426 
<a name="l17427"></a>17427     <span class="keyword">explicit</span> LITE_INLINE array(<span class="keyword">const</span> size_type&amp; sz)
<a name="l17428"></a>17428     {
<a name="l17429"></a>17429         init();
<a name="l17430"></a>17430         resize(sz);
<a name="l17431"></a>17431     }
<a name="l17432"></a>17432 
<a name="l17433"></a>17433     LITE_INLINE array(<span class="keyword">const</span> array&amp; other) 
<a name="l17434"></a>17434     {
<a name="l17435"></a>17435         <span class="keyword">typedef</span> b_iterator&lt;iterator, const_iterator, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l17436"></a>17436 
<a name="l17437"></a>17437         init();
<a name="l17438"></a>17438         resize(other.size());
<a name="l17439"></a>17439         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.m_iterator), m_size);
<a name="l17440"></a>17440     }
<a name="l17441"></a>17441 
<a name="l17442"></a>17442     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l17443"></a>17443     LITE_INLINE array(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l17444"></a>17444     {
<a name="l17445"></a>17445         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l17446"></a>17446             iterator, 
<a name="l17447"></a>17447             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l17448"></a>17448             assign&lt;value_type&gt; &gt; 
<a name="l17449"></a>17449             iterator_type;
<a name="l17450"></a>17450 
<a name="l17451"></a>17451         init();
<a name="l17452"></a>17452         resize(other.size());
<a name="l17453"></a>17453         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.begin()), m_size);
<a name="l17454"></a>17454     }
<a name="l17455"></a>17455 
<a name="l17456"></a>17456     LITE_INLINE array(<span class="keyword">const</span> value_type&amp; value) 
<a name="l17457"></a>17457     {
<a name="l17458"></a>17458         <span class="keyword">typedef</span> b_iterator&lt;iterator, c_iterator&lt;value_type&gt;, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l17459"></a>17459 
<a name="l17460"></a>17460         init();
<a name="l17461"></a>17461         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, value), m_size);
<a name="l17462"></a>17462     }
<a name="l17463"></a>17463 
<a name="l17464"></a>17464     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> array&amp; other) 
<a name="l17465"></a>17465     {
<a name="l17466"></a>17466         <span class="keyword">typedef</span> b_iterator&lt;iterator, const_iterator, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l17467"></a>17467 
<a name="l17468"></a>17468         resize(other.size());
<a name="l17469"></a>17469         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.m_iterator), m_size);
<a name="l17470"></a>17470         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l17471"></a>17471     }
<a name="l17472"></a>17472 
<a name="l17473"></a>17473     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l17474"></a>17474     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l17475"></a>17475     {
<a name="l17476"></a>17476         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l17477"></a>17477             iterator, 
<a name="l17478"></a>17478             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l17479"></a>17479             assign&lt;value_type&gt; &gt; 
<a name="l17480"></a>17480             iterator_type;
<a name="l17481"></a>17481 
<a name="l17482"></a>17482         resize(other.size());
<a name="l17483"></a>17483         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.begin()), m_size);
<a name="l17484"></a>17484         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l17485"></a>17485     }
<a name="l17486"></a>17486 
<a name="l17487"></a>17487     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> value_type&amp; value)
<a name="l17488"></a>17488     {
<a name="l17489"></a>17489         <span class="keyword">typedef</span> b_iterator&lt;iterator, c_iterator&lt;value_type&gt;, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l17490"></a>17490 
<a name="l17491"></a>17491         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, value), m_size);
<a name="l17492"></a>17492         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l17493"></a>17493     }
<a name="l17494"></a>17494 
<a name="l17495"></a>17495     LITE_INLINE const_iterator begin()<span class="keyword"> const</span>
<a name="l17496"></a>17496 <span class="keyword">    </span>{
<a name="l17497"></a>17497         <span class="keywordflow">return</span> m_iterator;
<a name="l17498"></a>17498     }
<a name="l17499"></a>17499 
<a name="l17500"></a>17500     LITE_INLINE iterator begin()
<a name="l17501"></a>17501     {
<a name="l17502"></a>17502         <span class="keywordflow">return</span> m_iterator;
<a name="l17503"></a>17503     }
<a name="l17504"></a>17504 
<a name="l17505"></a>17505     LITE_INLINE size_type size()<span class="keyword"> const</span>
<a name="l17506"></a>17506 <span class="keyword">    </span>{
<a name="l17507"></a>17507         <span class="keywordflow">return</span> m_size;
<a name="l17508"></a>17508     }
<a name="l17509"></a>17509 
<a name="l17510"></a>17510     LITE_INLINE const_reference 
<a name="l17511"></a>17511     operator()(<span class="keywordtype">int</span> i0)<span class="keyword"> const</span>
<a name="l17512"></a>17512 <span class="keyword">    </span>{
<a name="l17513"></a>17513         <span class="keywordflow">return</span> *(m_iterator.i0+i0*m_iterator.i1);
<a name="l17514"></a>17514     }
<a name="l17515"></a>17515 
<a name="l17516"></a>17516     LITE_INLINE reference 
<a name="l17517"></a>17517     operator()(<span class="keywordtype">int</span> i0) 
<a name="l17518"></a>17518     {
<a name="l17519"></a>17519         <span class="keywordflow">return</span> *(m_iterator.i0+i0*m_iterator.i1);
<a name="l17520"></a>17520     }
<a name="l17521"></a>17521 
<a name="l17522"></a>17522     LITE_INLINE const_reference 
<a name="l17523"></a>17523     operator[](<span class="keywordtype">int</span> i0)<span class="keyword"> const</span>
<a name="l17524"></a>17524 <span class="keyword">    </span>{
<a name="l17525"></a>17525         <span class="keywordflow">return</span> *(m_iterator.i0+i0*m_iterator.i1);
<a name="l17526"></a>17526     }
<a name="l17527"></a>17527 
<a name="l17528"></a>17528     LITE_INLINE reference 
<a name="l17529"></a>17529     operator[](<span class="keywordtype">int</span> i0)
<a name="l17530"></a>17530     {
<a name="l17531"></a>17531         <span class="keywordflow">return</span> *(m_iterator.i0+i0*m_iterator.i1);
<a name="l17532"></a>17532     }
<a name="l17533"></a>17533 
<a name="l17534"></a>17534 
<a name="l17535"></a>17535     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_&gt;
<a name="l17536"></a>17536     LITE_INLINE <span class="keyword">const</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::const_array
<a name="l17537"></a>17537     operator[](<span class="keyword">const</span> transform_type_&amp; trans)<span class="keyword"> const</span>
<a name="l17538"></a>17538 <span class="keyword">    </span>{
<a name="l17539"></a>17539         <span class="keyword">typedef</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::const_array result_type;
<a name="l17540"></a>17540 
<a name="l17541"></a>17541         <span class="keywordflow">return</span> result_type(begin(), size(), trans);
<a name="l17542"></a>17542     }
<a name="l17543"></a>17543 
<a name="l17544"></a>17544     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_&gt;
<a name="l17545"></a>17545     LITE_INLINE <span class="keyword">const</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::array
<a name="l17546"></a>17546     operator[](<span class="keyword">const</span> transform_type_&amp; trans)
<a name="l17547"></a>17547     {
<a name="l17548"></a>17548         <span class="keyword">typedef</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::array result_type;
<a name="l17549"></a>17549 
<a name="l17550"></a>17550         <span class="keywordflow">return</span> result_type(begin(), size(), trans);
<a name="l17551"></a>17551     }
<a name="l17552"></a>17552 
<a name="l17553"></a>17553     LITE_INLINE <span class="keyword">const</span> value_type* data()<span class="keyword"> const</span>
<a name="l17554"></a>17554 <span class="keyword">    </span>{
<a name="l17555"></a>17555         <span class="keywordflow">return</span> m_iterator.i0;
<a name="l17556"></a>17556     }
<a name="l17557"></a>17557 
<a name="l17558"></a>17558     LITE_INLINE value_type* data()
<a name="l17559"></a>17559     {
<a name="l17560"></a>17560         <span class="keywordflow">return</span> m_iterator.i0;
<a name="l17561"></a>17561     }
<a name="l17562"></a>17562 
<a name="l17563"></a>17563     LITE_INLINE <span class="keywordtype">void</span> release() 
<a name="l17564"></a>17564     {
<a name="l17565"></a>17565         <span class="keywordflow">if</span> (m_iterator.i0 &amp;&amp; m_iterator.i0 != m_buffer)
<a name="l17566"></a>17566             <span class="keyword">delete</span>[] m_iterator.i0;
<a name="l17567"></a>17567 
<a name="l17568"></a>17568         m_iterator.i0 = 0;
<a name="l17569"></a>17569         m_size.set(0);
<a name="l17570"></a>17570     }
<a name="l17571"></a>17571 
<a name="l17572"></a>17572     LITE_INLINE <span class="keywordtype">void</span> resize(<span class="keywordtype">int</span> n0)
<a name="l17573"></a>17573     {
<a name="l17574"></a>17574         resize(size_type(n0));
<a name="l17575"></a>17575     }
<a name="l17576"></a>17576 
<a name="l17577"></a>17577     LITE_INLINE <span class="keywordtype">void</span> resize(<span class="keyword">const</span> size_type&amp; new_size)
<a name="l17578"></a>17578     {
<a name="l17579"></a>17579         <span class="keywordtype">int</span> old_volumne = <a class="code" href="group__array__operations.html#gae75c2a405afffef6e4b64e7ea1831372" title="Returns the total volume of an array of the size sz.">volume</a>(m_size);
<a name="l17580"></a>17580         <span class="keywordtype">int</span> new_volume = <a class="code" href="group__array__operations.html#gae75c2a405afffef6e4b64e7ea1831372" title="Returns the total volume of an array of the size sz.">volume</a>(new_size);
<a name="l17581"></a>17581 
<a name="l17582"></a>17582         <span class="keywordflow">if</span> (old_volumne != new_volume || m_iterator.i0==0) {
<a name="l17583"></a>17583             <span class="keywordflow">if</span> (m_iterator.i0 &amp;&amp; m_iterator.i0 != m_buffer)
<a name="l17584"></a>17584                 <span class="keyword">delete</span>[] m_iterator.i0;
<a name="l17585"></a>17585             m_iterator.i0 = 0;
<a name="l17586"></a>17586             m_size.set(0);
<a name="l17587"></a>17587 
<a name="l17588"></a>17588             <span class="keywordflow">if</span> (new_volume == 0)
<a name="l17589"></a>17589                 <span class="keywordflow">return</span>;
<a name="l17590"></a>17590 
<a name="l17591"></a>17591             m_iterator.i0 = new_volume &lt;= internal_buffer_size ? m_buffer : <span class="keyword">new</span> value_type[new_volume];
<a name="l17592"></a>17592         }
<a name="l17593"></a>17593         m_size = new_size;
<a name="l17594"></a>17594         m_iterator.set(
<a name="l17595"></a>17595             m_iterator.i0,
<a name="l17596"></a>17596             1
<a name="l17597"></a>17597         );
<a name="l17598"></a>17598     }
<a name="l17599"></a>17599 
<a name="l17600"></a>17600     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l17601"></a>17601     LITE_INLINE <span class="keywordtype">void</span> swap(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l17602"></a>17602     {
<a name="l17603"></a>17603         regular_swap(other);
<a name="l17604"></a>17604     }
<a name="l17605"></a>17605 
<a name="l17606"></a>17606     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l17607"></a>17607     LITE_INLINE <span class="keywordtype">void</span> swap(array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l17608"></a>17608     {
<a name="l17609"></a>17609         regular_swap(other);
<a name="l17610"></a>17610     }
<a name="l17611"></a>17611 
<a name="l17612"></a>17612     LITE_INLINE <span class="keywordtype">void</span> swap(array&amp; other)
<a name="l17613"></a>17613     {
<a name="l17614"></a>17614         <span class="comment">// fast swap</span>
<a name="l17615"></a>17615         <span class="keywordflow">if</span> (m_iterator.i0 != m_buffer &amp;&amp; other.m_iterator.i0 != other.m_buffer) {
<a name="l17616"></a>17616             iterator tmp_iter = other.m_iterator;
<a name="l17617"></a>17617             size_type tmp_size = other.m_size;
<a name="l17618"></a>17618 
<a name="l17619"></a>17619             other.m_iterator = m_iterator;
<a name="l17620"></a>17620             other.m_size = m_size;
<a name="l17621"></a>17621 
<a name="l17622"></a>17622             m_iterator = tmp_iter;
<a name="l17623"></a>17623             m_size = tmp_size;
<a name="l17624"></a>17624         }
<a name="l17625"></a>17625         <span class="keywordflow">else</span>
<a name="l17626"></a>17626             regular_swap(other);
<a name="l17627"></a>17627     }
<a name="l17628"></a>17628 
<a name="l17629"></a>17629 
<a name="l17630"></a>17630     LITE_INLINE ~array() 
<a name="l17631"></a>17631     {
<a name="l17632"></a>17632         <span class="keywordflow">if</span> (m_iterator.i0 &amp;&amp; m_iterator.i0 != m_buffer)
<a name="l17633"></a>17633             <span class="keyword">delete</span>[] m_iterator.i0;
<a name="l17634"></a>17634     }
<a name="l17635"></a>17635 
<a name="l17636"></a>17636 <span class="keyword">private</span>:
<a name="l17637"></a>17637 
<a name="l17638"></a>17638     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_array_&gt;
<a name="l17639"></a>17639     LITE_INLINE <span class="keywordtype">void</span> regular_swap(other_array_&amp; other)
<a name="l17640"></a>17640     {
<a name="l17641"></a>17641         <span class="keyword">typedef</span> b_iterator&lt;iterator, typename other_array_::iterator, swapper&lt;value_type&gt; &gt; iterator_type;
<a name="l17642"></a>17642 
<a name="l17643"></a>17643         <span class="keywordflow">if</span> (m_size == other.size()) 
<a name="l17644"></a>17644             <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.begin()), m_size);
<a name="l17645"></a>17645         <span class="keywordflow">else</span> {
<a name="l17646"></a>17646             <span class="keyword">typename</span> other_array_::temporary_array tmp = other;
<a name="l17647"></a>17647 
<a name="l17648"></a>17648             other = *<span class="keyword">this</span>;
<a name="l17649"></a>17649             *<span class="keyword">this</span> = tmp;
<a name="l17650"></a>17650         }
<a name="l17651"></a>17651     }
<a name="l17652"></a>17652 
<a name="l17653"></a>17653     <span class="comment">//template&lt;typename other_signature_, typename other_traits_type_, typename other_rep_&gt;</span>
<a name="l17654"></a>17654     <span class="comment">//friend class array;</span>
<a name="l17655"></a>17655 
<a name="l17656"></a>17656     LITE_INLINE <span class="keywordtype">void</span> init()
<a name="l17657"></a>17657     {
<a name="l17658"></a>17658         m_iterator.i0 = 0;
<a name="l17659"></a>17659         m_size.set(0);
<a name="l17660"></a>17660         resize(m_size);
<a name="l17661"></a>17661     }
<a name="l17662"></a>17662 
<a name="l17663"></a>17663     iterator m_iterator;
<a name="l17664"></a>17664     size_type m_size;
<a name="l17665"></a>17665     value_type m_buffer[internal_buffer_size &gt;= 1 ? internal_buffer_size : 1];
<a name="l17666"></a>17666 };
<a name="l17667"></a>17667 
<a name="l17668"></a>17668 <span class="comment">/***********************************************************************************************************/</span>
<a name="l17669"></a>17669 
<a name="l17670"></a>17670 <span class="keyword">template</span>&lt;
<a name="l17671"></a>17671     <span class="keyword">typename</span> value_type_,
<a name="l17672"></a>17672     <span class="keywordtype">int</span> n0_, 
<a name="l17673"></a>17673     <span class="keywordtype">int</span> n1_, 
<a name="l17674"></a>17674     <span class="keyword">typename</span> traits_type_,
<a name="l17675"></a>17675     <span class="keywordtype">int</span> internal_buf_size_
<a name="l17676"></a>17676     &gt;
<a name="l17677"></a>17677 <span class="keyword">class </span>array&lt;
<a name="l17678"></a>17678     value_type_[n0_][n1_],
<a name="l17679"></a>17679     traits_type_,
<a name="l17680"></a>17680     hybrid_rep&lt;false, internal_buf_size_&gt;
<a name="l17681"></a>17681     &gt;
<a name="l17682"></a>17682 {
<a name="l17683"></a>17683 <span class="keyword">public</span>:
<a name="l17684"></a>17684     <span class="keyword">typedef</span> value_type_ signature[n0_][n1_];
<a name="l17685"></a>17685     <span class="keyword">typedef</span> traits_type_ traits_type;
<a name="l17686"></a>17686     <span class="keyword">typedef</span> value_type_ value_type;
<a name="l17687"></a>17687     <span class="keyword">typedef</span> <span class="keyword">const</span> value_type_&amp; const_reference;
<a name="l17688"></a>17688     <span class="keyword">typedef</span> value_type_&amp; reference;
<a name="l17689"></a>17689 
<a name="l17690"></a>17690     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;const signature&gt;::default_iterator const_iterator;
<a name="l17691"></a>17691     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;signature&gt;::default_iterator iterator;
<a name="l17692"></a>17692     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;signature&gt;::size_type size_type;
<a name="l17693"></a>17693 
<a name="l17694"></a>17694     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::temporary_array temporary_array;
<a name="l17695"></a>17695     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::fwd_temporary_array fwd_temporary_array;
<a name="l17696"></a>17696     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::rev_temporary_array rev_temporary_array;
<a name="l17697"></a>17697 
<a name="l17698"></a>17698     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> dimensions = 2;
<a name="l17699"></a>17699     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_reverse = <span class="keyword">false</span>;
<a name="l17700"></a>17700     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> internal_buffer_size = internal_buf_size_;
<a name="l17701"></a>17701 
<a name="l17702"></a>17702     LITE_INLINE array() 
<a name="l17703"></a>17703     {
<a name="l17704"></a>17704         init();
<a name="l17705"></a>17705         resize(size_type());
<a name="l17706"></a>17706     }
<a name="l17707"></a>17707 
<a name="l17708"></a>17708     <span class="keyword">explicit</span> LITE_INLINE array(<span class="keywordtype">int</span> n0, <span class="keywordtype">int</span> n1)
<a name="l17709"></a>17709     {
<a name="l17710"></a>17710         init();
<a name="l17711"></a>17711         resize(size_type(n0, n1));
<a name="l17712"></a>17712     }
<a name="l17713"></a>17713 
<a name="l17714"></a>17714     <span class="keyword">explicit</span> LITE_INLINE array(<span class="keyword">const</span> size_type&amp; sz)
<a name="l17715"></a>17715     {
<a name="l17716"></a>17716         init();
<a name="l17717"></a>17717         resize(sz);
<a name="l17718"></a>17718     }
<a name="l17719"></a>17719 
<a name="l17720"></a>17720     LITE_INLINE array(<span class="keyword">const</span> array&amp; other) 
<a name="l17721"></a>17721     {
<a name="l17722"></a>17722         <span class="keyword">typedef</span> b_iterator&lt;iterator, const_iterator, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l17723"></a>17723 
<a name="l17724"></a>17724         init();
<a name="l17725"></a>17725         resize(other.size());
<a name="l17726"></a>17726         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.m_iterator), m_size);
<a name="l17727"></a>17727     }
<a name="l17728"></a>17728 
<a name="l17729"></a>17729     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l17730"></a>17730     LITE_INLINE array(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l17731"></a>17731     {
<a name="l17732"></a>17732         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l17733"></a>17733             iterator, 
<a name="l17734"></a>17734             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l17735"></a>17735             assign&lt;value_type&gt; &gt; 
<a name="l17736"></a>17736             iterator_type;
<a name="l17737"></a>17737 
<a name="l17738"></a>17738         init();
<a name="l17739"></a>17739         resize(other.size());
<a name="l17740"></a>17740         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.begin()), m_size);
<a name="l17741"></a>17741     }
<a name="l17742"></a>17742 
<a name="l17743"></a>17743     LITE_INLINE array(<span class="keyword">const</span> value_type&amp; value) 
<a name="l17744"></a>17744     {
<a name="l17745"></a>17745         <span class="keyword">typedef</span> b_iterator&lt;iterator, c_iterator&lt;value_type&gt;, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l17746"></a>17746 
<a name="l17747"></a>17747         init();
<a name="l17748"></a>17748         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, value), m_size);
<a name="l17749"></a>17749     }
<a name="l17750"></a>17750 
<a name="l17751"></a>17751     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> array&amp; other) 
<a name="l17752"></a>17752     {
<a name="l17753"></a>17753         <span class="keyword">typedef</span> b_iterator&lt;iterator, const_iterator, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l17754"></a>17754 
<a name="l17755"></a>17755         resize(other.size());
<a name="l17756"></a>17756         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.m_iterator), m_size);
<a name="l17757"></a>17757         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l17758"></a>17758     }
<a name="l17759"></a>17759 
<a name="l17760"></a>17760     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l17761"></a>17761     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l17762"></a>17762     {
<a name="l17763"></a>17763         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l17764"></a>17764             iterator, 
<a name="l17765"></a>17765             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l17766"></a>17766             assign&lt;value_type&gt; &gt; 
<a name="l17767"></a>17767             iterator_type;
<a name="l17768"></a>17768 
<a name="l17769"></a>17769         resize(other.size());
<a name="l17770"></a>17770         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.begin()), m_size);
<a name="l17771"></a>17771         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l17772"></a>17772     }
<a name="l17773"></a>17773 
<a name="l17774"></a>17774     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> value_type&amp; value)
<a name="l17775"></a>17775     {
<a name="l17776"></a>17776         <span class="keyword">typedef</span> b_iterator&lt;iterator, c_iterator&lt;value_type&gt;, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l17777"></a>17777 
<a name="l17778"></a>17778         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, value), m_size);
<a name="l17779"></a>17779         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l17780"></a>17780     }
<a name="l17781"></a>17781 
<a name="l17782"></a>17782     LITE_INLINE const_iterator begin()<span class="keyword"> const</span>
<a name="l17783"></a>17783 <span class="keyword">    </span>{
<a name="l17784"></a>17784         <span class="keywordflow">return</span> m_iterator;
<a name="l17785"></a>17785     }
<a name="l17786"></a>17786 
<a name="l17787"></a>17787     LITE_INLINE iterator begin()
<a name="l17788"></a>17788     {
<a name="l17789"></a>17789         <span class="keywordflow">return</span> m_iterator;
<a name="l17790"></a>17790     }
<a name="l17791"></a>17791 
<a name="l17792"></a>17792     LITE_INLINE size_type size()<span class="keyword"> const</span>
<a name="l17793"></a>17793 <span class="keyword">    </span>{
<a name="l17794"></a>17794         <span class="keywordflow">return</span> m_size;
<a name="l17795"></a>17795     }
<a name="l17796"></a>17796 
<a name="l17797"></a>17797     LITE_INLINE const_reference 
<a name="l17798"></a>17798     operator()(<span class="keywordtype">int</span> i0, <span class="keywordtype">int</span> i1)<span class="keyword"> const</span>
<a name="l17799"></a>17799 <span class="keyword">    </span>{
<a name="l17800"></a>17800         <span class="keywordflow">return</span> *(m_iterator.i0+i0*m_iterator.i1+i1*m_iterator.i2);
<a name="l17801"></a>17801     }
<a name="l17802"></a>17802 
<a name="l17803"></a>17803     LITE_INLINE reference 
<a name="l17804"></a>17804     operator()(<span class="keywordtype">int</span> i0, <span class="keywordtype">int</span> i1) 
<a name="l17805"></a>17805     {
<a name="l17806"></a>17806         <span class="keywordflow">return</span> *(m_iterator.i0+i0*m_iterator.i1+i1*m_iterator.i2);
<a name="l17807"></a>17807     }
<a name="l17808"></a>17808 
<a name="l17809"></a>17809 
<a name="l17810"></a>17810     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_&gt;
<a name="l17811"></a>17811     LITE_INLINE <span class="keyword">const</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::const_array
<a name="l17812"></a>17812     operator[](<span class="keyword">const</span> transform_type_&amp; trans)<span class="keyword"> const</span>
<a name="l17813"></a>17813 <span class="keyword">    </span>{
<a name="l17814"></a>17814         <span class="keyword">typedef</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::const_array result_type;
<a name="l17815"></a>17815 
<a name="l17816"></a>17816         <span class="keywordflow">return</span> result_type(begin(), size(), trans);
<a name="l17817"></a>17817     }
<a name="l17818"></a>17818 
<a name="l17819"></a>17819     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_&gt;
<a name="l17820"></a>17820     LITE_INLINE <span class="keyword">const</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::array
<a name="l17821"></a>17821     operator[](<span class="keyword">const</span> transform_type_&amp; trans)
<a name="l17822"></a>17822     {
<a name="l17823"></a>17823         <span class="keyword">typedef</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::array result_type;
<a name="l17824"></a>17824 
<a name="l17825"></a>17825         <span class="keywordflow">return</span> result_type(begin(), size(), trans);
<a name="l17826"></a>17826     }
<a name="l17827"></a>17827 
<a name="l17828"></a>17828     LITE_INLINE <span class="keyword">const</span> value_type* data()<span class="keyword"> const</span>
<a name="l17829"></a>17829 <span class="keyword">    </span>{
<a name="l17830"></a>17830         <span class="keywordflow">return</span> m_iterator.i0;
<a name="l17831"></a>17831     }
<a name="l17832"></a>17832 
<a name="l17833"></a>17833     LITE_INLINE value_type* data()
<a name="l17834"></a>17834     {
<a name="l17835"></a>17835         <span class="keywordflow">return</span> m_iterator.i0;
<a name="l17836"></a>17836     }
<a name="l17837"></a>17837 
<a name="l17838"></a>17838     LITE_INLINE <span class="keywordtype">void</span> release() 
<a name="l17839"></a>17839     {
<a name="l17840"></a>17840         <span class="keywordflow">if</span> (m_iterator.i0 &amp;&amp; m_iterator.i0 != m_buffer)
<a name="l17841"></a>17841             <span class="keyword">delete</span>[] m_iterator.i0;
<a name="l17842"></a>17842 
<a name="l17843"></a>17843         m_iterator.i0 = 0;
<a name="l17844"></a>17844         m_size.set(0, 0);
<a name="l17845"></a>17845     }
<a name="l17846"></a>17846 
<a name="l17847"></a>17847     LITE_INLINE <span class="keywordtype">void</span> resize(<span class="keywordtype">int</span> n0, <span class="keywordtype">int</span> n1)
<a name="l17848"></a>17848     {
<a name="l17849"></a>17849         resize(size_type(n0, n1));
<a name="l17850"></a>17850     }
<a name="l17851"></a>17851 
<a name="l17852"></a>17852     LITE_INLINE <span class="keywordtype">void</span> resize(<span class="keyword">const</span> size_type&amp; new_size)
<a name="l17853"></a>17853     {
<a name="l17854"></a>17854         <span class="keywordtype">int</span> old_volumne = <a class="code" href="group__array__operations.html#gae75c2a405afffef6e4b64e7ea1831372" title="Returns the total volume of an array of the size sz.">volume</a>(m_size);
<a name="l17855"></a>17855         <span class="keywordtype">int</span> new_volume = <a class="code" href="group__array__operations.html#gae75c2a405afffef6e4b64e7ea1831372" title="Returns the total volume of an array of the size sz.">volume</a>(new_size);
<a name="l17856"></a>17856 
<a name="l17857"></a>17857         <span class="keywordflow">if</span> (old_volumne != new_volume || m_iterator.i0==0) {
<a name="l17858"></a>17858             <span class="keywordflow">if</span> (m_iterator.i0 &amp;&amp; m_iterator.i0 != m_buffer)
<a name="l17859"></a>17859                 <span class="keyword">delete</span>[] m_iterator.i0;
<a name="l17860"></a>17860             m_iterator.i0 = 0;
<a name="l17861"></a>17861             m_size.set(0, 0);
<a name="l17862"></a>17862 
<a name="l17863"></a>17863             <span class="keywordflow">if</span> (new_volume == 0)
<a name="l17864"></a>17864                 <span class="keywordflow">return</span>;
<a name="l17865"></a>17865 
<a name="l17866"></a>17866             m_iterator.i0 = new_volume &lt;= internal_buffer_size ? m_buffer : <span class="keyword">new</span> value_type[new_volume];
<a name="l17867"></a>17867         }
<a name="l17868"></a>17868         m_size = new_size;
<a name="l17869"></a>17869         m_iterator.set(
<a name="l17870"></a>17870             m_iterator.i0,
<a name="l17871"></a>17871             m_size.i1,
<a name="l17872"></a>17872             1
<a name="l17873"></a>17873         );
<a name="l17874"></a>17874     }
<a name="l17875"></a>17875 
<a name="l17876"></a>17876     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l17877"></a>17877     LITE_INLINE <span class="keywordtype">void</span> swap(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l17878"></a>17878     {
<a name="l17879"></a>17879         regular_swap(other);
<a name="l17880"></a>17880     }
<a name="l17881"></a>17881 
<a name="l17882"></a>17882     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l17883"></a>17883     LITE_INLINE <span class="keywordtype">void</span> swap(array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l17884"></a>17884     {
<a name="l17885"></a>17885         regular_swap(other);
<a name="l17886"></a>17886     }
<a name="l17887"></a>17887 
<a name="l17888"></a>17888     LITE_INLINE <span class="keywordtype">void</span> swap(array&amp; other)
<a name="l17889"></a>17889     {
<a name="l17890"></a>17890         <span class="comment">// fast swap</span>
<a name="l17891"></a>17891         <span class="keywordflow">if</span> (m_iterator.i0 != m_buffer &amp;&amp; other.m_iterator.i0 != other.m_buffer) {
<a name="l17892"></a>17892             iterator tmp_iter = other.m_iterator;
<a name="l17893"></a>17893             size_type tmp_size = other.m_size;
<a name="l17894"></a>17894 
<a name="l17895"></a>17895             other.m_iterator = m_iterator;
<a name="l17896"></a>17896             other.m_size = m_size;
<a name="l17897"></a>17897 
<a name="l17898"></a>17898             m_iterator = tmp_iter;
<a name="l17899"></a>17899             m_size = tmp_size;
<a name="l17900"></a>17900         }
<a name="l17901"></a>17901         <span class="keywordflow">else</span>
<a name="l17902"></a>17902             regular_swap(other);
<a name="l17903"></a>17903     }
<a name="l17904"></a>17904 
<a name="l17905"></a>17905 
<a name="l17906"></a>17906     LITE_INLINE ~array() 
<a name="l17907"></a>17907     {
<a name="l17908"></a>17908         <span class="keywordflow">if</span> (m_iterator.i0 &amp;&amp; m_iterator.i0 != m_buffer)
<a name="l17909"></a>17909             <span class="keyword">delete</span>[] m_iterator.i0;
<a name="l17910"></a>17910     }
<a name="l17911"></a>17911 
<a name="l17912"></a>17912 <span class="keyword">private</span>:
<a name="l17913"></a>17913 
<a name="l17914"></a>17914     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_array_&gt;
<a name="l17915"></a>17915     LITE_INLINE <span class="keywordtype">void</span> regular_swap(other_array_&amp; other)
<a name="l17916"></a>17916     {
<a name="l17917"></a>17917         <span class="keyword">typedef</span> b_iterator&lt;iterator, typename other_array_::iterator, swapper&lt;value_type&gt; &gt; iterator_type;
<a name="l17918"></a>17918 
<a name="l17919"></a>17919         <span class="keywordflow">if</span> (m_size == other.size()) 
<a name="l17920"></a>17920             <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.begin()), m_size);
<a name="l17921"></a>17921         <span class="keywordflow">else</span> {
<a name="l17922"></a>17922             <span class="keyword">typename</span> other_array_::temporary_array tmp = other;
<a name="l17923"></a>17923 
<a name="l17924"></a>17924             other = *<span class="keyword">this</span>;
<a name="l17925"></a>17925             *<span class="keyword">this</span> = tmp;
<a name="l17926"></a>17926         }
<a name="l17927"></a>17927     }
<a name="l17928"></a>17928 
<a name="l17929"></a>17929     <span class="comment">//template&lt;typename other_signature_, typename other_traits_type_, typename other_rep_&gt;</span>
<a name="l17930"></a>17930     <span class="comment">//friend class array;</span>
<a name="l17931"></a>17931 
<a name="l17932"></a>17932     LITE_INLINE <span class="keywordtype">void</span> init()
<a name="l17933"></a>17933     {
<a name="l17934"></a>17934         m_iterator.i0 = 0;
<a name="l17935"></a>17935         m_size.set(0, 0);
<a name="l17936"></a>17936         resize(m_size);
<a name="l17937"></a>17937     }
<a name="l17938"></a>17938 
<a name="l17939"></a>17939     iterator m_iterator;
<a name="l17940"></a>17940     size_type m_size;
<a name="l17941"></a>17941     value_type m_buffer[internal_buffer_size &gt;= 1 ? internal_buffer_size : 1];
<a name="l17942"></a>17942 };
<a name="l17943"></a>17943 
<a name="l17944"></a>17944 <span class="comment">/***********************************************************************************************************/</span>
<a name="l17945"></a>17945 
<a name="l17946"></a>17946 <span class="keyword">template</span>&lt;
<a name="l17947"></a>17947     <span class="keyword">typename</span> value_type_,
<a name="l17948"></a>17948     <span class="keywordtype">int</span> n0_, 
<a name="l17949"></a>17949     <span class="keywordtype">int</span> n1_, 
<a name="l17950"></a>17950     <span class="keywordtype">int</span> n2_, 
<a name="l17951"></a>17951     <span class="keyword">typename</span> traits_type_,
<a name="l17952"></a>17952     <span class="keywordtype">int</span> internal_buf_size_
<a name="l17953"></a>17953     &gt;
<a name="l17954"></a>17954 <span class="keyword">class </span>array&lt;
<a name="l17955"></a>17955     value_type_[n0_][n1_][n2_],
<a name="l17956"></a>17956     traits_type_,
<a name="l17957"></a>17957     hybrid_rep&lt;false, internal_buf_size_&gt;
<a name="l17958"></a>17958     &gt;
<a name="l17959"></a>17959 {
<a name="l17960"></a>17960 <span class="keyword">public</span>:
<a name="l17961"></a>17961     <span class="keyword">typedef</span> value_type_ signature[n0_][n1_][n2_];
<a name="l17962"></a>17962     <span class="keyword">typedef</span> traits_type_ traits_type;
<a name="l17963"></a>17963     <span class="keyword">typedef</span> value_type_ value_type;
<a name="l17964"></a>17964     <span class="keyword">typedef</span> <span class="keyword">const</span> value_type_&amp; const_reference;
<a name="l17965"></a>17965     <span class="keyword">typedef</span> value_type_&amp; reference;
<a name="l17966"></a>17966 
<a name="l17967"></a>17967     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;const signature&gt;::default_iterator const_iterator;
<a name="l17968"></a>17968     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;signature&gt;::default_iterator iterator;
<a name="l17969"></a>17969     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;signature&gt;::size_type size_type;
<a name="l17970"></a>17970 
<a name="l17971"></a>17971     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::temporary_array temporary_array;
<a name="l17972"></a>17972     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::fwd_temporary_array fwd_temporary_array;
<a name="l17973"></a>17973     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::rev_temporary_array rev_temporary_array;
<a name="l17974"></a>17974 
<a name="l17975"></a>17975     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> dimensions = 3;
<a name="l17976"></a>17976     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_reverse = <span class="keyword">false</span>;
<a name="l17977"></a>17977     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> internal_buffer_size = internal_buf_size_;
<a name="l17978"></a>17978 
<a name="l17979"></a>17979     LITE_INLINE array() 
<a name="l17980"></a>17980     {
<a name="l17981"></a>17981         init();
<a name="l17982"></a>17982         resize(size_type());
<a name="l17983"></a>17983     }
<a name="l17984"></a>17984 
<a name="l17985"></a>17985     <span class="keyword">explicit</span> LITE_INLINE array(<span class="keywordtype">int</span> n0, <span class="keywordtype">int</span> n1, <span class="keywordtype">int</span> n2)
<a name="l17986"></a>17986     {
<a name="l17987"></a>17987         init();
<a name="l17988"></a>17988         resize(size_type(n0, n1, n2));
<a name="l17989"></a>17989     }
<a name="l17990"></a>17990 
<a name="l17991"></a>17991     <span class="keyword">explicit</span> LITE_INLINE array(<span class="keyword">const</span> size_type&amp; sz)
<a name="l17992"></a>17992     {
<a name="l17993"></a>17993         init();
<a name="l17994"></a>17994         resize(sz);
<a name="l17995"></a>17995     }
<a name="l17996"></a>17996 
<a name="l17997"></a>17997     LITE_INLINE array(<span class="keyword">const</span> array&amp; other) 
<a name="l17998"></a>17998     {
<a name="l17999"></a>17999         <span class="keyword">typedef</span> b_iterator&lt;iterator, const_iterator, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l18000"></a>18000 
<a name="l18001"></a>18001         init();
<a name="l18002"></a>18002         resize(other.size());
<a name="l18003"></a>18003         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.m_iterator), m_size);
<a name="l18004"></a>18004     }
<a name="l18005"></a>18005 
<a name="l18006"></a>18006     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l18007"></a>18007     LITE_INLINE array(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l18008"></a>18008     {
<a name="l18009"></a>18009         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l18010"></a>18010             iterator, 
<a name="l18011"></a>18011             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l18012"></a>18012             assign&lt;value_type&gt; &gt; 
<a name="l18013"></a>18013             iterator_type;
<a name="l18014"></a>18014 
<a name="l18015"></a>18015         init();
<a name="l18016"></a>18016         resize(other.size());
<a name="l18017"></a>18017         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.begin()), m_size);
<a name="l18018"></a>18018     }
<a name="l18019"></a>18019 
<a name="l18020"></a>18020     LITE_INLINE array(<span class="keyword">const</span> value_type&amp; value) 
<a name="l18021"></a>18021     {
<a name="l18022"></a>18022         <span class="keyword">typedef</span> b_iterator&lt;iterator, c_iterator&lt;value_type&gt;, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l18023"></a>18023 
<a name="l18024"></a>18024         init();
<a name="l18025"></a>18025         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, value), m_size);
<a name="l18026"></a>18026     }
<a name="l18027"></a>18027 
<a name="l18028"></a>18028     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> array&amp; other) 
<a name="l18029"></a>18029     {
<a name="l18030"></a>18030         <span class="keyword">typedef</span> b_iterator&lt;iterator, const_iterator, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l18031"></a>18031 
<a name="l18032"></a>18032         resize(other.size());
<a name="l18033"></a>18033         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.m_iterator), m_size);
<a name="l18034"></a>18034         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l18035"></a>18035     }
<a name="l18036"></a>18036 
<a name="l18037"></a>18037     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l18038"></a>18038     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l18039"></a>18039     {
<a name="l18040"></a>18040         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l18041"></a>18041             iterator, 
<a name="l18042"></a>18042             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l18043"></a>18043             assign&lt;value_type&gt; &gt; 
<a name="l18044"></a>18044             iterator_type;
<a name="l18045"></a>18045 
<a name="l18046"></a>18046         resize(other.size());
<a name="l18047"></a>18047         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.begin()), m_size);
<a name="l18048"></a>18048         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l18049"></a>18049     }
<a name="l18050"></a>18050 
<a name="l18051"></a>18051     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> value_type&amp; value)
<a name="l18052"></a>18052     {
<a name="l18053"></a>18053         <span class="keyword">typedef</span> b_iterator&lt;iterator, c_iterator&lt;value_type&gt;, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l18054"></a>18054 
<a name="l18055"></a>18055         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, value), m_size);
<a name="l18056"></a>18056         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l18057"></a>18057     }
<a name="l18058"></a>18058 
<a name="l18059"></a>18059     LITE_INLINE const_iterator begin()<span class="keyword"> const</span>
<a name="l18060"></a>18060 <span class="keyword">    </span>{
<a name="l18061"></a>18061         <span class="keywordflow">return</span> m_iterator;
<a name="l18062"></a>18062     }
<a name="l18063"></a>18063 
<a name="l18064"></a>18064     LITE_INLINE iterator begin()
<a name="l18065"></a>18065     {
<a name="l18066"></a>18066         <span class="keywordflow">return</span> m_iterator;
<a name="l18067"></a>18067     }
<a name="l18068"></a>18068 
<a name="l18069"></a>18069     LITE_INLINE size_type size()<span class="keyword"> const</span>
<a name="l18070"></a>18070 <span class="keyword">    </span>{
<a name="l18071"></a>18071         <span class="keywordflow">return</span> m_size;
<a name="l18072"></a>18072     }
<a name="l18073"></a>18073 
<a name="l18074"></a>18074     LITE_INLINE const_reference 
<a name="l18075"></a>18075     operator()(<span class="keywordtype">int</span> i0, <span class="keywordtype">int</span> i1, <span class="keywordtype">int</span> i2)<span class="keyword"> const</span>
<a name="l18076"></a>18076 <span class="keyword">    </span>{
<a name="l18077"></a>18077         <span class="keywordflow">return</span> *(m_iterator.i0+i0*m_iterator.i1+i1*m_iterator.i2+i2*m_iterator.i3);
<a name="l18078"></a>18078     }
<a name="l18079"></a>18079 
<a name="l18080"></a>18080     LITE_INLINE reference 
<a name="l18081"></a>18081     operator()(<span class="keywordtype">int</span> i0, <span class="keywordtype">int</span> i1, <span class="keywordtype">int</span> i2) 
<a name="l18082"></a>18082     {
<a name="l18083"></a>18083         <span class="keywordflow">return</span> *(m_iterator.i0+i0*m_iterator.i1+i1*m_iterator.i2+i2*m_iterator.i3);
<a name="l18084"></a>18084     }
<a name="l18085"></a>18085 
<a name="l18086"></a>18086 
<a name="l18087"></a>18087     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_&gt;
<a name="l18088"></a>18088     LITE_INLINE <span class="keyword">const</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::const_array
<a name="l18089"></a>18089     operator[](<span class="keyword">const</span> transform_type_&amp; trans)<span class="keyword"> const</span>
<a name="l18090"></a>18090 <span class="keyword">    </span>{
<a name="l18091"></a>18091         <span class="keyword">typedef</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::const_array result_type;
<a name="l18092"></a>18092 
<a name="l18093"></a>18093         <span class="keywordflow">return</span> result_type(begin(), size(), trans);
<a name="l18094"></a>18094     }
<a name="l18095"></a>18095 
<a name="l18096"></a>18096     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_&gt;
<a name="l18097"></a>18097     LITE_INLINE <span class="keyword">const</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::array
<a name="l18098"></a>18098     operator[](<span class="keyword">const</span> transform_type_&amp; trans)
<a name="l18099"></a>18099     {
<a name="l18100"></a>18100         <span class="keyword">typedef</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::array result_type;
<a name="l18101"></a>18101 
<a name="l18102"></a>18102         <span class="keywordflow">return</span> result_type(begin(), size(), trans);
<a name="l18103"></a>18103     }
<a name="l18104"></a>18104 
<a name="l18105"></a>18105     LITE_INLINE <span class="keyword">const</span> value_type* data()<span class="keyword"> const</span>
<a name="l18106"></a>18106 <span class="keyword">    </span>{
<a name="l18107"></a>18107         <span class="keywordflow">return</span> m_iterator.i0;
<a name="l18108"></a>18108     }
<a name="l18109"></a>18109 
<a name="l18110"></a>18110     LITE_INLINE value_type* data()
<a name="l18111"></a>18111     {
<a name="l18112"></a>18112         <span class="keywordflow">return</span> m_iterator.i0;
<a name="l18113"></a>18113     }
<a name="l18114"></a>18114 
<a name="l18115"></a>18115     LITE_INLINE <span class="keywordtype">void</span> release() 
<a name="l18116"></a>18116     {
<a name="l18117"></a>18117         <span class="keywordflow">if</span> (m_iterator.i0 &amp;&amp; m_iterator.i0 != m_buffer)
<a name="l18118"></a>18118             <span class="keyword">delete</span>[] m_iterator.i0;
<a name="l18119"></a>18119 
<a name="l18120"></a>18120         m_iterator.i0 = 0;
<a name="l18121"></a>18121         m_size.set(0, 0, 0);
<a name="l18122"></a>18122     }
<a name="l18123"></a>18123 
<a name="l18124"></a>18124     LITE_INLINE <span class="keywordtype">void</span> resize(<span class="keywordtype">int</span> n0, <span class="keywordtype">int</span> n1, <span class="keywordtype">int</span> n2)
<a name="l18125"></a>18125     {
<a name="l18126"></a>18126         resize(size_type(n0, n1, n2));
<a name="l18127"></a>18127     }
<a name="l18128"></a>18128 
<a name="l18129"></a>18129     LITE_INLINE <span class="keywordtype">void</span> resize(<span class="keyword">const</span> size_type&amp; new_size)
<a name="l18130"></a>18130     {
<a name="l18131"></a>18131         <span class="keywordtype">int</span> old_volumne = <a class="code" href="group__array__operations.html#gae75c2a405afffef6e4b64e7ea1831372" title="Returns the total volume of an array of the size sz.">volume</a>(m_size);
<a name="l18132"></a>18132         <span class="keywordtype">int</span> new_volume = <a class="code" href="group__array__operations.html#gae75c2a405afffef6e4b64e7ea1831372" title="Returns the total volume of an array of the size sz.">volume</a>(new_size);
<a name="l18133"></a>18133 
<a name="l18134"></a>18134         <span class="keywordflow">if</span> (old_volumne != new_volume || m_iterator.i0==0) {
<a name="l18135"></a>18135             <span class="keywordflow">if</span> (m_iterator.i0 &amp;&amp; m_iterator.i0 != m_buffer)
<a name="l18136"></a>18136                 <span class="keyword">delete</span>[] m_iterator.i0;
<a name="l18137"></a>18137             m_iterator.i0 = 0;
<a name="l18138"></a>18138             m_size.set(0, 0, 0);
<a name="l18139"></a>18139 
<a name="l18140"></a>18140             <span class="keywordflow">if</span> (new_volume == 0)
<a name="l18141"></a>18141                 <span class="keywordflow">return</span>;
<a name="l18142"></a>18142 
<a name="l18143"></a>18143             m_iterator.i0 = new_volume &lt;= internal_buffer_size ? m_buffer : <span class="keyword">new</span> value_type[new_volume];
<a name="l18144"></a>18144         }
<a name="l18145"></a>18145         m_size = new_size;
<a name="l18146"></a>18146         m_iterator.set(
<a name="l18147"></a>18147             m_iterator.i0,
<a name="l18148"></a>18148             m_size.i1*m_size.i2,
<a name="l18149"></a>18149             m_size.i2,
<a name="l18150"></a>18150             1
<a name="l18151"></a>18151         );
<a name="l18152"></a>18152     }
<a name="l18153"></a>18153 
<a name="l18154"></a>18154     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l18155"></a>18155     LITE_INLINE <span class="keywordtype">void</span> swap(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l18156"></a>18156     {
<a name="l18157"></a>18157         regular_swap(other);
<a name="l18158"></a>18158     }
<a name="l18159"></a>18159 
<a name="l18160"></a>18160     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l18161"></a>18161     LITE_INLINE <span class="keywordtype">void</span> swap(array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l18162"></a>18162     {
<a name="l18163"></a>18163         regular_swap(other);
<a name="l18164"></a>18164     }
<a name="l18165"></a>18165 
<a name="l18166"></a>18166     LITE_INLINE <span class="keywordtype">void</span> swap(array&amp; other)
<a name="l18167"></a>18167     {
<a name="l18168"></a>18168         <span class="comment">// fast swap</span>
<a name="l18169"></a>18169         <span class="keywordflow">if</span> (m_iterator.i0 != m_buffer &amp;&amp; other.m_iterator.i0 != other.m_buffer) {
<a name="l18170"></a>18170             iterator tmp_iter = other.m_iterator;
<a name="l18171"></a>18171             size_type tmp_size = other.m_size;
<a name="l18172"></a>18172 
<a name="l18173"></a>18173             other.m_iterator = m_iterator;
<a name="l18174"></a>18174             other.m_size = m_size;
<a name="l18175"></a>18175 
<a name="l18176"></a>18176             m_iterator = tmp_iter;
<a name="l18177"></a>18177             m_size = tmp_size;
<a name="l18178"></a>18178         }
<a name="l18179"></a>18179         <span class="keywordflow">else</span>
<a name="l18180"></a>18180             regular_swap(other);
<a name="l18181"></a>18181     }
<a name="l18182"></a>18182 
<a name="l18183"></a>18183 
<a name="l18184"></a>18184     LITE_INLINE ~array() 
<a name="l18185"></a>18185     {
<a name="l18186"></a>18186         <span class="keywordflow">if</span> (m_iterator.i0 &amp;&amp; m_iterator.i0 != m_buffer)
<a name="l18187"></a>18187             <span class="keyword">delete</span>[] m_iterator.i0;
<a name="l18188"></a>18188     }
<a name="l18189"></a>18189 
<a name="l18190"></a>18190 <span class="keyword">private</span>:
<a name="l18191"></a>18191 
<a name="l18192"></a>18192     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_array_&gt;
<a name="l18193"></a>18193     LITE_INLINE <span class="keywordtype">void</span> regular_swap(other_array_&amp; other)
<a name="l18194"></a>18194     {
<a name="l18195"></a>18195         <span class="keyword">typedef</span> b_iterator&lt;iterator, typename other_array_::iterator, swapper&lt;value_type&gt; &gt; iterator_type;
<a name="l18196"></a>18196 
<a name="l18197"></a>18197         <span class="keywordflow">if</span> (m_size == other.size()) 
<a name="l18198"></a>18198             <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.begin()), m_size);
<a name="l18199"></a>18199         <span class="keywordflow">else</span> {
<a name="l18200"></a>18200             <span class="keyword">typename</span> other_array_::temporary_array tmp = other;
<a name="l18201"></a>18201 
<a name="l18202"></a>18202             other = *<span class="keyword">this</span>;
<a name="l18203"></a>18203             *<span class="keyword">this</span> = tmp;
<a name="l18204"></a>18204         }
<a name="l18205"></a>18205     }
<a name="l18206"></a>18206 
<a name="l18207"></a>18207     <span class="comment">//template&lt;typename other_signature_, typename other_traits_type_, typename other_rep_&gt;</span>
<a name="l18208"></a>18208     <span class="comment">//friend class array;</span>
<a name="l18209"></a>18209 
<a name="l18210"></a>18210     LITE_INLINE <span class="keywordtype">void</span> init()
<a name="l18211"></a>18211     {
<a name="l18212"></a>18212         m_iterator.i0 = 0;
<a name="l18213"></a>18213         m_size.set(0, 0, 0);
<a name="l18214"></a>18214         resize(m_size);
<a name="l18215"></a>18215     }
<a name="l18216"></a>18216 
<a name="l18217"></a>18217     iterator m_iterator;
<a name="l18218"></a>18218     size_type m_size;
<a name="l18219"></a>18219     value_type m_buffer[internal_buffer_size &gt;= 1 ? internal_buffer_size : 1];
<a name="l18220"></a>18220 };
<a name="l18221"></a>18221 
<a name="l18222"></a>18222 <span class="comment">/***********************************************************************************************************/</span>
<a name="l18223"></a>18223 
<a name="l18224"></a>18224 <span class="keyword">template</span>&lt;
<a name="l18225"></a>18225     <span class="keyword">typename</span> value_type_,
<a name="l18226"></a>18226     <span class="keyword">typename</span> traits_type_,
<a name="l18227"></a>18227     <span class="keywordtype">int</span> internal_buf_size_
<a name="l18228"></a>18228     &gt;
<a name="l18229"></a>18229 <span class="keyword">class </span>array&lt;
<a name="l18230"></a>18230     value_type_,
<a name="l18231"></a>18231     traits_type_,
<a name="l18232"></a>18232     hybrid_rep&lt;true, internal_buf_size_&gt;
<a name="l18233"></a>18233     &gt;
<a name="l18234"></a>18234 {
<a name="l18235"></a>18235 <span class="keyword">public</span>:
<a name="l18236"></a>18236     <span class="keyword">typedef</span> value_type_ signature;
<a name="l18237"></a>18237     <span class="keyword">typedef</span> traits_type_ traits_type;
<a name="l18238"></a>18238     <span class="keyword">typedef</span> value_type_ value_type;
<a name="l18239"></a>18239     <span class="keyword">typedef</span> <span class="keyword">const</span> value_type_&amp; const_reference;
<a name="l18240"></a>18240     <span class="keyword">typedef</span> value_type_&amp; reference;
<a name="l18241"></a>18241 
<a name="l18242"></a>18242     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;const signature&gt;::default_rev_iterator const_iterator;
<a name="l18243"></a>18243     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;signature&gt;::default_rev_iterator iterator;
<a name="l18244"></a>18244     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;signature&gt;::size_type size_type;
<a name="l18245"></a>18245 
<a name="l18246"></a>18246     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::temporary_array temporary_array;
<a name="l18247"></a>18247     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::fwd_temporary_array fwd_temporary_array;
<a name="l18248"></a>18248     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::rev_temporary_array rev_temporary_array;
<a name="l18249"></a>18249 
<a name="l18250"></a>18250     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> dimensions = 0;
<a name="l18251"></a>18251     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_reverse = <span class="keyword">true</span>;
<a name="l18252"></a>18252     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> internal_buffer_size = internal_buf_size_;
<a name="l18253"></a>18253 
<a name="l18254"></a>18254 
<a name="l18255"></a>18255 
<a name="l18256"></a>18256     <span class="keyword">explicit</span> LITE_INLINE array(<span class="keyword">const</span> size_type&amp; sz)
<a name="l18257"></a>18257     {
<a name="l18258"></a>18258         init();
<a name="l18259"></a>18259         resize(sz);
<a name="l18260"></a>18260     }
<a name="l18261"></a>18261 
<a name="l18262"></a>18262     LITE_INLINE array(<span class="keyword">const</span> array&amp; other) 
<a name="l18263"></a>18263     {
<a name="l18264"></a>18264         <span class="keyword">typedef</span> b_iterator&lt;iterator, const_iterator, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l18265"></a>18265 
<a name="l18266"></a>18266         init();
<a name="l18267"></a>18267         resize(other.size());
<a name="l18268"></a>18268         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.m_iterator), m_size);
<a name="l18269"></a>18269     }
<a name="l18270"></a>18270 
<a name="l18271"></a>18271     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l18272"></a>18272     LITE_INLINE array(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l18273"></a>18273     {
<a name="l18274"></a>18274         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l18275"></a>18275             iterator, 
<a name="l18276"></a>18276             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l18277"></a>18277             assign&lt;value_type&gt; &gt; 
<a name="l18278"></a>18278             iterator_type;
<a name="l18279"></a>18279 
<a name="l18280"></a>18280         init();
<a name="l18281"></a>18281         resize(other.size());
<a name="l18282"></a>18282         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.begin()), m_size);
<a name="l18283"></a>18283     }
<a name="l18284"></a>18284 
<a name="l18285"></a>18285     LITE_INLINE array(<span class="keyword">const</span> value_type&amp; value) 
<a name="l18286"></a>18286     {
<a name="l18287"></a>18287         <span class="keyword">typedef</span> b_iterator&lt;iterator, c_iterator&lt;value_type&gt;, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l18288"></a>18288 
<a name="l18289"></a>18289         init();
<a name="l18290"></a>18290         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, value), m_size);
<a name="l18291"></a>18291     }
<a name="l18292"></a>18292 
<a name="l18293"></a>18293     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> array&amp; other) 
<a name="l18294"></a>18294     {
<a name="l18295"></a>18295         <span class="keyword">typedef</span> b_iterator&lt;iterator, const_iterator, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l18296"></a>18296 
<a name="l18297"></a>18297         resize(other.size());
<a name="l18298"></a>18298         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.m_iterator), m_size);
<a name="l18299"></a>18299         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l18300"></a>18300     }
<a name="l18301"></a>18301 
<a name="l18302"></a>18302     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l18303"></a>18303     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l18304"></a>18304     {
<a name="l18305"></a>18305         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l18306"></a>18306             iterator, 
<a name="l18307"></a>18307             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l18308"></a>18308             assign&lt;value_type&gt; &gt; 
<a name="l18309"></a>18309             iterator_type;
<a name="l18310"></a>18310 
<a name="l18311"></a>18311         resize(other.size());
<a name="l18312"></a>18312         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.begin()), m_size);
<a name="l18313"></a>18313         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l18314"></a>18314     }
<a name="l18315"></a>18315 
<a name="l18316"></a>18316     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> value_type&amp; value)
<a name="l18317"></a>18317     {
<a name="l18318"></a>18318         <span class="keyword">typedef</span> b_iterator&lt;iterator, c_iterator&lt;value_type&gt;, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l18319"></a>18319 
<a name="l18320"></a>18320         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, value), m_size);
<a name="l18321"></a>18321         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l18322"></a>18322     }
<a name="l18323"></a>18323 
<a name="l18324"></a>18324     LITE_INLINE const_iterator begin()<span class="keyword"> const</span>
<a name="l18325"></a>18325 <span class="keyword">    </span>{
<a name="l18326"></a>18326         <span class="keywordflow">return</span> m_iterator;
<a name="l18327"></a>18327     }
<a name="l18328"></a>18328 
<a name="l18329"></a>18329     LITE_INLINE iterator begin()
<a name="l18330"></a>18330     {
<a name="l18331"></a>18331         <span class="keywordflow">return</span> m_iterator;
<a name="l18332"></a>18332     }
<a name="l18333"></a>18333 
<a name="l18334"></a>18334     LITE_INLINE size_type size()<span class="keyword"> const</span>
<a name="l18335"></a>18335 <span class="keyword">    </span>{
<a name="l18336"></a>18336         <span class="keywordflow">return</span> m_size;
<a name="l18337"></a>18337     }
<a name="l18338"></a>18338 
<a name="l18339"></a>18339     LITE_INLINE const_reference 
<a name="l18340"></a>18340     operator()()<span class="keyword"> const</span>
<a name="l18341"></a>18341 <span class="keyword">    </span>{
<a name="l18342"></a>18342         <span class="keywordflow">return</span> *(m_iterator.i0);
<a name="l18343"></a>18343     }
<a name="l18344"></a>18344 
<a name="l18345"></a>18345     LITE_INLINE reference 
<a name="l18346"></a>18346     operator()() 
<a name="l18347"></a>18347     {
<a name="l18348"></a>18348         <span class="keywordflow">return</span> *(m_iterator.i0);
<a name="l18349"></a>18349     }
<a name="l18350"></a>18350 
<a name="l18351"></a>18351 
<a name="l18352"></a>18352     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_&gt;
<a name="l18353"></a>18353     LITE_INLINE <span class="keyword">const</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::const_array
<a name="l18354"></a>18354     operator[](<span class="keyword">const</span> transform_type_&amp; trans)<span class="keyword"> const</span>
<a name="l18355"></a>18355 <span class="keyword">    </span>{
<a name="l18356"></a>18356         <span class="keyword">typedef</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::const_array result_type;
<a name="l18357"></a>18357 
<a name="l18358"></a>18358         <span class="keywordflow">return</span> result_type(begin(), size(), trans);
<a name="l18359"></a>18359     }
<a name="l18360"></a>18360 
<a name="l18361"></a>18361     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_&gt;
<a name="l18362"></a>18362     LITE_INLINE <span class="keyword">const</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::array
<a name="l18363"></a>18363     operator[](<span class="keyword">const</span> transform_type_&amp; trans)
<a name="l18364"></a>18364     {
<a name="l18365"></a>18365         <span class="keyword">typedef</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::array result_type;
<a name="l18366"></a>18366 
<a name="l18367"></a>18367         <span class="keywordflow">return</span> result_type(begin(), size(), trans);
<a name="l18368"></a>18368     }
<a name="l18369"></a>18369 
<a name="l18370"></a>18370     LITE_INLINE <span class="keyword">const</span> value_type* data()<span class="keyword"> const</span>
<a name="l18371"></a>18371 <span class="keyword">    </span>{
<a name="l18372"></a>18372         <span class="keywordflow">return</span> m_iterator.i0;
<a name="l18373"></a>18373     }
<a name="l18374"></a>18374 
<a name="l18375"></a>18375     LITE_INLINE value_type* data()
<a name="l18376"></a>18376     {
<a name="l18377"></a>18377         <span class="keywordflow">return</span> m_iterator.i0;
<a name="l18378"></a>18378     }
<a name="l18379"></a>18379 
<a name="l18380"></a>18380     LITE_INLINE <span class="keywordtype">void</span> release() 
<a name="l18381"></a>18381     {
<a name="l18382"></a>18382         <span class="keywordflow">if</span> (m_iterator.i0 &amp;&amp; m_iterator.i0 != m_buffer)
<a name="l18383"></a>18383             <span class="keyword">delete</span>[] m_iterator.i0;
<a name="l18384"></a>18384 
<a name="l18385"></a>18385         m_iterator.i0 = 0;
<a name="l18386"></a>18386         m_size.set();
<a name="l18387"></a>18387     }
<a name="l18388"></a>18388 
<a name="l18389"></a>18389     LITE_INLINE <span class="keywordtype">void</span> resize()
<a name="l18390"></a>18390     {
<a name="l18391"></a>18391         resize(size_type());
<a name="l18392"></a>18392     }
<a name="l18393"></a>18393 
<a name="l18394"></a>18394     LITE_INLINE <span class="keywordtype">void</span> resize(<span class="keyword">const</span> size_type&amp; new_size)
<a name="l18395"></a>18395     {
<a name="l18396"></a>18396         <span class="keywordtype">int</span> old_volumne = <a class="code" href="group__array__operations.html#gae75c2a405afffef6e4b64e7ea1831372" title="Returns the total volume of an array of the size sz.">volume</a>(m_size);
<a name="l18397"></a>18397         <span class="keywordtype">int</span> new_volume = <a class="code" href="group__array__operations.html#gae75c2a405afffef6e4b64e7ea1831372" title="Returns the total volume of an array of the size sz.">volume</a>(new_size);
<a name="l18398"></a>18398 
<a name="l18399"></a>18399         <span class="keywordflow">if</span> (old_volumne != new_volume || m_iterator.i0==0) {
<a name="l18400"></a>18400             <span class="keywordflow">if</span> (m_iterator.i0 &amp;&amp; m_iterator.i0 != m_buffer)
<a name="l18401"></a>18401                 <span class="keyword">delete</span>[] m_iterator.i0;
<a name="l18402"></a>18402             m_iterator.i0 = 0;
<a name="l18403"></a>18403             m_size.set();
<a name="l18404"></a>18404 
<a name="l18405"></a>18405             <span class="keywordflow">if</span> (new_volume == 0)
<a name="l18406"></a>18406                 <span class="keywordflow">return</span>;
<a name="l18407"></a>18407 
<a name="l18408"></a>18408             m_iterator.i0 = new_volume &lt;= internal_buffer_size ? m_buffer : <span class="keyword">new</span> value_type[new_volume];
<a name="l18409"></a>18409         }
<a name="l18410"></a>18410         m_size = new_size;
<a name="l18411"></a>18411         m_iterator.set(
<a name="l18412"></a>18412             m_iterator.i0
<a name="l18413"></a>18413         );
<a name="l18414"></a>18414     }
<a name="l18415"></a>18415 
<a name="l18416"></a>18416     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l18417"></a>18417     LITE_INLINE <span class="keywordtype">void</span> swap(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l18418"></a>18418     {
<a name="l18419"></a>18419         regular_swap(other);
<a name="l18420"></a>18420     }
<a name="l18421"></a>18421 
<a name="l18422"></a>18422     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l18423"></a>18423     LITE_INLINE <span class="keywordtype">void</span> swap(array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l18424"></a>18424     {
<a name="l18425"></a>18425         regular_swap(other);
<a name="l18426"></a>18426     }
<a name="l18427"></a>18427 
<a name="l18428"></a>18428     LITE_INLINE <span class="keywordtype">void</span> swap(array&amp; other)
<a name="l18429"></a>18429     {
<a name="l18430"></a>18430         <span class="comment">// fast swap</span>
<a name="l18431"></a>18431         <span class="keywordflow">if</span> (m_iterator.i0 != m_buffer &amp;&amp; other.m_iterator.i0 != other.m_buffer) {
<a name="l18432"></a>18432             iterator tmp_iter = other.m_iterator;
<a name="l18433"></a>18433             size_type tmp_size = other.m_size;
<a name="l18434"></a>18434 
<a name="l18435"></a>18435             other.m_iterator = m_iterator;
<a name="l18436"></a>18436             other.m_size = m_size;
<a name="l18437"></a>18437 
<a name="l18438"></a>18438             m_iterator = tmp_iter;
<a name="l18439"></a>18439             m_size = tmp_size;
<a name="l18440"></a>18440         }
<a name="l18441"></a>18441         <span class="keywordflow">else</span>
<a name="l18442"></a>18442             regular_swap(other);
<a name="l18443"></a>18443     }
<a name="l18444"></a>18444 
<a name="l18445"></a>18445 
<a name="l18446"></a>18446     LITE_INLINE ~array() 
<a name="l18447"></a>18447     {
<a name="l18448"></a>18448         <span class="keywordflow">if</span> (m_iterator.i0 &amp;&amp; m_iterator.i0 != m_buffer)
<a name="l18449"></a>18449             <span class="keyword">delete</span>[] m_iterator.i0;
<a name="l18450"></a>18450     }
<a name="l18451"></a>18451 
<a name="l18452"></a>18452 <span class="keyword">private</span>:
<a name="l18453"></a>18453 
<a name="l18454"></a>18454     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_array_&gt;
<a name="l18455"></a>18455     LITE_INLINE <span class="keywordtype">void</span> regular_swap(other_array_&amp; other)
<a name="l18456"></a>18456     {
<a name="l18457"></a>18457         <span class="keyword">typedef</span> b_iterator&lt;iterator, typename other_array_::iterator, swapper&lt;value_type&gt; &gt; iterator_type;
<a name="l18458"></a>18458 
<a name="l18459"></a>18459         <span class="keywordflow">if</span> (m_size == other.size()) 
<a name="l18460"></a>18460             <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.begin()), m_size);
<a name="l18461"></a>18461         <span class="keywordflow">else</span> {
<a name="l18462"></a>18462             <span class="keyword">typename</span> other_array_::temporary_array tmp = other;
<a name="l18463"></a>18463 
<a name="l18464"></a>18464             other = *<span class="keyword">this</span>;
<a name="l18465"></a>18465             *<span class="keyword">this</span> = tmp;
<a name="l18466"></a>18466         }
<a name="l18467"></a>18467     }
<a name="l18468"></a>18468 
<a name="l18469"></a>18469     <span class="comment">//template&lt;typename other_signature_, typename other_traits_type_, typename other_rep_&gt;</span>
<a name="l18470"></a>18470     <span class="comment">//friend class array;</span>
<a name="l18471"></a>18471 
<a name="l18472"></a>18472     LITE_INLINE <span class="keywordtype">void</span> init()
<a name="l18473"></a>18473     {
<a name="l18474"></a>18474         m_iterator.i0 = 0;
<a name="l18475"></a>18475         m_size.set();
<a name="l18476"></a>18476         resize(m_size);
<a name="l18477"></a>18477     }
<a name="l18478"></a>18478 
<a name="l18479"></a>18479     iterator m_iterator;
<a name="l18480"></a>18480     size_type m_size;
<a name="l18481"></a>18481     value_type m_buffer[internal_buffer_size &gt;= 1 ? internal_buffer_size : 1];
<a name="l18482"></a>18482 };
<a name="l18483"></a>18483 
<a name="l18484"></a>18484 <span class="comment">/***********************************************************************************************************/</span>
<a name="l18485"></a>18485 
<a name="l18486"></a>18486 <span class="keyword">template</span>&lt;
<a name="l18487"></a>18487     <span class="keyword">typename</span> value_type_,
<a name="l18488"></a>18488     <span class="keywordtype">int</span> n0_, 
<a name="l18489"></a>18489     <span class="keyword">typename</span> traits_type_,
<a name="l18490"></a>18490     <span class="keywordtype">int</span> internal_buf_size_
<a name="l18491"></a>18491     &gt;
<a name="l18492"></a>18492 <span class="keyword">class </span>array&lt;
<a name="l18493"></a>18493     value_type_[n0_],
<a name="l18494"></a>18494     traits_type_,
<a name="l18495"></a>18495     hybrid_rep&lt;true, internal_buf_size_&gt;
<a name="l18496"></a>18496     &gt;
<a name="l18497"></a>18497 {
<a name="l18498"></a>18498 <span class="keyword">public</span>:
<a name="l18499"></a>18499     <span class="keyword">typedef</span> value_type_ signature[n0_];
<a name="l18500"></a>18500     <span class="keyword">typedef</span> traits_type_ traits_type;
<a name="l18501"></a>18501     <span class="keyword">typedef</span> value_type_ value_type;
<a name="l18502"></a>18502     <span class="keyword">typedef</span> <span class="keyword">const</span> value_type_&amp; const_reference;
<a name="l18503"></a>18503     <span class="keyword">typedef</span> value_type_&amp; reference;
<a name="l18504"></a>18504 
<a name="l18505"></a>18505     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;const signature&gt;::default_rev_iterator const_iterator;
<a name="l18506"></a>18506     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;signature&gt;::default_rev_iterator iterator;
<a name="l18507"></a>18507     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;signature&gt;::size_type size_type;
<a name="l18508"></a>18508 
<a name="l18509"></a>18509     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::temporary_array temporary_array;
<a name="l18510"></a>18510     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::fwd_temporary_array fwd_temporary_array;
<a name="l18511"></a>18511     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::rev_temporary_array rev_temporary_array;
<a name="l18512"></a>18512 
<a name="l18513"></a>18513     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> dimensions = 1;
<a name="l18514"></a>18514     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_reverse = <span class="keyword">true</span>;
<a name="l18515"></a>18515     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> internal_buffer_size = internal_buf_size_;
<a name="l18516"></a>18516 
<a name="l18517"></a>18517     LITE_INLINE array() 
<a name="l18518"></a>18518     {
<a name="l18519"></a>18519         init();
<a name="l18520"></a>18520         resize(size_type());
<a name="l18521"></a>18521     }
<a name="l18522"></a>18522 
<a name="l18523"></a>18523     <span class="keyword">explicit</span> LITE_INLINE array(<span class="keywordtype">int</span> n0)
<a name="l18524"></a>18524     {
<a name="l18525"></a>18525         init();
<a name="l18526"></a>18526         resize(size_type(n0));
<a name="l18527"></a>18527     }
<a name="l18528"></a>18528 
<a name="l18529"></a>18529     <span class="keyword">explicit</span> LITE_INLINE array(<span class="keyword">const</span> size_type&amp; sz)
<a name="l18530"></a>18530     {
<a name="l18531"></a>18531         init();
<a name="l18532"></a>18532         resize(sz);
<a name="l18533"></a>18533     }
<a name="l18534"></a>18534 
<a name="l18535"></a>18535     LITE_INLINE array(<span class="keyword">const</span> array&amp; other) 
<a name="l18536"></a>18536     {
<a name="l18537"></a>18537         <span class="keyword">typedef</span> b_iterator&lt;iterator, const_iterator, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l18538"></a>18538 
<a name="l18539"></a>18539         init();
<a name="l18540"></a>18540         resize(other.size());
<a name="l18541"></a>18541         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.m_iterator), m_size);
<a name="l18542"></a>18542     }
<a name="l18543"></a>18543 
<a name="l18544"></a>18544     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l18545"></a>18545     LITE_INLINE array(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l18546"></a>18546     {
<a name="l18547"></a>18547         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l18548"></a>18548             iterator, 
<a name="l18549"></a>18549             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l18550"></a>18550             assign&lt;value_type&gt; &gt; 
<a name="l18551"></a>18551             iterator_type;
<a name="l18552"></a>18552 
<a name="l18553"></a>18553         init();
<a name="l18554"></a>18554         resize(other.size());
<a name="l18555"></a>18555         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.begin()), m_size);
<a name="l18556"></a>18556     }
<a name="l18557"></a>18557 
<a name="l18558"></a>18558     LITE_INLINE array(<span class="keyword">const</span> value_type&amp; value) 
<a name="l18559"></a>18559     {
<a name="l18560"></a>18560         <span class="keyword">typedef</span> b_iterator&lt;iterator, c_iterator&lt;value_type&gt;, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l18561"></a>18561 
<a name="l18562"></a>18562         init();
<a name="l18563"></a>18563         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, value), m_size);
<a name="l18564"></a>18564     }
<a name="l18565"></a>18565 
<a name="l18566"></a>18566     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> array&amp; other) 
<a name="l18567"></a>18567     {
<a name="l18568"></a>18568         <span class="keyword">typedef</span> b_iterator&lt;iterator, const_iterator, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l18569"></a>18569 
<a name="l18570"></a>18570         resize(other.size());
<a name="l18571"></a>18571         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.m_iterator), m_size);
<a name="l18572"></a>18572         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l18573"></a>18573     }
<a name="l18574"></a>18574 
<a name="l18575"></a>18575     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l18576"></a>18576     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l18577"></a>18577     {
<a name="l18578"></a>18578         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l18579"></a>18579             iterator, 
<a name="l18580"></a>18580             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l18581"></a>18581             assign&lt;value_type&gt; &gt; 
<a name="l18582"></a>18582             iterator_type;
<a name="l18583"></a>18583 
<a name="l18584"></a>18584         resize(other.size());
<a name="l18585"></a>18585         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.begin()), m_size);
<a name="l18586"></a>18586         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l18587"></a>18587     }
<a name="l18588"></a>18588 
<a name="l18589"></a>18589     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> value_type&amp; value)
<a name="l18590"></a>18590     {
<a name="l18591"></a>18591         <span class="keyword">typedef</span> b_iterator&lt;iterator, c_iterator&lt;value_type&gt;, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l18592"></a>18592 
<a name="l18593"></a>18593         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, value), m_size);
<a name="l18594"></a>18594         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l18595"></a>18595     }
<a name="l18596"></a>18596 
<a name="l18597"></a>18597     LITE_INLINE const_iterator begin()<span class="keyword"> const</span>
<a name="l18598"></a>18598 <span class="keyword">    </span>{
<a name="l18599"></a>18599         <span class="keywordflow">return</span> m_iterator;
<a name="l18600"></a>18600     }
<a name="l18601"></a>18601 
<a name="l18602"></a>18602     LITE_INLINE iterator begin()
<a name="l18603"></a>18603     {
<a name="l18604"></a>18604         <span class="keywordflow">return</span> m_iterator;
<a name="l18605"></a>18605     }
<a name="l18606"></a>18606 
<a name="l18607"></a>18607     LITE_INLINE size_type size()<span class="keyword"> const</span>
<a name="l18608"></a>18608 <span class="keyword">    </span>{
<a name="l18609"></a>18609         <span class="keywordflow">return</span> m_size;
<a name="l18610"></a>18610     }
<a name="l18611"></a>18611 
<a name="l18612"></a>18612     LITE_INLINE const_reference 
<a name="l18613"></a>18613     operator()(<span class="keywordtype">int</span> i0)<span class="keyword"> const</span>
<a name="l18614"></a>18614 <span class="keyword">    </span>{
<a name="l18615"></a>18615         <span class="keywordflow">return</span> *(m_iterator.i0+i0*m_iterator.i1);
<a name="l18616"></a>18616     }
<a name="l18617"></a>18617 
<a name="l18618"></a>18618     LITE_INLINE reference 
<a name="l18619"></a>18619     operator()(<span class="keywordtype">int</span> i0) 
<a name="l18620"></a>18620     {
<a name="l18621"></a>18621         <span class="keywordflow">return</span> *(m_iterator.i0+i0*m_iterator.i1);
<a name="l18622"></a>18622     }
<a name="l18623"></a>18623 
<a name="l18624"></a>18624     LITE_INLINE const_reference 
<a name="l18625"></a>18625     operator[](<span class="keywordtype">int</span> i0)<span class="keyword"> const</span>
<a name="l18626"></a>18626 <span class="keyword">    </span>{
<a name="l18627"></a>18627         <span class="keywordflow">return</span> *(m_iterator.i0+i0*m_iterator.i1);
<a name="l18628"></a>18628     }
<a name="l18629"></a>18629 
<a name="l18630"></a>18630     LITE_INLINE reference 
<a name="l18631"></a>18631     operator[](<span class="keywordtype">int</span> i0)
<a name="l18632"></a>18632     {
<a name="l18633"></a>18633         <span class="keywordflow">return</span> *(m_iterator.i0+i0*m_iterator.i1);
<a name="l18634"></a>18634     }
<a name="l18635"></a>18635 
<a name="l18636"></a>18636 
<a name="l18637"></a>18637     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_&gt;
<a name="l18638"></a>18638     LITE_INLINE <span class="keyword">const</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::const_array
<a name="l18639"></a>18639     operator[](<span class="keyword">const</span> transform_type_&amp; trans)<span class="keyword"> const</span>
<a name="l18640"></a>18640 <span class="keyword">    </span>{
<a name="l18641"></a>18641         <span class="keyword">typedef</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::const_array result_type;
<a name="l18642"></a>18642 
<a name="l18643"></a>18643         <span class="keywordflow">return</span> result_type(begin(), size(), trans);
<a name="l18644"></a>18644     }
<a name="l18645"></a>18645 
<a name="l18646"></a>18646     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_&gt;
<a name="l18647"></a>18647     LITE_INLINE <span class="keyword">const</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::array
<a name="l18648"></a>18648     operator[](<span class="keyword">const</span> transform_type_&amp; trans)
<a name="l18649"></a>18649     {
<a name="l18650"></a>18650         <span class="keyword">typedef</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::array result_type;
<a name="l18651"></a>18651 
<a name="l18652"></a>18652         <span class="keywordflow">return</span> result_type(begin(), size(), trans);
<a name="l18653"></a>18653     }
<a name="l18654"></a>18654 
<a name="l18655"></a>18655     LITE_INLINE <span class="keyword">const</span> value_type* data()<span class="keyword"> const</span>
<a name="l18656"></a>18656 <span class="keyword">    </span>{
<a name="l18657"></a>18657         <span class="keywordflow">return</span> m_iterator.i0;
<a name="l18658"></a>18658     }
<a name="l18659"></a>18659 
<a name="l18660"></a>18660     LITE_INLINE value_type* data()
<a name="l18661"></a>18661     {
<a name="l18662"></a>18662         <span class="keywordflow">return</span> m_iterator.i0;
<a name="l18663"></a>18663     }
<a name="l18664"></a>18664 
<a name="l18665"></a>18665     LITE_INLINE <span class="keywordtype">void</span> release() 
<a name="l18666"></a>18666     {
<a name="l18667"></a>18667         <span class="keywordflow">if</span> (m_iterator.i0 &amp;&amp; m_iterator.i0 != m_buffer)
<a name="l18668"></a>18668             <span class="keyword">delete</span>[] m_iterator.i0;
<a name="l18669"></a>18669 
<a name="l18670"></a>18670         m_iterator.i0 = 0;
<a name="l18671"></a>18671         m_size.set(0);
<a name="l18672"></a>18672     }
<a name="l18673"></a>18673 
<a name="l18674"></a>18674     LITE_INLINE <span class="keywordtype">void</span> resize(<span class="keywordtype">int</span> n0)
<a name="l18675"></a>18675     {
<a name="l18676"></a>18676         resize(size_type(n0));
<a name="l18677"></a>18677     }
<a name="l18678"></a>18678 
<a name="l18679"></a>18679     LITE_INLINE <span class="keywordtype">void</span> resize(<span class="keyword">const</span> size_type&amp; new_size)
<a name="l18680"></a>18680     {
<a name="l18681"></a>18681         <span class="keywordtype">int</span> old_volumne = <a class="code" href="group__array__operations.html#gae75c2a405afffef6e4b64e7ea1831372" title="Returns the total volume of an array of the size sz.">volume</a>(m_size);
<a name="l18682"></a>18682         <span class="keywordtype">int</span> new_volume = <a class="code" href="group__array__operations.html#gae75c2a405afffef6e4b64e7ea1831372" title="Returns the total volume of an array of the size sz.">volume</a>(new_size);
<a name="l18683"></a>18683 
<a name="l18684"></a>18684         <span class="keywordflow">if</span> (old_volumne != new_volume || m_iterator.i0==0) {
<a name="l18685"></a>18685             <span class="keywordflow">if</span> (m_iterator.i0 &amp;&amp; m_iterator.i0 != m_buffer)
<a name="l18686"></a>18686                 <span class="keyword">delete</span>[] m_iterator.i0;
<a name="l18687"></a>18687             m_iterator.i0 = 0;
<a name="l18688"></a>18688             m_size.set(0);
<a name="l18689"></a>18689 
<a name="l18690"></a>18690             <span class="keywordflow">if</span> (new_volume == 0)
<a name="l18691"></a>18691                 <span class="keywordflow">return</span>;
<a name="l18692"></a>18692 
<a name="l18693"></a>18693             m_iterator.i0 = new_volume &lt;= internal_buffer_size ? m_buffer : <span class="keyword">new</span> value_type[new_volume];
<a name="l18694"></a>18694         }
<a name="l18695"></a>18695         m_size = new_size;
<a name="l18696"></a>18696         m_iterator.set(
<a name="l18697"></a>18697             m_iterator.i0,
<a name="l18698"></a>18698             1
<a name="l18699"></a>18699         );
<a name="l18700"></a>18700     }
<a name="l18701"></a>18701 
<a name="l18702"></a>18702     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l18703"></a>18703     LITE_INLINE <span class="keywordtype">void</span> swap(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l18704"></a>18704     {
<a name="l18705"></a>18705         regular_swap(other);
<a name="l18706"></a>18706     }
<a name="l18707"></a>18707 
<a name="l18708"></a>18708     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l18709"></a>18709     LITE_INLINE <span class="keywordtype">void</span> swap(array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l18710"></a>18710     {
<a name="l18711"></a>18711         regular_swap(other);
<a name="l18712"></a>18712     }
<a name="l18713"></a>18713 
<a name="l18714"></a>18714     LITE_INLINE <span class="keywordtype">void</span> swap(array&amp; other)
<a name="l18715"></a>18715     {
<a name="l18716"></a>18716         <span class="comment">// fast swap</span>
<a name="l18717"></a>18717         <span class="keywordflow">if</span> (m_iterator.i0 != m_buffer &amp;&amp; other.m_iterator.i0 != other.m_buffer) {
<a name="l18718"></a>18718             iterator tmp_iter = other.m_iterator;
<a name="l18719"></a>18719             size_type tmp_size = other.m_size;
<a name="l18720"></a>18720 
<a name="l18721"></a>18721             other.m_iterator = m_iterator;
<a name="l18722"></a>18722             other.m_size = m_size;
<a name="l18723"></a>18723 
<a name="l18724"></a>18724             m_iterator = tmp_iter;
<a name="l18725"></a>18725             m_size = tmp_size;
<a name="l18726"></a>18726         }
<a name="l18727"></a>18727         <span class="keywordflow">else</span>
<a name="l18728"></a>18728             regular_swap(other);
<a name="l18729"></a>18729     }
<a name="l18730"></a>18730 
<a name="l18731"></a>18731 
<a name="l18732"></a>18732     LITE_INLINE ~array() 
<a name="l18733"></a>18733     {
<a name="l18734"></a>18734         <span class="keywordflow">if</span> (m_iterator.i0 &amp;&amp; m_iterator.i0 != m_buffer)
<a name="l18735"></a>18735             <span class="keyword">delete</span>[] m_iterator.i0;
<a name="l18736"></a>18736     }
<a name="l18737"></a>18737 
<a name="l18738"></a>18738 <span class="keyword">private</span>:
<a name="l18739"></a>18739 
<a name="l18740"></a>18740     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_array_&gt;
<a name="l18741"></a>18741     LITE_INLINE <span class="keywordtype">void</span> regular_swap(other_array_&amp; other)
<a name="l18742"></a>18742     {
<a name="l18743"></a>18743         <span class="keyword">typedef</span> b_iterator&lt;iterator, typename other_array_::iterator, swapper&lt;value_type&gt; &gt; iterator_type;
<a name="l18744"></a>18744 
<a name="l18745"></a>18745         <span class="keywordflow">if</span> (m_size == other.size()) 
<a name="l18746"></a>18746             <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.begin()), m_size);
<a name="l18747"></a>18747         <span class="keywordflow">else</span> {
<a name="l18748"></a>18748             <span class="keyword">typename</span> other_array_::temporary_array tmp = other;
<a name="l18749"></a>18749 
<a name="l18750"></a>18750             other = *<span class="keyword">this</span>;
<a name="l18751"></a>18751             *<span class="keyword">this</span> = tmp;
<a name="l18752"></a>18752         }
<a name="l18753"></a>18753     }
<a name="l18754"></a>18754 
<a name="l18755"></a>18755     <span class="comment">//template&lt;typename other_signature_, typename other_traits_type_, typename other_rep_&gt;</span>
<a name="l18756"></a>18756     <span class="comment">//friend class array;</span>
<a name="l18757"></a>18757 
<a name="l18758"></a>18758     LITE_INLINE <span class="keywordtype">void</span> init()
<a name="l18759"></a>18759     {
<a name="l18760"></a>18760         m_iterator.i0 = 0;
<a name="l18761"></a>18761         m_size.set(0);
<a name="l18762"></a>18762         resize(m_size);
<a name="l18763"></a>18763     }
<a name="l18764"></a>18764 
<a name="l18765"></a>18765     iterator m_iterator;
<a name="l18766"></a>18766     size_type m_size;
<a name="l18767"></a>18767     value_type m_buffer[internal_buffer_size &gt;= 1 ? internal_buffer_size : 1];
<a name="l18768"></a>18768 };
<a name="l18769"></a>18769 
<a name="l18770"></a>18770 <span class="comment">/***********************************************************************************************************/</span>
<a name="l18771"></a>18771 
<a name="l18772"></a>18772 <span class="keyword">template</span>&lt;
<a name="l18773"></a>18773     <span class="keyword">typename</span> value_type_,
<a name="l18774"></a>18774     <span class="keywordtype">int</span> n0_, 
<a name="l18775"></a>18775     <span class="keywordtype">int</span> n1_, 
<a name="l18776"></a>18776     <span class="keyword">typename</span> traits_type_,
<a name="l18777"></a>18777     <span class="keywordtype">int</span> internal_buf_size_
<a name="l18778"></a>18778     &gt;
<a name="l18779"></a>18779 <span class="keyword">class </span>array&lt;
<a name="l18780"></a>18780     value_type_[n0_][n1_],
<a name="l18781"></a>18781     traits_type_,
<a name="l18782"></a>18782     hybrid_rep&lt;true, internal_buf_size_&gt;
<a name="l18783"></a>18783     &gt;
<a name="l18784"></a>18784 {
<a name="l18785"></a>18785 <span class="keyword">public</span>:
<a name="l18786"></a>18786     <span class="keyword">typedef</span> value_type_ signature[n0_][n1_];
<a name="l18787"></a>18787     <span class="keyword">typedef</span> traits_type_ traits_type;
<a name="l18788"></a>18788     <span class="keyword">typedef</span> value_type_ value_type;
<a name="l18789"></a>18789     <span class="keyword">typedef</span> <span class="keyword">const</span> value_type_&amp; const_reference;
<a name="l18790"></a>18790     <span class="keyword">typedef</span> value_type_&amp; reference;
<a name="l18791"></a>18791 
<a name="l18792"></a>18792     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;const signature&gt;::default_rev_iterator const_iterator;
<a name="l18793"></a>18793     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;signature&gt;::default_rev_iterator iterator;
<a name="l18794"></a>18794     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;signature&gt;::size_type size_type;
<a name="l18795"></a>18795 
<a name="l18796"></a>18796     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::temporary_array temporary_array;
<a name="l18797"></a>18797     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::fwd_temporary_array fwd_temporary_array;
<a name="l18798"></a>18798     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::rev_temporary_array rev_temporary_array;
<a name="l18799"></a>18799 
<a name="l18800"></a>18800     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> dimensions = 2;
<a name="l18801"></a>18801     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_reverse = <span class="keyword">true</span>;
<a name="l18802"></a>18802     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> internal_buffer_size = internal_buf_size_;
<a name="l18803"></a>18803 
<a name="l18804"></a>18804     LITE_INLINE array() 
<a name="l18805"></a>18805     {
<a name="l18806"></a>18806         init();
<a name="l18807"></a>18807         resize(size_type());
<a name="l18808"></a>18808     }
<a name="l18809"></a>18809 
<a name="l18810"></a>18810     <span class="keyword">explicit</span> LITE_INLINE array(<span class="keywordtype">int</span> n0, <span class="keywordtype">int</span> n1)
<a name="l18811"></a>18811     {
<a name="l18812"></a>18812         init();
<a name="l18813"></a>18813         resize(size_type(n0, n1));
<a name="l18814"></a>18814     }
<a name="l18815"></a>18815 
<a name="l18816"></a>18816     <span class="keyword">explicit</span> LITE_INLINE array(<span class="keyword">const</span> size_type&amp; sz)
<a name="l18817"></a>18817     {
<a name="l18818"></a>18818         init();
<a name="l18819"></a>18819         resize(sz);
<a name="l18820"></a>18820     }
<a name="l18821"></a>18821 
<a name="l18822"></a>18822     LITE_INLINE array(<span class="keyword">const</span> array&amp; other) 
<a name="l18823"></a>18823     {
<a name="l18824"></a>18824         <span class="keyword">typedef</span> b_iterator&lt;iterator, const_iterator, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l18825"></a>18825 
<a name="l18826"></a>18826         init();
<a name="l18827"></a>18827         resize(other.size());
<a name="l18828"></a>18828         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.m_iterator), m_size);
<a name="l18829"></a>18829     }
<a name="l18830"></a>18830 
<a name="l18831"></a>18831     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l18832"></a>18832     LITE_INLINE array(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l18833"></a>18833     {
<a name="l18834"></a>18834         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l18835"></a>18835             iterator, 
<a name="l18836"></a>18836             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l18837"></a>18837             assign&lt;value_type&gt; &gt; 
<a name="l18838"></a>18838             iterator_type;
<a name="l18839"></a>18839 
<a name="l18840"></a>18840         init();
<a name="l18841"></a>18841         resize(other.size());
<a name="l18842"></a>18842         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.begin()), m_size);
<a name="l18843"></a>18843     }
<a name="l18844"></a>18844 
<a name="l18845"></a>18845     LITE_INLINE array(<span class="keyword">const</span> value_type&amp; value) 
<a name="l18846"></a>18846     {
<a name="l18847"></a>18847         <span class="keyword">typedef</span> b_iterator&lt;iterator, c_iterator&lt;value_type&gt;, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l18848"></a>18848 
<a name="l18849"></a>18849         init();
<a name="l18850"></a>18850         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, value), m_size);
<a name="l18851"></a>18851     }
<a name="l18852"></a>18852 
<a name="l18853"></a>18853     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> array&amp; other) 
<a name="l18854"></a>18854     {
<a name="l18855"></a>18855         <span class="keyword">typedef</span> b_iterator&lt;iterator, const_iterator, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l18856"></a>18856 
<a name="l18857"></a>18857         resize(other.size());
<a name="l18858"></a>18858         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.m_iterator), m_size);
<a name="l18859"></a>18859         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l18860"></a>18860     }
<a name="l18861"></a>18861 
<a name="l18862"></a>18862     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l18863"></a>18863     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l18864"></a>18864     {
<a name="l18865"></a>18865         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l18866"></a>18866             iterator, 
<a name="l18867"></a>18867             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l18868"></a>18868             assign&lt;value_type&gt; &gt; 
<a name="l18869"></a>18869             iterator_type;
<a name="l18870"></a>18870 
<a name="l18871"></a>18871         resize(other.size());
<a name="l18872"></a>18872         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.begin()), m_size);
<a name="l18873"></a>18873         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l18874"></a>18874     }
<a name="l18875"></a>18875 
<a name="l18876"></a>18876     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> value_type&amp; value)
<a name="l18877"></a>18877     {
<a name="l18878"></a>18878         <span class="keyword">typedef</span> b_iterator&lt;iterator, c_iterator&lt;value_type&gt;, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l18879"></a>18879 
<a name="l18880"></a>18880         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, value), m_size);
<a name="l18881"></a>18881         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l18882"></a>18882     }
<a name="l18883"></a>18883 
<a name="l18884"></a>18884     LITE_INLINE const_iterator begin()<span class="keyword"> const</span>
<a name="l18885"></a>18885 <span class="keyword">    </span>{
<a name="l18886"></a>18886         <span class="keywordflow">return</span> m_iterator;
<a name="l18887"></a>18887     }
<a name="l18888"></a>18888 
<a name="l18889"></a>18889     LITE_INLINE iterator begin()
<a name="l18890"></a>18890     {
<a name="l18891"></a>18891         <span class="keywordflow">return</span> m_iterator;
<a name="l18892"></a>18892     }
<a name="l18893"></a>18893 
<a name="l18894"></a>18894     LITE_INLINE size_type size()<span class="keyword"> const</span>
<a name="l18895"></a>18895 <span class="keyword">    </span>{
<a name="l18896"></a>18896         <span class="keywordflow">return</span> m_size;
<a name="l18897"></a>18897     }
<a name="l18898"></a>18898 
<a name="l18899"></a>18899     LITE_INLINE const_reference 
<a name="l18900"></a>18900     operator()(<span class="keywordtype">int</span> i0, <span class="keywordtype">int</span> i1)<span class="keyword"> const</span>
<a name="l18901"></a>18901 <span class="keyword">    </span>{
<a name="l18902"></a>18902         <span class="keywordflow">return</span> *(m_iterator.i0+i0*m_iterator.i1+i1*m_iterator.i2);
<a name="l18903"></a>18903     }
<a name="l18904"></a>18904 
<a name="l18905"></a>18905     LITE_INLINE reference 
<a name="l18906"></a>18906     operator()(<span class="keywordtype">int</span> i0, <span class="keywordtype">int</span> i1) 
<a name="l18907"></a>18907     {
<a name="l18908"></a>18908         <span class="keywordflow">return</span> *(m_iterator.i0+i0*m_iterator.i1+i1*m_iterator.i2);
<a name="l18909"></a>18909     }
<a name="l18910"></a>18910 
<a name="l18911"></a>18911 
<a name="l18912"></a>18912     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_&gt;
<a name="l18913"></a>18913     LITE_INLINE <span class="keyword">const</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::const_array
<a name="l18914"></a>18914     operator[](<span class="keyword">const</span> transform_type_&amp; trans)<span class="keyword"> const</span>
<a name="l18915"></a>18915 <span class="keyword">    </span>{
<a name="l18916"></a>18916         <span class="keyword">typedef</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::const_array result_type;
<a name="l18917"></a>18917 
<a name="l18918"></a>18918         <span class="keywordflow">return</span> result_type(begin(), size(), trans);
<a name="l18919"></a>18919     }
<a name="l18920"></a>18920 
<a name="l18921"></a>18921     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_&gt;
<a name="l18922"></a>18922     LITE_INLINE <span class="keyword">const</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::array
<a name="l18923"></a>18923     operator[](<span class="keyword">const</span> transform_type_&amp; trans)
<a name="l18924"></a>18924     {
<a name="l18925"></a>18925         <span class="keyword">typedef</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::array result_type;
<a name="l18926"></a>18926 
<a name="l18927"></a>18927         <span class="keywordflow">return</span> result_type(begin(), size(), trans);
<a name="l18928"></a>18928     }
<a name="l18929"></a>18929 
<a name="l18930"></a>18930     LITE_INLINE <span class="keyword">const</span> value_type* data()<span class="keyword"> const</span>
<a name="l18931"></a>18931 <span class="keyword">    </span>{
<a name="l18932"></a>18932         <span class="keywordflow">return</span> m_iterator.i0;
<a name="l18933"></a>18933     }
<a name="l18934"></a>18934 
<a name="l18935"></a>18935     LITE_INLINE value_type* data()
<a name="l18936"></a>18936     {
<a name="l18937"></a>18937         <span class="keywordflow">return</span> m_iterator.i0;
<a name="l18938"></a>18938     }
<a name="l18939"></a>18939 
<a name="l18940"></a>18940     LITE_INLINE <span class="keywordtype">void</span> release() 
<a name="l18941"></a>18941     {
<a name="l18942"></a>18942         <span class="keywordflow">if</span> (m_iterator.i0 &amp;&amp; m_iterator.i0 != m_buffer)
<a name="l18943"></a>18943             <span class="keyword">delete</span>[] m_iterator.i0;
<a name="l18944"></a>18944 
<a name="l18945"></a>18945         m_iterator.i0 = 0;
<a name="l18946"></a>18946         m_size.set(0, 0);
<a name="l18947"></a>18947     }
<a name="l18948"></a>18948 
<a name="l18949"></a>18949     LITE_INLINE <span class="keywordtype">void</span> resize(<span class="keywordtype">int</span> n0, <span class="keywordtype">int</span> n1)
<a name="l18950"></a>18950     {
<a name="l18951"></a>18951         resize(size_type(n0, n1));
<a name="l18952"></a>18952     }
<a name="l18953"></a>18953 
<a name="l18954"></a>18954     LITE_INLINE <span class="keywordtype">void</span> resize(<span class="keyword">const</span> size_type&amp; new_size)
<a name="l18955"></a>18955     {
<a name="l18956"></a>18956         <span class="keywordtype">int</span> old_volumne = <a class="code" href="group__array__operations.html#gae75c2a405afffef6e4b64e7ea1831372" title="Returns the total volume of an array of the size sz.">volume</a>(m_size);
<a name="l18957"></a>18957         <span class="keywordtype">int</span> new_volume = <a class="code" href="group__array__operations.html#gae75c2a405afffef6e4b64e7ea1831372" title="Returns the total volume of an array of the size sz.">volume</a>(new_size);
<a name="l18958"></a>18958 
<a name="l18959"></a>18959         <span class="keywordflow">if</span> (old_volumne != new_volume || m_iterator.i0==0) {
<a name="l18960"></a>18960             <span class="keywordflow">if</span> (m_iterator.i0 &amp;&amp; m_iterator.i0 != m_buffer)
<a name="l18961"></a>18961                 <span class="keyword">delete</span>[] m_iterator.i0;
<a name="l18962"></a>18962             m_iterator.i0 = 0;
<a name="l18963"></a>18963             m_size.set(0, 0);
<a name="l18964"></a>18964 
<a name="l18965"></a>18965             <span class="keywordflow">if</span> (new_volume == 0)
<a name="l18966"></a>18966                 <span class="keywordflow">return</span>;
<a name="l18967"></a>18967 
<a name="l18968"></a>18968             m_iterator.i0 = new_volume &lt;= internal_buffer_size ? m_buffer : <span class="keyword">new</span> value_type[new_volume];
<a name="l18969"></a>18969         }
<a name="l18970"></a>18970         m_size = new_size;
<a name="l18971"></a>18971         m_iterator.set(
<a name="l18972"></a>18972             m_iterator.i0,
<a name="l18973"></a>18973             1,
<a name="l18974"></a>18974             m_size.i0
<a name="l18975"></a>18975         );
<a name="l18976"></a>18976     }
<a name="l18977"></a>18977 
<a name="l18978"></a>18978     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l18979"></a>18979     LITE_INLINE <span class="keywordtype">void</span> swap(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l18980"></a>18980     {
<a name="l18981"></a>18981         regular_swap(other);
<a name="l18982"></a>18982     }
<a name="l18983"></a>18983 
<a name="l18984"></a>18984     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l18985"></a>18985     LITE_INLINE <span class="keywordtype">void</span> swap(array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l18986"></a>18986     {
<a name="l18987"></a>18987         regular_swap(other);
<a name="l18988"></a>18988     }
<a name="l18989"></a>18989 
<a name="l18990"></a>18990     LITE_INLINE <span class="keywordtype">void</span> swap(array&amp; other)
<a name="l18991"></a>18991     {
<a name="l18992"></a>18992         <span class="comment">// fast swap</span>
<a name="l18993"></a>18993         <span class="keywordflow">if</span> (m_iterator.i0 != m_buffer &amp;&amp; other.m_iterator.i0 != other.m_buffer) {
<a name="l18994"></a>18994             iterator tmp_iter = other.m_iterator;
<a name="l18995"></a>18995             size_type tmp_size = other.m_size;
<a name="l18996"></a>18996 
<a name="l18997"></a>18997             other.m_iterator = m_iterator;
<a name="l18998"></a>18998             other.m_size = m_size;
<a name="l18999"></a>18999 
<a name="l19000"></a>19000             m_iterator = tmp_iter;
<a name="l19001"></a>19001             m_size = tmp_size;
<a name="l19002"></a>19002         }
<a name="l19003"></a>19003         <span class="keywordflow">else</span>
<a name="l19004"></a>19004             regular_swap(other);
<a name="l19005"></a>19005     }
<a name="l19006"></a>19006 
<a name="l19007"></a>19007 
<a name="l19008"></a>19008     LITE_INLINE ~array() 
<a name="l19009"></a>19009     {
<a name="l19010"></a>19010         <span class="keywordflow">if</span> (m_iterator.i0 &amp;&amp; m_iterator.i0 != m_buffer)
<a name="l19011"></a>19011             <span class="keyword">delete</span>[] m_iterator.i0;
<a name="l19012"></a>19012     }
<a name="l19013"></a>19013 
<a name="l19014"></a>19014 <span class="keyword">private</span>:
<a name="l19015"></a>19015 
<a name="l19016"></a>19016     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_array_&gt;
<a name="l19017"></a>19017     LITE_INLINE <span class="keywordtype">void</span> regular_swap(other_array_&amp; other)
<a name="l19018"></a>19018     {
<a name="l19019"></a>19019         <span class="keyword">typedef</span> b_iterator&lt;iterator, typename other_array_::iterator, swapper&lt;value_type&gt; &gt; iterator_type;
<a name="l19020"></a>19020 
<a name="l19021"></a>19021         <span class="keywordflow">if</span> (m_size == other.size()) 
<a name="l19022"></a>19022             <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.begin()), m_size);
<a name="l19023"></a>19023         <span class="keywordflow">else</span> {
<a name="l19024"></a>19024             <span class="keyword">typename</span> other_array_::temporary_array tmp = other;
<a name="l19025"></a>19025 
<a name="l19026"></a>19026             other = *<span class="keyword">this</span>;
<a name="l19027"></a>19027             *<span class="keyword">this</span> = tmp;
<a name="l19028"></a>19028         }
<a name="l19029"></a>19029     }
<a name="l19030"></a>19030 
<a name="l19031"></a>19031     <span class="comment">//template&lt;typename other_signature_, typename other_traits_type_, typename other_rep_&gt;</span>
<a name="l19032"></a>19032     <span class="comment">//friend class array;</span>
<a name="l19033"></a>19033 
<a name="l19034"></a>19034     LITE_INLINE <span class="keywordtype">void</span> init()
<a name="l19035"></a>19035     {
<a name="l19036"></a>19036         m_iterator.i0 = 0;
<a name="l19037"></a>19037         m_size.set(0, 0);
<a name="l19038"></a>19038         resize(m_size);
<a name="l19039"></a>19039     }
<a name="l19040"></a>19040 
<a name="l19041"></a>19041     iterator m_iterator;
<a name="l19042"></a>19042     size_type m_size;
<a name="l19043"></a>19043     value_type m_buffer[internal_buffer_size &gt;= 1 ? internal_buffer_size : 1];
<a name="l19044"></a>19044 };
<a name="l19045"></a>19045 
<a name="l19046"></a>19046 <span class="comment">/***********************************************************************************************************/</span>
<a name="l19047"></a>19047 
<a name="l19048"></a>19048 <span class="keyword">template</span>&lt;
<a name="l19049"></a>19049     <span class="keyword">typename</span> value_type_,
<a name="l19050"></a>19050     <span class="keywordtype">int</span> n0_, 
<a name="l19051"></a>19051     <span class="keywordtype">int</span> n1_, 
<a name="l19052"></a>19052     <span class="keywordtype">int</span> n2_, 
<a name="l19053"></a>19053     <span class="keyword">typename</span> traits_type_,
<a name="l19054"></a>19054     <span class="keywordtype">int</span> internal_buf_size_
<a name="l19055"></a>19055     &gt;
<a name="l19056"></a>19056 <span class="keyword">class </span>array&lt;
<a name="l19057"></a>19057     value_type_[n0_][n1_][n2_],
<a name="l19058"></a>19058     traits_type_,
<a name="l19059"></a>19059     hybrid_rep&lt;true, internal_buf_size_&gt;
<a name="l19060"></a>19060     &gt;
<a name="l19061"></a>19061 {
<a name="l19062"></a>19062 <span class="keyword">public</span>:
<a name="l19063"></a>19063     <span class="keyword">typedef</span> value_type_ signature[n0_][n1_][n2_];
<a name="l19064"></a>19064     <span class="keyword">typedef</span> traits_type_ traits_type;
<a name="l19065"></a>19065     <span class="keyword">typedef</span> value_type_ value_type;
<a name="l19066"></a>19066     <span class="keyword">typedef</span> <span class="keyword">const</span> value_type_&amp; const_reference;
<a name="l19067"></a>19067     <span class="keyword">typedef</span> value_type_&amp; reference;
<a name="l19068"></a>19068 
<a name="l19069"></a>19069     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;const signature&gt;::default_rev_iterator const_iterator;
<a name="l19070"></a>19070     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;signature&gt;::default_rev_iterator iterator;
<a name="l19071"></a>19071     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;signature&gt;::size_type size_type;
<a name="l19072"></a>19072 
<a name="l19073"></a>19073     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::temporary_array temporary_array;
<a name="l19074"></a>19074     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::fwd_temporary_array fwd_temporary_array;
<a name="l19075"></a>19075     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature, traits_type_&gt;::rev_temporary_array rev_temporary_array;
<a name="l19076"></a>19076 
<a name="l19077"></a>19077     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> dimensions = 3;
<a name="l19078"></a>19078     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_reverse = <span class="keyword">true</span>;
<a name="l19079"></a>19079     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> internal_buffer_size = internal_buf_size_;
<a name="l19080"></a>19080 
<a name="l19081"></a>19081     LITE_INLINE array() 
<a name="l19082"></a>19082     {
<a name="l19083"></a>19083         init();
<a name="l19084"></a>19084         resize(size_type());
<a name="l19085"></a>19085     }
<a name="l19086"></a>19086 
<a name="l19087"></a>19087     <span class="keyword">explicit</span> LITE_INLINE array(<span class="keywordtype">int</span> n0, <span class="keywordtype">int</span> n1, <span class="keywordtype">int</span> n2)
<a name="l19088"></a>19088     {
<a name="l19089"></a>19089         init();
<a name="l19090"></a>19090         resize(size_type(n0, n1, n2));
<a name="l19091"></a>19091     }
<a name="l19092"></a>19092 
<a name="l19093"></a>19093     <span class="keyword">explicit</span> LITE_INLINE array(<span class="keyword">const</span> size_type&amp; sz)
<a name="l19094"></a>19094     {
<a name="l19095"></a>19095         init();
<a name="l19096"></a>19096         resize(sz);
<a name="l19097"></a>19097     }
<a name="l19098"></a>19098 
<a name="l19099"></a>19099     LITE_INLINE array(<span class="keyword">const</span> array&amp; other) 
<a name="l19100"></a>19100     {
<a name="l19101"></a>19101         <span class="keyword">typedef</span> b_iterator&lt;iterator, const_iterator, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l19102"></a>19102 
<a name="l19103"></a>19103         init();
<a name="l19104"></a>19104         resize(other.size());
<a name="l19105"></a>19105         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.m_iterator), m_size);
<a name="l19106"></a>19106     }
<a name="l19107"></a>19107 
<a name="l19108"></a>19108     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l19109"></a>19109     LITE_INLINE array(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l19110"></a>19110     {
<a name="l19111"></a>19111         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l19112"></a>19112             iterator, 
<a name="l19113"></a>19113             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l19114"></a>19114             assign&lt;value_type&gt; &gt; 
<a name="l19115"></a>19115             iterator_type;
<a name="l19116"></a>19116 
<a name="l19117"></a>19117         init();
<a name="l19118"></a>19118         resize(other.size());
<a name="l19119"></a>19119         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.begin()), m_size);
<a name="l19120"></a>19120     }
<a name="l19121"></a>19121 
<a name="l19122"></a>19122     LITE_INLINE array(<span class="keyword">const</span> value_type&amp; value) 
<a name="l19123"></a>19123     {
<a name="l19124"></a>19124         <span class="keyword">typedef</span> b_iterator&lt;iterator, c_iterator&lt;value_type&gt;, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l19125"></a>19125 
<a name="l19126"></a>19126         init();
<a name="l19127"></a>19127         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, value), m_size);
<a name="l19128"></a>19128     }
<a name="l19129"></a>19129 
<a name="l19130"></a>19130     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> array&amp; other) 
<a name="l19131"></a>19131     {
<a name="l19132"></a>19132         <span class="keyword">typedef</span> b_iterator&lt;iterator, const_iterator, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l19133"></a>19133 
<a name="l19134"></a>19134         resize(other.size());
<a name="l19135"></a>19135         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.m_iterator), m_size);
<a name="l19136"></a>19136         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l19137"></a>19137     }
<a name="l19138"></a>19138 
<a name="l19139"></a>19139     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l19140"></a>19140     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l19141"></a>19141     {
<a name="l19142"></a>19142         <span class="keyword">typedef</span> b_iterator&lt;
<a name="l19143"></a>19143             iterator, 
<a name="l19144"></a>19144             <span class="keyword">typename</span> array&lt;signature, traits_type_, other_rep_&gt;::const_iterator, 
<a name="l19145"></a>19145             assign&lt;value_type&gt; &gt; 
<a name="l19146"></a>19146             iterator_type;
<a name="l19147"></a>19147 
<a name="l19148"></a>19148         resize(other.size());
<a name="l19149"></a>19149         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.begin()), m_size);
<a name="l19150"></a>19150         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l19151"></a>19151     }
<a name="l19152"></a>19152 
<a name="l19153"></a>19153     LITE_INLINE array&amp; operator=(<span class="keyword">const</span> value_type&amp; value)
<a name="l19154"></a>19154     {
<a name="l19155"></a>19155         <span class="keyword">typedef</span> b_iterator&lt;iterator, c_iterator&lt;value_type&gt;, assign&lt;value_type&gt; &gt; iterator_type;
<a name="l19156"></a>19156 
<a name="l19157"></a>19157         <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, value), m_size);
<a name="l19158"></a>19158         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l19159"></a>19159     }
<a name="l19160"></a>19160 
<a name="l19161"></a>19161     LITE_INLINE const_iterator begin()<span class="keyword"> const</span>
<a name="l19162"></a>19162 <span class="keyword">    </span>{
<a name="l19163"></a>19163         <span class="keywordflow">return</span> m_iterator;
<a name="l19164"></a>19164     }
<a name="l19165"></a>19165 
<a name="l19166"></a>19166     LITE_INLINE iterator begin()
<a name="l19167"></a>19167     {
<a name="l19168"></a>19168         <span class="keywordflow">return</span> m_iterator;
<a name="l19169"></a>19169     }
<a name="l19170"></a>19170 
<a name="l19171"></a>19171     LITE_INLINE size_type size()<span class="keyword"> const</span>
<a name="l19172"></a>19172 <span class="keyword">    </span>{
<a name="l19173"></a>19173         <span class="keywordflow">return</span> m_size;
<a name="l19174"></a>19174     }
<a name="l19175"></a>19175 
<a name="l19176"></a>19176     LITE_INLINE const_reference 
<a name="l19177"></a>19177     operator()(<span class="keywordtype">int</span> i0, <span class="keywordtype">int</span> i1, <span class="keywordtype">int</span> i2)<span class="keyword"> const</span>
<a name="l19178"></a>19178 <span class="keyword">    </span>{
<a name="l19179"></a>19179         <span class="keywordflow">return</span> *(m_iterator.i0+i0*m_iterator.i1+i1*m_iterator.i2+i2*m_iterator.i3);
<a name="l19180"></a>19180     }
<a name="l19181"></a>19181 
<a name="l19182"></a>19182     LITE_INLINE reference 
<a name="l19183"></a>19183     operator()(<span class="keywordtype">int</span> i0, <span class="keywordtype">int</span> i1, <span class="keywordtype">int</span> i2) 
<a name="l19184"></a>19184     {
<a name="l19185"></a>19185         <span class="keywordflow">return</span> *(m_iterator.i0+i0*m_iterator.i1+i1*m_iterator.i2+i2*m_iterator.i3);
<a name="l19186"></a>19186     }
<a name="l19187"></a>19187 
<a name="l19188"></a>19188 
<a name="l19189"></a>19189     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_&gt;
<a name="l19190"></a>19190     LITE_INLINE <span class="keyword">const</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::const_array
<a name="l19191"></a>19191     operator[](<span class="keyword">const</span> transform_type_&amp; trans)<span class="keyword"> const</span>
<a name="l19192"></a>19192 <span class="keyword">    </span>{
<a name="l19193"></a>19193         <span class="keyword">typedef</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::const_array result_type;
<a name="l19194"></a>19194 
<a name="l19195"></a>19195         <span class="keywordflow">return</span> result_type(begin(), size(), trans);
<a name="l19196"></a>19196     }
<a name="l19197"></a>19197 
<a name="l19198"></a>19198     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_&gt;
<a name="l19199"></a>19199     LITE_INLINE <span class="keyword">const</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::array
<a name="l19200"></a>19200     operator[](<span class="keyword">const</span> transform_type_&amp; trans)
<a name="l19201"></a>19201     {
<a name="l19202"></a>19202         <span class="keyword">typedef</span> <span class="keyword">typename</span> transform_traits&lt;array, transform_type_&gt;::array result_type;
<a name="l19203"></a>19203 
<a name="l19204"></a>19204         <span class="keywordflow">return</span> result_type(begin(), size(), trans);
<a name="l19205"></a>19205     }
<a name="l19206"></a>19206 
<a name="l19207"></a>19207     LITE_INLINE <span class="keyword">const</span> value_type* data()<span class="keyword"> const</span>
<a name="l19208"></a>19208 <span class="keyword">    </span>{
<a name="l19209"></a>19209         <span class="keywordflow">return</span> m_iterator.i0;
<a name="l19210"></a>19210     }
<a name="l19211"></a>19211 
<a name="l19212"></a>19212     LITE_INLINE value_type* data()
<a name="l19213"></a>19213     {
<a name="l19214"></a>19214         <span class="keywordflow">return</span> m_iterator.i0;
<a name="l19215"></a>19215     }
<a name="l19216"></a>19216 
<a name="l19217"></a>19217     LITE_INLINE <span class="keywordtype">void</span> release() 
<a name="l19218"></a>19218     {
<a name="l19219"></a>19219         <span class="keywordflow">if</span> (m_iterator.i0 &amp;&amp; m_iterator.i0 != m_buffer)
<a name="l19220"></a>19220             <span class="keyword">delete</span>[] m_iterator.i0;
<a name="l19221"></a>19221 
<a name="l19222"></a>19222         m_iterator.i0 = 0;
<a name="l19223"></a>19223         m_size.set(0, 0, 0);
<a name="l19224"></a>19224     }
<a name="l19225"></a>19225 
<a name="l19226"></a>19226     LITE_INLINE <span class="keywordtype">void</span> resize(<span class="keywordtype">int</span> n0, <span class="keywordtype">int</span> n1, <span class="keywordtype">int</span> n2)
<a name="l19227"></a>19227     {
<a name="l19228"></a>19228         resize(size_type(n0, n1, n2));
<a name="l19229"></a>19229     }
<a name="l19230"></a>19230 
<a name="l19231"></a>19231     LITE_INLINE <span class="keywordtype">void</span> resize(<span class="keyword">const</span> size_type&amp; new_size)
<a name="l19232"></a>19232     {
<a name="l19233"></a>19233         <span class="keywordtype">int</span> old_volumne = <a class="code" href="group__array__operations.html#gae75c2a405afffef6e4b64e7ea1831372" title="Returns the total volume of an array of the size sz.">volume</a>(m_size);
<a name="l19234"></a>19234         <span class="keywordtype">int</span> new_volume = <a class="code" href="group__array__operations.html#gae75c2a405afffef6e4b64e7ea1831372" title="Returns the total volume of an array of the size sz.">volume</a>(new_size);
<a name="l19235"></a>19235 
<a name="l19236"></a>19236         <span class="keywordflow">if</span> (old_volumne != new_volume || m_iterator.i0==0) {
<a name="l19237"></a>19237             <span class="keywordflow">if</span> (m_iterator.i0 &amp;&amp; m_iterator.i0 != m_buffer)
<a name="l19238"></a>19238                 <span class="keyword">delete</span>[] m_iterator.i0;
<a name="l19239"></a>19239             m_iterator.i0 = 0;
<a name="l19240"></a>19240             m_size.set(0, 0, 0);
<a name="l19241"></a>19241 
<a name="l19242"></a>19242             <span class="keywordflow">if</span> (new_volume == 0)
<a name="l19243"></a>19243                 <span class="keywordflow">return</span>;
<a name="l19244"></a>19244 
<a name="l19245"></a>19245             m_iterator.i0 = new_volume &lt;= internal_buffer_size ? m_buffer : <span class="keyword">new</span> value_type[new_volume];
<a name="l19246"></a>19246         }
<a name="l19247"></a>19247         m_size = new_size;
<a name="l19248"></a>19248         m_iterator.set(
<a name="l19249"></a>19249             m_iterator.i0,
<a name="l19250"></a>19250             1,
<a name="l19251"></a>19251             m_size.i0,
<a name="l19252"></a>19252             m_size.i0*m_size.i1
<a name="l19253"></a>19253         );
<a name="l19254"></a>19254     }
<a name="l19255"></a>19255 
<a name="l19256"></a>19256     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l19257"></a>19257     LITE_INLINE <span class="keywordtype">void</span> swap(<span class="keyword">const</span> array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l19258"></a>19258     {
<a name="l19259"></a>19259         regular_swap(other);
<a name="l19260"></a>19260     }
<a name="l19261"></a>19261 
<a name="l19262"></a>19262     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_rep_&gt;
<a name="l19263"></a>19263     LITE_INLINE <span class="keywordtype">void</span> swap(array&lt;signature, traits_type_, other_rep_&gt;&amp; other) 
<a name="l19264"></a>19264     {
<a name="l19265"></a>19265         regular_swap(other);
<a name="l19266"></a>19266     }
<a name="l19267"></a>19267 
<a name="l19268"></a>19268     LITE_INLINE <span class="keywordtype">void</span> swap(array&amp; other)
<a name="l19269"></a>19269     {
<a name="l19270"></a>19270         <span class="comment">// fast swap</span>
<a name="l19271"></a>19271         <span class="keywordflow">if</span> (m_iterator.i0 != m_buffer &amp;&amp; other.m_iterator.i0 != other.m_buffer) {
<a name="l19272"></a>19272             iterator tmp_iter = other.m_iterator;
<a name="l19273"></a>19273             size_type tmp_size = other.m_size;
<a name="l19274"></a>19274 
<a name="l19275"></a>19275             other.m_iterator = m_iterator;
<a name="l19276"></a>19276             other.m_size = m_size;
<a name="l19277"></a>19277 
<a name="l19278"></a>19278             m_iterator = tmp_iter;
<a name="l19279"></a>19279             m_size = tmp_size;
<a name="l19280"></a>19280         }
<a name="l19281"></a>19281         <span class="keywordflow">else</span>
<a name="l19282"></a>19282             regular_swap(other);
<a name="l19283"></a>19283     }
<a name="l19284"></a>19284 
<a name="l19285"></a>19285 
<a name="l19286"></a>19286     LITE_INLINE ~array() 
<a name="l19287"></a>19287     {
<a name="l19288"></a>19288         <span class="keywordflow">if</span> (m_iterator.i0 &amp;&amp; m_iterator.i0 != m_buffer)
<a name="l19289"></a>19289             <span class="keyword">delete</span>[] m_iterator.i0;
<a name="l19290"></a>19290     }
<a name="l19291"></a>19291 
<a name="l19292"></a>19292 <span class="keyword">private</span>:
<a name="l19293"></a>19293 
<a name="l19294"></a>19294     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> other_array_&gt;
<a name="l19295"></a>19295     LITE_INLINE <span class="keywordtype">void</span> regular_swap(other_array_&amp; other)
<a name="l19296"></a>19296     {
<a name="l19297"></a>19297         <span class="keyword">typedef</span> b_iterator&lt;iterator, typename other_array_::iterator, swapper&lt;value_type&gt; &gt; iterator_type;
<a name="l19298"></a>19298 
<a name="l19299"></a>19299         <span class="keywordflow">if</span> (m_size == other.size()) 
<a name="l19300"></a>19300             <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(m_iterator, other.begin()), m_size);
<a name="l19301"></a>19301         <span class="keywordflow">else</span> {
<a name="l19302"></a>19302             <span class="keyword">typename</span> other_array_::temporary_array tmp = other;
<a name="l19303"></a>19303 
<a name="l19304"></a>19304             other = *<span class="keyword">this</span>;
<a name="l19305"></a>19305             *<span class="keyword">this</span> = tmp;
<a name="l19306"></a>19306         }
<a name="l19307"></a>19307     }
<a name="l19308"></a>19308 
<a name="l19309"></a>19309     <span class="comment">//template&lt;typename other_signature_, typename other_traits_type_, typename other_rep_&gt;</span>
<a name="l19310"></a>19310     <span class="comment">//friend class array;</span>
<a name="l19311"></a>19311 
<a name="l19312"></a>19312     LITE_INLINE <span class="keywordtype">void</span> init()
<a name="l19313"></a>19313     {
<a name="l19314"></a>19314         m_iterator.i0 = 0;
<a name="l19315"></a>19315         m_size.set(0, 0, 0);
<a name="l19316"></a>19316         resize(m_size);
<a name="l19317"></a>19317     }
<a name="l19318"></a>19318 
<a name="l19319"></a>19319     iterator m_iterator;
<a name="l19320"></a>19320     size_type m_size;
<a name="l19321"></a>19321     value_type m_buffer[internal_buffer_size &gt;= 1 ? internal_buffer_size : 1];
<a name="l19322"></a>19322 };
<a name="l19323"></a>19323 
<a name="l19324"></a>19324 <span class="comment">/***********************************************************************************************************/</span>
<a name="l19325"></a>19325 
<a name="l19326"></a>19326 
<a name="l19327"></a>19327 <span class="comment">/***********************************************************************************************************/</span>
<a name="l19328"></a>19328 <span class="comment">/* transform_traits ****************************************************************************************/</span>
<a name="l19329"></a>19329 <span class="comment">/***********************************************************************************************************/</span>
<a name="l19330"></a>19330 
<a name="l19331"></a>19331 <span class="preprocessor">#ifdef DOCUMENTATION_ONLY</span>
<a name="l19332"></a>19332 <span class="preprocessor"></span>
<a name="l19361"></a>19361 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> array_type_, <span class="keyword">typename</span> trans_type_&gt;
<a name="l19362"></a><a class="code" href="structlite_1_1transform__traits.html">19362</a> <span class="keyword">struct </span><a class="code" href="structlite_1_1transform__traits.html" title="This class provides information about applying a transform object to an array object...">transform_traits</a>
<a name="l19363"></a>19363 {
<a name="l19365"></a><a class="code" href="structlite_1_1transform__traits.html#a1481880eabec13ec261860b5ca877011">19365</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structlite_1_1size__transformer.html" title="This can be used to apply a transform object of type transform_type_ to a size object...">size_transformer&lt;trans_type_, typename array_type_::size_type&gt;::size_type</a> size_type;
<a name="l19366"></a>19366 
<a name="l19368"></a><a class="code" href="structlite_1_1transform__traits.html#af7c176f2bc17636815da9df0561c324f">19368</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::size_to_signature&lt;size_type, typename array_type_::value_type&gt;::type signature;
<a name="l19369"></a>19369 
<a name="l19371"></a><a class="code" href="structlite_1_1transform__traits.html#a4aa94118efe9c5b931e01365fc55f04f">19371</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_type_::traits_type traits_type;
<a name="l19372"></a>19372 
<a name="l19374"></a>19374     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structlite_1_1iterator__transformer.html" title="This can be used to apply a transform object of type transform_type_ to a pair of...">iterator_transformer</a>&lt;
<a name="l19375"></a>19375         trans_type_, 
<a name="l19376"></a>19376         <span class="keyword">typename</span> array_type_::iterator, 
<a name="l19377"></a><a class="code" href="structlite_1_1transform__traits.html#a6e4728177cffdb1acc11c46ad04392ac">19377</a>         <span class="keyword">typename</span> array_type_::size_type&gt;::iterator_type iterator;
<a name="l19378"></a>19378 
<a name="l19380"></a>19380     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structlite_1_1iterator__transformer.html" title="This can be used to apply a transform object of type transform_type_ to a pair of...">iterator_transformer</a>&lt;
<a name="l19381"></a>19381         trans_type_, 
<a name="l19382"></a>19382         <span class="keyword">typename</span> array_type_::const_iterator, 
<a name="l19383"></a><a class="code" href="structlite_1_1transform__traits.html#ac54b3caccecbb523eef88dcc64250263">19383</a>         <span class="keyword">typename</span> array_type_::size_type&gt;::iterator_type const_iterator;
<a name="l19384"></a>19384 
<a name="l19386"></a><a class="code" href="structlite_1_1transform__traits.html#aa6268c9f888502f6b93c444a7b2ec354">19386</a>     typedef ::lite::array&lt;signature, traits_type, reference_rep&lt;iterator&gt; &gt; <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a>;
<a name="l19387"></a>19387     
<a name="l19389"></a><a class="code" href="structlite_1_1transform__traits.html#a079c115c3cf086e66df0a4e004510cde">19389</a>     typedef ::lite::array&lt;signature, traits_type, reference_rep&lt;const_iterator&gt; &gt; <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">const_array</a>;
<a name="l19390"></a>19390 
<a name="l19396"></a><a class="code" href="structlite_1_1transform__traits.html#a9f955b6339c92325956f62ea4281b63c">19396</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array_helper&lt;signature, traits_type&gt;::temporary_array</a> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">temporary_array</a>;
<a name="l19397"></a>19397 
<a name="l19403"></a><a class="code" href="structlite_1_1transform__traits.html#ac49c3d1eb58b73aac24f0dd170b8d3f6">19403</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array_helper&lt;signature, traits_type&gt;::fwd_temporary_array</a> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">fwd_temporary_array</a>;
<a name="l19404"></a>19404 
<a name="l19410"></a><a class="code" href="structlite_1_1transform__traits.html#a27673da9e7f279b64e57dbbeee6c151a">19410</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array_helper&lt;signature, traits_type&gt;::rev_temporary_array</a> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">rev_temporary_array</a>;
<a name="l19411"></a>19411 };
<a name="l19412"></a>19412 
<a name="l19413"></a>19413 <span class="preprocessor">#else // DOCUMENTATION_ONLY</span>
<a name="l19414"></a>19414 <span class="preprocessor"></span>
<a name="l19415"></a>19415 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> array_type_, <span class="keyword">typename</span> trans_type_&gt;
<a name="l19416"></a>19416 <span class="keyword">struct </span><a class="code" href="structlite_1_1transform__traits.html" title="This class provides information about applying a transform object to an array object...">transform_traits</a>&lt;
<a name="l19417"></a>19417     array_type_, 
<a name="l19418"></a>19418     trans_type_, 
<a name="l19419"></a>19419     typename detail::enable_if&lt;
<a name="l19420"></a>19420         detail::defined&lt;typename size_transformer&lt;trans_type_, 
<a name="l19421"></a>19421             typename array_type_::size_type&gt;::size_type&gt;::value
<a name="l19422"></a>19422         &gt;::type
<a name="l19423"></a>19423     &gt;
<a name="l19424"></a>19424 {
<a name="l19425"></a>19425     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structlite_1_1size__transformer.html" title="This can be used to apply a transform object of type transform_type_ to a size object...">size_transformer&lt;trans_type_, typename array_type_::size_type&gt;::size_type</a> size_type;
<a name="l19426"></a>19426     <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::size_to_signature&lt;size_type, typename array_type_::value_type&gt;::type signature;
<a name="l19427"></a>19427     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_type_::traits_type traits_type;
<a name="l19428"></a>19428 
<a name="l19429"></a>19429     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structlite_1_1iterator__transformer.html" title="This can be used to apply a transform object of type transform_type_ to a pair of...">iterator_transformer</a>&lt;
<a name="l19430"></a>19430         trans_type_, 
<a name="l19431"></a>19431         <span class="keyword">typename</span> array_type_::iterator, 
<a name="l19432"></a>19432         <span class="keyword">typename</span> array_type_::size_type&gt;::iterator_type iterator;
<a name="l19433"></a>19433 
<a name="l19434"></a>19434     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structlite_1_1iterator__transformer.html" title="This can be used to apply a transform object of type transform_type_ to a pair of...">iterator_transformer</a>&lt;
<a name="l19435"></a>19435         trans_type_, 
<a name="l19436"></a>19436         <span class="keyword">typename</span> array_type_::const_iterator, 
<a name="l19437"></a>19437         <span class="keyword">typename</span> array_type_::size_type&gt;::iterator_type const_iterator;
<a name="l19438"></a>19438 
<a name="l19439"></a>19439     typedef ::lite::array&lt;signature, traits_type, reference_rep&lt;iterator&gt; &gt; <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a>;
<a name="l19440"></a>19440     typedef ::lite::array&lt;signature, traits_type, reference_rep&lt;const_iterator&gt; &gt; const_array;
<a name="l19441"></a>19441 
<a name="l19442"></a>19442     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array_helper&lt;signature, traits_type&gt;::temporary_array</a> temporary_array;
<a name="l19443"></a>19443     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array_helper&lt;signature, traits_type&gt;::fwd_temporary_array</a> fwd_temporary_array;
<a name="l19444"></a>19444     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array_helper&lt;signature, traits_type&gt;::rev_temporary_array</a> rev_temporary_array;
<a name="l19445"></a>19445 };
<a name="l19446"></a>19446 
<a name="l19447"></a>19447 <span class="preprocessor">#endif // DOCUMENTATION_ONLY</span>
<a name="l19448"></a>19448 <span class="preprocessor"></span>
<a name="l19449"></a>19449 <span class="comment">/***********************************************************************************************************/</span>
<a name="l19450"></a>19450 <span class="comment">/* function objects ****************************************************************************************/</span>
<a name="l19451"></a>19451 <span class="comment">/***********************************************************************************************************/</span>
<a name="l19452"></a>19452 
<a name="l19453"></a>19453 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_&gt;
<a name="l19454"></a>19454 <span class="keyword">class </span>uplus
<a name="l19455"></a>19455 { 
<a name="l19456"></a>19456 <span class="keyword">public</span>: 
<a name="l19457"></a>19457     <span class="keyword">typedef</span> type_ argument_type;
<a name="l19458"></a>19458     <span class="keyword">typedef</span> type_ result_type;
<a name="l19459"></a>19459 
<a name="l19460"></a>19460     LITE_INLINE result_type operator()(<span class="keyword">const</span> argument_type&amp; a)<span class="keyword"> const </span>
<a name="l19461"></a>19461 <span class="keyword">    </span>{ <span class="keywordflow">return</span> +a; } 
<a name="l19462"></a>19462 };
<a name="l19463"></a>19463 
<a name="l19464"></a>19464 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_&gt;
<a name="l19465"></a>19465 <span class="keyword">class </span>negate
<a name="l19466"></a>19466 { 
<a name="l19467"></a>19467 <span class="keyword">public</span>: 
<a name="l19468"></a>19468     <span class="keyword">typedef</span> type_ argument_type;
<a name="l19469"></a>19469     <span class="keyword">typedef</span> type_ result_type;
<a name="l19470"></a>19470 
<a name="l19471"></a>19471     LITE_INLINE result_type operator()(<span class="keyword">const</span> argument_type&amp; a)<span class="keyword"> const </span>
<a name="l19472"></a>19472 <span class="keyword">    </span>{ <span class="keywordflow">return</span> -a; } 
<a name="l19473"></a>19473 };
<a name="l19474"></a>19474 
<a name="l19475"></a>19475 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_&gt;
<a name="l19476"></a>19476 <span class="keyword">class </span>plus
<a name="l19477"></a>19477 { 
<a name="l19478"></a>19478 <span class="keyword">public</span>: 
<a name="l19479"></a>19479     <span class="keyword">typedef</span> type_ first_argument_type;
<a name="l19480"></a>19480     <span class="keyword">typedef</span> type_ second_argument_type;
<a name="l19481"></a>19481     <span class="keyword">typedef</span> type_ result_type;
<a name="l19482"></a>19482 
<a name="l19483"></a>19483     LITE_INLINE result_type operator()(<span class="keyword">const</span> first_argument_type&amp; a, <span class="keyword">const</span> second_argument_type&amp; b)<span class="keyword"> const </span>
<a name="l19484"></a>19484 <span class="keyword">    </span>{ <span class="keywordflow">return</span> a + b; } 
<a name="l19485"></a>19485 };
<a name="l19486"></a>19486 
<a name="l19487"></a>19487 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_&gt;
<a name="l19488"></a>19488 <span class="keyword">class </span>minus
<a name="l19489"></a>19489 { 
<a name="l19490"></a>19490 <span class="keyword">public</span>: 
<a name="l19491"></a>19491     <span class="keyword">typedef</span> type_ first_argument_type;
<a name="l19492"></a>19492     <span class="keyword">typedef</span> type_ second_argument_type;
<a name="l19493"></a>19493     <span class="keyword">typedef</span> type_ result_type;
<a name="l19494"></a>19494 
<a name="l19495"></a>19495     LITE_INLINE result_type operator()(<span class="keyword">const</span> first_argument_type&amp; a, <span class="keyword">const</span> second_argument_type&amp; b)<span class="keyword"> const </span>
<a name="l19496"></a>19496 <span class="keyword">    </span>{ <span class="keywordflow">return</span> a - b; } 
<a name="l19497"></a>19497 };
<a name="l19498"></a>19498 
<a name="l19499"></a>19499 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_&gt;
<a name="l19500"></a>19500 <span class="keyword">class </span>multiplies
<a name="l19501"></a>19501 { 
<a name="l19502"></a>19502 <span class="keyword">public</span>: 
<a name="l19503"></a>19503     <span class="keyword">typedef</span> type_ first_argument_type;
<a name="l19504"></a>19504     <span class="keyword">typedef</span> type_ second_argument_type;
<a name="l19505"></a>19505     <span class="keyword">typedef</span> type_ result_type;
<a name="l19506"></a>19506 
<a name="l19507"></a>19507     LITE_INLINE result_type operator()(<span class="keyword">const</span> first_argument_type&amp; a, <span class="keyword">const</span> second_argument_type&amp; b)<span class="keyword"> const </span>
<a name="l19508"></a>19508 <span class="keyword">    </span>{ <span class="keywordflow">return</span> a*b; } 
<a name="l19509"></a>19509 };
<a name="l19510"></a>19510 
<a name="l19511"></a>19511 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_&gt;
<a name="l19512"></a>19512 <span class="keyword">class </span>divides
<a name="l19513"></a>19513 { 
<a name="l19514"></a>19514 <span class="keyword">public</span>: 
<a name="l19515"></a>19515     <span class="keyword">typedef</span> type_ first_argument_type;
<a name="l19516"></a>19516     <span class="keyword">typedef</span> type_ second_argument_type;
<a name="l19517"></a>19517     <span class="keyword">typedef</span> type_ result_type;
<a name="l19518"></a>19518 
<a name="l19519"></a>19519     LITE_INLINE result_type operator()(<span class="keyword">const</span> first_argument_type&amp; a, <span class="keyword">const</span> second_argument_type&amp; b)<span class="keyword"> const </span>
<a name="l19520"></a>19520 <span class="keyword">    </span>{ <span class="keywordflow">return</span> a/b; } 
<a name="l19521"></a>19521 };
<a name="l19522"></a>19522 
<a name="l19523"></a>19523 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_&gt;
<a name="l19524"></a>19524 <span class="keyword">class </span>assign
<a name="l19525"></a>19525 { 
<a name="l19526"></a>19526 <span class="keyword">public</span>: 
<a name="l19527"></a>19527     <span class="keyword">typedef</span> type_ first_argument_type;
<a name="l19528"></a>19528     <span class="keyword">typedef</span> type_ second_argument_type;
<a name="l19529"></a>19529     <span class="keyword">typedef</span> type_&amp; result_type;
<a name="l19530"></a>19530 
<a name="l19531"></a>19531     LITE_INLINE result_type operator()(first_argument_type&amp; a, <span class="keyword">const</span> second_argument_type&amp; b)<span class="keyword"> const </span>
<a name="l19532"></a>19532 <span class="keyword">    </span>{ <span class="keywordflow">return</span> a = b; } 
<a name="l19533"></a>19533 };
<a name="l19534"></a>19534 
<a name="l19535"></a>19535 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_&gt;
<a name="l19536"></a>19536 <span class="keyword">class </span>plus_assign
<a name="l19537"></a>19537 { 
<a name="l19538"></a>19538 <span class="keyword">public</span>: 
<a name="l19539"></a>19539     <span class="keyword">typedef</span> type_ first_argument_type;
<a name="l19540"></a>19540     <span class="keyword">typedef</span> type_ second_argument_type;
<a name="l19541"></a>19541     <span class="keyword">typedef</span> type_&amp; result_type;
<a name="l19542"></a>19542 
<a name="l19543"></a>19543     LITE_INLINE result_type operator()(first_argument_type&amp; a, <span class="keyword">const</span> second_argument_type&amp; b)<span class="keyword"> const </span>
<a name="l19544"></a>19544 <span class="keyword">    </span>{ <span class="keywordflow">return</span> a += b; } 
<a name="l19545"></a>19545 };
<a name="l19546"></a>19546 
<a name="l19547"></a>19547 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_&gt;
<a name="l19548"></a>19548 <span class="keyword">class </span>minus_assign
<a name="l19549"></a>19549 { 
<a name="l19550"></a>19550 <span class="keyword">public</span>: 
<a name="l19551"></a>19551     <span class="keyword">typedef</span> type_ first_argument_type;
<a name="l19552"></a>19552     <span class="keyword">typedef</span> type_ second_argument_type;
<a name="l19553"></a>19553     <span class="keyword">typedef</span> type_&amp; result_type;
<a name="l19554"></a>19554 
<a name="l19555"></a>19555     LITE_INLINE result_type operator()(first_argument_type&amp; a, <span class="keyword">const</span> second_argument_type&amp; b)<span class="keyword"> const </span>
<a name="l19556"></a>19556 <span class="keyword">    </span>{ <span class="keywordflow">return</span> a -= b; } 
<a name="l19557"></a>19557 };
<a name="l19558"></a>19558 
<a name="l19559"></a>19559 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_&gt;
<a name="l19560"></a>19560 <span class="keyword">class </span>multiplies_assign
<a name="l19561"></a>19561 { 
<a name="l19562"></a>19562 <span class="keyword">public</span>: 
<a name="l19563"></a>19563     <span class="keyword">typedef</span> type_ first_argument_type;
<a name="l19564"></a>19564     <span class="keyword">typedef</span> type_ second_argument_type;
<a name="l19565"></a>19565     <span class="keyword">typedef</span> type_&amp; result_type;
<a name="l19566"></a>19566 
<a name="l19567"></a>19567     LITE_INLINE result_type operator()(first_argument_type&amp; a, <span class="keyword">const</span> second_argument_type&amp; b)<span class="keyword"> const </span>
<a name="l19568"></a>19568 <span class="keyword">    </span>{ <span class="keywordflow">return</span> a *= b; } 
<a name="l19569"></a>19569 };
<a name="l19570"></a>19570 
<a name="l19571"></a>19571 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_&gt;
<a name="l19572"></a>19572 <span class="keyword">class </span>divides_assign
<a name="l19573"></a>19573 { 
<a name="l19574"></a>19574 <span class="keyword">public</span>: 
<a name="l19575"></a>19575     <span class="keyword">typedef</span> type_ first_argument_type;
<a name="l19576"></a>19576     <span class="keyword">typedef</span> type_ second_argument_type;
<a name="l19577"></a>19577     <span class="keyword">typedef</span> type_&amp; result_type;
<a name="l19578"></a>19578 
<a name="l19579"></a>19579     LITE_INLINE result_type operator()(first_argument_type&amp; a, <span class="keyword">const</span> second_argument_type&amp; b)<span class="keyword"> const </span>
<a name="l19580"></a>19580 <span class="keyword">    </span>{ <span class="keywordflow">return</span> a /= b; } 
<a name="l19581"></a>19581 };
<a name="l19582"></a>19582 
<a name="l19583"></a>19583 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_&gt;
<a name="l19584"></a>19584 <span class="keyword">class </span>minimum
<a name="l19585"></a>19585 { 
<a name="l19586"></a>19586 <span class="keyword">public</span>: 
<a name="l19587"></a>19587     <span class="keyword">typedef</span> type_ first_argument_type;
<a name="l19588"></a>19588     <span class="keyword">typedef</span> type_ second_argument_type;
<a name="l19589"></a>19589     <span class="keyword">typedef</span> <span class="keyword">const</span> type_&amp; result_type;
<a name="l19590"></a>19590 
<a name="l19591"></a>19591     LITE_INLINE result_type operator()(<span class="keyword">const</span> first_argument_type&amp; a, <span class="keyword">const</span> second_argument_type&amp; b)<span class="keyword"> const </span>
<a name="l19592"></a>19592 <span class="keyword">    </span>{ <span class="keywordflow">return</span> a &lt; b ? a : b; } 
<a name="l19593"></a>19593 };
<a name="l19594"></a>19594 
<a name="l19595"></a>19595 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_&gt;
<a name="l19596"></a>19596 <span class="keyword">class </span>maximum
<a name="l19597"></a>19597 { 
<a name="l19598"></a>19598 <span class="keyword">public</span>: 
<a name="l19599"></a>19599     <span class="keyword">typedef</span> type_ first_argument_type;
<a name="l19600"></a>19600     <span class="keyword">typedef</span> type_ second_argument_type;
<a name="l19601"></a>19601     <span class="keyword">typedef</span> <span class="keyword">const</span> type_&amp; result_type;
<a name="l19602"></a>19602 
<a name="l19603"></a>19603     LITE_INLINE result_type operator()(<span class="keyword">const</span> first_argument_type&amp; a, <span class="keyword">const</span> second_argument_type&amp; b)<span class="keyword"> const </span>
<a name="l19604"></a>19604 <span class="keyword">    </span>{ <span class="keywordflow">return</span> a &gt; b ? a : b; } 
<a name="l19605"></a>19605 };
<a name="l19606"></a>19606 
<a name="l19607"></a>19607 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_&gt;
<a name="l19608"></a>19608 <span class="keyword">class </span>square
<a name="l19609"></a>19609 { 
<a name="l19610"></a>19610 <span class="keyword">public</span>: 
<a name="l19611"></a>19611     <span class="keyword">typedef</span> type_ argument_type;
<a name="l19612"></a>19612     <span class="keyword">typedef</span> type_ result_type;
<a name="l19613"></a>19613 
<a name="l19614"></a>19614     LITE_INLINE result_type operator()(<span class="keyword">const</span> argument_type&amp; a)<span class="keyword"> const </span>
<a name="l19615"></a>19615 <span class="keyword">    </span>{ <span class="keywordflow">return</span> a*a; } 
<a name="l19616"></a>19616 };
<a name="l19617"></a>19617 
<a name="l19618"></a>19618 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_&gt;
<a name="l19619"></a>19619 <span class="keyword">class </span>less
<a name="l19620"></a>19620 { 
<a name="l19621"></a>19621 <span class="keyword">public</span>: 
<a name="l19622"></a>19622     <span class="keyword">typedef</span> type_ first_argument_type;
<a name="l19623"></a>19623     <span class="keyword">typedef</span> type_ second_argument_type;
<a name="l19624"></a>19624     <span class="keyword">typedef</span> <span class="keywordtype">bool</span> result_type;
<a name="l19625"></a>19625 
<a name="l19626"></a>19626     LITE_INLINE result_type operator()(<span class="keyword">const</span> first_argument_type&amp; a, <span class="keyword">const</span> second_argument_type&amp; b)<span class="keyword"> const </span>
<a name="l19627"></a>19627 <span class="keyword">    </span>{ <span class="keywordflow">return</span> a &lt; b; } 
<a name="l19628"></a>19628 };
<a name="l19629"></a>19629 
<a name="l19630"></a>19630 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_&gt;
<a name="l19631"></a>19631 <span class="keyword">class </span>less_equal
<a name="l19632"></a>19632 { 
<a name="l19633"></a>19633 <span class="keyword">public</span>: 
<a name="l19634"></a>19634     <span class="keyword">typedef</span> type_ first_argument_type;
<a name="l19635"></a>19635     <span class="keyword">typedef</span> type_ second_argument_type;
<a name="l19636"></a>19636     <span class="keyword">typedef</span> <span class="keywordtype">bool</span> result_type;
<a name="l19637"></a>19637 
<a name="l19638"></a>19638     LITE_INLINE result_type operator()(<span class="keyword">const</span> first_argument_type&amp; a, <span class="keyword">const</span> second_argument_type&amp; b)<span class="keyword"> const </span>
<a name="l19639"></a>19639 <span class="keyword">    </span>{ <span class="keywordflow">return</span> a &lt;= b; } 
<a name="l19640"></a>19640 };
<a name="l19641"></a>19641 
<a name="l19642"></a>19642 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_&gt;
<a name="l19643"></a>19643 <span class="keyword">class </span>equal_to
<a name="l19644"></a>19644 { 
<a name="l19645"></a>19645 <span class="keyword">public</span>: 
<a name="l19646"></a>19646     <span class="keyword">typedef</span> type_ first_argument_type;
<a name="l19647"></a>19647     <span class="keyword">typedef</span> type_ second_argument_type;
<a name="l19648"></a>19648     <span class="keyword">typedef</span> <span class="keywordtype">bool</span> result_type;
<a name="l19649"></a>19649 
<a name="l19650"></a>19650     LITE_INLINE result_type operator()(<span class="keyword">const</span> first_argument_type&amp; a, <span class="keyword">const</span> second_argument_type&amp; b)<span class="keyword"> const </span>
<a name="l19651"></a>19651 <span class="keyword">    </span>{ <span class="keywordflow">return</span> a == b; } 
<a name="l19652"></a>19652 };
<a name="l19653"></a>19653 
<a name="l19654"></a>19654 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_&gt;
<a name="l19655"></a>19655 <span class="keyword">class </span>greater_equal
<a name="l19656"></a>19656 { 
<a name="l19657"></a>19657 <span class="keyword">public</span>: 
<a name="l19658"></a>19658     <span class="keyword">typedef</span> type_ first_argument_type;
<a name="l19659"></a>19659     <span class="keyword">typedef</span> type_ second_argument_type;
<a name="l19660"></a>19660     <span class="keyword">typedef</span> <span class="keywordtype">bool</span> result_type;
<a name="l19661"></a>19661 
<a name="l19662"></a>19662     LITE_INLINE result_type operator()(<span class="keyword">const</span> first_argument_type&amp; a, <span class="keyword">const</span> second_argument_type&amp; b)<span class="keyword"> const </span>
<a name="l19663"></a>19663 <span class="keyword">    </span>{ <span class="keywordflow">return</span> a &gt;= b; } 
<a name="l19664"></a>19664 };
<a name="l19665"></a>19665 
<a name="l19666"></a>19666 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_&gt;
<a name="l19667"></a>19667 <span class="keyword">class </span>greater
<a name="l19668"></a>19668 { 
<a name="l19669"></a>19669 <span class="keyword">public</span>: 
<a name="l19670"></a>19670     <span class="keyword">typedef</span> type_ first_argument_type;
<a name="l19671"></a>19671     <span class="keyword">typedef</span> type_ second_argument_type;
<a name="l19672"></a>19672     <span class="keyword">typedef</span> <span class="keywordtype">bool</span> result_type;
<a name="l19673"></a>19673 
<a name="l19674"></a>19674     LITE_INLINE result_type operator()(<span class="keyword">const</span> first_argument_type&amp; a, <span class="keyword">const</span> second_argument_type&amp; b)<span class="keyword"> const </span>
<a name="l19675"></a>19675 <span class="keyword">    </span>{ <span class="keywordflow">return</span> a &gt; b; } 
<a name="l19676"></a>19676 };
<a name="l19677"></a>19677 
<a name="l19678"></a>19678 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_&gt;
<a name="l19679"></a>19679 <span class="keyword">class </span>compare3
<a name="l19680"></a>19680 { 
<a name="l19681"></a>19681 <span class="keyword">public</span>: 
<a name="l19682"></a>19682     <span class="keyword">typedef</span> type_ first_argument_type;
<a name="l19683"></a>19683     <span class="keyword">typedef</span> type_ second_argument_type;
<a name="l19684"></a>19684     <span class="keyword">typedef</span> <span class="keywordtype">int</span> result_type;
<a name="l19685"></a>19685 
<a name="l19686"></a>19686     LITE_INLINE result_type operator()(<span class="keyword">const</span> first_argument_type&amp; a, <span class="keyword">const</span> second_argument_type&amp; b)<span class="keyword"> const </span>
<a name="l19687"></a>19687 <span class="keyword">    </span>{ <span class="keywordflow">return</span> a &lt; b ? -1 : b &lt; a ? 1 : 0; } 
<a name="l19688"></a>19688 };
<a name="l19689"></a>19689 
<a name="l19690"></a>19690 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_&gt;
<a name="l19691"></a>19691 <span class="keyword">class </span>round
<a name="l19692"></a>19692 { 
<a name="l19693"></a>19693 <span class="keyword">public</span>: 
<a name="l19694"></a>19694     <span class="keyword">typedef</span> type_ argument_type;
<a name="l19695"></a>19695     <span class="keyword">typedef</span> type_ result_type;
<a name="l19696"></a>19696 
<a name="l19697"></a>19697     round(<span class="keyword">const</span> type_&amp; normal = type_(1)) : m_normal(normal) {}
<a name="l19698"></a>19698 
<a name="l19699"></a>19699     LITE_INLINE result_type operator()(<span class="keyword">const</span> argument_type&amp; a)<span class="keyword"> const </span>
<a name="l19700"></a>19700 <span class="keyword">    </span>{ <span class="keywordflow">return</span> (a+m_normal)-m_normal; } 
<a name="l19701"></a>19701 
<a name="l19702"></a>19702 <span class="keyword">private</span>:
<a name="l19703"></a>19703     type_ m_normal;
<a name="l19704"></a>19704 };
<a name="l19705"></a>19705 
<a name="l19706"></a>19706 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_&gt;
<a name="l19707"></a>19707 <span class="keyword">class </span>accumulator
<a name="l19708"></a>19708 { 
<a name="l19709"></a>19709 <span class="keyword">public</span>: 
<a name="l19710"></a>19710     <span class="keyword">typedef</span> type_ argument_type;
<a name="l19711"></a>19711     <span class="keyword">typedef</span> <span class="keywordtype">void</span> result_type;
<a name="l19712"></a>19712 
<a name="l19713"></a>19713     LITE_INLINE accumulator(<span class="keyword">const</span> type_&amp; value = type_()) 
<a name="l19714"></a>19714         : m_value(value) 
<a name="l19715"></a>19715     {}
<a name="l19716"></a>19716 
<a name="l19717"></a>19717     LITE_INLINE accumulator(<span class="keyword">const</span> accumulator&amp; other) 
<a name="l19718"></a>19718         : m_value(other.m_value) 
<a name="l19719"></a>19719     {}
<a name="l19720"></a>19720 
<a name="l19721"></a>19721     LITE_INLINE accumulator&amp; operator=(<span class="keyword">const</span> accumulator&amp; other)
<a name="l19722"></a>19722     {
<a name="l19723"></a>19723         m_value = other.m_value;
<a name="l19724"></a>19724         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l19725"></a>19725     }
<a name="l19726"></a>19726 
<a name="l19727"></a>19727     LITE_INLINE <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> argument_type&amp; a) 
<a name="l19728"></a>19728     { 
<a name="l19729"></a>19729         m_value += a;
<a name="l19730"></a>19730     }
<a name="l19731"></a>19731 
<a name="l19732"></a>19732     LITE_INLINE type_ operator()()<span class="keyword"> const</span>
<a name="l19733"></a>19733 <span class="keyword">    </span>{ 
<a name="l19734"></a>19734         <span class="keywordflow">return</span> m_value;
<a name="l19735"></a>19735     }
<a name="l19736"></a>19736 
<a name="l19737"></a>19737 <span class="keyword">private</span>:
<a name="l19738"></a>19738     type_ m_value;
<a name="l19739"></a>19739 };
<a name="l19740"></a>19740 
<a name="l19741"></a>19741 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_&gt;
<a name="l19742"></a>19742 <span class="keyword">class </span>while_equal
<a name="l19743"></a>19743 { 
<a name="l19744"></a>19744 <span class="keyword">public</span>: 
<a name="l19745"></a>19745     <span class="keyword">typedef</span> type_ argument_type;
<a name="l19746"></a>19746     <span class="keyword">typedef</span> <span class="keywordtype">bool</span> result_type;
<a name="l19747"></a>19747 
<a name="l19748"></a>19748     LITE_INLINE while_equal(): m_result() {}
<a name="l19749"></a>19749 
<a name="l19750"></a>19750     LITE_INLINE while_equal(<span class="keyword">const</span> while_equal&amp; other) : m_result(other.m_result) {}
<a name="l19751"></a>19751 
<a name="l19752"></a>19752     LITE_INLINE while_equal&amp; operator=(<span class="keyword">const</span> while_equal&amp; other) 
<a name="l19753"></a>19753     { 
<a name="l19754"></a>19754         m_result = other.m_result;
<a name="l19755"></a>19755         <span class="keywordflow">return</span> *<span class="keyword">this</span>; 
<a name="l19756"></a>19756     }
<a name="l19757"></a>19757 
<a name="l19758"></a>19758     LITE_INLINE result_type operator()(<span class="keyword">const</span> argument_type&amp; a) 
<a name="l19759"></a>19759     { 
<a name="l19760"></a>19760         <span class="keywordflow">if</span> (a == 0)
<a name="l19761"></a>19761             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l19762"></a>19762 
<a name="l19763"></a>19763         m_result = a;
<a name="l19764"></a>19764         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l19765"></a>19765     }
<a name="l19766"></a>19766     
<a name="l19767"></a>19767     LITE_INLINE argument_type operator()()<span class="keyword"> const</span>
<a name="l19768"></a>19768 <span class="keyword">    </span>{
<a name="l19769"></a>19769         <span class="keywordflow">return</span> m_result;
<a name="l19770"></a>19770     }
<a name="l19771"></a>19771 
<a name="l19772"></a>19772 <span class="keyword">private</span>:
<a name="l19773"></a>19773     argument_type m_result;
<a name="l19774"></a>19774 };
<a name="l19775"></a>19775 
<a name="l19776"></a>19776 
<a name="l19777"></a>19777 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_&gt;
<a name="l19778"></a>19778 <span class="keyword">class </span>swapper
<a name="l19779"></a>19779 { 
<a name="l19780"></a>19780 <span class="keyword">public</span>: 
<a name="l19781"></a>19781     <span class="keyword">typedef</span> type_ first_argument_type;
<a name="l19782"></a>19782     <span class="keyword">typedef</span> type_ second_argument_type;
<a name="l19783"></a>19783     <span class="keyword">typedef</span> <span class="keywordtype">bool</span> result_type;
<a name="l19784"></a>19784 
<a name="l19785"></a>19785     LITE_INLINE result_type operator()(first_argument_type&amp; a, second_argument_type&amp; b)<span class="keyword"> const </span>
<a name="l19786"></a>19786 <span class="keyword">    </span>{ 
<a name="l19787"></a>19787         std::swap(a, b);
<a name="l19788"></a>19788         <span class="keywordflow">return</span> <span class="keyword">true</span>; 
<a name="l19789"></a>19789     } 
<a name="l19790"></a>19790 };
<a name="l19791"></a>19791 
<a name="l19792"></a>19792 <span class="comment">/***********************************************************************************************************/</span>
<a name="l19793"></a>19793 <span class="comment">/* apply&lt;F&gt;(A) *********************************************************************************************/</span>
<a name="l19794"></a>19794 <span class="comment">/***********************************************************************************************************/</span>
<a name="l19795"></a>19795 
<a name="l19796"></a>19796 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> func_type_, <span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> rep_&gt;
<a name="l19797"></a>19797 LITE_INLINE array&lt;signature_, traits_type_, reference_rep&lt;u_iterator&lt;
<a name="l19798"></a>19798     <span class="keyword">typename</span> array&lt;signature_,traits_type_, rep_&gt;::const_iterator,
<a name="l19799"></a>19799     func_type_&gt;
<a name="l19800"></a>19800     &gt; &gt;
<a name="l19801"></a>19801 apply(<span class="keyword">const</span> array&lt;signature_, traits_type_, rep_&gt;&amp; a)
<a name="l19802"></a>19802 {
<a name="l19803"></a>19803     <span class="keyword">typedef</span> array&lt;signature_, traits_type_, reference_rep&lt;u_iterator&lt;
<a name="l19804"></a>19804         <span class="keyword">typename</span> array&lt;signature_,traits_type_, rep_&gt;::const_iterator,
<a name="l19805"></a>19805         func_type_&gt; &gt; 
<a name="l19806"></a>19806     &gt; result_type;
<a name="l19807"></a>19807 
<a name="l19808"></a>19808     <span class="keywordflow">return</span> result_type(a.begin(), a.size());
<a name="l19809"></a>19809 }
<a name="l19810"></a>19810 
<a name="l19811"></a>19811 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> func_type_, <span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> rep_&gt;
<a name="l19812"></a>19812 LITE_INLINE array&lt;signature_, traits_type_, reference_rep&lt;u_iterator&lt;
<a name="l19813"></a>19813     <span class="keyword">typename</span> array&lt;signature_,traits_type_, rep_&gt;::iterator,
<a name="l19814"></a>19814     func_type_&gt;
<a name="l19815"></a>19815     &gt; &gt;
<a name="l19816"></a>19816 apply(array&lt;signature_, traits_type_, rep_&gt;&amp; a)
<a name="l19817"></a>19817 {
<a name="l19818"></a>19818     <span class="keyword">typedef</span> array&lt;signature_, traits_type_, reference_rep&lt;u_iterator&lt;
<a name="l19819"></a>19819         <span class="keyword">typename</span> array&lt;signature_,traits_type_, rep_&gt;::iterator,
<a name="l19820"></a>19820         func_type_&gt; &gt; 
<a name="l19821"></a>19821     &gt; result_type;
<a name="l19822"></a>19822 
<a name="l19823"></a>19823     <span class="keywordflow">return</span> result_type(a.begin(), a.size());
<a name="l19824"></a>19824 }
<a name="l19825"></a>19825 
<a name="l19826"></a>19826 <span class="comment">/***********************************************************************************************************/</span>
<a name="l19827"></a>19827 <span class="comment">/* apply(A,f) **********************************************************************************************/</span>
<a name="l19828"></a>19828 <span class="comment">/***********************************************************************************************************/</span>
<a name="l19829"></a>19829 
<a name="l19830"></a>19830 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> func_type_, <span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> rep_&gt;
<a name="l19831"></a>19831 LITE_INLINE array&lt;signature_, traits_type_, reference_rep&lt;u_iterator&lt;
<a name="l19832"></a>19832     <span class="keyword">typename</span> array&lt;signature_,traits_type_, rep_&gt;::const_iterator,
<a name="l19833"></a>19833     func_type_,
<a name="l19834"></a>19834     <span class="keyword">false</span>&gt;
<a name="l19835"></a>19835     &gt; &gt;
<a name="l19836"></a>19836 apply(<span class="keyword">const</span> array&lt;signature_, traits_type_, rep_&gt;&amp; a, <span class="keyword">const</span> func_type_&amp; func)
<a name="l19837"></a>19837 {
<a name="l19838"></a>19838     <span class="keyword">typedef</span> array&lt;signature_, traits_type_, reference_rep&lt;u_iterator&lt;
<a name="l19839"></a>19839         <span class="keyword">typename</span> array&lt;signature_,traits_type_, rep_&gt;::const_iterator,
<a name="l19840"></a>19840         func_type_,
<a name="l19841"></a>19841         <span class="keyword">false</span>&gt; &gt; 
<a name="l19842"></a>19842     &gt; result_type;
<a name="l19843"></a>19843 
<a name="l19844"></a>19844     <span class="keywordflow">return</span> result_type(a.begin(), func, a.size());
<a name="l19845"></a>19845 }
<a name="l19846"></a>19846 
<a name="l19847"></a>19847 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> func_type_, <span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> rep_&gt;
<a name="l19848"></a>19848 LITE_INLINE array&lt;signature_, traits_type_, reference_rep&lt;u_iterator&lt;
<a name="l19849"></a>19849     <span class="keyword">typename</span> array&lt;signature_,traits_type_, rep_&gt;::iterator,
<a name="l19850"></a>19850     func_type_,
<a name="l19851"></a>19851     <span class="keyword">false</span>&gt;
<a name="l19852"></a>19852     &gt; &gt;
<a name="l19853"></a>19853 apply(array&lt;signature_, traits_type_, rep_&gt;&amp; a, <span class="keyword">const</span> func_type_&amp; func)
<a name="l19854"></a>19854 {
<a name="l19855"></a>19855     <span class="keyword">typedef</span> array&lt;signature_, traits_type_, reference_rep&lt;u_iterator&lt;
<a name="l19856"></a>19856         <span class="keyword">typename</span> array&lt;signature_,traits_type_, rep_&gt;::iterator,
<a name="l19857"></a>19857         func_type_,
<a name="l19858"></a>19858         <span class="keyword">false</span>&gt; &gt; 
<a name="l19859"></a>19859     &gt; result_type;
<a name="l19860"></a>19860 
<a name="l19861"></a>19861     <span class="keywordflow">return</span> result_type(a.begin(), func, a.size());
<a name="l19862"></a>19862 }
<a name="l19863"></a>19863 
<a name="l19864"></a>19864 
<a name="l19865"></a>19865 <span class="comment">/***********************************************************************************************************/</span>
<a name="l19866"></a>19866 <span class="comment">/* apply&lt;F&gt;(A,A) *******************************************************************************************/</span>
<a name="l19867"></a>19867 <span class="comment">/***********************************************************************************************************/</span>
<a name="l19868"></a>19868 
<a name="l19869"></a>19869 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> func_type_, <span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_, <span class="keyword">typename</span> r_rep_&gt;
<a name="l19870"></a>19870 LITE_INLINE 
<a name="l19871"></a>19871 array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l19872"></a>19872     <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::const_iterator,
<a name="l19873"></a>19873     <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::const_iterator,
<a name="l19874"></a>19874     func_type_&gt;
<a name="l19875"></a>19875     &gt; &gt;
<a name="l19876"></a>19876 apply(<span class="keyword">const</span> array&lt;signature_, traits_type_, l_rep_&gt;&amp; a, <span class="keyword">const</span> array&lt;signature_, traits_type_, r_rep_&gt;&amp; b)
<a name="l19877"></a>19877 {
<a name="l19878"></a>19878     <span class="keyword">typedef</span> array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l19879"></a>19879         <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::const_iterator,
<a name="l19880"></a>19880         <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::const_iterator,
<a name="l19881"></a>19881         func_type_
<a name="l19882"></a>19882         &gt; &gt; &gt; result_type;
<a name="l19883"></a>19883 
<a name="l19884"></a>19884     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), <span class="stringliteral">&quot;apply&lt;F&gt;(A,A): array sizes do not match&quot;</span>);
<a name="l19885"></a>19885     <span class="keywordflow">return</span> result_type(a.begin(), b.begin(), a.size());
<a name="l19886"></a>19886 }
<a name="l19887"></a>19887 
<a name="l19888"></a>19888 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> func_type_, <span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_, <span class="keyword">typename</span> r_rep_&gt;
<a name="l19889"></a>19889 LITE_INLINE 
<a name="l19890"></a>19890 array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l19891"></a>19891     <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::iterator,
<a name="l19892"></a>19892     <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::const_iterator,
<a name="l19893"></a>19893     func_type_&gt;
<a name="l19894"></a>19894     &gt; &gt;
<a name="l19895"></a>19895 apply(array&lt;signature_, traits_type_, l_rep_&gt;&amp; a, <span class="keyword">const</span> array&lt;signature_, traits_type_, r_rep_&gt;&amp; b)
<a name="l19896"></a>19896 {
<a name="l19897"></a>19897     <span class="keyword">typedef</span> array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l19898"></a>19898         <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::iterator,
<a name="l19899"></a>19899         <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::const_iterator,
<a name="l19900"></a>19900         func_type_
<a name="l19901"></a>19901         &gt; &gt; &gt; result_type;
<a name="l19902"></a>19902 
<a name="l19903"></a>19903     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), <span class="stringliteral">&quot;apply&lt;F&gt;(A,A): array sizes do not match&quot;</span>);
<a name="l19904"></a>19904     <span class="keywordflow">return</span> result_type(a.begin(), b.begin(), a.size());
<a name="l19905"></a>19905 }
<a name="l19906"></a>19906 
<a name="l19907"></a>19907 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> func_type_, <span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_, <span class="keyword">typename</span> r_rep_&gt;
<a name="l19908"></a>19908 LITE_INLINE 
<a name="l19909"></a>19909 array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l19910"></a>19910     <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::const_iterator,
<a name="l19911"></a>19911     <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::iterator,
<a name="l19912"></a>19912     func_type_&gt;
<a name="l19913"></a>19913     &gt; &gt;
<a name="l19914"></a>19914 apply(<span class="keyword">const</span> array&lt;signature_, traits_type_, l_rep_&gt;&amp; a, array&lt;signature_, traits_type_, r_rep_&gt;&amp; b)
<a name="l19915"></a>19915 {
<a name="l19916"></a>19916     <span class="keyword">typedef</span> array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l19917"></a>19917         <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::const_iterator,
<a name="l19918"></a>19918         <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::iterator,
<a name="l19919"></a>19919         func_type_
<a name="l19920"></a>19920         &gt; &gt; &gt; result_type;
<a name="l19921"></a>19921 
<a name="l19922"></a>19922     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), <span class="stringliteral">&quot;apply&lt;F&gt;(A,A): array sizes do not match&quot;</span>);
<a name="l19923"></a>19923     <span class="keywordflow">return</span> result_type(a.begin(), b.begin(), a.size());
<a name="l19924"></a>19924 }
<a name="l19925"></a>19925 
<a name="l19926"></a>19926 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> func_type_, <span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_, <span class="keyword">typename</span> r_rep_&gt;
<a name="l19927"></a>19927 LITE_INLINE 
<a name="l19928"></a>19928 array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l19929"></a>19929     <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::iterator,
<a name="l19930"></a>19930     <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::iterator,
<a name="l19931"></a>19931     func_type_&gt;
<a name="l19932"></a>19932     &gt; &gt;
<a name="l19933"></a>19933 apply(array&lt;signature_, traits_type_, l_rep_&gt;&amp; a, array&lt;signature_, traits_type_, r_rep_&gt;&amp; b)
<a name="l19934"></a>19934 {
<a name="l19935"></a>19935     <span class="keyword">typedef</span> array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l19936"></a>19936         <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::iterator,
<a name="l19937"></a>19937         <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::iterator,
<a name="l19938"></a>19938         func_type_
<a name="l19939"></a>19939         &gt; &gt; &gt; result_type;
<a name="l19940"></a>19940 
<a name="l19941"></a>19941     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), <span class="stringliteral">&quot;apply&lt;F&gt;(A,A): array sizes do not match&quot;</span>);
<a name="l19942"></a>19942     <span class="keywordflow">return</span> result_type(a.begin(), b.begin(), a.size());
<a name="l19943"></a>19943 }
<a name="l19944"></a>19944 
<a name="l19945"></a>19945 <span class="comment">/***********************************************************************************************************/</span>
<a name="l19946"></a>19946 <span class="comment">/* apply(A,A,f) ********************************************************************************************/</span>
<a name="l19947"></a>19947 <span class="comment">/***********************************************************************************************************/</span>
<a name="l19948"></a>19948 
<a name="l19949"></a>19949 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> func_type_, <span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_, <span class="keyword">typename</span> r_rep_&gt;
<a name="l19950"></a>19950 LITE_INLINE 
<a name="l19951"></a>19951 array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l19952"></a>19952     <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::const_iterator,
<a name="l19953"></a>19953     <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::const_iterator,
<a name="l19954"></a>19954     func_type_&gt;
<a name="l19955"></a>19955     &gt; &gt;
<a name="l19956"></a>19956 apply(
<a name="l19957"></a>19957     <span class="keyword">const</span> array&lt;signature_, traits_type_, l_rep_&gt;&amp; a, 
<a name="l19958"></a>19958     <span class="keyword">const</span> array&lt;signature_, traits_type_, r_rep_&gt;&amp; b,
<a name="l19959"></a>19959     <span class="keyword">const</span> func_type_&amp; func)
<a name="l19960"></a>19960 {
<a name="l19961"></a>19961     <span class="keyword">typedef</span> array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l19962"></a>19962         <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::const_iterator,
<a name="l19963"></a>19963         <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::const_iterator,
<a name="l19964"></a>19964         func_type_,
<a name="l19965"></a>19965         <span class="keyword">false</span>
<a name="l19966"></a>19966         &gt; &gt; &gt; result_type;
<a name="l19967"></a>19967 
<a name="l19968"></a>19968     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), <span class="stringliteral">&quot;apply(A,A,f): array sizes do not match&quot;</span>);
<a name="l19969"></a>19969     <span class="keywordflow">return</span> result_type(a.begin(), b.begin(), func, a.size());
<a name="l19970"></a>19970 }
<a name="l19971"></a>19971 
<a name="l19972"></a>19972 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> func_type_, <span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_, <span class="keyword">typename</span> r_rep_&gt;
<a name="l19973"></a>19973 LITE_INLINE 
<a name="l19974"></a>19974 array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l19975"></a>19975     <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::iterator,
<a name="l19976"></a>19976     <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::const_iterator,
<a name="l19977"></a>19977     func_type_&gt;
<a name="l19978"></a>19978     &gt; &gt;
<a name="l19979"></a>19979 apply(
<a name="l19980"></a>19980     array&lt;signature_, traits_type_, l_rep_&gt;&amp; a, 
<a name="l19981"></a>19981     <span class="keyword">const</span> array&lt;signature_, traits_type_, r_rep_&gt;&amp; b,
<a name="l19982"></a>19982     <span class="keyword">const</span> func_type_&amp; func)
<a name="l19983"></a>19983 {
<a name="l19984"></a>19984     <span class="keyword">typedef</span> array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l19985"></a>19985         <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::iterator,
<a name="l19986"></a>19986         <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::const_iterator,
<a name="l19987"></a>19987         func_type_,
<a name="l19988"></a>19988         <span class="keyword">false</span>
<a name="l19989"></a>19989         &gt; &gt; &gt; result_type;
<a name="l19990"></a>19990 
<a name="l19991"></a>19991     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), <span class="stringliteral">&quot;apply(A,A,f): array sizes do not match&quot;</span>);
<a name="l19992"></a>19992     <span class="keywordflow">return</span> result_type(a.begin(), b.begin(), func, a.size());
<a name="l19993"></a>19993 }
<a name="l19994"></a>19994 
<a name="l19995"></a>19995 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> func_type_, <span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_, <span class="keyword">typename</span> r_rep_&gt;
<a name="l19996"></a>19996 LITE_INLINE 
<a name="l19997"></a>19997 array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l19998"></a>19998     <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::const_iterator,
<a name="l19999"></a>19999     <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::iterator,
<a name="l20000"></a>20000     func_type_&gt;
<a name="l20001"></a>20001     &gt; &gt;
<a name="l20002"></a>20002 apply(
<a name="l20003"></a>20003     <span class="keyword">const</span> array&lt;signature_, traits_type_, l_rep_&gt;&amp; a, 
<a name="l20004"></a>20004     array&lt;signature_, traits_type_, r_rep_&gt;&amp; b,
<a name="l20005"></a>20005     <span class="keyword">const</span> func_type_&amp; func)
<a name="l20006"></a>20006 {
<a name="l20007"></a>20007     <span class="keyword">typedef</span> array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l20008"></a>20008         <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::const_iterator,
<a name="l20009"></a>20009         <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::iterator,
<a name="l20010"></a>20010         func_type_,
<a name="l20011"></a>20011         <span class="keyword">false</span>
<a name="l20012"></a>20012         &gt; &gt; &gt; result_type;
<a name="l20013"></a>20013 
<a name="l20014"></a>20014     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), <span class="stringliteral">&quot;apply(A,A,f): array sizes do not match&quot;</span>);
<a name="l20015"></a>20015     <span class="keywordflow">return</span> result_type(a.begin(), b.begin(), func, a.size());
<a name="l20016"></a>20016 }
<a name="l20017"></a>20017 
<a name="l20018"></a>20018 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> func_type_, <span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_, <span class="keyword">typename</span> r_rep_&gt;
<a name="l20019"></a>20019 LITE_INLINE 
<a name="l20020"></a>20020 array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l20021"></a>20021     <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::iterator,
<a name="l20022"></a>20022     <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::iterator,
<a name="l20023"></a>20023     func_type_&gt;
<a name="l20024"></a>20024     &gt; &gt;
<a name="l20025"></a>20025 apply(
<a name="l20026"></a>20026     array&lt;signature_, traits_type_, l_rep_&gt;&amp; a, 
<a name="l20027"></a>20027     array&lt;signature_, traits_type_, r_rep_&gt;&amp; b,
<a name="l20028"></a>20028     <span class="keyword">const</span> func_type_&amp; func)
<a name="l20029"></a>20029 {
<a name="l20030"></a>20030     <span class="keyword">typedef</span> array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l20031"></a>20031         <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::iterator,
<a name="l20032"></a>20032         <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::iterator,
<a name="l20033"></a>20033         func_type_,
<a name="l20034"></a>20034         <span class="keyword">false</span>
<a name="l20035"></a>20035         &gt; &gt; &gt; result_type;
<a name="l20036"></a>20036 
<a name="l20037"></a>20037     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), <span class="stringliteral">&quot;apply(A,A,f): array sizes do not match&quot;</span>);
<a name="l20038"></a>20038     <span class="keywordflow">return</span> result_type(a.begin(), b.begin(), func, a.size());
<a name="l20039"></a>20039 }
<a name="l20040"></a>20040 
<a name="l20041"></a>20041 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20042"></a>20042 <span class="comment">/* +A ******************************************************************************************************/</span>
<a name="l20043"></a>20043 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20044"></a>20044 
<a name="l20045"></a>20045 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> rep_&gt;
<a name="l20046"></a>20046 LITE_INLINE 
<a name="l20047"></a>20047 array&lt;signature_, traits_type_, reference_rep&lt;u_iterator&lt;
<a name="l20048"></a>20048     <span class="keyword">typename</span> array&lt;signature_,traits_type_, rep_&gt;::const_iterator,
<a name="l20049"></a>20049     uplus&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20050"></a>20050     &gt; &gt; &gt;
<a name="l20051"></a>20051 operator+(<span class="keyword">const</span> array&lt;signature_, traits_type_, rep_&gt;&amp; a)
<a name="l20052"></a>20052 {
<a name="l20053"></a>20053     <span class="keyword">typedef</span> array&lt;signature_, traits_type_, reference_rep&lt;u_iterator&lt;
<a name="l20054"></a>20054         <span class="keyword">typename</span> array&lt;signature_,traits_type_, rep_&gt;::const_iterator,
<a name="l20055"></a>20055         uplus&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20056"></a>20056         &gt; &gt; &gt; result_type;
<a name="l20057"></a>20057 
<a name="l20058"></a>20058     <span class="keywordflow">return</span> result_type(a.begin(), a.size());
<a name="l20059"></a>20059 }
<a name="l20060"></a>20060 
<a name="l20061"></a>20061 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20062"></a>20062 <span class="comment">/* -A ******************************************************************************************************/</span>
<a name="l20063"></a>20063 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20064"></a>20064 
<a name="l20065"></a>20065 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> rep_&gt;
<a name="l20066"></a>20066 LITE_INLINE array&lt;signature_, traits_type_, reference_rep&lt;u_iterator&lt;
<a name="l20067"></a>20067     <span class="keyword">typename</span> array&lt;signature_,traits_type_, rep_&gt;::const_iterator,
<a name="l20068"></a>20068     negate&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20069"></a>20069     &gt; &gt; &gt;
<a name="l20070"></a>20070 operator-(<span class="keyword">const</span> array&lt;signature_, traits_type_, rep_&gt;&amp; a)
<a name="l20071"></a>20071 {
<a name="l20072"></a>20072     <span class="keyword">typedef</span> array&lt;signature_, traits_type_, reference_rep&lt;u_iterator&lt;
<a name="l20073"></a>20073         <span class="keyword">typename</span> array&lt;signature_,traits_type_, rep_&gt;::const_iterator,
<a name="l20074"></a>20074         negate&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20075"></a>20075         &gt; &gt; &gt; result_type;
<a name="l20076"></a>20076 
<a name="l20077"></a>20077     <span class="keywordflow">return</span> result_type(a.begin(), a.size());
<a name="l20078"></a>20078 }
<a name="l20079"></a>20079 
<a name="l20080"></a>20080 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20081"></a>20081 <span class="comment">/* A+c *****************************************************************************************************/</span>
<a name="l20082"></a>20082 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20083"></a>20083 
<a name="l20084"></a>20084 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_&gt;
<a name="l20085"></a>20085 LITE_INLINE 
<a name="l20086"></a>20086 array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l20087"></a>20087     <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::const_iterator,
<a name="l20088"></a>20088     c_iterator&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;,
<a name="l20089"></a>20089     plus&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20090"></a>20090     &gt; &gt; &gt;
<a name="l20091"></a>20091 operator+(
<a name="l20092"></a>20092     <span class="keyword">const</span> array&lt;signature_, traits_type_, l_rep_&gt;&amp; a, 
<a name="l20093"></a>20093     <span class="keyword">const</span> <span class="keyword">typename</span> array_signature_traits&lt;signature_&gt;::element_type&amp; b)
<a name="l20094"></a>20094 {
<a name="l20095"></a>20095     <span class="keyword">typedef</span> array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l20096"></a>20096         <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::const_iterator,
<a name="l20097"></a>20097         c_iterator&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;,
<a name="l20098"></a>20098         plus&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20099"></a>20099         &gt; &gt; &gt; result_type;
<a name="l20100"></a>20100 
<a name="l20101"></a>20101     <span class="keywordflow">return</span> result_type(a.begin(), b, a.size());
<a name="l20102"></a>20102 }
<a name="l20103"></a>20103 
<a name="l20104"></a>20104 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20105"></a>20105 <span class="comment">/* c+A *****************************************************************************************************/</span>
<a name="l20106"></a>20106 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20107"></a>20107 
<a name="l20108"></a>20108 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> r_rep_&gt;
<a name="l20109"></a>20109 LITE_INLINE 
<a name="l20110"></a>20110 array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l20111"></a>20111     c_iterator&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;,
<a name="l20112"></a>20112     <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::const_iterator,
<a name="l20113"></a>20113     plus&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20114"></a>20114     &gt; &gt; &gt;
<a name="l20115"></a>20115 operator+(
<a name="l20116"></a>20116     <span class="keyword">const</span> <span class="keyword">typename</span> array_signature_traits&lt;signature_&gt;::element_type&amp; a, 
<a name="l20117"></a>20117     <span class="keyword">const</span> array&lt;signature_, traits_type_, r_rep_&gt;&amp; b)
<a name="l20118"></a>20118 {
<a name="l20119"></a>20119     <span class="keyword">typedef</span> array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l20120"></a>20120         c_iterator&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;,
<a name="l20121"></a>20121         <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::const_iterator,
<a name="l20122"></a>20122         plus&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20123"></a>20123         &gt; &gt; &gt; result_type;
<a name="l20124"></a>20124 
<a name="l20125"></a>20125     <span class="keywordflow">return</span> result_type(a, b.begin(), b.size());
<a name="l20126"></a>20126 }
<a name="l20127"></a>20127 
<a name="l20128"></a>20128 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20129"></a>20129 <span class="comment">/* A-c *****************************************************************************************************/</span>
<a name="l20130"></a>20130 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20131"></a>20131 
<a name="l20132"></a>20132 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_&gt;
<a name="l20133"></a>20133 LITE_INLINE 
<a name="l20134"></a>20134 array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l20135"></a>20135     <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::const_iterator,
<a name="l20136"></a>20136     c_iterator&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;,
<a name="l20137"></a>20137     minus&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20138"></a>20138     &gt; &gt; &gt;
<a name="l20139"></a>20139 operator-(
<a name="l20140"></a>20140     <span class="keyword">const</span> array&lt;signature_, traits_type_, l_rep_&gt;&amp; a, 
<a name="l20141"></a>20141     <span class="keyword">const</span> <span class="keyword">typename</span> array_signature_traits&lt;signature_&gt;::element_type&amp; b)
<a name="l20142"></a>20142 {
<a name="l20143"></a>20143     <span class="keyword">typedef</span> array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l20144"></a>20144         <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::const_iterator,
<a name="l20145"></a>20145         c_iterator&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;,
<a name="l20146"></a>20146         minus&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20147"></a>20147         &gt; &gt; &gt; result_type;
<a name="l20148"></a>20148 
<a name="l20149"></a>20149     <span class="keywordflow">return</span> result_type(a.begin(), b, a.size());
<a name="l20150"></a>20150 }
<a name="l20151"></a>20151 
<a name="l20152"></a>20152 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20153"></a>20153 <span class="comment">/* c-A *****************************************************************************************************/</span>
<a name="l20154"></a>20154 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20155"></a>20155 
<a name="l20156"></a>20156 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> r_rep_&gt;
<a name="l20157"></a>20157 LITE_INLINE 
<a name="l20158"></a>20158 array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l20159"></a>20159     c_iterator&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;,
<a name="l20160"></a>20160     <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::const_iterator,
<a name="l20161"></a>20161     minus&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20162"></a>20162     &gt; &gt; &gt;
<a name="l20163"></a>20163 operator-(
<a name="l20164"></a>20164     <span class="keyword">const</span> <span class="keyword">typename</span> array_signature_traits&lt;signature_&gt;::element_type&amp; a, 
<a name="l20165"></a>20165     <span class="keyword">const</span> array&lt;signature_, traits_type_, r_rep_&gt;&amp; b)
<a name="l20166"></a>20166 {
<a name="l20167"></a>20167     <span class="keyword">typedef</span> array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l20168"></a>20168         c_iterator&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;,
<a name="l20169"></a>20169         <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::const_iterator,
<a name="l20170"></a>20170         minus&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20171"></a>20171         &gt; &gt; &gt; result_type;
<a name="l20172"></a>20172 
<a name="l20173"></a>20173     <span class="keywordflow">return</span> result_type(a, b.begin(), b.size());
<a name="l20174"></a>20174 }
<a name="l20175"></a>20175 
<a name="l20176"></a>20176 
<a name="l20177"></a>20177 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20178"></a>20178 <span class="comment">/* A*c *****************************************************************************************************/</span>
<a name="l20179"></a>20179 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20180"></a>20180 
<a name="l20181"></a>20181 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_&gt;
<a name="l20182"></a>20182 LITE_INLINE 
<a name="l20183"></a>20183 array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l20184"></a>20184     <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::const_iterator,
<a name="l20185"></a>20185     c_iterator&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;,
<a name="l20186"></a>20186     multiplies&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20187"></a>20187     &gt; &gt; &gt;
<a name="l20188"></a>20188 operator*(
<a name="l20189"></a>20189     <span class="keyword">const</span> array&lt;signature_, traits_type_, l_rep_&gt;&amp; a, 
<a name="l20190"></a>20190     <span class="keyword">const</span> <span class="keyword">typename</span> array_signature_traits&lt;signature_&gt;::element_type&amp; b)
<a name="l20191"></a>20191 {
<a name="l20192"></a>20192     <span class="keyword">typedef</span> array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l20193"></a>20193         <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::const_iterator,
<a name="l20194"></a>20194         c_iterator&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;,
<a name="l20195"></a>20195         multiplies&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20196"></a>20196         &gt; &gt; &gt; result_type;
<a name="l20197"></a>20197 
<a name="l20198"></a>20198     <span class="keywordflow">return</span> result_type(a.begin(), b, a.size());
<a name="l20199"></a>20199 }
<a name="l20200"></a>20200 
<a name="l20201"></a>20201 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20202"></a>20202 <span class="comment">/* c*A *****************************************************************************************************/</span>
<a name="l20203"></a>20203 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20204"></a>20204 
<a name="l20205"></a>20205 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> r_rep_&gt;
<a name="l20206"></a>20206 LITE_INLINE 
<a name="l20207"></a>20207 array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l20208"></a>20208     c_iterator&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;,
<a name="l20209"></a>20209     <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::const_iterator,
<a name="l20210"></a>20210     multiplies&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20211"></a>20211     &gt; &gt; &gt;
<a name="l20212"></a>20212 operator*(
<a name="l20213"></a>20213     <span class="keyword">const</span> <span class="keyword">typename</span> array_signature_traits&lt;signature_&gt;::element_type&amp; a, 
<a name="l20214"></a>20214     <span class="keyword">const</span> array&lt;signature_, traits_type_, r_rep_&gt;&amp; b)
<a name="l20215"></a>20215 {
<a name="l20216"></a>20216     <span class="keyword">typedef</span> array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l20217"></a>20217         c_iterator&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;,
<a name="l20218"></a>20218         <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::const_iterator,
<a name="l20219"></a>20219         multiplies&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20220"></a>20220         &gt; &gt; &gt; result_type;
<a name="l20221"></a>20221 
<a name="l20222"></a>20222     <span class="keywordflow">return</span> result_type(a, b.begin(), b.size());
<a name="l20223"></a>20223 }
<a name="l20224"></a>20224 
<a name="l20225"></a>20225 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20226"></a>20226 <span class="comment">/* A/c *****************************************************************************************************/</span>
<a name="l20227"></a>20227 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20228"></a>20228 
<a name="l20229"></a>20229 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_&gt;
<a name="l20230"></a>20230 LITE_INLINE 
<a name="l20231"></a>20231 array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l20232"></a>20232     <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::const_iterator,
<a name="l20233"></a>20233     c_iterator&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;,
<a name="l20234"></a>20234     divides&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20235"></a>20235     &gt; &gt; &gt;
<a name="l20236"></a>20236 operator/(
<a name="l20237"></a>20237     <span class="keyword">const</span> array&lt;signature_, traits_type_, l_rep_&gt;&amp; a, 
<a name="l20238"></a>20238     <span class="keyword">const</span> <span class="keyword">typename</span> array_signature_traits&lt;signature_&gt;::element_type&amp; b)
<a name="l20239"></a>20239 {
<a name="l20240"></a>20240     <span class="keyword">typedef</span> array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l20241"></a>20241         <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::const_iterator,
<a name="l20242"></a>20242         c_iterator&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;,
<a name="l20243"></a>20243         divides&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20244"></a>20244         &gt; &gt; &gt; result_type;
<a name="l20245"></a>20245 
<a name="l20246"></a>20246     <span class="keywordflow">return</span> result_type(a.begin(), b, a.size());
<a name="l20247"></a>20247 }
<a name="l20248"></a>20248 
<a name="l20249"></a>20249 
<a name="l20250"></a>20250 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20251"></a>20251 <span class="comment">/* A+A *****************************************************************************************************/</span>
<a name="l20252"></a>20252 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20253"></a>20253 
<a name="l20254"></a>20254 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_, <span class="keyword">typename</span> r_rep_&gt;
<a name="l20255"></a>20255 LITE_INLINE 
<a name="l20256"></a>20256 array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l20257"></a>20257     <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::const_iterator,
<a name="l20258"></a>20258     <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::const_iterator,
<a name="l20259"></a>20259     plus&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20260"></a>20260     &gt; &gt; &gt;
<a name="l20261"></a>20261 operator+(<span class="keyword">const</span> array&lt;signature_, traits_type_, l_rep_&gt;&amp; a, <span class="keyword">const</span> array&lt;signature_, traits_type_, r_rep_&gt;&amp; b)
<a name="l20262"></a>20262 {
<a name="l20263"></a>20263     <span class="keyword">typedef</span> array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l20264"></a>20264         <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::const_iterator,
<a name="l20265"></a>20265         <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::const_iterator,
<a name="l20266"></a>20266         plus&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20267"></a>20267         &gt; &gt; &gt; result_type;
<a name="l20268"></a>20268 
<a name="l20269"></a>20269     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), <span class="stringliteral">&quot;operator+(A,A): array sizes do not match&quot;</span>);
<a name="l20270"></a>20270     <span class="keywordflow">return</span> result_type(a.begin(), b.begin(), a.size());
<a name="l20271"></a>20271 }
<a name="l20272"></a>20272 
<a name="l20273"></a>20273 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20274"></a>20274 <span class="comment">/* A-A *****************************************************************************************************/</span>
<a name="l20275"></a>20275 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20276"></a>20276 
<a name="l20277"></a>20277 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_, <span class="keyword">typename</span> r_rep_&gt;
<a name="l20278"></a>20278 LITE_INLINE 
<a name="l20279"></a>20279 array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l20280"></a>20280     <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::const_iterator,
<a name="l20281"></a>20281     <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::const_iterator,
<a name="l20282"></a>20282     minus&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20283"></a>20283     &gt; &gt; &gt;
<a name="l20284"></a>20284 operator-(<span class="keyword">const</span> array&lt;signature_, traits_type_, l_rep_&gt;&amp; a, <span class="keyword">const</span> array&lt;signature_, traits_type_, r_rep_&gt;&amp; b)
<a name="l20285"></a>20285 {
<a name="l20286"></a>20286     <span class="keyword">typedef</span> array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l20287"></a>20287         <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::const_iterator,
<a name="l20288"></a>20288         <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::const_iterator,
<a name="l20289"></a>20289         minus&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20290"></a>20290         &gt; &gt; &gt; result_type;
<a name="l20291"></a>20291 
<a name="l20292"></a>20292     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), <span class="stringliteral">&quot;operator-(A,A): array sizes do not match&quot;</span>);
<a name="l20293"></a>20293     <span class="keywordflow">return</span> result_type(a.begin(), b.begin(), a.size());
<a name="l20294"></a>20294 }
<a name="l20295"></a>20295 
<a name="l20296"></a>20296 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20297"></a>20297 <span class="comment">/* A|A *****************************************************************************************************/</span>
<a name="l20298"></a>20298 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20299"></a>20299 
<a name="l20300"></a>20300 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_, <span class="keyword">typename</span> r_rep_&gt;
<a name="l20301"></a>20301 LITE_INLINE 
<a name="l20302"></a>20302 array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l20303"></a>20303     <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::const_iterator,
<a name="l20304"></a>20304     <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::const_iterator,
<a name="l20305"></a>20305     multiplies&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20306"></a>20306     &gt; &gt; &gt;
<a name="l20307"></a>20307 operator|(<span class="keyword">const</span> array&lt;signature_, traits_type_, l_rep_&gt;&amp; a, <span class="keyword">const</span> array&lt;signature_, traits_type_, r_rep_&gt;&amp; b)
<a name="l20308"></a>20308 {
<a name="l20309"></a>20309     <span class="keyword">typedef</span> array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l20310"></a>20310         <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::const_iterator,
<a name="l20311"></a>20311         <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::const_iterator,
<a name="l20312"></a>20312         multiplies&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20313"></a>20313         &gt; &gt; &gt; result_type;
<a name="l20314"></a>20314 
<a name="l20315"></a>20315     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), <span class="stringliteral">&quot;operator|(A,A): array sizes do not match&quot;</span>);
<a name="l20316"></a>20316     <span class="keywordflow">return</span> result_type(a.begin(), b.begin(), a.size());
<a name="l20317"></a>20317 }
<a name="l20318"></a>20318 
<a name="l20319"></a>20319 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20320"></a>20320 <span class="comment">/* A+=c ****************************************************************************************************/</span>
<a name="l20321"></a>20321 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20322"></a>20322 
<a name="l20323"></a>20323 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_&gt;
<a name="l20324"></a>20324 LITE_INLINE 
<a name="l20325"></a>20325 <span class="keyword">const</span> array&lt;signature_, traits_type_, l_rep_&gt;&amp;
<a name="l20326"></a>20326 operator+=(
<a name="l20327"></a>20327     <span class="keyword">const</span> array&lt;signature_, traits_type_, l_rep_&gt;&amp; a, 
<a name="l20328"></a>20328     <span class="keyword">const</span> <span class="keyword">typename</span> array_signature_traits&lt;signature_&gt;::element_type&amp; b)
<a name="l20329"></a>20329 {
<a name="l20330"></a>20330     <span class="keyword">typedef</span> b_iterator&lt;
<a name="l20331"></a>20331         <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::iterator,
<a name="l20332"></a>20332         c_iterator&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;,
<a name="l20333"></a>20333         plus_assign&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20334"></a>20334         &gt; iterator_type;
<a name="l20335"></a>20335 
<a name="l20336"></a>20336     <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(a.begin(), b), a.size());
<a name="l20337"></a>20337     <span class="keywordflow">return</span> a;
<a name="l20338"></a>20338 }
<a name="l20339"></a>20339 
<a name="l20340"></a>20340 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_&gt;
<a name="l20341"></a>20341 LITE_INLINE 
<a name="l20342"></a>20342 array&lt;signature_, traits_type_, l_rep_&gt;&amp;
<a name="l20343"></a>20343 operator+=(
<a name="l20344"></a>20344     array&lt;signature_, traits_type_, l_rep_&gt;&amp; a, 
<a name="l20345"></a>20345     <span class="keyword">const</span> <span class="keyword">typename</span> array_signature_traits&lt;signature_&gt;::element_type&amp; b)
<a name="l20346"></a>20346 {
<a name="l20347"></a>20347     <span class="keyword">typedef</span> b_iterator&lt;
<a name="l20348"></a>20348         <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::iterator,
<a name="l20349"></a>20349         c_iterator&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;,
<a name="l20350"></a>20350         plus_assign&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20351"></a>20351         &gt; iterator_type;
<a name="l20352"></a>20352 
<a name="l20353"></a>20353     <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(a.begin(), b), a.size());
<a name="l20354"></a>20354     <span class="keywordflow">return</span> a;
<a name="l20355"></a>20355 }
<a name="l20356"></a>20356 
<a name="l20357"></a>20357 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20358"></a>20358 <span class="comment">/* A-=c ****************************************************************************************************/</span>
<a name="l20359"></a>20359 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20360"></a>20360 
<a name="l20361"></a>20361 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_&gt;
<a name="l20362"></a>20362 LITE_INLINE 
<a name="l20363"></a>20363 <span class="keyword">const</span> array&lt;signature_, traits_type_, l_rep_&gt;&amp;
<a name="l20364"></a>20364 operator-=(
<a name="l20365"></a>20365     <span class="keyword">const</span> array&lt;signature_, traits_type_, l_rep_&gt;&amp; a, 
<a name="l20366"></a>20366     <span class="keyword">const</span> <span class="keyword">typename</span> array_signature_traits&lt;signature_&gt;::element_type&amp; b)
<a name="l20367"></a>20367 {
<a name="l20368"></a>20368     <span class="keyword">typedef</span> b_iterator&lt;
<a name="l20369"></a>20369         <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::iterator,
<a name="l20370"></a>20370         c_iterator&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;,
<a name="l20371"></a>20371         minus_assign&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20372"></a>20372         &gt; iterator_type;
<a name="l20373"></a>20373 
<a name="l20374"></a>20374     <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(a.begin(), b), a.size());
<a name="l20375"></a>20375     <span class="keywordflow">return</span> a;
<a name="l20376"></a>20376 }
<a name="l20377"></a>20377 
<a name="l20378"></a>20378 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_&gt;
<a name="l20379"></a>20379 LITE_INLINE 
<a name="l20380"></a>20380 array&lt;signature_, traits_type_, l_rep_&gt;&amp;
<a name="l20381"></a>20381 operator-=(
<a name="l20382"></a>20382     array&lt;signature_, traits_type_, l_rep_&gt;&amp; a, 
<a name="l20383"></a>20383     <span class="keyword">const</span> <span class="keyword">typename</span> array_signature_traits&lt;signature_&gt;::element_type&amp; b)
<a name="l20384"></a>20384 {
<a name="l20385"></a>20385     <span class="keyword">typedef</span> b_iterator&lt;
<a name="l20386"></a>20386         <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::iterator,
<a name="l20387"></a>20387         c_iterator&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;,
<a name="l20388"></a>20388         minus_assign&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20389"></a>20389         &gt; iterator_type;
<a name="l20390"></a>20390 
<a name="l20391"></a>20391     <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(a.begin(), b), a.size());
<a name="l20392"></a>20392     <span class="keywordflow">return</span> a;
<a name="l20393"></a>20393 }
<a name="l20394"></a>20394 
<a name="l20395"></a>20395 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20396"></a>20396 <span class="comment">/* A*=c ****************************************************************************************************/</span>
<a name="l20397"></a>20397 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20398"></a>20398 
<a name="l20399"></a>20399 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_&gt;
<a name="l20400"></a>20400 LITE_INLINE 
<a name="l20401"></a>20401 <span class="keyword">const</span> array&lt;signature_, traits_type_, l_rep_&gt;&amp;
<a name="l20402"></a>20402 operator*=(
<a name="l20403"></a>20403     <span class="keyword">const</span> array&lt;signature_, traits_type_, l_rep_&gt;&amp; a, 
<a name="l20404"></a>20404     <span class="keyword">const</span> <span class="keyword">typename</span> array_signature_traits&lt;signature_&gt;::element_type&amp; b)
<a name="l20405"></a>20405 {
<a name="l20406"></a>20406     <span class="keyword">typedef</span> b_iterator&lt;
<a name="l20407"></a>20407         <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::iterator,
<a name="l20408"></a>20408         c_iterator&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;,
<a name="l20409"></a>20409         multiplies_assign&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20410"></a>20410         &gt; iterator_type;
<a name="l20411"></a>20411 
<a name="l20412"></a>20412     <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(a.begin(), b), a.size());
<a name="l20413"></a>20413     <span class="keywordflow">return</span> a;
<a name="l20414"></a>20414 }
<a name="l20415"></a>20415 
<a name="l20416"></a>20416 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_&gt;
<a name="l20417"></a>20417 LITE_INLINE 
<a name="l20418"></a>20418 array&lt;signature_, traits_type_, l_rep_&gt;&amp;
<a name="l20419"></a>20419 operator*=(
<a name="l20420"></a>20420     array&lt;signature_, traits_type_, l_rep_&gt;&amp; a, 
<a name="l20421"></a>20421     <span class="keyword">const</span> <span class="keyword">typename</span> array_signature_traits&lt;signature_&gt;::element_type&amp; b)
<a name="l20422"></a>20422 {
<a name="l20423"></a>20423     <span class="keyword">typedef</span> b_iterator&lt;
<a name="l20424"></a>20424         <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::iterator,
<a name="l20425"></a>20425         c_iterator&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;,
<a name="l20426"></a>20426         multiplies_assign&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20427"></a>20427         &gt; iterator_type;
<a name="l20428"></a>20428 
<a name="l20429"></a>20429     <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(a.begin(), b), a.size());
<a name="l20430"></a>20430     <span class="keywordflow">return</span> a;
<a name="l20431"></a>20431 }
<a name="l20432"></a>20432 
<a name="l20433"></a>20433 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20434"></a>20434 <span class="comment">/* A/=c ****************************************************************************************************/</span>
<a name="l20435"></a>20435 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20436"></a>20436 
<a name="l20437"></a>20437 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_&gt;
<a name="l20438"></a>20438 LITE_INLINE 
<a name="l20439"></a>20439 <span class="keyword">const</span> array&lt;signature_, traits_type_, l_rep_&gt;&amp;
<a name="l20440"></a>20440 operator/=(
<a name="l20441"></a>20441     <span class="keyword">const</span> array&lt;signature_, traits_type_, l_rep_&gt;&amp; a, 
<a name="l20442"></a>20442     <span class="keyword">const</span> <span class="keyword">typename</span> array_signature_traits&lt;signature_&gt;::element_type&amp; b)
<a name="l20443"></a>20443 {
<a name="l20444"></a>20444     <span class="keyword">typedef</span> b_iterator&lt;
<a name="l20445"></a>20445         <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::iterator,
<a name="l20446"></a>20446         c_iterator&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;,
<a name="l20447"></a>20447         divides_assign&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20448"></a>20448         &gt; iterator_type;
<a name="l20449"></a>20449 
<a name="l20450"></a>20450     <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(a.begin(), b), a.size());
<a name="l20451"></a>20451     <span class="keywordflow">return</span> a;
<a name="l20452"></a>20452 }
<a name="l20453"></a>20453 
<a name="l20454"></a>20454 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_&gt;
<a name="l20455"></a>20455 LITE_INLINE 
<a name="l20456"></a>20456 array&lt;signature_, traits_type_, l_rep_&gt;&amp;
<a name="l20457"></a>20457 operator/=(
<a name="l20458"></a>20458     array&lt;signature_, traits_type_, l_rep_&gt;&amp; a, 
<a name="l20459"></a>20459     <span class="keyword">const</span> <span class="keyword">typename</span> array_signature_traits&lt;signature_&gt;::element_type&amp; b)
<a name="l20460"></a>20460 {
<a name="l20461"></a>20461     <span class="keyword">typedef</span> b_iterator&lt;
<a name="l20462"></a>20462         <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::iterator,
<a name="l20463"></a>20463         c_iterator&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;,
<a name="l20464"></a>20464         divides_assign&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20465"></a>20465         &gt; iterator_type;
<a name="l20466"></a>20466 
<a name="l20467"></a>20467     <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(a.begin(), b), a.size());
<a name="l20468"></a>20468     <span class="keywordflow">return</span> a;
<a name="l20469"></a>20469 }
<a name="l20470"></a>20470 
<a name="l20471"></a>20471 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20472"></a>20472 <span class="comment">/* A+=A ****************************************************************************************************/</span>
<a name="l20473"></a>20473 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20474"></a>20474 
<a name="l20475"></a>20475 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_, <span class="keyword">typename</span> r_rep_&gt;
<a name="l20476"></a>20476 LITE_INLINE 
<a name="l20477"></a>20477 array&lt;signature_, traits_type_, l_rep_&gt;&amp;
<a name="l20478"></a>20478 operator+=(array&lt;signature_, traits_type_, l_rep_&gt;&amp; a, <span class="keyword">const</span> array&lt;signature_, traits_type_, r_rep_&gt;&amp; b)
<a name="l20479"></a>20479 {
<a name="l20480"></a>20480     <span class="keyword">typedef</span> b_iterator&lt;
<a name="l20481"></a>20481         <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::iterator,
<a name="l20482"></a>20482         <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::const_iterator,
<a name="l20483"></a>20483         plus_assign&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20484"></a>20484         &gt; iterator_type;
<a name="l20485"></a>20485 
<a name="l20486"></a>20486     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), <span class="stringliteral">&quot;operator+=(A,A): array sizes do not match&quot;</span>);
<a name="l20487"></a>20487     <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(a.begin(), b.begin()), a.size());
<a name="l20488"></a>20488     <span class="keywordflow">return</span> a;
<a name="l20489"></a>20489 }
<a name="l20490"></a>20490 
<a name="l20491"></a>20491 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_, <span class="keyword">typename</span> r_rep_&gt;
<a name="l20492"></a>20492 LITE_INLINE 
<a name="l20493"></a>20493 <span class="keyword">const</span> array&lt;signature_, traits_type_, l_rep_&gt;&amp;
<a name="l20494"></a>20494 operator+=(<span class="keyword">const</span> array&lt;signature_, traits_type_, l_rep_&gt;&amp; a, <span class="keyword">const</span> array&lt;signature_, traits_type_, r_rep_&gt;&amp; b)
<a name="l20495"></a>20495 {
<a name="l20496"></a>20496     <span class="keyword">typedef</span> b_iterator&lt;
<a name="l20497"></a>20497         <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::iterator,
<a name="l20498"></a>20498         <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::const_iterator,
<a name="l20499"></a>20499         plus_assign&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20500"></a>20500         &gt; iterator_type;
<a name="l20501"></a>20501 
<a name="l20502"></a>20502     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), <span class="stringliteral">&quot;operator+=(A,A): array sizes do not match&quot;</span>);
<a name="l20503"></a>20503     <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(a.begin(), b.begin()), a.size());
<a name="l20504"></a>20504     <span class="keywordflow">return</span> a;
<a name="l20505"></a>20505 }
<a name="l20506"></a>20506 
<a name="l20507"></a>20507 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20508"></a>20508 <span class="comment">/* A-=A ****************************************************************************************************/</span>
<a name="l20509"></a>20509 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20510"></a>20510 
<a name="l20511"></a>20511 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_, <span class="keyword">typename</span> r_rep_&gt;
<a name="l20512"></a>20512 LITE_INLINE 
<a name="l20513"></a>20513 array&lt;signature_, traits_type_, l_rep_&gt;&amp;
<a name="l20514"></a>20514 operator-=(array&lt;signature_, traits_type_, l_rep_&gt;&amp; a, <span class="keyword">const</span> array&lt;signature_, traits_type_, r_rep_&gt;&amp; b)
<a name="l20515"></a>20515 {
<a name="l20516"></a>20516     <span class="keyword">typedef</span> b_iterator&lt;
<a name="l20517"></a>20517         <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::iterator,
<a name="l20518"></a>20518         <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::const_iterator,
<a name="l20519"></a>20519         minus_assign&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20520"></a>20520         &gt; iterator_type;
<a name="l20521"></a>20521 
<a name="l20522"></a>20522     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), <span class="stringliteral">&quot;operator-=(A,A): array sizes do not match&quot;</span>);
<a name="l20523"></a>20523     <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(a.begin(), b.begin()), a.size());
<a name="l20524"></a>20524     <span class="keywordflow">return</span> a;
<a name="l20525"></a>20525 }
<a name="l20526"></a>20526 
<a name="l20527"></a>20527 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_, <span class="keyword">typename</span> r_rep_&gt;
<a name="l20528"></a>20528 LITE_INLINE 
<a name="l20529"></a>20529 <span class="keyword">const</span> array&lt;signature_, traits_type_, l_rep_&gt;&amp;
<a name="l20530"></a>20530 operator-=(<span class="keyword">const</span> array&lt;signature_, traits_type_, l_rep_&gt;&amp; a, <span class="keyword">const</span> array&lt;signature_, traits_type_, r_rep_&gt;&amp; b)
<a name="l20531"></a>20531 {
<a name="l20532"></a>20532     <span class="keyword">typedef</span> b_iterator&lt;
<a name="l20533"></a>20533         <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::iterator,
<a name="l20534"></a>20534         <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::const_iterator,
<a name="l20535"></a>20535         minus_assign&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20536"></a>20536         &gt; iterator_type;
<a name="l20537"></a>20537 
<a name="l20538"></a>20538     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), <span class="stringliteral">&quot;operator-=(A,A): array sizes do not match&quot;</span>);
<a name="l20539"></a>20539     <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(a.begin(), b.begin()), a.size());
<a name="l20540"></a>20540     <span class="keywordflow">return</span> a;
<a name="l20541"></a>20541 }
<a name="l20542"></a>20542 
<a name="l20543"></a>20543 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20544"></a>20544 <span class="comment">/* A|=A ****************************************************************************************************/</span>
<a name="l20545"></a>20545 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20546"></a>20546 
<a name="l20547"></a>20547 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_, <span class="keyword">typename</span> r_rep_&gt;
<a name="l20548"></a>20548 LITE_INLINE 
<a name="l20549"></a>20549 array&lt;signature_, traits_type_, l_rep_&gt;&amp;
<a name="l20550"></a>20550 operator|=(array&lt;signature_, traits_type_, l_rep_&gt;&amp; a, <span class="keyword">const</span> array&lt;signature_, traits_type_, r_rep_&gt;&amp; b)
<a name="l20551"></a>20551 {
<a name="l20552"></a>20552     <span class="keyword">typedef</span> b_iterator&lt;
<a name="l20553"></a>20553         <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::iterator,
<a name="l20554"></a>20554         <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::const_iterator,
<a name="l20555"></a>20555         multiplies_assign&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20556"></a>20556     &gt; iterator_type;
<a name="l20557"></a>20557 
<a name="l20558"></a>20558     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), <span class="stringliteral">&quot;operator|=(A,A): array sizes do not match&quot;</span>);
<a name="l20559"></a>20559     <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(a.begin(), b.begin()), a.size());
<a name="l20560"></a>20560     <span class="keywordflow">return</span> a;
<a name="l20561"></a>20561 }
<a name="l20562"></a>20562 
<a name="l20563"></a>20563 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_, <span class="keyword">typename</span> r_rep_&gt;
<a name="l20564"></a>20564 LITE_INLINE 
<a name="l20565"></a>20565 <span class="keyword">const</span> array&lt;signature_, traits_type_, l_rep_&gt;&amp;
<a name="l20566"></a>20566 operator|=(<span class="keyword">const</span> array&lt;signature_, traits_type_, l_rep_&gt;&amp; a, <span class="keyword">const</span> array&lt;signature_, traits_type_, r_rep_&gt;&amp; b)
<a name="l20567"></a>20567 {
<a name="l20568"></a>20568     <span class="keyword">typedef</span> b_iterator&lt;
<a name="l20569"></a>20569         <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::iterator,
<a name="l20570"></a>20570         <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::const_iterator,
<a name="l20571"></a>20571         multiplies_assign&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20572"></a>20572     &gt; iterator_type;
<a name="l20573"></a>20573 
<a name="l20574"></a>20574     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), <span class="stringliteral">&quot;operator|=(A,A): array sizes do not match&quot;</span>);
<a name="l20575"></a>20575     <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(a.begin(), b.begin()), a.size());
<a name="l20576"></a>20576     <span class="keywordflow">return</span> a;
<a name="l20577"></a>20577 }
<a name="l20578"></a>20578 
<a name="l20579"></a>20579 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20580"></a>20580 <span class="comment">/* A&lt;A *****************************************************************************************************/</span>
<a name="l20581"></a>20581 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20582"></a>20582 
<a name="l20583"></a>20583 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_, <span class="keyword">typename</span> r_rep_&gt;
<a name="l20584"></a>20584 LITE_INLINE <span class="keywordtype">bool</span> 
<a name="l20585"></a>20585 operator&lt;(const array&lt;signature_, traits_type_, l_rep_&gt;&amp; a, <span class="keyword">const</span> array&lt;signature_, traits_type_, r_rep_&gt;&amp; b)
<a name="l20586"></a>20586 {
<a name="l20587"></a>20587     <span class="keyword">typedef</span> b_iterator&lt;
<a name="l20588"></a>20588         <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::const_iterator,
<a name="l20589"></a>20589         <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::const_iterator,
<a name="l20590"></a>20590         less&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20591"></a>20591     &gt; iterator_type;
<a name="l20592"></a>20592 
<a name="l20593"></a>20593     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), <span class="stringliteral">&quot;operator&lt;(A,A): array sizes do not match&quot;</span>);
<a name="l20594"></a>20594     <span class="keywordflow">return</span> <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(iterator_type(a.begin(), b.begin()), a.size());
<a name="l20595"></a>20595 }
<a name="l20596"></a>20596 
<a name="l20597"></a>20597 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20598"></a>20598 <span class="comment">/* A&lt;=A ****************************************************************************************************/</span>
<a name="l20599"></a>20599 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20600"></a>20600 
<a name="l20601"></a>20601 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_, <span class="keyword">typename</span> r_rep_&gt;
<a name="l20602"></a>20602 LITE_INLINE <span class="keywordtype">bool</span> 
<a name="l20603"></a>20603 operator&lt;=(const array&lt;signature_, traits_type_, l_rep_&gt;&amp; a, <span class="keyword">const</span> array&lt;signature_, traits_type_, r_rep_&gt;&amp; b)
<a name="l20604"></a>20604 {
<a name="l20605"></a>20605     <span class="keyword">typedef</span> b_iterator&lt;
<a name="l20606"></a>20606         <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::const_iterator,
<a name="l20607"></a>20607         <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::const_iterator,
<a name="l20608"></a>20608         less_equal&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20609"></a>20609     &gt; iterator_type;
<a name="l20610"></a>20610 
<a name="l20611"></a>20611     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), <span class="stringliteral">&quot;operator&lt;=(A,A): array sizes do not match&quot;</span>);
<a name="l20612"></a>20612     <span class="keywordflow">return</span> <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(iterator_type(a.begin(), b.begin()), a.size());
<a name="l20613"></a>20613 }
<a name="l20614"></a>20614 
<a name="l20615"></a>20615 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20616"></a>20616 <span class="comment">/* A==A ****************************************************************************************************/</span>
<a name="l20617"></a>20617 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20618"></a>20618 
<a name="l20619"></a>20619 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_, <span class="keyword">typename</span> r_rep_&gt;
<a name="l20620"></a>20620 LITE_INLINE <span class="keywordtype">bool</span> 
<a name="l20621"></a>20621 <a class="code" href="group__array__tools.html#gafb4665bc1c0357dfad90b38e7db87b42">operator==</a>(<span class="keyword">const</span> array&lt;signature_, traits_type_, l_rep_&gt;&amp; a, <span class="keyword">const</span> array&lt;signature_, traits_type_, r_rep_&gt;&amp; b)
<a name="l20622"></a>20622 {
<a name="l20623"></a>20623     <span class="keyword">typedef</span> b_iterator&lt;
<a name="l20624"></a>20624         <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::const_iterator,
<a name="l20625"></a>20625         <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::const_iterator,
<a name="l20626"></a>20626         equal_to&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20627"></a>20627     &gt; iterator_type;
<a name="l20628"></a>20628 
<a name="l20629"></a>20629     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), <span class="stringliteral">&quot;operator==(A,A): array sizes do not match&quot;</span>);
<a name="l20630"></a>20630     <span class="keywordflow">return</span> <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(iterator_type(a.begin(), b.begin()), a.size());
<a name="l20631"></a>20631 }
<a name="l20632"></a>20632 
<a name="l20633"></a>20633 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20634"></a>20634 <span class="comment">/* A!=A ****************************************************************************************************/</span>
<a name="l20635"></a>20635 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20636"></a>20636 
<a name="l20637"></a>20637 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_, <span class="keyword">typename</span> r_rep_&gt;
<a name="l20638"></a>20638 LITE_INLINE <span class="keywordtype">bool</span> 
<a name="l20639"></a>20639 <a class="code" href="group__array__tools.html#ga0ce6a172c0bf2ab8bbc98e3f2a6f512a">operator!=</a>(<span class="keyword">const</span> array&lt;signature_, traits_type_, l_rep_&gt;&amp; a, <span class="keyword">const</span> array&lt;signature_, traits_type_, r_rep_&gt;&amp; b)
<a name="l20640"></a>20640 {
<a name="l20641"></a>20641     <span class="keywordflow">return</span> !(a==b);
<a name="l20642"></a>20642 }
<a name="l20643"></a>20643 
<a name="l20644"></a>20644 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20645"></a>20645 <span class="comment">/* A&gt;=A ****************************************************************************************************/</span>
<a name="l20646"></a>20646 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20647"></a>20647 
<a name="l20648"></a>20648 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_, <span class="keyword">typename</span> r_rep_&gt;
<a name="l20649"></a>20649 LITE_INLINE <span class="keywordtype">bool</span> 
<a name="l20650"></a>20650 <a class="code" href="group__array__tools.html#ga70df6c75029086c5b4c387b5721d8fe4">operator&gt;=</a>(<span class="keyword">const</span> array&lt;signature_, traits_type_, l_rep_&gt;&amp; a, <span class="keyword">const</span> array&lt;signature_, traits_type_, r_rep_&gt;&amp; b)
<a name="l20651"></a>20651 {
<a name="l20652"></a>20652     <span class="keyword">typedef</span> b_iterator&lt;
<a name="l20653"></a>20653         <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::const_iterator,
<a name="l20654"></a>20654         <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::const_iterator,
<a name="l20655"></a>20655         greater_equal&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20656"></a>20656     &gt; iterator_type;
<a name="l20657"></a>20657 
<a name="l20658"></a>20658     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), <span class="stringliteral">&quot;operator&gt;=(A,A): array sizes do not match&quot;</span>);
<a name="l20659"></a>20659     <span class="keywordflow">return</span> <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(iterator_type(a.begin(), b.begin()), a.size());
<a name="l20660"></a>20660 }
<a name="l20661"></a>20661 
<a name="l20662"></a>20662 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20663"></a>20663 <span class="comment">/* A&gt;A *****************************************************************************************************/</span>
<a name="l20664"></a>20664 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20665"></a>20665 
<a name="l20666"></a>20666 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_, <span class="keyword">typename</span> r_rep_&gt;
<a name="l20667"></a>20667 LITE_INLINE <span class="keywordtype">bool</span> 
<a name="l20668"></a>20668 <a class="code" href="group__array__tools.html#ga59489aa474069686a607b2a748fcc83e">operator&gt;</a>(<span class="keyword">const</span> array&lt;signature_, traits_type_, l_rep_&gt;&amp; a, <span class="keyword">const</span> array&lt;signature_, traits_type_, r_rep_&gt;&amp; b)
<a name="l20669"></a>20669 {
<a name="l20670"></a>20670     <span class="keyword">typedef</span> b_iterator&lt;
<a name="l20671"></a>20671         <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::const_iterator,
<a name="l20672"></a>20672         <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::const_iterator,
<a name="l20673"></a>20673         greater&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20674"></a>20674     &gt; iterator_type;
<a name="l20675"></a>20675 
<a name="l20676"></a>20676     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), <span class="stringliteral">&quot;operator&gt;(A,A): array sizes do not match&quot;</span>);
<a name="l20677"></a>20677     <span class="keywordflow">return</span> <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(iterator_type(a.begin(), b.begin()), a.size());
<a name="l20678"></a>20678 }
<a name="l20679"></a>20679 
<a name="l20680"></a>20680 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20681"></a>20681 <span class="comment">/* compare(A,A) ********************************************************************************************/</span>
<a name="l20682"></a>20682 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20683"></a>20683 
<a name="l20684"></a>20684 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_, <span class="keyword">typename</span> r_rep_&gt;
<a name="l20685"></a>20685 LITE_INLINE <span class="keywordtype">int</span>
<a name="l20686"></a>20686 compare(<span class="keyword">const</span> array&lt;signature_, traits_type_, l_rep_&gt;&amp; a, <span class="keyword">const</span> array&lt;signature_, traits_type_, r_rep_&gt;&amp; b)
<a name="l20687"></a>20687 {
<a name="l20688"></a>20688     <span class="keyword">typedef</span> b_iterator&lt;
<a name="l20689"></a>20689         <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::const_iterator,
<a name="l20690"></a>20690         <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::const_iterator,
<a name="l20691"></a>20691         compare3&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20692"></a>20692         &gt; iterator_type;
<a name="l20693"></a>20693 
<a name="l20694"></a>20694     while_equal&lt;<span class="keyword">typename</span> compare3&lt;
<a name="l20695"></a>20695         <span class="keyword">typename</span> array_signature_traits&lt;signature_&gt;::element_type&gt;::result_type&gt; func;
<a name="l20696"></a>20696 
<a name="l20697"></a>20697     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), <span class="stringliteral">&quot;compare(A,A): array sizes do not match&quot;</span>);
<a name="l20698"></a>20698     <a class="code" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">for_each_c</a>(iterator_type(a.begin(), b.begin()), func, a.size());
<a name="l20699"></a>20699     <span class="keywordflow">return</span> func();
<a name="l20700"></a>20700 }
<a name="l20701"></a>20701 
<a name="l20702"></a>20702 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20703"></a>20703 <span class="comment">/* norm(A) *************************************************************************************************/</span>
<a name="l20704"></a>20704 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20705"></a>20705 
<a name="l20706"></a>20706 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> rep_&gt;
<a name="l20707"></a>20707 LITE_INLINE <span class="keyword">typename</span> array_signature_traits&lt;signature_&gt;::element_type 
<a name="l20708"></a>20708 norm(<span class="keyword">const</span> array&lt;signature_, traits_type_, rep_&gt;&amp; a)
<a name="l20709"></a>20709 {
<a name="l20710"></a>20710     <span class="keyword">typedef</span> u_iterator&lt;
<a name="l20711"></a>20711         <span class="keyword">typename</span> array&lt;signature_,traits_type_, rep_&gt;::const_iterator,
<a name="l20712"></a>20712         square&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20713"></a>20713     &gt; iterator_type;
<a name="l20714"></a>20714 
<a name="l20715"></a>20715     accumulator&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt; acc;
<a name="l20716"></a>20716 
<a name="l20717"></a>20717     <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(a.begin()), acc, a.size());
<a name="l20718"></a>20718     <span class="keywordflow">return</span> acc();
<a name="l20719"></a>20719 }
<a name="l20720"></a>20720 
<a name="l20721"></a>20721 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20722"></a>20722 <span class="comment">/* normalized(A) *******************************************************************************************/</span>
<a name="l20723"></a>20723 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20724"></a>20724 
<a name="l20725"></a>20725 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> rep_&gt;
<a name="l20726"></a>20726 LITE_INLINE <span class="keyword">const</span> <span class="keyword">typename</span> array_helper&lt;signature_, traits_type_&gt;::temporary_array
<a name="l20727"></a>20727 normalized(<span class="keyword">const</span> array&lt;signature_, traits_type_, rep_&gt;&amp; a)
<a name="l20728"></a>20728 {
<a name="l20729"></a>20729     <span class="keyword">typedef</span> array&lt;signature_, traits_type_, rep_&gt; a_type;
<a name="l20730"></a>20730     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;signature_, traits_type_&gt;::temporary_array result_type;
<a name="l20731"></a>20731     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_signature_traits&lt;signature_&gt;::element_type value_type;
<a name="l20732"></a>20732     <span class="keyword">typedef</span> u_iterator&lt;typename result_type::iterator, square&lt;value_type&gt; &gt; iterator_type;
<a name="l20733"></a>20733 
<a name="l20734"></a>20734     result_type result = a;
<a name="l20735"></a>20735     accumulator&lt;value_type&gt; acc;
<a name="l20736"></a>20736 
<a name="l20737"></a>20737     <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(result.begin()), acc, result.size());
<a name="l20738"></a>20738     result *= value_type(1)/sqrt(acc());
<a name="l20739"></a>20739     <span class="keywordflow">return</span> result;
<a name="l20740"></a>20740 }
<a name="l20741"></a>20741 
<a name="l20742"></a>20742 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20743"></a>20743 <span class="comment">/* abs(A) **************************************************************************************************/</span>
<a name="l20744"></a>20744 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20745"></a>20745 
<a name="l20746"></a>20746 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> rep_&gt;
<a name="l20747"></a>20747 LITE_INLINE <span class="keyword">typename</span> array_signature_traits&lt;signature_&gt;::element_type 
<a name="l20748"></a>20748 abs(<span class="keyword">const</span> array&lt;signature_, traits_type_, rep_&gt;&amp; a)
<a name="l20749"></a>20749 {
<a name="l20750"></a>20750     <span class="keywordflow">return</span> sqrt(norm(a));
<a name="l20751"></a>20751 }
<a name="l20752"></a>20752 
<a name="l20753"></a>20753 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20754"></a>20754 <span class="comment">/* min(A,A) ************************************************************************************************/</span>
<a name="l20755"></a>20755 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20756"></a>20756 
<a name="l20757"></a>20757 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_, <span class="keyword">typename</span> r_rep_&gt;
<a name="l20758"></a>20758 LITE_INLINE 
<a name="l20759"></a>20759 array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l20760"></a>20760     <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::const_iterator,
<a name="l20761"></a>20761     <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::const_iterator,
<a name="l20762"></a>20762     minimum&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20763"></a>20763     &gt; &gt; &gt;
<a name="l20764"></a>20764 min(<span class="keyword">const</span> array&lt;signature_, traits_type_, l_rep_&gt;&amp; a, <span class="keyword">const</span> array&lt;signature_, traits_type_, r_rep_&gt;&amp; b)
<a name="l20765"></a>20765 {
<a name="l20766"></a>20766     <span class="keyword">typedef</span> array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l20767"></a>20767         <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::const_iterator,
<a name="l20768"></a>20768         <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::const_iterator,
<a name="l20769"></a>20769         minimum&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20770"></a>20770         &gt; &gt; &gt; result_type;
<a name="l20771"></a>20771 
<a name="l20772"></a>20772     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), <span class="stringliteral">&quot;min(A,A): array sizes do not match&quot;</span>);
<a name="l20773"></a>20773 
<a name="l20774"></a>20774     <span class="keywordflow">return</span> result_type(a.begin(), b.begin(), a.size());
<a name="l20775"></a>20775 }
<a name="l20776"></a>20776 
<a name="l20777"></a>20777 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> rep_&gt;
<a name="l20778"></a>20778 LITE_INLINE 
<a name="l20779"></a>20779 array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l20780"></a>20780     <span class="keyword">typename</span> array&lt;signature_,traits_type_, rep_&gt;::const_iterator,
<a name="l20781"></a>20781     <span class="keyword">typename</span> array&lt;signature_,traits_type_, rep_&gt;::const_iterator,
<a name="l20782"></a>20782     minimum&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20783"></a>20783     &gt; &gt; &gt;
<a name="l20784"></a>20784 min(<span class="keyword">const</span> array&lt;signature_, traits_type_, rep_&gt;&amp; a, <span class="keyword">const</span> array&lt;signature_, traits_type_, rep_&gt;&amp; b)
<a name="l20785"></a>20785 {
<a name="l20786"></a>20786     <span class="keyword">typedef</span> array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l20787"></a>20787         <span class="keyword">typename</span> array&lt;signature_,traits_type_, rep_&gt;::const_iterator,
<a name="l20788"></a>20788         <span class="keyword">typename</span> array&lt;signature_,traits_type_, rep_&gt;::const_iterator,
<a name="l20789"></a>20789         minimum&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20790"></a>20790         &gt; &gt; &gt; result_type;
<a name="l20791"></a>20791 
<a name="l20792"></a>20792     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), <span class="stringliteral">&quot;min(A,A): array sizes do not match&quot;</span>);
<a name="l20793"></a>20793 
<a name="l20794"></a>20794     <span class="keywordflow">return</span> result_type(a.begin(), b.begin(), a.size());
<a name="l20795"></a>20795 }
<a name="l20796"></a>20796 
<a name="l20797"></a>20797 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20798"></a>20798 <span class="comment">/* max(A,A) ************************************************************************************************/</span>
<a name="l20799"></a>20799 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20800"></a>20800 
<a name="l20801"></a>20801 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_, <span class="keyword">typename</span> r_rep_&gt;
<a name="l20802"></a>20802 LITE_INLINE 
<a name="l20803"></a>20803 array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l20804"></a>20804     <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::const_iterator,
<a name="l20805"></a>20805     <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::const_iterator,
<a name="l20806"></a>20806     maximum&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20807"></a>20807     &gt; &gt; &gt;
<a name="l20808"></a>20808 max(<span class="keyword">const</span> array&lt;signature_, traits_type_, l_rep_&gt;&amp; a, <span class="keyword">const</span> array&lt;signature_, traits_type_, r_rep_&gt;&amp; b)
<a name="l20809"></a>20809 {
<a name="l20810"></a>20810     <span class="keyword">typedef</span> array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l20811"></a>20811         <span class="keyword">typename</span> array&lt;signature_,traits_type_, l_rep_&gt;::const_iterator,
<a name="l20812"></a>20812         <span class="keyword">typename</span> array&lt;signature_,traits_type_, r_rep_&gt;::const_iterator,
<a name="l20813"></a>20813         maximum&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20814"></a>20814         &gt; &gt; &gt; result_type;
<a name="l20815"></a>20815 
<a name="l20816"></a>20816     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), <span class="stringliteral">&quot;max(A,A): array sizes do not match&quot;</span>);
<a name="l20817"></a>20817 
<a name="l20818"></a>20818     <span class="keywordflow">return</span> result_type(a.begin(), b.begin(), a.size());
<a name="l20819"></a>20819 }
<a name="l20820"></a>20820 
<a name="l20821"></a>20821 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> rep_&gt;
<a name="l20822"></a>20822 LITE_INLINE 
<a name="l20823"></a>20823 array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l20824"></a>20824     <span class="keyword">typename</span> array&lt;signature_,traits_type_, rep_&gt;::const_iterator,
<a name="l20825"></a>20825     <span class="keyword">typename</span> array&lt;signature_,traits_type_, rep_&gt;::const_iterator,
<a name="l20826"></a>20826     maximum&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20827"></a>20827     &gt; &gt; &gt;
<a name="l20828"></a>20828 max(<span class="keyword">const</span> array&lt;signature_, traits_type_, rep_&gt;&amp; a, <span class="keyword">const</span> array&lt;signature_, traits_type_, rep_&gt;&amp; b)
<a name="l20829"></a>20829 {
<a name="l20830"></a>20830     <span class="keyword">typedef</span> array&lt;signature_, traits_type_, reference_rep&lt;b_iterator&lt;
<a name="l20831"></a>20831         <span class="keyword">typename</span> array&lt;signature_,traits_type_, rep_&gt;::const_iterator,
<a name="l20832"></a>20832         <span class="keyword">typename</span> array&lt;signature_,traits_type_, rep_&gt;::const_iterator,
<a name="l20833"></a>20833         maximum&lt;typename array_signature_traits&lt;signature_&gt;::element_type&gt;
<a name="l20834"></a>20834         &gt; &gt; &gt; result_type;
<a name="l20835"></a>20835 
<a name="l20836"></a>20836     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), <span class="stringliteral">&quot;max(A,A): array sizes do not match&quot;</span>);
<a name="l20837"></a>20837 
<a name="l20838"></a>20838     <span class="keywordflow">return</span> result_type(a.begin(), b.begin(), a.size());
<a name="l20839"></a>20839 }
<a name="l20840"></a>20840 
<a name="l20841"></a>20841 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20842"></a>20842 <span class="comment">/* V*V *****************************************************************************************************/</span>
<a name="l20843"></a>20843 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20844"></a>20844 
<a name="l20845"></a>20845 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> value_type_, <span class="keywordtype">int</span> n_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_, <span class="keyword">typename</span> r_rep_&gt;
<a name="l20846"></a>20846 LITE_INLINE 
<a name="l20847"></a>20847 <span class="keyword">typename</span> detail::enable_if&lt;(array_signature_traits&lt;value_type_&gt;::dimensions == 0), value_type_&gt;::type
<a name="l20848"></a>20848 <span class="keyword">operator</span>*(
<a name="l20849"></a>20849     <span class="keyword">const</span> array&lt;value_type_[n_], traits_type_, l_rep_&gt;&amp; a, 
<a name="l20850"></a>20850     <span class="keyword">const</span> array&lt;value_type_[n_], traits_type_, r_rep_&gt;&amp; b)
<a name="l20851"></a>20851 {
<a name="l20852"></a>20852     <span class="keyword">typedef</span> b_iterator&lt;
<a name="l20853"></a>20853         <span class="keyword">typename</span> array&lt;value_type_[n_],traits_type_, l_rep_&gt;::const_iterator,
<a name="l20854"></a>20854         <span class="keyword">typename</span> array&lt;value_type_[n_],traits_type_, r_rep_&gt;::const_iterator,
<a name="l20855"></a>20855         multiplies&lt;value_type_&gt;
<a name="l20856"></a>20856         &gt; iterator_type;
<a name="l20857"></a>20857 
<a name="l20858"></a>20858     accumulator&lt;value_type_&gt; acc;
<a name="l20859"></a>20859 
<a name="l20860"></a>20860     LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), <span class="stringliteral">&quot;operator*(V,V): vector sizes do not match&quot;</span>);
<a name="l20861"></a>20861     <a class="code" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">for_each</a>(iterator_type(a.begin(), b.begin()), acc, a.size());
<a name="l20862"></a>20862     <span class="keywordflow">return</span> acc();
<a name="l20863"></a>20863 }
<a name="l20864"></a>20864 
<a name="l20865"></a>20865 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20866"></a>20866 <span class="comment">/* M*V *****************************************************************************************************/</span>
<a name="l20867"></a>20867 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20868"></a>20868 
<a name="l20869"></a>20869 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> value_type_, <span class="keywordtype">int</span> m_, <span class="keywordtype">int</span> n_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_, <span class="keyword">typename</span> r_rep_&gt;
<a name="l20870"></a>20870 LITE_INLINE 
<a name="l20871"></a>20871 <span class="keyword">typename</span> detail::enable_if&lt;
<a name="l20872"></a>20872     (array_signature_traits&lt;value_type_&gt;::dimensions == 0), 
<a name="l20873"></a>20873     <span class="keyword">const</span> <span class="keyword">typename</span> array_helper&lt;value_type_[m_], traits_type_&gt;::temporary_array
<a name="l20874"></a>20874     &gt;::type
<a name="l20875"></a>20875 <span class="keyword">operator</span>*(
<a name="l20876"></a>20876     <span class="keyword">const</span> array&lt;value_type_[m_][n_], traits_type_, l_rep_&gt;&amp; a, 
<a name="l20877"></a>20877     <span class="keyword">const</span> array&lt;value_type_[n_], traits_type_, r_rep_&gt;&amp; b)
<a name="l20878"></a>20878 {
<a name="l20879"></a>20879     <span class="keyword">typedef</span> array&lt;value_type_[m_][n_], traits_type_, l_rep_&gt; a_type;
<a name="l20880"></a>20880     <span class="keyword">typedef</span> array&lt;value_type_[n_], traits_type_, r_rep_&gt; b_type;
<a name="l20881"></a>20881     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;value_type_[m_], traits_type_&gt;::temporary_array result_type;
<a name="l20882"></a>20882     <span class="keyword">typedef</span> <span class="keyword">typename</span> result_type::size_type <a class="code" href="structlite_1_1transform__traits.html#a1481880eabec13ec261860b5ca877011" title="The size type of the resulting array.">size_type</a>;
<a name="l20883"></a>20883 
<a name="l20884"></a>20884     <span class="keyword">typename</span> detail::matrix_policy&lt;a_type, 1&gt; ::cached_fwd_array aa = a;
<a name="l20885"></a>20885     <span class="keyword">typename</span> detail::matrix_policy&lt;b_type, 9&gt; ::cached_array bb = b;
<a name="l20886"></a>20886 
<a name="l20887"></a>20887     <span class="keyword">const</span> <span class="keywordtype">int</span> m = aa.size().i0;
<a name="l20888"></a>20888 
<a name="l20889"></a>20889     <span class="keyword">const</span> size_type size(m);
<a name="l20890"></a>20890     result_type result(size);
<a name="l20891"></a>20891 
<a name="l20892"></a>20892     LITE_ARRAY_SIZE_CHECK(aa.size().i1, b.size().i0, <span class="stringliteral">&quot;operator*(M,V): matrix/vector sizes do not match&quot;</span>);
<a name="l20893"></a>20893 
<a name="l20894"></a>20894     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;m; i++)
<a name="l20895"></a>20895         result[i] = aa[<a class="code" href="group__array__transforms.html#gac13d5a020f69071131362062cbb527cb" title="This transform, when applied to an array of dimension N, returns a reference array...">row</a>(i)]*bb;
<a name="l20896"></a>20896 
<a name="l20897"></a>20897     <span class="keywordflow">return</span> result;
<a name="l20898"></a>20898 }
<a name="l20899"></a>20899 
<a name="l20900"></a>20900 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20901"></a>20901 <span class="comment">/* V*M *****************************************************************************************************/</span>
<a name="l20902"></a>20902 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20903"></a>20903 
<a name="l20904"></a>20904 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> value_type_, <span class="keywordtype">int</span> m_, <span class="keywordtype">int</span> n_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_, <span class="keyword">typename</span> r_rep_&gt;
<a name="l20905"></a>20905 LITE_INLINE 
<a name="l20906"></a>20906 <span class="keyword">typename</span> detail::enable_if&lt;
<a name="l20907"></a>20907     (array_signature_traits&lt;value_type_&gt;::dimensions == 0), 
<a name="l20908"></a>20908     <span class="keyword">const</span> <span class="keyword">typename</span> array_helper&lt;value_type_[n_], traits_type_&gt;::temporary_array
<a name="l20909"></a>20909     &gt;::type
<a name="l20910"></a>20910 <span class="keyword">operator</span>*(
<a name="l20911"></a>20911     <span class="keyword">const</span> array&lt;value_type_[m_], traits_type_, l_rep_&gt;&amp; a,
<a name="l20912"></a>20912     <span class="keyword">const</span> array&lt;value_type_[m_][n_], traits_type_, r_rep_&gt;&amp; b)
<a name="l20913"></a>20913 {
<a name="l20914"></a>20914     <span class="keyword">typedef</span> array&lt;value_type_[m_], traits_type_, l_rep_&gt; a_type;
<a name="l20915"></a>20915     <span class="keyword">typedef</span> array&lt;value_type_[m_][n_], traits_type_, r_rep_&gt; b_type;
<a name="l20916"></a>20916     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;value_type_[n_], traits_type_&gt;::temporary_array result_type;
<a name="l20917"></a>20917     <span class="keyword">typedef</span> <span class="keyword">typename</span> result_type::size_type size_type;
<a name="l20918"></a>20918 
<a name="l20919"></a>20919     <span class="keyword">typename</span> detail::matrix_policy&lt;a_type, 9&gt;::cached_array aa = a;
<a name="l20920"></a>20920     <span class="keyword">typename</span> detail::matrix_policy&lt;b_type, 1&gt;::cached_rev_array bb = b;
<a name="l20921"></a>20921 
<a name="l20922"></a>20922     <span class="keyword">const</span> <span class="keywordtype">int</span> n = bb.size().i1;
<a name="l20923"></a>20923 
<a name="l20924"></a>20924     <span class="keyword">const</span> size_type size(n);
<a name="l20925"></a>20925     result_type result(size);
<a name="l20926"></a>20926 
<a name="l20927"></a>20927     LITE_ARRAY_SIZE_CHECK(aa.size().i0, bb.size().i0, <span class="stringliteral">&quot;operator*(V,M): matrix/vector sizes do not match&quot;</span>);
<a name="l20928"></a>20928 
<a name="l20929"></a>20929     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;n; j++)
<a name="l20930"></a>20930         result[j] = aa*bb[<a class="code" href="group__array__transforms.html#gadb85ceb967b099b563484f6a96ca911c" title="This transform, when applied to an array of dimension N (N must be at least 2), returns...">column</a>(j)];
<a name="l20931"></a>20931 
<a name="l20932"></a>20932     <span class="keywordflow">return</span> result;
<a name="l20933"></a>20933 }
<a name="l20934"></a>20934 
<a name="l20935"></a>20935 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20936"></a>20936 <span class="comment">/* M*M *****************************************************************************************************/</span>
<a name="l20937"></a>20937 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20938"></a>20938 
<a name="l20939"></a>20939 <span class="keyword">template</span>&lt;
<a name="l20940"></a>20940     <span class="keyword">typename</span> value_type_, 
<a name="l20941"></a>20941     <span class="keywordtype">int</span> m_, 
<a name="l20942"></a>20942     <span class="keywordtype">int</span> n_, 
<a name="l20943"></a>20943     <span class="keywordtype">int</span> p_, 
<a name="l20944"></a>20944     <span class="keyword">typename</span> traits_type_, 
<a name="l20945"></a>20945     <span class="keyword">typename</span> l_rep_, 
<a name="l20946"></a>20946     <span class="keyword">typename</span> r_rep_&gt;
<a name="l20947"></a>20947 LITE_INLINE 
<a name="l20948"></a>20948 <span class="keyword">typename</span> detail::enable_if&lt;
<a name="l20949"></a>20949     (array_signature_traits&lt;value_type_&gt;::dimensions == 0), 
<a name="l20950"></a>20950     <span class="keyword">const</span> <span class="keyword">typename</span> array_helper&lt;value_type_[m_][p_], traits_type_&gt;::temporary_array
<a name="l20951"></a>20951     &gt;::type
<a name="l20952"></a>20952 <span class="keyword">operator</span>*(
<a name="l20953"></a>20953     <span class="keyword">const</span> array&lt;value_type_[m_][n_], traits_type_, l_rep_&gt;&amp; a,
<a name="l20954"></a>20954     <span class="keyword">const</span> array&lt;value_type_[n_][p_], traits_type_, r_rep_&gt;&amp; b)
<a name="l20955"></a>20955 {
<a name="l20956"></a>20956     <span class="keyword">typedef</span> array&lt;value_type_[m_][n_], traits_type_, l_rep_&gt; a_type;
<a name="l20957"></a>20957     <span class="keyword">typedef</span> array&lt;value_type_[n_][p_], traits_type_, r_rep_&gt; b_type;
<a name="l20958"></a>20958     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;value_type_[m_][p_], traits_type_&gt;::temporary_array result_type;
<a name="l20959"></a>20959     <span class="keyword">typedef</span> <span class="keyword">typename</span> result_type::size_type size_type;
<a name="l20960"></a>20960 
<a name="l20961"></a>20961     <span class="keyword">typename</span> detail::matrix_policy&lt;a_type, 9&gt;::cached_fwd_array aa = a;
<a name="l20962"></a>20962     <span class="keyword">typename</span> detail::matrix_policy&lt;b_type, 9&gt;::cached_rev_array bb = b;
<a name="l20963"></a>20963 
<a name="l20964"></a>20964     <span class="keyword">const</span> <span class="keywordtype">int</span> m = aa.size().i0;
<a name="l20965"></a>20965     <span class="keyword">const</span> <span class="keywordtype">int</span> p = bb.size().i1;
<a name="l20966"></a>20966 
<a name="l20967"></a>20967     <span class="keyword">const</span> size_type size(m, p);
<a name="l20968"></a>20968     result_type result(size);
<a name="l20969"></a>20969 
<a name="l20970"></a>20970     LITE_ARRAY_SIZE_CHECK(aa.size().i1, bb.size().i0, <span class="stringliteral">&quot;operator*(M,M): matrix sizes do not match&quot;</span>);
<a name="l20971"></a>20971 
<a name="l20972"></a>20972     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;m; i++)
<a name="l20973"></a>20973         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;p; j++)
<a name="l20974"></a>20974             result(i,j) = aa[<a class="code" href="group__array__transforms.html#gac13d5a020f69071131362062cbb527cb" title="This transform, when applied to an array of dimension N, returns a reference array...">row</a>(i)]*bb[<a class="code" href="group__array__transforms.html#gadb85ceb967b099b563484f6a96ca911c" title="This transform, when applied to an array of dimension N (N must be at least 2), returns...">column</a>(j)];
<a name="l20975"></a>20975 
<a name="l20976"></a>20976     <span class="keywordflow">return</span> result;
<a name="l20977"></a>20977 }
<a name="l20978"></a>20978 
<a name="l20979"></a>20979 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20980"></a>20980 <span class="comment">/* V%V, 2D (cross product) *********************************************************************************/</span>
<a name="l20981"></a>20981 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20982"></a>20982 
<a name="l20983"></a>20983 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> value_type_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_, <span class="keyword">typename</span> r_rep_&gt;
<a name="l20984"></a>20984 LITE_INLINE 
<a name="l20985"></a>20985 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l20986"></a>20986     array_signature_traits&lt;value_type_&gt;::dimensions == 0),
<a name="l20987"></a>20987     value_type_
<a name="l20988"></a>20988     &gt;::type
<a name="l20989"></a>20989 <span class="keyword">operator</span>%(
<a name="l20990"></a>20990     <span class="keyword">const</span> array&lt;value_type_[2], traits_type_, l_rep_&gt;&amp; a, 
<a name="l20991"></a>20991     <span class="keyword">const</span> array&lt;value_type_[2], traits_type_, r_rep_&gt;&amp; b)
<a name="l20992"></a>20992 {
<a name="l20993"></a>20993     <span class="keywordflow">return</span> a[0]*b[1]-a[1]*b[0];
<a name="l20994"></a>20994 }
<a name="l20995"></a>20995 
<a name="l20996"></a>20996 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20997"></a>20997 <span class="comment">/* V%V, 3D (cross product) *********************************************************************************/</span>
<a name="l20998"></a>20998 <span class="comment">/***********************************************************************************************************/</span>
<a name="l20999"></a>20999 
<a name="l21000"></a>21000 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> value_type_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_, <span class="keyword">typename</span> r_rep_&gt;
<a name="l21001"></a>21001 LITE_INLINE 
<a name="l21002"></a>21002 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l21003"></a>21003     array_signature_traits&lt;value_type_&gt;::dimensions == 0),
<a name="l21004"></a>21004     <span class="keyword">const</span> <span class="keyword">typename</span> array_helper&lt;value_type_[3], traits_type_&gt;::temporary_array
<a name="l21005"></a>21005     &gt;::type
<a name="l21006"></a>21006 <span class="keyword">operator</span>%(
<a name="l21007"></a>21007     <span class="keyword">const</span> array&lt;value_type_[3], traits_type_, l_rep_&gt;&amp; a, 
<a name="l21008"></a>21008     <span class="keyword">const</span> array&lt;value_type_[3], traits_type_, r_rep_&gt;&amp; b)
<a name="l21009"></a>21009 {
<a name="l21010"></a>21010     <span class="keyword">typedef</span> array&lt;value_type_[3], traits_type_, l_rep_&gt; a_type;
<a name="l21011"></a>21011     <span class="keyword">typedef</span> array&lt;value_type_[3], traits_type_, r_rep_&gt; b_type;
<a name="l21012"></a>21012     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;value_type_[3], traits_type_&gt;::temporary_array result_type;
<a name="l21013"></a>21013 
<a name="l21014"></a>21014     <span class="keyword">typename</span> detail::matrix_policy&lt;a_type, 9&gt;::cached_array aa = a;
<a name="l21015"></a>21015     <span class="keyword">typename</span> detail::matrix_policy&lt;b_type, 9&gt;::cached_array bb = b;
<a name="l21016"></a>21016 
<a name="l21017"></a>21017     <span class="keywordflow">return</span> result_type(aa[1]*bb[2]-aa[2]*bb[1], aa[2]*bb[0]-aa[0]*bb[2], aa[0]*bb[1]-aa[1]*bb[0]);
<a name="l21018"></a>21018 }
<a name="l21019"></a>21019 
<a name="l21020"></a>21020 <span class="comment">/***********************************************************************************************************/</span>
<a name="l21021"></a>21021 <span class="comment">/* determinant, 2D *****************************************************************************************/</span>
<a name="l21022"></a>21022 <span class="comment">/***********************************************************************************************************/</span>
<a name="l21023"></a>21023 
<a name="l21024"></a>21024 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> value_type_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> rep_&gt;
<a name="l21025"></a>21025 LITE_INLINE 
<a name="l21026"></a>21026 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l21027"></a>21027     array_signature_traits&lt;value_type_&gt;::dimensions == 0),
<a name="l21028"></a>21028     value_type_
<a name="l21029"></a>21029     &gt;::type
<a name="l21030"></a>21030 det(<span class="keyword">const</span> array&lt;value_type_[2][2], traits_type_, rep_&gt;&amp; a)
<a name="l21031"></a>21031 {
<a name="l21032"></a>21032     <span class="keywordflow">return</span> a(0, 0)*a(1, 1) - a(0, 1)*a(1, 0);
<a name="l21033"></a>21033 }
<a name="l21034"></a>21034 
<a name="l21035"></a>21035 <span class="comment">/***********************************************************************************************************/</span>
<a name="l21036"></a>21036 <span class="comment">/* determinant, 3D *****************************************************************************************/</span>
<a name="l21037"></a>21037 <span class="comment">/***********************************************************************************************************/</span>
<a name="l21038"></a>21038 
<a name="l21039"></a>21039 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> value_type_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> rep_&gt;
<a name="l21040"></a>21040 LITE_INLINE 
<a name="l21041"></a>21041 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l21042"></a>21042     array_signature_traits&lt;value_type_&gt;::dimensions == 0),
<a name="l21043"></a>21043     value_type_
<a name="l21044"></a>21044     &gt;::type
<a name="l21045"></a>21045 det(<span class="keyword">const</span> array&lt;value_type_[3][3], traits_type_, rep_&gt;&amp; a)
<a name="l21046"></a>21046 {
<a name="l21047"></a>21047     <span class="keyword">typedef</span> array&lt;value_type_[3][3], traits_type_, rep_&gt; a_type;
<a name="l21048"></a>21048     <span class="keyword">typename</span> detail::matrix_policy&lt;a_type, 9&gt;::cached_fwd_array aa = a;
<a name="l21049"></a>21049 
<a name="l21050"></a>21050     value_type_ det00 = aa(2, 2)*aa(1, 1)-aa(2, 1)*aa(1, 2);
<a name="l21051"></a>21051     value_type_ det10 = aa(2, 2)*aa(0, 1)-aa(2, 1)*aa(0, 2);
<a name="l21052"></a>21052     value_type_ det20 = aa(1, 2)*aa(0, 1)-aa(1, 1)*aa(0, 2);
<a name="l21053"></a>21053     <span class="keywordflow">return</span> aa(0, 0)*det00-aa(1, 0)*det10+aa(2, 0)*det20;
<a name="l21054"></a>21054 }
<a name="l21055"></a>21055 
<a name="l21056"></a>21056 <span class="comment">/***********************************************************************************************************/</span>
<a name="l21057"></a>21057 <span class="comment">/* determinant, nD *****************************************************************************************/</span>
<a name="l21058"></a>21058 <span class="comment">/***********************************************************************************************************/</span>
<a name="l21059"></a>21059 
<a name="l21060"></a>21060 <span class="comment">// uses Gaussian upper triangulation</span>
<a name="l21061"></a>21061 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> value_type_, <span class="keywordtype">int</span> n_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> rep_&gt;
<a name="l21062"></a>21062 LITE_INLINE 
<a name="l21063"></a>21063 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l21064"></a>21064     array_signature_traits&lt;value_type_&gt;::dimensions == 0),
<a name="l21065"></a>21065     value_type_
<a name="l21066"></a>21066     &gt;::type
<a name="l21067"></a>21067 det(<span class="keyword">const</span> array&lt;value_type_[n_][n_], traits_type_, rep_&gt;&amp; a)
<a name="l21068"></a>21068 {
<a name="l21069"></a>21069     <span class="keyword">using</span> std::abs;
<a name="l21070"></a>21070 
<a name="l21071"></a>21071     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;value_type_[n_][n_], traits_type_&gt;::fwd_temporary_array temporary_type;
<a name="l21072"></a>21072     <span class="keyword">typedef</span> array&lt;value_type_[n_][n_], traits_type_, rep_&gt; a_type;
<a name="l21073"></a>21073 
<a name="l21074"></a>21074     LITE_ARRAY_SIZE_CHECK(a.size().i0, a.size().i1, <span class="stringliteral">&quot;det(M): not a square matrix&quot;</span>);
<a name="l21075"></a>21075 
<a name="l21076"></a>21076     temporary_type aa = a;
<a name="l21077"></a>21077     <span class="keyword">const</span> <span class="keywordtype">int</span> n = aa.size().i0;
<a name="l21078"></a>21078     <span class="keywordtype">int</span> swaps = 0;
<a name="l21079"></a>21079 
<a name="l21080"></a>21080     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; i++) {
<a name="l21081"></a>21081         <span class="keyword">const</span> block&lt;0,1&gt; blk(0, n-i);
<a name="l21082"></a>21082         <span class="keywordtype">int</span> i_max = i;
<a name="l21083"></a>21083         value_type_ val_max = abs(aa(i, i));
<a name="l21084"></a>21084 
<a name="l21085"></a>21085         <span class="comment">// find the strongest row</span>
<a name="l21086"></a>21086         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i2 = i+1; i2&lt;n; i2++)
<a name="l21087"></a>21087             <span class="keywordflow">if</span> (abs(aa(i2, i)) &gt; val_max) {
<a name="l21088"></a>21088                 i_max = i2;
<a name="l21089"></a>21089                 val_max = abs(aa(i2, i));
<a name="l21090"></a>21090             }
<a name="l21091"></a>21091 
<a name="l21092"></a>21092         <span class="comment">// swap row i_max with row i</span>
<a name="l21093"></a>21093         <span class="keywordflow">if</span> (i_max != i) {
<a name="l21094"></a>21094             <span class="keyword">typename</span> transform_traits&lt;temporary_type, block&lt;0,1&gt; &gt;<a class="code" href="structlite_1_1transform__traits.html#a9f955b6339c92325956f62ea4281b63c" title="An array type compatible with the resulting array (i.e. with the same signature and...">::temporary_array</a> tmp_row;
<a name="l21095"></a>21095 
<a name="l21096"></a>21096             tmp_row = aa[blk(i, i)];
<a name="l21097"></a>21097             aa[blk(i, i)] = aa[blk(i_max, i)];
<a name="l21098"></a>21098             aa[blk(i_max, i)] = tmp_row;
<a name="l21099"></a>21099             swaps++;
<a name="l21100"></a>21100         }
<a name="l21101"></a>21101 
<a name="l21102"></a>21102         <span class="comment">// if a singular matrix return a zero matrix</span>
<a name="l21103"></a>21103         <span class="keywordflow">if</span> (aa(i, i) == value_type_())
<a name="l21104"></a>21104             <span class="keywordflow">return</span> value_type_();
<a name="l21105"></a>21105 
<a name="l21106"></a>21106         value_type_ epsilon = std::numeric_limits&lt;value_type_&gt;::epsilon()*aa(i, i)*n;
<a name="l21107"></a>21107         value_type_ factor = value_type_(1)/aa(i, i);
<a name="l21108"></a>21108 
<a name="l21109"></a>21109         <span class="comment">// simplify the column in the lower triangle</span>
<a name="l21110"></a>21110         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i2 = i+1; i2&lt;n; i2++) 
<a name="l21111"></a>21111             <span class="keywordflow">if</span> (abs(aa(i2, i)) &gt; epsilon)
<a name="l21112"></a>21112                 aa[blk(i2, i)] -= (aa(i2, i)*factor)*aa[blk(i, i)];
<a name="l21113"></a>21113     }
<a name="l21114"></a>21114 
<a name="l21115"></a>21115     value_type_ result = value_type_(1);
<a name="l21116"></a>21116 
<a name="l21117"></a>21117     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; i++)
<a name="l21118"></a>21118         result *= aa(i, i);
<a name="l21119"></a>21119 
<a name="l21120"></a>21120     <span class="keywordflow">return</span> (swaps &amp; 1) != 0 ? -result : result;
<a name="l21121"></a>21121 }
<a name="l21122"></a>21122 
<a name="l21123"></a>21123 <span class="comment">/***********************************************************************************************************/</span>
<a name="l21124"></a>21124 <span class="comment">/* inverse, 2D *********************************************************************************************/</span>
<a name="l21125"></a>21125 <span class="comment">/***********************************************************************************************************/</span>
<a name="l21126"></a>21126 
<a name="l21127"></a>21127 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> value_type_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> rep_&gt;
<a name="l21128"></a>21128 LITE_INLINE 
<a name="l21129"></a>21129 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l21130"></a>21130     array_signature_traits&lt;value_type_&gt;::dimensions == 0),
<a name="l21131"></a>21131     <span class="keyword">const</span> <span class="keyword">typename</span> array_helper&lt;value_type_[2][2], traits_type_&gt;::temporary_array
<a name="l21132"></a>21132     &gt;::type
<a name="l21133"></a>21133 inverse(<span class="keyword">const</span> array&lt;value_type_[2][2], traits_type_, rep_&gt;&amp; a)
<a name="l21134"></a>21134 {
<a name="l21135"></a>21135     <span class="keyword">typedef</span> array&lt;value_type_[2][2], traits_type_, rep_&gt; a_type;
<a name="l21136"></a>21136     <span class="keyword">typename</span> detail::matrix_policy&lt;a_type, 9&gt;::cached_fwd_array aa = a;
<a name="l21137"></a>21137 
<a name="l21138"></a>21138     <span class="keyword">typename</span> array_helper&lt;value_type_[2][2], traits_type_&gt;::temporary_array result;
<a name="l21139"></a>21139 
<a name="l21140"></a>21140     value_type_ inv_det = value_type_(1)/(aa(0, 0)*aa(1, 1) - aa(0, 1)*a(1, 0));
<a name="l21141"></a>21141 
<a name="l21142"></a>21142     result(0, 0) = aa(1, 1) * inv_det;
<a name="l21143"></a>21143     result(0, 1) = -aa(0, 1) * inv_det;
<a name="l21144"></a>21144     result(0, 2) = -aa(1, 0) * inv_det;
<a name="l21145"></a>21145     result(0, 3) = aa(0, 0) * inv_det;
<a name="l21146"></a>21146 
<a name="l21147"></a>21147     <span class="keywordflow">return</span> result;
<a name="l21148"></a>21148 }
<a name="l21149"></a>21149 
<a name="l21150"></a>21150 <span class="comment">/***********************************************************************************************************/</span>
<a name="l21151"></a>21151 <span class="comment">/* inverse, 3D *********************************************************************************************/</span>
<a name="l21152"></a>21152 <span class="comment">/***********************************************************************************************************/</span>
<a name="l21153"></a>21153 
<a name="l21154"></a>21154 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> value_type_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> rep_&gt;
<a name="l21155"></a>21155 LITE_INLINE 
<a name="l21156"></a>21156 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l21157"></a>21157     array_signature_traits&lt;value_type_&gt;::dimensions == 0),
<a name="l21158"></a>21158     <span class="keyword">const</span> <span class="keyword">typename</span> array_helper&lt;value_type_[3][3], traits_type_&gt;::temporary_array
<a name="l21159"></a>21159     &gt;::type
<a name="l21160"></a>21160 inverse(<span class="keyword">const</span> array&lt;value_type_[3][3], traits_type_, rep_&gt;&amp; a)
<a name="l21161"></a>21161 {
<a name="l21162"></a>21162     <span class="keyword">typedef</span> array&lt;value_type_[3][3], traits_type_, rep_&gt; a_type;
<a name="l21163"></a>21163     <span class="keyword">typename</span> detail::matrix_policy&lt;a_type, 9&gt;::cached_fwd_array aa = a;
<a name="l21164"></a>21164 
<a name="l21165"></a>21165     <span class="keyword">typename</span> array_helper&lt;value_type_[3][3], traits_type_&gt;::temporary_array result;
<a name="l21166"></a>21166     
<a name="l21167"></a>21167     value_type_ det00 = aa(2, 2)*aa(1, 1)-aa(2, 1)*aa(1, 2);
<a name="l21168"></a>21168     value_type_ det10 = aa(2, 2)*aa(0, 1)-aa(2, 1)*aa(0, 2);
<a name="l21169"></a>21169     value_type_ det20 = aa(1, 2)*aa(0, 1)-aa(1, 1)*aa(0, 2);
<a name="l21170"></a>21170     value_type_ inv_det = value_type_(1)/(aa(0, 0)*det00-aa(1, 0)*det10+aa(2, 0)*det20);
<a name="l21171"></a>21171 
<a name="l21172"></a>21172     result(0, 0) = det00*inv_det; 
<a name="l21173"></a>21173     result(0, 1) = -det10*inv_det; 
<a name="l21174"></a>21174     result(0, 2) = det20*inv_det;
<a name="l21175"></a>21175     result(1, 0) = (aa(2, 0)*aa(1, 2)-aa(2, 2)*aa(1, 0))*inv_det; 
<a name="l21176"></a>21176     result(1, 1) = (aa(2, 2)*aa(0, 0)-aa(2, 0)*aa(0, 2))*inv_det;
<a name="l21177"></a>21177     result(1, 2) = (aa(1, 0)*aa(0, 2)-aa(1, 2)*aa(0, 0))*inv_det;
<a name="l21178"></a>21178     result(2, 0) = (aa(2, 1)*aa(1, 0)-aa(2, 0)*aa(1, 1))*inv_det;
<a name="l21179"></a>21179     result(2, 1) = (aa(2, 0)*aa(0, 1)-aa(2, 1)*aa(0, 0))*inv_det;
<a name="l21180"></a>21180     result(2, 2) = (aa(1, 1)*aa(0, 0)-aa(1, 0)*aa(0, 1))*inv_det;
<a name="l21181"></a>21181 
<a name="l21182"></a>21182     <span class="keywordflow">return</span> result;
<a name="l21183"></a>21183 }
<a name="l21184"></a>21184 
<a name="l21185"></a>21185 <span class="comment">/***********************************************************************************************************/</span>
<a name="l21186"></a>21186 <span class="comment">/* inverse, nD *********************************************************************************************/</span>
<a name="l21187"></a>21187 <span class="comment">/***********************************************************************************************************/</span>
<a name="l21188"></a>21188 
<a name="l21189"></a>21189 <span class="comment">// uses Gauss-Jordan elimination</span>
<a name="l21190"></a>21190 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> value_type_, <span class="keywordtype">int</span> n_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> rep_&gt;
<a name="l21191"></a>21191 LITE_INLINE 
<a name="l21192"></a>21192 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l21193"></a>21193     array_signature_traits&lt;value_type_&gt;::dimensions == 0),
<a name="l21194"></a>21194     <span class="keyword">const</span> <span class="keyword">typename</span> array_helper&lt;value_type_[n_][n_], traits_type_&gt;::temporary_array
<a name="l21195"></a>21195     &gt;::type
<a name="l21196"></a>21196 inverse(<span class="keyword">const</span> array&lt;value_type_[n_][n_], traits_type_, rep_&gt;&amp; a)
<a name="l21197"></a>21197 {
<a name="l21198"></a>21198     <span class="keyword">using</span> std::abs;
<a name="l21199"></a>21199 
<a name="l21200"></a>21200     <span class="keyword">typedef</span> array&lt;value_type_[n_][n_], traits_type_, rep_&gt; a_type;
<a name="l21201"></a>21201     <span class="keyword">typedef</span> <span class="keyword">typename</span> array_helper&lt;value_type_[n_][n_], traits_type_&gt;::temporary_array temporary_type;
<a name="l21202"></a>21202 
<a name="l21203"></a>21203     LITE_ARRAY_SIZE_CHECK(a.size().i0, a.size().i1, <span class="stringliteral">&quot;inverse(M): not a square matrix&quot;</span>);
<a name="l21204"></a>21204 
<a name="l21205"></a>21205     <span class="keyword">const</span> <span class="keywordtype">int</span> n = a.size().i0;
<a name="l21206"></a>21206     temporary_type aa=a, result(n, n);
<a name="l21207"></a>21207 
<a name="l21208"></a>21208     result = value_type_();
<a name="l21209"></a>21209 
<a name="l21210"></a>21210     result[diagonal()] = value_type_(1);
<a name="l21211"></a>21211 
<a name="l21212"></a>21212     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; i++) {
<a name="l21213"></a>21213         <span class="keyword">const</span> block&lt;0,1&gt; blk(0, n-i);
<a name="l21214"></a>21214         <span class="keywordtype">int</span> i_max = i;
<a name="l21215"></a>21215         value_type_ val_max = abs(aa(i, i));
<a name="l21216"></a>21216 
<a name="l21217"></a>21217         <span class="comment">// find the strongest row</span>
<a name="l21218"></a>21218         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i2 = i+1; i2&lt;n; i2++)
<a name="l21219"></a>21219             <span class="keywordflow">if</span> (abs(aa(i2, i)) &gt; val_max) {
<a name="l21220"></a>21220                 i_max = i2;
<a name="l21221"></a>21221                 val_max = abs(aa(i2, i));
<a name="l21222"></a>21222             }
<a name="l21223"></a>21223 
<a name="l21224"></a>21224         <span class="comment">// swap row i_max with row i</span>
<a name="l21225"></a>21225         <span class="keywordflow">if</span> (i_max != i) {
<a name="l21226"></a>21226             <span class="keyword">typename</span> transform_traits&lt;temporary_type, row&gt;::temporary_array res_tmp;
<a name="l21227"></a>21227 
<a name="l21228"></a>21228             res_tmp = result[<a class="code" href="group__array__transforms.html#gac13d5a020f69071131362062cbb527cb" title="This transform, when applied to an array of dimension N, returns a reference array...">row</a>(i)];
<a name="l21229"></a>21229             result[<a class="code" href="group__array__transforms.html#gac13d5a020f69071131362062cbb527cb" title="This transform, when applied to an array of dimension N, returns a reference array...">row</a>(i)] = result[<a class="code" href="group__array__transforms.html#gac13d5a020f69071131362062cbb527cb" title="This transform, when applied to an array of dimension N, returns a reference array...">row</a>(i_max)];
<a name="l21230"></a>21230             result[<a class="code" href="group__array__transforms.html#gac13d5a020f69071131362062cbb527cb" title="This transform, when applied to an array of dimension N, returns a reference array...">row</a>(i_max)] = res_tmp; 
<a name="l21231"></a>21231 
<a name="l21232"></a>21232             <span class="keyword">typename</span> transform_traits&lt;temporary_type, block&lt;0,1&gt; &gt;<a class="code" href="structlite_1_1transform__traits.html#a9f955b6339c92325956f62ea4281b63c" title="An array type compatible with the resulting array (i.e. with the same signature and...">::temporary_array</a> org_tmp;
<a name="l21233"></a>21233                 
<a name="l21234"></a>21234             org_tmp = aa[blk(i,i)];
<a name="l21235"></a>21235             aa[blk(i,i)] = aa[blk(i_max, i)];
<a name="l21236"></a>21236             aa[blk(i_max,i)] = org_tmp; 
<a name="l21237"></a>21237         }
<a name="l21238"></a>21238 
<a name="l21239"></a>21239         <span class="comment">// if a singular matrix return a zero matrix</span>
<a name="l21240"></a>21240         <span class="keywordflow">if</span> (aa(i, i) == value_type_()) {
<a name="l21241"></a>21241             result = value_type_();
<a name="l21242"></a>21242             <span class="keywordflow">break</span>;
<a name="l21243"></a>21243         }
<a name="l21244"></a>21244 
<a name="l21245"></a>21245         <span class="comment">// normalize the row</span>
<a name="l21246"></a>21246         value_type_ factor = value_type_(1)/aa(i, i);
<a name="l21247"></a>21247 
<a name="l21248"></a>21248         result[<a class="code" href="group__array__transforms.html#gac13d5a020f69071131362062cbb527cb" title="This transform, when applied to an array of dimension N, returns a reference array...">row</a>(i)] *= factor;
<a name="l21249"></a>21249         aa[blk(i, i)] *= factor;
<a name="l21250"></a>21250 
<a name="l21251"></a>21251         value_type_ epsilon = std::numeric_limits&lt;value_type_&gt;::epsilon()*aa(i, i)*n;
<a name="l21252"></a>21252 
<a name="l21253"></a>21253         <span class="comment">// simplify the column in the lower triangle</span>
<a name="l21254"></a>21254         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i2 = i+1; i2&lt;n; i2++) 
<a name="l21255"></a>21255             <span class="keywordflow">if</span> (abs(aa(i2, i)) &gt; epsilon) {
<a name="l21256"></a>21256                 result[<a class="code" href="group__array__transforms.html#gac13d5a020f69071131362062cbb527cb" title="This transform, when applied to an array of dimension N, returns a reference array...">row</a>(i2)] -= aa(i2, i)*result[<a class="code" href="group__array__transforms.html#gac13d5a020f69071131362062cbb527cb" title="This transform, when applied to an array of dimension N, returns a reference array...">row</a>(i)];
<a name="l21257"></a>21257                 aa[blk(i2,i)] -= aa(i2, i)*aa[blk(i,i)];
<a name="l21258"></a>21258             }
<a name="l21259"></a>21259     }
<a name="l21260"></a>21260 
<a name="l21261"></a>21261     <span class="comment">// simplify the upper triangle</span>
<a name="l21262"></a>21262     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = n-1; i&gt;=0; i--) {
<a name="l21263"></a>21263         value_type_ epsilon = std::numeric_limits&lt;value_type_&gt;::epsilon()*aa(i, i)*n;
<a name="l21264"></a>21264 
<a name="l21265"></a>21265         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i2 = 0; i2&lt;i; i2++) 
<a name="l21266"></a>21266             <span class="keywordflow">if</span> (abs(aa(i2, i)) &gt; epsilon) 
<a name="l21267"></a>21267                 <span class="comment">// we don&apos;t need to update the original here as it won&apos;t be used any more!</span>
<a name="l21268"></a>21268                 result[<a class="code" href="group__array__transforms.html#gac13d5a020f69071131362062cbb527cb" title="This transform, when applied to an array of dimension N, returns a reference array...">row</a>(i2)] -= aa(i2, i)*result[<a class="code" href="group__array__transforms.html#gac13d5a020f69071131362062cbb527cb" title="This transform, when applied to an array of dimension N, returns a reference array...">row</a>(i)];
<a name="l21269"></a>21269     }
<a name="l21270"></a>21270 
<a name="l21271"></a>21271     <span class="keywordflow">return</span> result;
<a name="l21272"></a>21272 }
<a name="l21273"></a>21273 
<a name="l21274"></a>21274 <span class="comment">/***********************************************************************************************************/</span>
<a name="l21275"></a>21275 <span class="comment">/* rotation, 2D ********************************************************************************************/</span>
<a name="l21276"></a>21276 <span class="comment">/***********************************************************************************************************/</span>
<a name="l21277"></a>21277 
<a name="l21278"></a>21278 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> value_type_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> rep_&gt;
<a name="l21279"></a>21279 LITE_INLINE 
<a name="l21280"></a>21280 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l21281"></a>21281     array_signature_traits&lt;value_type_&gt;::dimensions == 0),
<a name="l21282"></a>21282     <span class="keyword">const</span> <span class="keyword">typename</span> array_helper&lt;value_type_[2][2], traits_type_&gt;::temporary_array
<a name="l21283"></a>21283     &gt;::type
<a name="l21284"></a>21284 rotation_n(
<a name="l21285"></a>21285     <span class="keyword">const</span> array&lt;value_type_[2], traits_type_, rep_&gt;&amp;, 
<a name="l21286"></a>21286     <span class="keyword">const</span> <span class="keyword">typename</span> array_signature_traits&lt;value_type_&gt;::element_type&amp; angle)
<a name="l21287"></a>21287 {
<a name="l21288"></a>21288     <span class="keyword">using namespace </span>std;
<a name="l21289"></a>21289     <span class="keyword">typename</span> array_helper&lt;value_type_[2][2], traits_type_&gt;::temporary_array result;
<a name="l21290"></a>21290 
<a name="l21291"></a>21291     value_type_ tmp_cos = cos(angle);
<a name="l21292"></a>21292     value_type_ tmp_sin = sin(angle);
<a name="l21293"></a>21293 
<a name="l21294"></a>21294     result(0, 0) = tmp_cos;
<a name="l21295"></a>21295     result(1, 1) = tmp_cos;
<a name="l21296"></a>21296     result(0, 1) = -tmp_sin;
<a name="l21297"></a>21297     result(1, 0) = tmp_sin;
<a name="l21298"></a>21298 
<a name="l21299"></a>21299     <span class="keywordflow">return</span> result;
<a name="l21300"></a>21300 }
<a name="l21301"></a>21301 
<a name="l21302"></a>21302 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> value_type_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> rep_&gt;
<a name="l21303"></a>21303 LITE_INLINE 
<a name="l21304"></a>21304 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l21305"></a>21305     array_signature_traits&lt;value_type_&gt;::dimensions == 0),
<a name="l21306"></a>21306     <span class="keyword">const</span> <span class="keyword">typename</span> array_helper&lt;value_type_[2][2], traits_type_&gt;::temporary_array
<a name="l21307"></a>21307     &gt;::type
<a name="l21308"></a>21308 rotation(
<a name="l21309"></a>21309     <span class="keyword">const</span> array&lt;value_type_[2], traits_type_, rep_&gt;&amp; dummy, 
<a name="l21310"></a>21310     <span class="keyword">const</span> <span class="keyword">typename</span> array_signature_traits&lt;value_type_&gt;::element_type&amp; angle)
<a name="l21311"></a>21311 {
<a name="l21312"></a>21312     <span class="keywordflow">return</span> rotation_n(dummy, angle);
<a name="l21313"></a>21313 }
<a name="l21314"></a>21314 
<a name="l21315"></a>21315 <span class="comment">/***********************************************************************************************************/</span>
<a name="l21316"></a>21316 <span class="comment">/* rotation, 3D ********************************************************************************************/</span>
<a name="l21317"></a>21317 <span class="comment">/***********************************************************************************************************/</span>
<a name="l21318"></a>21318 
<a name="l21319"></a>21319 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> value_type_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> rep_&gt;
<a name="l21320"></a>21320 LITE_INLINE 
<a name="l21321"></a>21321 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l21322"></a>21322     array_signature_traits&lt;value_type_&gt;::dimensions == 0),
<a name="l21323"></a>21323     <span class="keyword">const</span> <span class="keyword">typename</span> array_helper&lt;value_type_[3][3], traits_type_&gt;::temporary_array
<a name="l21324"></a>21324     &gt;::type
<a name="l21325"></a>21325 rotation_n(
<a name="l21326"></a>21326     <span class="keyword">const</span> array&lt;value_type_[3], traits_type_, rep_&gt;&amp; axis, 
<a name="l21327"></a>21327     <span class="keyword">const</span> <span class="keyword">typename</span> array_signature_traits&lt;value_type_&gt;::element_type&amp; angle)
<a name="l21328"></a>21328 {
<a name="l21329"></a>21329     <span class="keyword">using namespace </span>std;
<a name="l21330"></a>21330 
<a name="l21331"></a>21331     <span class="keyword">typedef</span> array&lt;value_type_[3], traits_type_, rep_&gt; axis_type;
<a name="l21332"></a>21332 
<a name="l21333"></a>21333     <span class="keyword">typename</span> detail::matrix_policy&lt;axis_type, 9&gt; ::cached_array cached_axis = axis;
<a name="l21334"></a>21334     <span class="keyword">typename</span> array_helper&lt;value_type_[3][3], traits_type_&gt;::temporary_array result;
<a name="l21335"></a>21335 
<a name="l21336"></a>21336     value_type_ tmp_cos = cos(angle);
<a name="l21337"></a>21337     value_type_ tmp_sin = sin(angle);
<a name="l21338"></a>21338     value_type_ tmp_rcos = value_type_(1) - tmp_cos;
<a name="l21339"></a>21339 
<a name="l21340"></a>21340     result(0, 0) = tmp_cos + cached_axis[0]*cached_axis[0]*tmp_rcos;
<a name="l21341"></a>21341     result(1, 1) = tmp_cos + cached_axis[1]*cached_axis[1]*tmp_rcos;
<a name="l21342"></a>21342     result(2, 2) = tmp_cos + cached_axis[2]*cached_axis[2]*tmp_rcos;
<a name="l21343"></a>21343 
<a name="l21344"></a>21344     value_type_ tmp1 = cached_axis[0]*cached_axis[1]*tmp_rcos;
<a name="l21345"></a>21345     value_type_ tmp2 = cached_axis[2]*tmp_sin;
<a name="l21346"></a>21346 
<a name="l21347"></a>21347     result(1, 0) = tmp1 + tmp2;
<a name="l21348"></a>21348     result(0, 1) = tmp1 - tmp2;
<a name="l21349"></a>21349     tmp1 = cached_axis[0]*cached_axis[2]*tmp_rcos;
<a name="l21350"></a>21350     tmp2 = cached_axis[1]*tmp_sin;
<a name="l21351"></a>21351     result(2, 0) = tmp1 - tmp2;
<a name="l21352"></a>21352     result(0, 2) = tmp1 + tmp2;    
<a name="l21353"></a>21353     tmp1 = cached_axis[1]*cached_axis[2]*tmp_rcos;
<a name="l21354"></a>21354     tmp2 = cached_axis[0]*tmp_sin;
<a name="l21355"></a>21355     result(2, 1) = tmp1 + tmp2;
<a name="l21356"></a>21356     result(1, 2) = tmp1 - tmp2;
<a name="l21357"></a>21357 
<a name="l21358"></a>21358     <span class="keywordflow">return</span> result;
<a name="l21359"></a>21359 }
<a name="l21360"></a>21360 
<a name="l21361"></a>21361 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> value_type_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> rep_&gt;
<a name="l21362"></a>21362 LITE_INLINE 
<a name="l21363"></a>21363 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l21364"></a>21364     array_signature_traits&lt;value_type_&gt;::dimensions == 0),
<a name="l21365"></a>21365     <span class="keyword">const</span> <span class="keyword">typename</span> array_helper&lt;value_type_[3][3], traits_type_&gt;::temporary_array
<a name="l21366"></a>21366     &gt;::type
<a name="l21367"></a>21367 rotation(
<a name="l21368"></a>21368     <span class="keyword">const</span> array&lt;value_type_[3], traits_type_, rep_&gt;&amp; axis, 
<a name="l21369"></a>21369     <span class="keyword">const</span> <span class="keyword">typename</span> array_signature_traits&lt;value_type_&gt;::element_type&amp; angle)
<a name="l21370"></a>21370 {
<a name="l21371"></a>21371     <span class="keyword">typename</span> array_helper&lt;value_type_[3], traits_type_&gt;::temporary_array normalized_axis = axis;
<a name="l21372"></a>21372 
<a name="l21373"></a>21373     normalized_axis *= value_type_(1)/abs(normalized_axis);
<a name="l21374"></a>21374 
<a name="l21375"></a>21375     <span class="keywordflow">return</span> rotation_n(normalized_axis, angle);
<a name="l21376"></a>21376 }
<a name="l21377"></a>21377 
<a name="l21378"></a>21378 <span class="comment">/***********************************************************************************************************/</span>
<a name="l21379"></a>21379 <span class="comment">/* scale ***************************************************************************************************/</span>
<a name="l21380"></a>21380 <span class="comment">/***********************************************************************************************************/</span>
<a name="l21381"></a>21381 
<a name="l21382"></a>21382 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> value_type_, <span class="keywordtype">int</span> n_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> rep_&gt;
<a name="l21383"></a>21383 LITE_INLINE 
<a name="l21384"></a>21384 <span class="keyword">typename</span> detail::enable_if&lt;(
<a name="l21385"></a>21385     array_signature_traits&lt;value_type_&gt;::dimensions == 0),
<a name="l21386"></a>21386     <span class="keyword">const</span> <span class="keyword">typename</span> array_helper&lt;value_type_[n_][n_], traits_type_&gt;::temporary_array
<a name="l21387"></a>21387     &gt;::type
<a name="l21388"></a>21388 scale(<span class="keyword">const</span> array&lt;value_type_[n_], traits_type_, rep_&gt;&amp; factors)
<a name="l21389"></a>21389 {
<a name="l21390"></a>21390     <span class="keyword">const</span> <span class="keywordtype">int</span> n = factors.size().i0;
<a name="l21391"></a>21391     <span class="keyword">typename</span> array_helper&lt;value_type_[n_][n_], traits_type_&gt;::temporary_array 
<a name="l21392"></a>21392         result(n, n);
<a name="l21393"></a>21393 
<a name="l21394"></a>21394     result = value_type_();
<a name="l21395"></a>21395     result[diagonal()] = factors;
<a name="l21396"></a>21396     <span class="keywordflow">return</span> result;
<a name="l21397"></a>21397 }
<a name="l21398"></a>21398 
<a name="l21399"></a>21399 <span class="comment">/***********************************************************************************************************/</span>
<a name="l21400"></a>21400 <span class="comment">/* array_comparator ****************************************************************************************/</span>
<a name="l21401"></a>21401 <span class="comment">/***********************************************************************************************************/</span>
<a name="l21402"></a>21402 
<a name="l21420"></a><a class="code" href="classlite_1_1array__comparator.html">21420</a> <span class="keyword">class </span><a class="code" href="classlite_1_1array__comparator.html" title="This class defines a function object that can be used to compare two compatible arrays...">array_comparator</a>
<a name="l21421"></a>21421 {
<a name="l21422"></a>21422 <span class="keyword">public</span>:
<a name="l21423"></a>21423     LITE_INLINE <a class="code" href="classlite_1_1array__comparator.html" title="This class defines a function object that can be used to compare two compatible arrays...">array_comparator</a>() {}
<a name="l21424"></a>21424 
<a name="l21425"></a>21425     LITE_INLINE <a class="code" href="classlite_1_1array__comparator.html" title="This class defines a function object that can be used to compare two compatible arrays...">array_comparator</a>(<span class="keyword">const</span> <a class="code" href="classlite_1_1array__comparator.html" title="This class defines a function object that can be used to compare two compatible arrays...">array_comparator</a>&amp;) {}
<a name="l21426"></a>21426 
<a name="l21427"></a>21427     LITE_INLINE <a class="code" href="classlite_1_1array__comparator.html" title="This class defines a function object that can be used to compare two compatible arrays...">array_comparator</a>&amp; operator= (<a class="code" href="classlite_1_1array__comparator.html" title="This class defines a function object that can be used to compare two compatible arrays...">array_comparator</a>&amp;) { <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l21428"></a>21428 
<a name="l21430"></a>21430     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_, <span class="keyword">typename</span> r_rep_&gt;
<a name="l21431"></a>21431     LITE_INLINE <span class="keywordtype">bool</span> 
<a name="l21432"></a><a class="code" href="classlite_1_1array__comparator.html#af8e314a7d9d753ce5a6f01b2b5102eb7">21432</a>     <a class="code" href="classlite_1_1array__comparator.html#af8e314a7d9d753ce5a6f01b2b5102eb7" title="Returns true if a is lexicographically before b.">operator()</a>(
<a name="l21433"></a>21433         <span class="keyword">const</span> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array&lt;signature_, traits_type_, l_rep_&gt;</a>&amp; a, 
<a name="l21434"></a>21434         <span class="keyword">const</span> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array&lt;signature_, traits_type_, r_rep_&gt;</a>&amp; b)<span class="keyword"> const</span>
<a name="l21435"></a>21435 <span class="keyword">    </span>{
<a name="l21436"></a>21436         <span class="keywordflow">return</span> compare(a, b) &lt; 0;
<a name="l21437"></a>21437     }
<a name="l21438"></a>21438 };
<a name="l21439"></a>21439 
<a name="l21440"></a>21440 <span class="comment">/***********************************************************************************************************/</span>
<a name="l21441"></a>21441 <span class="comment">/* from, fixed size ****************************************************************************************/</span>
<a name="l21442"></a>21442 <span class="comment">/***********************************************************************************************************/</span>
<a name="l21443"></a>21443 
<a name="l21444"></a>21444 <span class="preprocessor">#ifdef DOCUMENTATION_ONLY</span>
<a name="l21445"></a>21445 <span class="preprocessor"></span>
<a name="l21461"></a>21461 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> value_type_, <span class="keywordtype">int</span> n0_ ..., <span class="keywordtype">int</span> nN_&gt;
<a name="l21462"></a>21462 <span class="keyword">const</span> array&lt;...&gt;
<a name="l21463"></a>21463 <a class="code" href="group__array__operations.html#ga8ca9a46abc012ffa303e40c513e828bb" title="constructs a reference array to a C array.">from</a>(value_type_ (&amp;a)[n0_]...[nN_]);
<a name="l21464"></a>21464 
<a name="l21465"></a>21465 <span class="preprocessor">#else // DOCUMENTATION_ONLY</span>
<a name="l21466"></a>21466 <span class="preprocessor"></span>
<a name="l21467"></a>21467 <span class="keyword">template</span>&lt;
<a name="l21468"></a>21468     <span class="keyword">typename</span> value_type_,
<a name="l21469"></a>21469     <span class="keywordtype">int</span> n0_
<a name="l21470"></a>21470 &gt;
<a name="l21471"></a>21471 LITE_INLINE 
<a name="l21472"></a>21472 <span class="keyword">typename</span> detail::enable_if&lt;
<a name="l21473"></a>21473     array_signature_traits&lt;value_type_[n0_]&gt;::is_fixed_size,
<a name="l21474"></a>21474     <span class="keyword">const</span> array&lt;typename array_signature_traits&lt;value_type_[n0_]&gt;::signature, 
<a name="l21475"></a>21475         default_array_traits, 
<a name="l21476"></a>21476         reference_rep&lt;typename array_signature_traits&lt;value_type_[n0_]&gt;::default_iterator&gt; &gt; 
<a name="l21477"></a>21477     &gt;::type
<a name="l21478"></a>21478 <a class="code" href="group__array__operations.html#ga8ca9a46abc012ffa303e40c513e828bb" title="constructs a reference array to a C array.">from</a>(value_type_ (&amp;a)[n0_])
<a name="l21479"></a>21479 {
<a name="l21480"></a>21480     <span class="keyword">typedef</span> array&lt;typename array_signature_traits&lt;value_type_[n0_]&gt;::signature, 
<a name="l21481"></a>21481         default_array_traits, 
<a name="l21482"></a>21482         reference_rep&lt;typename array_signature_traits&lt;value_type_[n0_]&gt;::default_iterator&gt; 
<a name="l21483"></a>21483         &gt; result_type;
<a name="l21484"></a>21484 
<a name="l21485"></a>21485     <span class="keywordflow">return</span> result_type(&amp;a[0], <span class="keyword">typename</span> result_type::size_type());
<a name="l21486"></a>21486 };
<a name="l21487"></a>21487 
<a name="l21488"></a>21488 <span class="keyword">template</span>&lt;
<a name="l21489"></a>21489     <span class="keyword">typename</span> value_type_,
<a name="l21490"></a>21490     <span class="keywordtype">int</span> n0_,
<a name="l21491"></a>21491     <span class="keywordtype">int</span> n1_
<a name="l21492"></a>21492 &gt;
<a name="l21493"></a>21493 LITE_INLINE 
<a name="l21494"></a>21494 <span class="keyword">typename</span> detail::enable_if&lt;
<a name="l21495"></a>21495     array_signature_traits&lt;value_type_[n0_][n1_]&gt;::is_fixed_size,
<a name="l21496"></a>21496     <span class="keyword">const</span> array&lt;typename array_signature_traits&lt;value_type_[n0_][n1_]&gt;::signature, 
<a name="l21497"></a>21497         default_array_traits, 
<a name="l21498"></a>21498         reference_rep&lt;typename array_signature_traits&lt;value_type_[n0_][n1_]&gt;::default_iterator&gt; &gt; 
<a name="l21499"></a>21499     &gt;::type
<a name="l21500"></a>21500 <a class="code" href="group__array__operations.html#ga8ca9a46abc012ffa303e40c513e828bb" title="constructs a reference array to a C array.">from</a>(value_type_ (&amp;a)[n0_][n1_])
<a name="l21501"></a>21501 {
<a name="l21502"></a>21502     <span class="keyword">typedef</span> array&lt;typename array_signature_traits&lt;value_type_[n0_][n1_]&gt;::signature, 
<a name="l21503"></a>21503         default_array_traits, 
<a name="l21504"></a>21504         reference_rep&lt;typename array_signature_traits&lt;value_type_[n0_][n1_]&gt;::default_iterator&gt; 
<a name="l21505"></a>21505         &gt; result_type;
<a name="l21506"></a>21506 
<a name="l21507"></a>21507     <span class="keywordflow">return</span> result_type(&amp;a[0][0], <span class="keyword">typename</span> result_type::size_type());
<a name="l21508"></a>21508 };
<a name="l21509"></a>21509 
<a name="l21510"></a>21510 <span class="keyword">template</span>&lt;
<a name="l21511"></a>21511     <span class="keyword">typename</span> value_type_,
<a name="l21512"></a>21512     <span class="keywordtype">int</span> n0_,
<a name="l21513"></a>21513     <span class="keywordtype">int</span> n1_,
<a name="l21514"></a>21514     <span class="keywordtype">int</span> n2_
<a name="l21515"></a>21515 &gt;
<a name="l21516"></a>21516 LITE_INLINE 
<a name="l21517"></a>21517 <span class="keyword">typename</span> detail::enable_if&lt;
<a name="l21518"></a>21518     array_signature_traits&lt;value_type_[n0_][n1_][n2_]&gt;::is_fixed_size,
<a name="l21519"></a>21519     <span class="keyword">const</span> array&lt;typename array_signature_traits&lt;value_type_[n0_][n1_][n2_]&gt;::signature, 
<a name="l21520"></a>21520         default_array_traits, 
<a name="l21521"></a>21521         reference_rep&lt;typename array_signature_traits&lt;value_type_[n0_][n1_][n2_]&gt;::default_iterator&gt; &gt; 
<a name="l21522"></a>21522     &gt;::type
<a name="l21523"></a>21523 <a class="code" href="group__array__operations.html#ga8ca9a46abc012ffa303e40c513e828bb" title="constructs a reference array to a C array.">from</a>(value_type_ (&amp;a)[n0_][n1_][n2_])
<a name="l21524"></a>21524 {
<a name="l21525"></a>21525     <span class="keyword">typedef</span> array&lt;typename array_signature_traits&lt;value_type_[n0_][n1_][n2_]&gt;::signature, 
<a name="l21526"></a>21526         default_array_traits, 
<a name="l21527"></a>21527         reference_rep&lt;typename array_signature_traits&lt;value_type_[n0_][n1_][n2_]&gt;::default_iterator&gt; 
<a name="l21528"></a>21528         &gt; result_type;
<a name="l21529"></a>21529 
<a name="l21530"></a>21530     <span class="keywordflow">return</span> result_type(&amp;a[0][0][0], <span class="keyword">typename</span> result_type::size_type());
<a name="l21531"></a>21531 };
<a name="l21532"></a>21532 
<a name="l21533"></a>21533 
<a name="l21534"></a>21534 <span class="preprocessor">#endif // DOCUMENTATION_ONLY</span>
<a name="l21535"></a>21535 <span class="preprocessor"></span>
<a name="l21536"></a>21536 <span class="comment">/***********************************************************************************************************/</span>
<a name="l21537"></a>21537 <span class="comment">/* from, variable size *************************************************************************************/</span>
<a name="l21538"></a>21538 <span class="comment">/***********************************************************************************************************/</span>
<a name="l21539"></a>21539 
<a name="l21540"></a>21540 <span class="preprocessor">#ifdef DOCUMENTATION_ONLY</span>
<a name="l21541"></a>21541 <span class="preprocessor"></span>
<a name="l21560"></a>21560 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_&gt;
<a name="l21561"></a>21561 <span class="keyword">const</span> array&lt;...&gt;
<a name="l21562"></a>21562 <a class="code" href="group__array__operations.html#ga8ca9a46abc012ffa303e40c513e828bb" title="constructs a reference array to a C array.">from</a>(iterator_type_ it, <span class="keywordtype">int</span> n0 ..., <span class="keywordtype">int</span> nN);
<a name="l21563"></a>21563 
<a name="l21564"></a>21564 <span class="preprocessor">#else // DOCUMENTATION_ONLY</span>
<a name="l21565"></a>21565 <span class="preprocessor"></span>
<a name="l21566"></a>21566 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_&gt;
<a name="l21567"></a>21567 LITE_INLINE 
<a name="l21568"></a>21568 <span class="keyword">const</span> array&lt;
<a name="l21569"></a>21569     <span class="keyword">typename</span> std::iterator_traits&lt;iterator_type_&gt;::value_type[1],
<a name="l21570"></a>21570     default_array_traits, 
<a name="l21571"></a>21571     reference_rep&lt;pack&lt;iterator_type_, constant&lt;int, 1&gt; &gt; &gt; &gt; 
<a name="l21572"></a>21572 <a class="code" href="group__array__operations.html#ga8ca9a46abc012ffa303e40c513e828bb" title="constructs a reference array to a C array.">from</a>(iterator_type_ it, <span class="keywordtype">int</span> n0)
<a name="l21573"></a>21573 {
<a name="l21574"></a>21574     <span class="keyword">typedef</span> array&lt;
<a name="l21575"></a>21575         <span class="keyword">typename</span> std::iterator_traits&lt;iterator_type_&gt;::value_type[1],
<a name="l21576"></a>21576         default_array_traits, 
<a name="l21577"></a>21577         reference_rep&lt;pack&lt;iterator_type_, constant&lt;int, 1&gt; &gt; &gt; 
<a name="l21578"></a>21578         &gt; result_type;
<a name="l21579"></a>21579 
<a name="l21580"></a>21580     <span class="keyword">typedef</span> <span class="keyword">typename</span> result_type::iterator iterator_type;
<a name="l21581"></a>21581 
<a name="l21582"></a>21582     <span class="keywordflow">return</span> result_type(
<a name="l21583"></a>21583         iterator_type(it, 1), 
<a name="l21584"></a>21584         <span class="keyword">typename</span> result_type::size_type(n0));
<a name="l21585"></a>21585 }
<a name="l21586"></a>21586 
<a name="l21587"></a>21587 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_&gt;
<a name="l21588"></a>21588 LITE_INLINE 
<a name="l21589"></a>21589 <span class="keyword">const</span> array&lt;
<a name="l21590"></a>21590     <span class="keyword">typename</span> std::iterator_traits&lt;iterator_type_&gt;::value_type[1][1],
<a name="l21591"></a>21591     default_array_traits, 
<a name="l21592"></a>21592     reference_rep&lt;pack&lt;iterator_type_, int, constant&lt;int, 1&gt; &gt; &gt; &gt; 
<a name="l21593"></a>21593 <a class="code" href="group__array__operations.html#ga8ca9a46abc012ffa303e40c513e828bb" title="constructs a reference array to a C array.">from</a>(iterator_type_ it, <span class="keywordtype">int</span> n0, <span class="keywordtype">int</span> n1)
<a name="l21594"></a>21594 {
<a name="l21595"></a>21595     <span class="keyword">typedef</span> array&lt;
<a name="l21596"></a>21596         <span class="keyword">typename</span> std::iterator_traits&lt;iterator_type_&gt;::value_type[1][1],
<a name="l21597"></a>21597         default_array_traits, 
<a name="l21598"></a>21598         reference_rep&lt;pack&lt;iterator_type_, int, constant&lt;int, 1&gt; &gt; &gt; 
<a name="l21599"></a>21599         &gt; result_type;
<a name="l21600"></a>21600 
<a name="l21601"></a>21601     <span class="keyword">typedef</span> <span class="keyword">typename</span> result_type::iterator iterator_type;
<a name="l21602"></a>21602 
<a name="l21603"></a>21603     <span class="keywordflow">return</span> result_type(
<a name="l21604"></a>21604         iterator_type(it, n1, 1), 
<a name="l21605"></a>21605         <span class="keyword">typename</span> result_type::size_type(n0,n1));
<a name="l21606"></a>21606 }
<a name="l21607"></a>21607 
<a name="l21608"></a>21608 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_&gt;
<a name="l21609"></a>21609 LITE_INLINE 
<a name="l21610"></a>21610 <span class="keyword">const</span> array&lt;
<a name="l21611"></a>21611     <span class="keyword">typename</span> std::iterator_traits&lt;iterator_type_&gt;::value_type[1][1][1],
<a name="l21612"></a>21612     default_array_traits, 
<a name="l21613"></a>21613     reference_rep&lt;pack&lt;iterator_type_, int, int, constant&lt;int, 1&gt; &gt; &gt; &gt; 
<a name="l21614"></a>21614 <a class="code" href="group__array__operations.html#ga8ca9a46abc012ffa303e40c513e828bb" title="constructs a reference array to a C array.">from</a>(iterator_type_ it, <span class="keywordtype">int</span> n0, <span class="keywordtype">int</span> n1, <span class="keywordtype">int</span> n2)
<a name="l21615"></a>21615 {
<a name="l21616"></a>21616     <span class="keyword">typedef</span> array&lt;
<a name="l21617"></a>21617         <span class="keyword">typename</span> std::iterator_traits&lt;iterator_type_&gt;::value_type[1][1][1],
<a name="l21618"></a>21618         default_array_traits, 
<a name="l21619"></a>21619         reference_rep&lt;pack&lt;iterator_type_, int, int, constant&lt;int, 1&gt; &gt; &gt; 
<a name="l21620"></a>21620         &gt; result_type;
<a name="l21621"></a>21621 
<a name="l21622"></a>21622     <span class="keyword">typedef</span> <span class="keyword">typename</span> result_type::iterator iterator_type;
<a name="l21623"></a>21623 
<a name="l21624"></a>21624     <span class="keywordflow">return</span> result_type(
<a name="l21625"></a>21625         iterator_type(it, n1*n2, n2, 1), 
<a name="l21626"></a>21626         <span class="keyword">typename</span> result_type::size_type(n0,n1,n2));
<a name="l21627"></a>21627 }
<a name="l21628"></a>21628 
<a name="l21629"></a>21629 
<a name="l21630"></a>21630 <span class="preprocessor">#endif // DOCUMENTATION_ONLY</span>
<a name="l21631"></a>21631 <span class="preprocessor"></span>
<a name="l21632"></a>21632 <span class="comment">/***********************************************************************************************************/</span>
<a name="l21633"></a>21633 <span class="comment">/* from, pack size *****************************************************************************************/</span>
<a name="l21634"></a>21634 <span class="comment">/***********************************************************************************************************/</span>
<a name="l21635"></a>21635 
<a name="l21636"></a>21636 <span class="preprocessor">#ifdef DOCUMENTATION_ONLY</span>
<a name="l21637"></a>21637 <span class="preprocessor"></span>
<a name="l21656"></a>21656 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_, <span class="keyword">typename</span> type0_ ..., <span class="keyword">typename</span> typeN_&gt;
<a name="l21657"></a>21657 <span class="keyword">const</span> array&lt;...&gt;
<a name="l21658"></a>21658 <a class="code" href="group__array__operations.html#ga8ca9a46abc012ffa303e40c513e828bb" title="constructs a reference array to a C array.">from</a>(iterator_type_ it, <span class="keyword">const</span> pack&lt;type0_ ..., typeN_&gt;&amp; size);
<a name="l21659"></a>21659 
<a name="l21660"></a>21660 <span class="preprocessor">#else // DOCUMENTATION_ONLY</span>
<a name="l21661"></a>21661 <span class="preprocessor"></span>
<a name="l21662"></a>21662 
<a name="l21663"></a>21663 <span class="keyword">template</span>&lt;
<a name="l21664"></a>21664     <span class="keyword">typename</span> iterator_type_,
<a name="l21665"></a>21665     <span class="keyword">typename</span> type0_
<a name="l21666"></a>21666 &gt;
<a name="l21667"></a>21667 LITE_INLINE 
<a name="l21668"></a>21668 <span class="keyword">const</span> array&lt;
<a name="l21669"></a>21669     <span class="keyword">typename</span> detail::size_to_signature&lt;
<a name="l21670"></a>21670         pack&lt;type0_&gt;, 
<a name="l21671"></a>21671         <span class="keyword">typename</span> std::iterator_traits&lt;iterator_type_&gt;::value_type 
<a name="l21672"></a>21672     &gt;::type, 
<a name="l21673"></a>21673     default_array_traits, 
<a name="l21674"></a>21674     reference_rep&lt;
<a name="l21675"></a>21675         <span class="keyword">typename</span> array_signature_traits&lt;
<a name="l21676"></a>21676             <span class="keyword">typename</span> detail::size_to_signature&lt;
<a name="l21677"></a>21677                 pack&lt;type0_&gt;, 
<a name="l21678"></a>21678                 <span class="keyword">typename</span> std::iterator_traits&lt;iterator_type_&gt;::value_type 
<a name="l21679"></a>21679             &gt;::type,
<a name="l21680"></a>21680             iterator_type_
<a name="l21681"></a>21681         &gt;::default_iterator&gt;
<a name="l21682"></a>21682     &gt;
<a name="l21683"></a>21683 <a class="code" href="group__array__operations.html#ga8ca9a46abc012ffa303e40c513e828bb" title="constructs a reference array to a C array.">from</a>(
<a name="l21684"></a>21684     iterator_type_ it, 
<a name="l21685"></a>21685     <span class="keyword">const</span> pack&lt;type0_&gt;&amp; size) 
<a name="l21686"></a>21686 {
<a name="l21687"></a>21687     <span class="keyword">typedef</span> array&lt;
<a name="l21688"></a>21688         <span class="keyword">typename</span> detail::size_to_signature&lt;
<a name="l21689"></a>21689             pack&lt;type0_&gt;, 
<a name="l21690"></a>21690             <span class="keyword">typename</span> std::iterator_traits&lt;iterator_type_&gt;::value_type 
<a name="l21691"></a>21691         &gt;::type, 
<a name="l21692"></a>21692         default_array_traits, 
<a name="l21693"></a>21693         reference_rep&lt;
<a name="l21694"></a>21694             <span class="keyword">typename</span> array_signature_traits&lt;
<a name="l21695"></a>21695                 <span class="keyword">typename</span> detail::size_to_signature&lt;
<a name="l21696"></a>21696                     pack&lt;type0_&gt;, 
<a name="l21697"></a>21697                     <span class="keyword">typename</span> std::iterator_traits&lt;iterator_type_&gt;::value_type 
<a name="l21698"></a>21698                 &gt;::type,
<a name="l21699"></a>21699                 iterator_type_
<a name="l21700"></a>21700             &gt;::default_iterator&gt;
<a name="l21701"></a>21701         &gt; result_type;
<a name="l21702"></a>21702 
<a name="l21703"></a>21703     <span class="keyword">typedef</span> <span class="keyword">typename</span> result_type::iterator iterator_type;
<a name="l21704"></a>21704 
<a name="l21705"></a>21705     <span class="keywordflow">return</span> result_type(
<a name="l21706"></a>21706         iterator_type(it, 1), 
<a name="l21707"></a>21707         size);
<a name="l21708"></a>21708 }
<a name="l21709"></a>21709 
<a name="l21710"></a>21710 <span class="keyword">template</span>&lt;
<a name="l21711"></a>21711     <span class="keyword">typename</span> iterator_type_,
<a name="l21712"></a>21712     <span class="keyword">typename</span> type0_,
<a name="l21713"></a>21713     <span class="keyword">typename</span> type1_
<a name="l21714"></a>21714 &gt;
<a name="l21715"></a>21715 LITE_INLINE 
<a name="l21716"></a>21716 <span class="keyword">const</span> array&lt;
<a name="l21717"></a>21717     <span class="keyword">typename</span> detail::size_to_signature&lt;
<a name="l21718"></a>21718         pack&lt;type0_,type1_&gt;, 
<a name="l21719"></a>21719         <span class="keyword">typename</span> std::iterator_traits&lt;iterator_type_&gt;::value_type 
<a name="l21720"></a>21720     &gt;::type, 
<a name="l21721"></a>21721     default_array_traits, 
<a name="l21722"></a>21722     reference_rep&lt;
<a name="l21723"></a>21723         <span class="keyword">typename</span> array_signature_traits&lt;
<a name="l21724"></a>21724             <span class="keyword">typename</span> detail::size_to_signature&lt;
<a name="l21725"></a>21725                 pack&lt;type0_,type1_&gt;, 
<a name="l21726"></a>21726                 <span class="keyword">typename</span> std::iterator_traits&lt;iterator_type_&gt;::value_type 
<a name="l21727"></a>21727             &gt;::type,
<a name="l21728"></a>21728             iterator_type_
<a name="l21729"></a>21729         &gt;::default_iterator&gt;
<a name="l21730"></a>21730     &gt;
<a name="l21731"></a>21731 <a class="code" href="group__array__operations.html#ga8ca9a46abc012ffa303e40c513e828bb" title="constructs a reference array to a C array.">from</a>(
<a name="l21732"></a>21732     iterator_type_ it, 
<a name="l21733"></a>21733     <span class="keyword">const</span> pack&lt;type0_, type1_&gt;&amp; size) 
<a name="l21734"></a>21734 {
<a name="l21735"></a>21735     <span class="keyword">typedef</span> array&lt;
<a name="l21736"></a>21736         <span class="keyword">typename</span> detail::size_to_signature&lt;
<a name="l21737"></a>21737             pack&lt;type0_,type1_&gt;, 
<a name="l21738"></a>21738             <span class="keyword">typename</span> std::iterator_traits&lt;iterator_type_&gt;::value_type 
<a name="l21739"></a>21739         &gt;::type, 
<a name="l21740"></a>21740         default_array_traits, 
<a name="l21741"></a>21741         reference_rep&lt;
<a name="l21742"></a>21742             <span class="keyword">typename</span> array_signature_traits&lt;
<a name="l21743"></a>21743                 <span class="keyword">typename</span> detail::size_to_signature&lt;
<a name="l21744"></a>21744                     pack&lt;type0_,type1_&gt;, 
<a name="l21745"></a>21745                     <span class="keyword">typename</span> std::iterator_traits&lt;iterator_type_&gt;::value_type 
<a name="l21746"></a>21746                 &gt;::type,
<a name="l21747"></a>21747                 iterator_type_
<a name="l21748"></a>21748             &gt;::default_iterator&gt;
<a name="l21749"></a>21749         &gt; result_type;
<a name="l21750"></a>21750 
<a name="l21751"></a>21751     <span class="keyword">typedef</span> <span class="keyword">typename</span> result_type::iterator iterator_type;
<a name="l21752"></a>21752 
<a name="l21753"></a>21753     <span class="keywordflow">return</span> result_type(
<a name="l21754"></a>21754         iterator_type(it, size.i1, 1), 
<a name="l21755"></a>21755         size);
<a name="l21756"></a>21756 }
<a name="l21757"></a>21757 
<a name="l21758"></a>21758 <span class="keyword">template</span>&lt;
<a name="l21759"></a>21759     <span class="keyword">typename</span> iterator_type_,
<a name="l21760"></a>21760     <span class="keyword">typename</span> type0_,
<a name="l21761"></a>21761     <span class="keyword">typename</span> type1_,
<a name="l21762"></a>21762     <span class="keyword">typename</span> type2_
<a name="l21763"></a>21763 &gt;
<a name="l21764"></a>21764 LITE_INLINE 
<a name="l21765"></a>21765 <span class="keyword">const</span> array&lt;
<a name="l21766"></a>21766     <span class="keyword">typename</span> detail::size_to_signature&lt;
<a name="l21767"></a>21767         pack&lt;type0_,type1_,type2_&gt;, 
<a name="l21768"></a>21768         <span class="keyword">typename</span> std::iterator_traits&lt;iterator_type_&gt;::value_type 
<a name="l21769"></a>21769     &gt;::type, 
<a name="l21770"></a>21770     default_array_traits, 
<a name="l21771"></a>21771     reference_rep&lt;
<a name="l21772"></a>21772         <span class="keyword">typename</span> array_signature_traits&lt;
<a name="l21773"></a>21773             <span class="keyword">typename</span> detail::size_to_signature&lt;
<a name="l21774"></a>21774                 pack&lt;type0_,type1_,type2_&gt;, 
<a name="l21775"></a>21775                 <span class="keyword">typename</span> std::iterator_traits&lt;iterator_type_&gt;::value_type 
<a name="l21776"></a>21776             &gt;::type,
<a name="l21777"></a>21777             iterator_type_
<a name="l21778"></a>21778         &gt;::default_iterator&gt;
<a name="l21779"></a>21779     &gt;
<a name="l21780"></a>21780 <a class="code" href="group__array__operations.html#ga8ca9a46abc012ffa303e40c513e828bb" title="constructs a reference array to a C array.">from</a>(
<a name="l21781"></a>21781     iterator_type_ it, 
<a name="l21782"></a>21782     <span class="keyword">const</span> pack&lt;type0_, type1_, type2_&gt;&amp; size) 
<a name="l21783"></a>21783 {
<a name="l21784"></a>21784     <span class="keyword">typedef</span> array&lt;
<a name="l21785"></a>21785         <span class="keyword">typename</span> detail::size_to_signature&lt;
<a name="l21786"></a>21786             pack&lt;type0_,type1_,type2_&gt;, 
<a name="l21787"></a>21787             <span class="keyword">typename</span> std::iterator_traits&lt;iterator_type_&gt;::value_type 
<a name="l21788"></a>21788         &gt;::type, 
<a name="l21789"></a>21789         default_array_traits, 
<a name="l21790"></a>21790         reference_rep&lt;
<a name="l21791"></a>21791             <span class="keyword">typename</span> array_signature_traits&lt;
<a name="l21792"></a>21792                 <span class="keyword">typename</span> detail::size_to_signature&lt;
<a name="l21793"></a>21793                     pack&lt;type0_,type1_,type2_&gt;, 
<a name="l21794"></a>21794                     <span class="keyword">typename</span> std::iterator_traits&lt;iterator_type_&gt;::value_type 
<a name="l21795"></a>21795                 &gt;::type,
<a name="l21796"></a>21796                 iterator_type_
<a name="l21797"></a>21797             &gt;::default_iterator&gt;
<a name="l21798"></a>21798         &gt; result_type;
<a name="l21799"></a>21799 
<a name="l21800"></a>21800     <span class="keyword">typedef</span> <span class="keyword">typename</span> result_type::iterator iterator_type;
<a name="l21801"></a>21801 
<a name="l21802"></a>21802     <span class="keywordflow">return</span> result_type(
<a name="l21803"></a>21803         iterator_type(it, size.i1*size.i2, size.i2, 1), 
<a name="l21804"></a>21804         size);
<a name="l21805"></a>21805 }
<a name="l21806"></a>21806 
<a name="l21807"></a>21807 
<a name="l21808"></a>21808 <span class="preprocessor">#endif // !DOCUMENTATION_ONLY</span>
<a name="l21809"></a>21809 <span class="preprocessor"></span>
<a name="l21810"></a>21810 <span class="comment">/***********************************************************************************************************/</span>
<a name="l21811"></a>21811 <span class="comment">/* from, identity ******************************************************************************************/</span>
<a name="l21812"></a>21812 <span class="comment">/***********************************************************************************************************/</span>
<a name="l21813"></a>21813 
<a name="l21814"></a>21814 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> rep_&gt;
<a name="l21815"></a>21815 LITE_INLINE 
<a name="l21816"></a>21816 array&lt;signature_, traits_type_, rep_&gt;&amp;
<a name="l21817"></a>21817 <a class="code" href="group__array__operations.html#ga8ca9a46abc012ffa303e40c513e828bb" title="constructs a reference array to a C array.">from</a>(array&lt;signature_, traits_type_, rep_&gt;&amp; a)
<a name="l21818"></a>21818 {
<a name="l21819"></a>21819     <span class="keywordflow">return</span> a;
<a name="l21820"></a>21820 }
<a name="l21821"></a>21821 
<a name="l21822"></a>21822 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> rep_&gt;
<a name="l21823"></a>21823 LITE_INLINE 
<a name="l21824"></a>21824 <span class="keyword">const</span> array&lt;signature_, traits_type_, rep_&gt;&amp;
<a name="l21825"></a>21825 <a class="code" href="group__array__operations.html#ga8ca9a46abc012ffa303e40c513e828bb" title="constructs a reference array to a C array.">from</a>(<span class="keyword">const</span> array&lt;signature_, traits_type_, rep_&gt;&amp; a)
<a name="l21826"></a>21826 {
<a name="l21827"></a>21827     <span class="keywordflow">return</span> a;
<a name="l21828"></a>21828 }
<a name="l21829"></a>21829 
<a name="l21830"></a>21830 <span class="comment">/***********************************************************************************************************/</span>
<a name="l21831"></a>21831 <span class="comment">/* array_cast **********************************************************************************************/</span>
<a name="l21832"></a>21832 <span class="comment">/***********************************************************************************************************/</span>
<a name="l21833"></a>21833 
<a name="l21834"></a>21834 <span class="preprocessor">#ifdef DOCUMENTATION_ONLY</span>
<a name="l21835"></a>21835 <span class="preprocessor"></span>
<a name="l21859"></a>21859 <span class="keyword">template</span>&lt;
<a name="l21860"></a>21860     <span class="keyword">typename</span> dst_array_type_, 
<a name="l21861"></a>21861     <span class="keyword">typename</span> src_signature_, 
<a name="l21862"></a>21862     <span class="keyword">typename</span> src_traits_type_, 
<a name="l21863"></a>21863     <span class="keyword">typename</span> src_rep_&gt;
<a name="l21864"></a>21864 <span class="keyword">const</span> array&lt;...&gt;
<a name="l21865"></a>21865 <a class="code" href="group__array__operations.html#gada066bede8b32394da0de8f747c8b7c3" title="Casts the array ar to a compatible array type that has the same signature and traits...">array_cast</a>(<span class="keyword">const</span> array&lt;src_signature_, src_traits_type_, src_rep_&gt;&amp; ar);
<a name="l21866"></a>21866 
<a name="l21867"></a>21867 <span class="preprocessor">#else // DOCUMENTATION_ONLY</span>
<a name="l21868"></a>21868 <span class="preprocessor"></span>
<a name="l21869"></a>21869 <span class="keyword">template</span>&lt;
<a name="l21870"></a>21870     <span class="keyword">typename</span> dst_array_type_, 
<a name="l21871"></a>21871     <span class="keyword">typename</span> src_signature_, 
<a name="l21872"></a>21872     <span class="keyword">typename</span> src_traits_type_, 
<a name="l21873"></a>21873     <span class="keyword">typename</span> src_rep_&gt;
<a name="l21874"></a>21874 LITE_INLINE 
<a name="l21875"></a>21875 <span class="keyword">typename</span> detail::enable_if&lt;
<a name="l21876"></a>21876     (array_signature_traits&lt;src_signature_&gt;::dimensions == dst_array_type_::dimensions),
<a name="l21877"></a>21877     <span class="keyword">const</span> array&lt;
<a name="l21878"></a>21878         <span class="keyword">typename</span> dst_array_type_::signature,
<a name="l21879"></a>21879         <span class="keyword">typename</span> dst_array_type_::traits_type,
<a name="l21880"></a>21880         reference_rep&lt;<span class="keyword">typename</span> array&lt;src_signature_, src_traits_type_, src_rep_&gt;::const_iterator&gt; &gt;
<a name="l21881"></a>21881     &gt;::type
<a name="l21882"></a>21882 <a class="code" href="group__array__operations.html#gada066bede8b32394da0de8f747c8b7c3" title="Casts the array ar to a compatible array type that has the same signature and traits...">array_cast</a>(<span class="keyword">const</span> array&lt;src_signature_, src_traits_type_, src_rep_&gt;&amp; a)
<a name="l21883"></a>21883 {
<a name="l21884"></a>21884     <span class="keyword">typedef</span> array&lt;
<a name="l21885"></a>21885         <span class="keyword">typename</span> dst_array_type_::signature,
<a name="l21886"></a>21886         <span class="keyword">typename</span> dst_array_type_::traits_type,
<a name="l21887"></a>21887         reference_rep&lt;typename array&lt;src_signature_, src_traits_type_, src_rep_&gt;::const_iterator&gt; &gt;
<a name="l21888"></a>21888         result_type;
<a name="l21889"></a>21889 
<a name="l21890"></a>21890     <span class="keyword">typename</span> result_type::size_type new_size(a.size());
<a name="l21891"></a>21891    
<a name="l21892"></a>21892     LITE_ARRAY_SIZE_CHECK(a.size(), new_size, <span class="stringliteral">&quot;array_cast&lt;A&gt;(A): source/target sizes do not match&quot;</span>);
<a name="l21893"></a>21893 
<a name="l21894"></a>21894     <span class="keywordflow">return</span> result_type(a.begin(), new_size);
<a name="l21895"></a>21895 }
<a name="l21896"></a>21896 
<a name="l21897"></a>21897 <span class="keyword">template</span>&lt;
<a name="l21898"></a>21898     <span class="keyword">typename</span> dst_array_type_, 
<a name="l21899"></a>21899     <span class="keyword">typename</span> src_signature_, 
<a name="l21900"></a>21900     <span class="keyword">typename</span> src_traits_type_, 
<a name="l21901"></a>21901     <span class="keyword">typename</span> src_rep_&gt;
<a name="l21902"></a>21902 LITE_INLINE 
<a name="l21903"></a>21903 <span class="keyword">typename</span> detail::enable_if&lt;
<a name="l21904"></a>21904     (array_signature_traits&lt;src_signature_&gt;::dimensions == dst_array_type_::dimensions),
<a name="l21905"></a>21905     <span class="keyword">const</span> array&lt;
<a name="l21906"></a>21906         <span class="keyword">typename</span> dst_array_type_::signature,
<a name="l21907"></a>21907         <span class="keyword">typename</span> dst_array_type_::traits_type,
<a name="l21908"></a>21908         reference_rep&lt;<span class="keyword">typename</span> array&lt;src_signature_, src_traits_type_, src_rep_&gt;::iterator&gt; &gt;
<a name="l21909"></a>21909     &gt;::type
<a name="l21910"></a>21910 <a class="code" href="group__array__operations.html#gada066bede8b32394da0de8f747c8b7c3" title="Casts the array ar to a compatible array type that has the same signature and traits...">array_cast</a>(array&lt;src_signature_, src_traits_type_, src_rep_&gt;&amp; a)
<a name="l21911"></a>21911 {
<a name="l21912"></a>21912     <span class="keyword">typedef</span> array&lt;
<a name="l21913"></a>21913         <span class="keyword">typename</span> dst_array_type_::signature,
<a name="l21914"></a>21914         <span class="keyword">typename</span> dst_array_type_::traits_type,
<a name="l21915"></a>21915         reference_rep&lt;typename array&lt;src_signature_, src_traits_type_, src_rep_&gt;::iterator&gt; &gt;
<a name="l21916"></a>21916         result_type;
<a name="l21917"></a>21917 
<a name="l21918"></a>21918     <span class="keyword">typename</span> result_type::size_type new_size(a.size());
<a name="l21919"></a>21919    
<a name="l21920"></a>21920     LITE_ARRAY_SIZE_CHECK(a.size(), new_size, <span class="stringliteral">&quot;array_cast&lt;A&gt;(A): source/target sizes do not match&quot;</span>);
<a name="l21921"></a>21921 
<a name="l21922"></a>21922     <span class="keywordflow">return</span> result_type(a.begin(), new_size);
<a name="l21923"></a>21923 }
<a name="l21924"></a>21924 
<a name="l21925"></a>21925 <span class="preprocessor">#endif // !DOCUMENTATION_ONLY</span>
<a name="l21926"></a>21926 <span class="preprocessor"></span>
<a name="l21927"></a>21927 <span class="comment">/***********************************************************************************************************/</span>
<a name="l21928"></a>21928 <span class="comment">/* array io, operator&lt;&lt; ************************************************************************************/</span>
<a name="l21929"></a>21929 <span class="comment">/***********************************************************************************************************/</span>
<a name="l21930"></a>21930 
<a name="l21931"></a>21931 <span class="keyword">template</span>&lt;
<a name="l21932"></a>21932     <span class="keyword">typename</span> char_type_ , 
<a name="l21933"></a>21933     <span class="keyword">typename</span> char_traits_type_, 
<a name="l21934"></a>21934     <span class="keyword">typename</span> value_type_, 
<a name="l21935"></a>21935     <span class="keyword">typename</span> traits_type_, 
<a name="l21936"></a>21936     <span class="keyword">typename</span> rep_&gt;
<a name="l21937"></a>21937 <span class="keywordtype">void</span> print(
<a name="l21938"></a>21938     std::basic_ostream&lt;char_type_, char_traits_type_&gt;&amp; os, 
<a name="l21939"></a>21939     <span class="keyword">const</span> array&lt;value_type_, traits_type_, rep_&gt;&amp; ar,
<a name="l21940"></a>21940     <span class="keywordtype">int</span> level
<a name="l21941"></a>21941     )
<a name="l21942"></a>21942 {       
<a name="l21943"></a>21943     std::streamsize width = os.width();
<a name="l21944"></a>21944     <span class="keywordtype">bool</span> punct = (os.flags() &amp; std::ios_base::boolalpha) != 0;
<a name="l21945"></a>21945     
<a name="l21946"></a>21946     os.width(0);
<a name="l21947"></a>21947 
<a name="l21948"></a>21948     <span class="keywordflow">if</span> (punct)
<a name="l21949"></a>21949         os &lt;&lt; <span class="charliteral">&apos;[&apos;</span>;
<a name="l21950"></a>21950 
<a name="l21951"></a>21951     os.width(width);
<a name="l21952"></a>21952     os &lt;&lt; ar();
<a name="l21953"></a>21953 
<a name="l21954"></a>21954     <span class="keywordflow">if</span> (punct)
<a name="l21955"></a>21955         os &lt;&lt; <span class="charliteral">&apos;]&apos;</span>;
<a name="l21956"></a>21956 }
<a name="l21957"></a>21957 
<a name="l21958"></a>21958 <span class="keyword">template</span>&lt;
<a name="l21959"></a>21959     <span class="keyword">typename</span> char_type_ , 
<a name="l21960"></a>21960     <span class="keyword">typename</span> char_traits_type_, 
<a name="l21961"></a>21961     <span class="keyword">typename</span> value_type_, 
<a name="l21962"></a>21962     <span class="keywordtype">int</span> n0_,
<a name="l21963"></a>21963     <span class="keyword">typename</span> traits_type_, 
<a name="l21964"></a>21964     <span class="keyword">typename</span> rep_&gt;
<a name="l21965"></a>21965 <span class="keywordtype">void</span> print(
<a name="l21966"></a>21966     std::basic_ostream&lt;char_type_, char_traits_type_&gt;&amp; os, 
<a name="l21967"></a>21967     <span class="keyword">const</span> array&lt;value_type_[n0_], traits_type_, rep_&gt;&amp; ar,
<a name="l21968"></a>21968     <span class="keywordtype">int</span>
<a name="l21969"></a>21969     )
<a name="l21970"></a>21970 {       
<a name="l21971"></a>21971     std::streamsize width = os.width();
<a name="l21972"></a>21972     <span class="keywordtype">bool</span> punct = (os.flags() &amp; std::ios_base::boolalpha) != 0;
<a name="l21973"></a>21973     <span class="keyword">const</span> <span class="keywordtype">int</span> n =ar.size().i0;
<a name="l21974"></a>21974 
<a name="l21975"></a>21975     os.width(0);
<a name="l21976"></a>21976 
<a name="l21977"></a>21977     <span class="keywordflow">if</span> (punct)
<a name="l21978"></a>21978         os &lt;&lt; <span class="charliteral">&apos;[&apos;</span>;
<a name="l21979"></a>21979 
<a name="l21980"></a>21980     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; i++) {
<a name="l21981"></a>21981         <span class="keywordflow">if</span> (i != 0)
<a name="l21982"></a>21982             os &lt;&lt; <span class="charliteral">&apos; &apos;</span>;
<a name="l21983"></a>21983         os.width(width);
<a name="l21984"></a>21984         os &lt;&lt; ar[i];
<a name="l21985"></a>21985     }
<a name="l21986"></a>21986 
<a name="l21987"></a>21987     <span class="keywordflow">if</span> (punct)
<a name="l21988"></a>21988         os &lt;&lt; <span class="charliteral">&apos;]&apos;</span>;
<a name="l21989"></a>21989 }
<a name="l21990"></a>21990 
<a name="l21991"></a>21991 <span class="keyword">template</span>&lt;
<a name="l21992"></a>21992     <span class="keyword">typename</span> char_type_ , 
<a name="l21993"></a>21993     <span class="keyword">typename</span> char_traits_type_, 
<a name="l21994"></a>21994     <span class="keyword">typename</span> tail_type_, 
<a name="l21995"></a>21995     <span class="keywordtype">int</span> n0_,
<a name="l21996"></a>21996     <span class="keywordtype">int</span> n1_,
<a name="l21997"></a>21997     <span class="keyword">typename</span> traits_type_, 
<a name="l21998"></a>21998     <span class="keyword">typename</span> rep_&gt;
<a name="l21999"></a>21999 <span class="keywordtype">void</span> print(
<a name="l22000"></a>22000     std::basic_ostream&lt;char_type_, char_traits_type_&gt;&amp; os, 
<a name="l22001"></a>22001     <span class="keyword">const</span> array&lt;tail_type_[n0_][n1_], traits_type_, rep_&gt;&amp; ar,
<a name="l22002"></a>22002     <span class="keywordtype">int</span> level =0
<a name="l22003"></a>22003     )
<a name="l22004"></a>22004 {       
<a name="l22005"></a>22005     std::streamsize width = os.width();
<a name="l22006"></a>22006     <span class="keywordtype">bool</span> punct = (os.flags() &amp; std::ios_base::boolalpha) != 0;
<a name="l22007"></a>22007     <span class="keyword">const</span> <span class="keywordtype">int</span> n =ar.size().i0;
<a name="l22008"></a>22008 
<a name="l22009"></a>22009     os.width(0);
<a name="l22010"></a>22010 
<a name="l22011"></a>22011     <span class="keywordflow">if</span> (punct) {
<a name="l22012"></a>22012         os &lt;&lt; <span class="charliteral">&apos;[&apos;</span> &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l22013"></a>22013         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;level; j++) { os.width(width); os &lt;&lt; <span class="charliteral">&apos; &apos;</span>; }
<a name="l22014"></a>22014     }
<a name="l22015"></a>22015     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; i++) {
<a name="l22016"></a>22016         os.width(width); 
<a name="l22017"></a>22017         os &lt;&lt; <span class="charliteral">&apos; &apos;</span>;
<a name="l22018"></a>22018         os.width(width);
<a name="l22019"></a>22019         print(os, ar[<a class="code" href="group__array__transforms.html#gac13d5a020f69071131362062cbb527cb" title="This transform, when applied to an array of dimension N, returns a reference array...">row</a>(i)], level+1);
<a name="l22020"></a>22020         <span class="keywordflow">if</span> (i &lt; n-1) {
<a name="l22021"></a>22021             os &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l22022"></a>22022             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;level; j++) { os.width(width); os &lt;&lt; <span class="charliteral">&apos; &apos;</span>; }
<a name="l22023"></a>22023         }
<a name="l22024"></a>22024     }
<a name="l22025"></a>22025     <span class="keywordflow">if</span> (punct) {
<a name="l22026"></a>22026         os &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l22027"></a>22027         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;level; j++) { os.width(width); os &lt;&lt; <span class="charliteral">&apos; &apos;</span>; }
<a name="l22028"></a>22028         os &lt;&lt; <span class="charliteral">&apos;]&apos;</span>;
<a name="l22029"></a>22029     }
<a name="l22030"></a>22030 }
<a name="l22031"></a>22031 
<a name="l22060"></a>22060 <span class="keyword">template</span>&lt;
<a name="l22061"></a>22061     <span class="keyword">typename</span> char_type_ , 
<a name="l22062"></a>22062     <span class="keyword">typename</span> char_traits_type_, 
<a name="l22063"></a>22063     <span class="keyword">typename</span> signature_, 
<a name="l22064"></a>22064     <span class="keyword">typename</span> traits_type_, 
<a name="l22065"></a>22065     <span class="keyword">typename</span> rep_&gt;
<a name="l22066"></a>22066 std::basic_ostream&lt;char_type_, char_traits_type_&gt;&amp; 
<a name="l22067"></a><a class="code" href="group__array__operations.html#ga4ecfb3588bd987aae7e291f884072765">22067</a> <a class="code" href="group__array__tools.html#ga8e88646b15818ea64dbfe75eb110eccf" title="Prints the pack p to the output stream os.">operator&lt;&lt;</a>(
<a name="l22068"></a>22068     std::basic_ostream&lt;char_type_, char_traits_type_&gt;&amp; os, 
<a name="l22069"></a>22069     <span class="keyword">const</span> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array&lt;signature_, traits_type_, rep_&gt;</a>&amp; ar)
<a name="l22070"></a>22070 {
<a name="l22071"></a>22071     print(os, ar, 0);
<a name="l22072"></a>22072     <span class="keywordflow">return</span> os;
<a name="l22073"></a>22073 }
<a name="l22074"></a>22074 
<a name="l22075"></a>22075 <span class="comment">/***********************************************************************************************************/</span>
<a name="l22076"></a>22076 <span class="comment">/* array io, operator&gt;&gt; ************************************************************************************/</span>
<a name="l22077"></a>22077 <span class="comment">/***********************************************************************************************************/</span>
<a name="l22078"></a>22078 
<a name="l22079"></a>22079 <span class="keyword">template</span>&lt;
<a name="l22080"></a>22080     <span class="keyword">typename</span> char_type_ , 
<a name="l22081"></a>22081     <span class="keyword">typename</span> char_traits_type_, 
<a name="l22082"></a>22082     <span class="keyword">typename</span> value_type_, 
<a name="l22083"></a>22083     <span class="keyword">typename</span> traits_type_, 
<a name="l22084"></a>22084     <span class="keyword">typename</span> rep_&gt;
<a name="l22085"></a>22085 <span class="keywordtype">void</span> scan(
<a name="l22086"></a>22086     std::basic_istream&lt;char_type_, char_traits_type_&gt;&amp; is, 
<a name="l22087"></a>22087     <span class="keyword">const</span> array&lt;value_type_, traits_type_, rep_&gt;&amp; ar,
<a name="l22088"></a>22088     <span class="keywordtype">bool</span> fancy
<a name="l22089"></a>22089     )
<a name="l22090"></a>22090 {
<a name="l22091"></a>22091     char_type_ ch;
<a name="l22092"></a>22092 
<a name="l22093"></a>22093     <span class="keywordflow">if</span> (fancy &amp;&amp; !(is &gt;&gt; ch &amp;&amp; is.narrow(ch, <span class="charliteral">&apos;\0&apos;</span>) == <span class="charliteral">&apos;[&apos;</span>)) {
<a name="l22094"></a>22094         is.setstate(std::ios_base::failbit);
<a name="l22095"></a>22095         <span class="keywordflow">return</span>;
<a name="l22096"></a>22096     }
<a name="l22097"></a>22097 
<a name="l22098"></a>22098     is &gt;&gt; ar();
<a name="l22099"></a>22099 
<a name="l22100"></a>22100     ch = char_type_();
<a name="l22101"></a>22101 
<a name="l22102"></a>22102     <span class="keywordflow">if</span> (fancy &amp;&amp; !(is &gt;&gt; ch &amp;&amp; is.narrow(ch, <span class="charliteral">&apos;\0&apos;</span>) == <span class="charliteral">&apos;]&apos;</span>)) {
<a name="l22103"></a>22103         is.setstate(std::ios_base::failbit);
<a name="l22104"></a>22104         <span class="keywordflow">return</span>;
<a name="l22105"></a>22105     }
<a name="l22106"></a>22106 }
<a name="l22107"></a>22107 
<a name="l22108"></a>22108 <span class="keyword">template</span>&lt;
<a name="l22109"></a>22109     <span class="keyword">typename</span> char_type_ , 
<a name="l22110"></a>22110     <span class="keyword">typename</span> char_traits_type_, 
<a name="l22111"></a>22111     <span class="keyword">typename</span> value_type_, 
<a name="l22112"></a>22112     <span class="keyword">typename</span> traits_type_, 
<a name="l22113"></a>22113     <span class="keyword">typename</span> rep_&gt;
<a name="l22114"></a>22114 <span class="keywordtype">void</span> scan(
<a name="l22115"></a>22115     std::basic_istream&lt;char_type_, char_traits_type_&gt;&amp; is, 
<a name="l22116"></a>22116     array&lt;value_type_, traits_type_, rep_&gt;&amp; ar,
<a name="l22117"></a>22117     <span class="keywordtype">bool</span> fancy
<a name="l22118"></a>22118     )
<a name="l22119"></a>22119 {
<a name="l22120"></a>22120     char_type_ ch;
<a name="l22121"></a>22121 
<a name="l22122"></a>22122     <span class="keywordflow">if</span> (fancy &amp;&amp; !(is &gt;&gt; ch &amp;&amp; is.narrow(ch, <span class="charliteral">&apos;\0&apos;</span>) == <span class="charliteral">&apos;[&apos;</span>)) {
<a name="l22123"></a>22123         is.setstate(std::ios_base::failbit);
<a name="l22124"></a>22124         <span class="keywordflow">return</span>;
<a name="l22125"></a>22125     }
<a name="l22126"></a>22126 
<a name="l22127"></a>22127     is &gt;&gt; ar();
<a name="l22128"></a>22128 
<a name="l22129"></a>22129     ch = char_type_();
<a name="l22130"></a>22130 
<a name="l22131"></a>22131     <span class="keywordflow">if</span> (fancy &amp;&amp; !(is &gt;&gt; ch &amp;&amp; is.narrow(ch, <span class="charliteral">&apos;\0&apos;</span>) == <span class="charliteral">&apos;]&apos;</span>)) {
<a name="l22132"></a>22132         is.setstate(std::ios_base::failbit);
<a name="l22133"></a>22133         <span class="keywordflow">return</span>;
<a name="l22134"></a>22134     }
<a name="l22135"></a>22135 }
<a name="l22136"></a>22136 
<a name="l22137"></a>22137 <span class="comment">/***********************************************************************************************************/</span>
<a name="l22138"></a>22138 
<a name="l22139"></a>22139 <span class="keyword">template</span>&lt;
<a name="l22140"></a>22140     <span class="keyword">typename</span> char_type_ , 
<a name="l22141"></a>22141     <span class="keyword">typename</span> char_traits_type_, 
<a name="l22142"></a>22142     <span class="keyword">typename</span> value_type_, 
<a name="l22143"></a>22143     <span class="keywordtype">int</span> n0_,
<a name="l22144"></a>22144     <span class="keyword">typename</span> traits_type_, 
<a name="l22145"></a>22145     <span class="keyword">typename</span> rep_&gt;
<a name="l22146"></a>22146 <span class="keywordtype">void</span> scan(
<a name="l22147"></a>22147     std::basic_istream&lt;char_type_, char_traits_type_&gt;&amp; is, 
<a name="l22148"></a>22148     <span class="keyword">const</span> array&lt;value_type_[n0_], traits_type_, rep_&gt;&amp; ar,
<a name="l22149"></a>22149     <span class="keywordtype">bool</span> fancy
<a name="l22150"></a>22150     )
<a name="l22151"></a>22151 {
<a name="l22152"></a>22152     <span class="keyword">const</span> <span class="keywordtype">int</span> n =ar.size().i0;
<a name="l22153"></a>22153     char_type_ ch;
<a name="l22154"></a>22154 
<a name="l22155"></a>22155     <span class="keywordflow">if</span> (fancy &amp;&amp; !(is &gt;&gt; ch &amp;&amp; is.narrow(ch, <span class="charliteral">&apos;\0&apos;</span>) == <span class="charliteral">&apos;[&apos;</span>)) {
<a name="l22156"></a>22156         is.setstate(std::ios_base::failbit);
<a name="l22157"></a>22157         <span class="keywordflow">return</span>;
<a name="l22158"></a>22158     }
<a name="l22159"></a>22159 
<a name="l22160"></a>22160     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; i++)
<a name="l22161"></a>22161         is &gt;&gt; ar[i];
<a name="l22162"></a>22162 
<a name="l22163"></a>22163     ch = char_type_();
<a name="l22164"></a>22164 
<a name="l22165"></a>22165     <span class="keywordflow">if</span> (fancy &amp;&amp; !(is &gt;&gt; ch &amp;&amp; is.narrow(ch, <span class="charliteral">&apos;\0&apos;</span>) == <span class="charliteral">&apos;]&apos;</span>)) {
<a name="l22166"></a>22166         is.setstate(std::ios_base::failbit);
<a name="l22167"></a>22167         <span class="keywordflow">return</span>;
<a name="l22168"></a>22168     }
<a name="l22169"></a>22169 }
<a name="l22170"></a>22170 
<a name="l22171"></a>22171 <span class="keyword">template</span>&lt;
<a name="l22172"></a>22172     <span class="keyword">typename</span> char_type_ , 
<a name="l22173"></a>22173     <span class="keyword">typename</span> char_traits_type_, 
<a name="l22174"></a>22174     <span class="keyword">typename</span> value_type_, 
<a name="l22175"></a>22175     <span class="keywordtype">int</span> n0_,
<a name="l22176"></a>22176     <span class="keyword">typename</span> traits_type_, 
<a name="l22177"></a>22177     <span class="keyword">typename</span> rep_&gt;
<a name="l22178"></a>22178 <span class="keywordtype">void</span> scan(
<a name="l22179"></a>22179     std::basic_istream&lt;char_type_, char_traits_type_&gt;&amp; is, 
<a name="l22180"></a>22180     array&lt;value_type_[n0_], traits_type_, rep_&gt;&amp; ar,
<a name="l22181"></a>22181     <span class="keywordtype">bool</span> fancy
<a name="l22182"></a>22182     )
<a name="l22183"></a>22183 {
<a name="l22184"></a>22184     <span class="keyword">const</span> <span class="keywordtype">int</span> n =ar.size().i0;
<a name="l22185"></a>22185     char_type_ ch;
<a name="l22186"></a>22186 
<a name="l22187"></a>22187     <span class="keywordflow">if</span> (fancy &amp;&amp; !(is &gt;&gt; ch &amp;&amp; is.narrow(ch, <span class="charliteral">&apos;\0&apos;</span>) == <span class="charliteral">&apos;[&apos;</span>)) {
<a name="l22188"></a>22188         is.setstate(std::ios_base::failbit);
<a name="l22189"></a>22189         <span class="keywordflow">return</span>;
<a name="l22190"></a>22190     }
<a name="l22191"></a>22191 
<a name="l22192"></a>22192     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; i++)
<a name="l22193"></a>22193         is &gt;&gt; ar[i];
<a name="l22194"></a>22194 
<a name="l22195"></a>22195     ch = char_type_();
<a name="l22196"></a>22196 
<a name="l22197"></a>22197     <span class="keywordflow">if</span> (fancy &amp;&amp; !(is &gt;&gt; ch &amp;&amp; is.narrow(ch, <span class="charliteral">&apos;\0&apos;</span>) == <span class="charliteral">&apos;]&apos;</span>)) {
<a name="l22198"></a>22198         is.setstate(std::ios_base::failbit);
<a name="l22199"></a>22199         <span class="keywordflow">return</span>;
<a name="l22200"></a>22200     }
<a name="l22201"></a>22201 }
<a name="l22202"></a>22202 
<a name="l22203"></a>22203 <span class="comment">/***********************************************************************************************************/</span>
<a name="l22204"></a>22204 
<a name="l22205"></a>22205 <span class="keyword">template</span>&lt;
<a name="l22206"></a>22206     <span class="keyword">typename</span> char_type_ , 
<a name="l22207"></a>22207     <span class="keyword">typename</span> char_traits_type_, 
<a name="l22208"></a>22208     <span class="keyword">typename</span> tail_type_, 
<a name="l22209"></a>22209     <span class="keywordtype">int</span> n0_,
<a name="l22210"></a>22210     <span class="keywordtype">int</span> n1_,
<a name="l22211"></a>22211     <span class="keyword">typename</span> traits_type_, 
<a name="l22212"></a>22212     <span class="keyword">typename</span> rep_&gt;
<a name="l22213"></a>22213 <span class="keywordtype">void</span> scan(
<a name="l22214"></a>22214     std::basic_istream&lt;char_type_, char_traits_type_&gt;&amp; is, 
<a name="l22215"></a>22215     <span class="keyword">const</span> array&lt;tail_type_[n0_][n1_], traits_type_, rep_&gt;&amp; ar,
<a name="l22216"></a>22216     <span class="keywordtype">bool</span> fancy
<a name="l22217"></a>22217     )
<a name="l22218"></a>22218 {
<a name="l22219"></a>22219     <span class="keyword">const</span> <span class="keywordtype">int</span> n =ar.size().i0;
<a name="l22220"></a>22220     char_type_ ch;
<a name="l22221"></a>22221 
<a name="l22222"></a>22222     <span class="keywordflow">if</span> (fancy &amp;&amp; !(is &gt;&gt; ch &amp;&amp; is.narrow(ch, <span class="charliteral">&apos;\0&apos;</span>) == <span class="charliteral">&apos;[&apos;</span>)) {
<a name="l22223"></a>22223         is.setstate(std::ios_base::failbit);
<a name="l22224"></a>22224         <span class="keywordflow">return</span>;
<a name="l22225"></a>22225     }
<a name="l22226"></a>22226 
<a name="l22227"></a>22227     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; i++)
<a name="l22228"></a>22228         scan(is, ar[<a class="code" href="group__array__transforms.html#gac13d5a020f69071131362062cbb527cb" title="This transform, when applied to an array of dimension N, returns a reference array...">row</a>(i)], fancy);
<a name="l22229"></a>22229 
<a name="l22230"></a>22230     ch = char_type_();
<a name="l22231"></a>22231 
<a name="l22232"></a>22232     <span class="keywordflow">if</span> (fancy &amp;&amp; !(is &gt;&gt; ch &amp;&amp; is.narrow(ch, <span class="charliteral">&apos;\0&apos;</span>) == <span class="charliteral">&apos;]&apos;</span>)) {
<a name="l22233"></a>22233         is.setstate(std::ios_base::failbit);
<a name="l22234"></a>22234         <span class="keywordflow">return</span>;
<a name="l22235"></a>22235     }
<a name="l22236"></a>22236 }
<a name="l22237"></a>22237 
<a name="l22238"></a>22238 
<a name="l22239"></a>22239 <span class="keyword">template</span>&lt;
<a name="l22240"></a>22240     <span class="keyword">typename</span> char_type_ , 
<a name="l22241"></a>22241     <span class="keyword">typename</span> char_traits_type_, 
<a name="l22242"></a>22242     <span class="keyword">typename</span> tail_type_, 
<a name="l22243"></a>22243     <span class="keywordtype">int</span> n0_,
<a name="l22244"></a>22244     <span class="keywordtype">int</span> n1_,
<a name="l22245"></a>22245     <span class="keyword">typename</span> traits_type_, 
<a name="l22246"></a>22246     <span class="keyword">typename</span> rep_&gt;
<a name="l22247"></a>22247 <span class="keywordtype">void</span> scan(
<a name="l22248"></a>22248     std::basic_istream&lt;char_type_, char_traits_type_&gt;&amp; is, 
<a name="l22249"></a>22249     array&lt;tail_type_[n0_][n1_], traits_type_, rep_&gt;&amp; ar,
<a name="l22250"></a>22250     <span class="keywordtype">bool</span> fancy
<a name="l22251"></a>22251     )
<a name="l22252"></a>22252 {
<a name="l22253"></a>22253     <span class="keyword">const</span> <span class="keywordtype">int</span> n =ar.size().i0;
<a name="l22254"></a>22254     char_type_ ch;
<a name="l22255"></a>22255 
<a name="l22256"></a>22256     <span class="keywordflow">if</span> (fancy &amp;&amp; !(is &gt;&gt; ch &amp;&amp; is.narrow(ch, <span class="charliteral">&apos;\0&apos;</span>) == <span class="charliteral">&apos;[&apos;</span>)) {
<a name="l22257"></a>22257         is.setstate(std::ios_base::failbit);
<a name="l22258"></a>22258         <span class="keywordflow">return</span>;
<a name="l22259"></a>22259     }
<a name="l22260"></a>22260 
<a name="l22261"></a>22261     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; i++)
<a name="l22262"></a>22262         scan(is, ar[<a class="code" href="group__array__transforms.html#gac13d5a020f69071131362062cbb527cb" title="This transform, when applied to an array of dimension N, returns a reference array...">row</a>(i)], fancy);
<a name="l22263"></a>22263 
<a name="l22264"></a>22264     ch = char_type_();
<a name="l22265"></a>22265 
<a name="l22266"></a>22266     <span class="keywordflow">if</span> (fancy &amp;&amp; !(is &gt;&gt; ch &amp;&amp; is.narrow(ch, <span class="charliteral">&apos;\0&apos;</span>) == <span class="charliteral">&apos;]&apos;</span>)) {
<a name="l22267"></a>22267         is.setstate(std::ios_base::failbit);
<a name="l22268"></a>22268         <span class="keywordflow">return</span>;
<a name="l22269"></a>22269     }
<a name="l22270"></a>22270 }
<a name="l22271"></a>22271 
<a name="l22272"></a>22272 <span class="comment">/***********************************************************************************************************/</span>
<a name="l22273"></a>22273 
<a name="l22303"></a>22303 <span class="keyword">template</span>&lt;
<a name="l22304"></a>22304     <span class="keyword">typename</span> char_type_ , 
<a name="l22305"></a>22305     <span class="keyword">typename</span> char_traits_type_, 
<a name="l22306"></a>22306     <span class="keyword">typename</span> signature_, 
<a name="l22307"></a>22307     <span class="keyword">typename</span> traits_type_, 
<a name="l22308"></a>22308     <span class="keyword">typename</span> rep_&gt;
<a name="l22309"></a>22309 std::basic_istream&lt;char_type_, char_traits_type_&gt;&amp; 
<a name="l22310"></a><a class="code" href="group__array__operations.html#ga565afb00dfe14b36927896bd0d0bab18">22310</a> <a class="code" href="group__array__tools.html#ga4697e22d4ec02c8907b59732c57169dc" title="Scans (reads) the pack p from the input stream is.">operator&gt;&gt;</a>(
<a name="l22311"></a>22311     std::basic_istream&lt;char_type_, char_traits_type_&gt;&amp; is, 
<a name="l22312"></a>22312     <span class="keyword">const</span> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array&lt;signature_, traits_type_, rep_&gt;</a>&amp; ar)
<a name="l22313"></a>22313 {
<a name="l22314"></a>22314     char_type_ ch;
<a name="l22315"></a>22315 
<a name="l22316"></a>22316     <span class="keywordflow">if</span> (!(is &gt;&gt; ch))
<a name="l22317"></a>22317         <span class="keywordflow">return</span> is;
<a name="l22318"></a>22318         
<a name="l22319"></a>22319     <span class="keywordtype">bool</span> fancy = is.narrow(ch, <span class="charliteral">&apos;\0&apos;</span>) == <span class="charliteral">&apos;[&apos;</span>;
<a name="l22320"></a>22320 
<a name="l22321"></a>22321     is.putback(ch);
<a name="l22322"></a>22322     scan(is, ar, fancy);
<a name="l22323"></a>22323     <span class="keywordflow">return</span> is;
<a name="l22324"></a>22324 }
<a name="l22325"></a>22325 
<a name="l22358"></a>22358 <span class="keyword">template</span>&lt;
<a name="l22359"></a>22359     <span class="keyword">typename</span> char_type_ , 
<a name="l22360"></a>22360     <span class="keyword">typename</span> char_traits_type_, 
<a name="l22361"></a>22361     <span class="keyword">typename</span> signature_, 
<a name="l22362"></a>22362     <span class="keyword">typename</span> traits_type_, 
<a name="l22363"></a>22363     <span class="keyword">typename</span> rep_&gt;
<a name="l22364"></a>22364 std::basic_istream&lt;char_type_, char_traits_type_&gt;&amp; 
<a name="l22365"></a><a class="code" href="group__array__operations.html#ga3aa0eaf152ba0305cef26eae060cb1f1">22365</a> <a class="code" href="group__array__tools.html#ga4697e22d4ec02c8907b59732c57169dc" title="Scans (reads) the pack p from the input stream is.">operator&gt;&gt;</a>(
<a name="l22366"></a>22366     std::basic_istream&lt;char_type_, char_traits_type_&gt;&amp; is, 
<a name="l22367"></a>22367     <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array&lt;signature_, traits_type_, rep_&gt;</a>&amp; ar)
<a name="l22368"></a>22368 {
<a name="l22369"></a>22369     char_type_ ch;
<a name="l22370"></a>22370 
<a name="l22371"></a>22371     <span class="keywordflow">if</span> (!(is &gt;&gt; ch))
<a name="l22372"></a>22372         <span class="keywordflow">return</span> is;
<a name="l22373"></a>22373         
<a name="l22374"></a>22374     <span class="keywordtype">bool</span> fancy = is.narrow(ch, <span class="charliteral">&apos;\0&apos;</span>) == <span class="charliteral">&apos;[&apos;</span>;
<a name="l22375"></a>22375 
<a name="l22376"></a>22376     is.putback(ch);
<a name="l22377"></a>22377     scan(is, ar, fancy);
<a name="l22378"></a>22378     <span class="keywordflow">return</span> is;
<a name="l22379"></a>22379 }
<a name="l22380"></a>22380 
<a name="l22381"></a>22381 } <span class="comment">// namespace lite</span>
<a name="l22382"></a>22382 
<a name="l22383"></a>22383 <span class="comment">/***********************************************************************************************************/</span>
<a name="l22384"></a>22384 <span class="comment">/* swap ****************************************************************************************************/</span>
<a name="l22385"></a>22385 <span class="comment">/***********************************************************************************************************/</span>
<a name="l22386"></a>22386 <span class="keyword">namespace </span>std {
<a name="l22387"></a>22387 
<a name="l22388"></a>22388 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> rep_&gt;
<a name="l22389"></a>22389 LITE_INLINE <span class="keywordtype">void</span> 
<a name="l22390"></a>22390 swap(
<a name="l22391"></a>22391     <span class="keyword">const</span> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">lite::array&lt;signature_, traits_type_, rep_&gt;</a>&amp; a, 
<a name="l22392"></a>22392     <span class="keyword">const</span> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">lite::array&lt;signature_, traits_type_, rep_&gt;</a>&amp; b)
<a name="l22393"></a>22393 {
<a name="l22394"></a>22394     a.swap(b);
<a name="l22395"></a>22395 }
<a name="l22396"></a>22396 
<a name="l22397"></a>22397 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> rep_&gt;
<a name="l22398"></a>22398 LITE_INLINE <span class="keywordtype">void</span> 
<a name="l22399"></a>22399 swap(
<a name="l22400"></a>22400     <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">lite::array&lt;signature_, traits_type_, rep_&gt;</a>&amp; a, 
<a name="l22401"></a>22401     <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">lite::array&lt;signature_, traits_type_, rep_&gt;</a>&amp; b)
<a name="l22402"></a>22402 {
<a name="l22403"></a>22403     a.swap(b);
<a name="l22404"></a>22404 }
<a name="l22405"></a>22405 
<a name="l22406"></a>22406 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_, <span class="keyword">typename</span> r_rep_&gt;
<a name="l22407"></a>22407 LITE_INLINE <span class="keywordtype">void</span> 
<a name="l22408"></a>22408 swap(
<a name="l22409"></a>22409     <span class="keyword">const</span> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">lite::array&lt;signature_, traits_type_, l_rep_&gt;</a>&amp; a, 
<a name="l22410"></a>22410     <span class="keyword">const</span> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">lite::array&lt;signature_, traits_type_, r_rep_&gt;</a>&amp; b)
<a name="l22411"></a>22411 {
<a name="l22412"></a>22412     a.swap(b);
<a name="l22413"></a>22413 }
<a name="l22414"></a>22414 
<a name="l22415"></a>22415 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_, <span class="keyword">typename</span> r_rep_&gt;
<a name="l22416"></a>22416 LITE_INLINE <span class="keywordtype">void</span> 
<a name="l22417"></a>22417 swap(
<a name="l22418"></a>22418     <span class="keyword">const</span> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">lite::array&lt;signature_, traits_type_, l_rep_&gt;</a>&amp; a, 
<a name="l22419"></a>22419     <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">lite::array&lt;signature_, traits_type_, r_rep_&gt;</a>&amp; b)
<a name="l22420"></a>22420 {
<a name="l22421"></a>22421     a.swap(b);
<a name="l22422"></a>22422 }
<a name="l22423"></a>22423 
<a name="l22424"></a>22424 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_, <span class="keyword">typename</span> r_rep_&gt;
<a name="l22425"></a>22425 LITE_INLINE <span class="keywordtype">void</span> 
<a name="l22426"></a>22426 swap(
<a name="l22427"></a>22427     <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">lite::array&lt;signature_, traits_type_, l_rep_&gt;</a>&amp; a, 
<a name="l22428"></a>22428     <span class="keyword">const</span> <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">lite::array&lt;signature_, traits_type_, r_rep_&gt;</a>&amp; b)
<a name="l22429"></a>22429 {
<a name="l22430"></a>22430     a.swap(b);
<a name="l22431"></a>22431 }
<a name="l22432"></a>22432 
<a name="l22433"></a>22433 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> l_rep_, <span class="keyword">typename</span> r_rep_&gt;
<a name="l22434"></a>22434 LITE_INLINE <span class="keywordtype">void</span> 
<a name="l22435"></a>22435 swap(
<a name="l22436"></a>22436     <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">lite::array&lt;signature_, traits_type_, l_rep_&gt;</a>&amp; a, 
<a name="l22437"></a>22437     <a class="code" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">lite::array&lt;signature_, traits_type_, r_rep_&gt;</a>&amp; b)
<a name="l22438"></a>22438 {
<a name="l22439"></a>22439     a.swap(b);
<a name="l22440"></a>22440 }
<a name="l22441"></a>22441 
<a name="l22442"></a>22442 } <span class="comment">// namespace std</span>
<a name="l22443"></a>22443 
<a name="l22444"></a>22444 <span class="preprocessor">#ifdef _MSC_VER</span>
<a name="l22445"></a>22445 <span class="preprocessor"></span><span class="preprocessor">#pragma warning(pop)</span>
<a name="l22446"></a>22446 <span class="preprocessor"></span><span class="preprocessor">#endif // _MSC_VER</span>
<a name="l22447"></a>22447 <span class="preprocessor"></span>
<a name="l22448"></a>22448 <span class="preprocessor">#endif // LITE_ARRAY_HPP</span>
<a name="l22449"></a>22449 <span class="preprocessor"></span>
<a name="l22450"></a>22450 
<a name="l22451"></a>22451 
</pre></div></div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on Fri Nov 6 02:03:20 2009 for Lite by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.0 </small></address>
</body>
</html>
