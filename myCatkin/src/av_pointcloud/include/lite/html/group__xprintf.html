<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/>
<title>Lite: xprintf Family of Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="lite.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.0 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>xprintf Family of Functions<br/>
<small>
[<a class="el" href="group__xformat.html">lite xformat - A C++ printf/scanf style IO library</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _char_type , typename _traits_type , typename _argument1_type , ... , typename _argumentN_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; _char_type, <br class="typebreak"/>
_traits_type &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__xprintf.html#gaea363078f6b0fcb284bdd8384e7abce6">lite::xprintf</a> (std::basic_ostream&lt; _char_type, _traits_type &gt; &amp;os, const _char_type *format, const _argument1_type &amp;arg1,..., const _argumentN_type &amp;argN)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _char_type , typename _traits_type , typename _argument1_type , ... , typename _argumentN_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_string&lt; _char_type &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__xprintf.html#ga047bf368cf393a2f389ab6248081a5d4">lite::xprintf</a> (const _char_type *format, const _argument1_type &amp;arg1,..., const _argumentN_type &amp;argN)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _char_type , typename _traits_type , typename _argument_iter_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; _char_type, <br class="typebreak"/>
_traits_type &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__xprintf.html#ga4e320cb48472f5719c204d0060b28125">lite::xprintf_range</a> (std::basic_ostream&lt; _char_type, _traits_type &gt; &amp;os, const _char_type *format_begin, const _char_type *format_end, _argument_iter_type first, _argument_iter_type last)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _char_type , typename _traits_type , typename _argument_iter_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; _char_type, <br class="typebreak"/>
_traits_type &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__xprintf.html#ga29a5c76fba4fac3428cab38d4d49b999">lite::xprintf_range</a> (std::basic_ostream&lt; _char_type, _traits_type &gt; &amp;os, const _char_type *format, _argument_iter_type first, _argument_iter_type last)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _char_type , typename _traits_type , typename _argument_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; _char_type, <br class="typebreak"/>
_traits_type &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__xprintf.html#ga78f4d9a604b960439948d4821ee3ac03">lite::xprintf_one</a> (std::basic_ostream&lt; _char_type, _traits_type &gt; &amp;os, const _char_type *fmt_begin, const _char_type *fmt_end, const _argument_type &amp;argument)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>prints the arguments using the specified format string.</p>
<p>These functions use a printf style format string which can use both Standard and Extended format fields. In both cases, each argument is printed by a call to an appropriate overload of <a class="el" href="group__xprintf.html#ga78f4d9a604b960439948d4821ee3ac03">xprintf_one()</a> function.</p>
<dl class="user"><dt><b>Standard Format Field</b></dt><dd>The standard format has the following pattern:</dd></dl>
<p><b>%[arg_pos$][flags][width][.precision][h|H|l|L|i|I]type</b></p>
<p>Each format string may cause certain stream flags to be set or cleared and the precision and/or width variable of the stream to be set. The goal has been to support all features that can be easily simulated using the iostream formatting facilities. Features that have no direct equivalent for iostreams are not supported.</p>
<p>The <b>arg_pos</b> is the positional argument specifying the index of the argument to be printed. The first argument (i.e. <em>arg1</em>) has index 1. using a positional argument also changes the current argument index so the next argument to be printed by the next format field will be <em>arg_pos+1</em>.</p>
<p>The following <b>flags</b> are supported:</p>
<ul>
<li>'-' left align.<ul>
<li>clears: <code>std::ios_base::adjustfield</code> </li>
<li>sets: <code>std::ios_base::left</code> </li>
</ul>
</li>
<li>' ' prefix with a blank if positive.<ul>
<li>clears: <code>std::ios_base::adjustfield</code> </li>
<li>sets: <code>std::ios_base::internal</code> </li>
</ul>
</li>
<li>'+' prefix with a '+' if positive.<ul>
<li>sets: <code>std::ios_base::showpos</code> </li>
</ul>
</li>
<li>'#' show the base for hexadecimal and octal numbers. Can also be used to enable <code>showpoint</code> and <code>boolalpha</code>.<ul>
<li>sets: <code>std::ios_base::showpoint</code>, <code>std::ios_base::showbase</code>, <code>std::ios_base::boolalpha</code> </li>
</ul>
</li>
<li>'0' is ignored.</li>
</ul>
<p>The <b>width</b> and <b>precision</b> simply sets the stream precision and the field width for the next formatted output of the stream.</p>
<p>All the type prefixes (i.e. 'h', 'H', 'l', ...) are ignored.</p>
<p>The <b>type</b> characters simply set/clear some of the stream flags. The actual type of the argument will be used by the stream for printing. The following <b>type</b> characters are supported:</p>
<ul>
<li>'c', 'C', 'p', 's', 'S' are ignored.</li>
<li>'d', 'i', 'u' integer numbers will be printed in decimal.<ul>
<li>clears: <code>std::ios_base::basefield</code> </li>
<li>sets: <code>std::ios_base::dec</code> </li>
</ul>
</li>
<li>'o' integer numbers will be printed in octal.<ul>
<li>clears: <code>std::ios_base::basefield</code> </li>
<li>sets: <code>std::ios_base::oct</code> </li>
</ul>
</li>
<li>'x' integer numbers will be printed in hexadecimal using lowercase letters.<ul>
<li>clears: <code>std::ios_base::basefield</code>, <code>std::ios_base::uppercase</code> </li>
<li>sets: <code>std::ios_base::hex</code> </li>
</ul>
</li>
<li>'X' integer numbers will be printed in hexadecimal using uppercase letters.<ul>
<li>clears: <code>std::ios_base::basefield</code> </li>
<li>sets: <code>std::ios_base::hex</code>, <code>std::ios_base::uppercase</code> </li>
</ul>
</li>
<li>'e','a' floating point numbers will be printed in scientific format using 'e' letter.<ul>
<li>clears: <code>std::ios_base::floatfield</code>, <code>std::ios_base::uppercase</code> </li>
<li>sets: <code>std::ios_base::scientific</code> </li>
</ul>
</li>
<li>'E','A' floating point numbers will be printed in scientific format using 'E' letter.<ul>
<li>clears: <code>std::ios_base::floatfield</code> </li>
<li>sets: <code>std::ios_base::scientific</code>, <code>std::ios_base::uppercase</code> </li>
</ul>
</li>
<li>'g' floating point numbers will be printed in the shortest of fixed or scientific format using 'e' letter.<ul>
<li>clears: <code>std::ios_base::floatfield</code>, <code>std::ios_base::uppercase</code> </li>
</ul>
</li>
<li>'G' floating point numbers will be printed in the shortest of fixed or scientific format using 'E' letter.<ul>
<li>clears: <code>std::ios_base::floatfield</code>, <code>std::ios_base::uppercase</code> </li>
</ul>
</li>
<li>'n' is ignored and the corresponding argument is skipped.</li>
</ul>
<dl class="user"><dt><b>Extended Format Field</b></dt><dd>In the extended format, a user defined format string is used to format the argument.</dd></dl>
<p><b>%[arg_pos$]{fmt}</b></p>
<p>The format string <em>fmt</em> is enclosed in braces and can be any arbitrary string which is balanced with respect to '{' and '}'. This allows for nesting of format fields. The <em>fmt</em> is then passed to the appropriate overload of the <a class="el" href="group__xprintf.html#ga78f4d9a604b960439948d4821ee3ac03">xprintf_one()</a> function for processing. The <a class="el" href="group__xprintf.html#ga78f4d9a604b960439948d4821ee3ac03">xprintf_one()</a> will do the actual printing.</p>
<dl class="user"><dt><b>Example:</b></dt><dd><div class="fragment"><pre class="fragment">        <a class="code" href="group__xprintf.html#gaea363078f6b0fcb284bdd8384e7abce6">xprintf</a>(std::cout, <span class="stringliteral">&quot;%.4f %5s %1$f&quot;</span>, 34.34, <span class="stringliteral">&quot;hello&quot;</span>);
        <a class="code" href="group__xprintf.html#gaea363078f6b0fcb284bdd8384e7abce6">xprintf</a>(std::cout, <span class="stringliteral">&quot;%.4s %5d %1$f&quot;</span>, 34.34, <span class="stringliteral">&quot;hello&quot;</span>); <span class="comment">// gives the same result</span>
        
        Date d; <span class="comment">// assume that xprintf_one() is defined for the Date class.</span>
        <a class="code" href="group__xprintf.html#gaea363078f6b0fcb284bdd8384e7abce6">xprintf</a>(std::cout, <span class="stringliteral">&quot;The date is : %{%m/%d/%y}, temperature is : %d&quot;</span>, d, 80); <span class="comment">// uses the extended format</span>
</pre></div></dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The precision and flags of the stream are saved at the beginning and restored to their initial value upon exiting the function even if the function exits due to an exception. Also, the stream flags and precision value are reset to their saved value before processing any of the format fields. However, for standard format fields, the flags are reset to the default stream values. </dd></dl>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga047bf368cf393a2f389ab6248081a5d4"></a><!-- doxytag: member="lite::xprintf" ref="ga047bf368cf393a2f389ab6248081a5d4" args="(const _char_type *format, const _argument1_type &amp;arg1,..., const _argumentN_type &amp;argN)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _char_type , typename _traits_type , typename _argument1_type , ... , typename _argumentN_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_string&lt;_char_type&gt; lite::xprintf </td>
          <td>(</td>
          <td class="paramtype">const _char_type *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _argument1_type &amp;&nbsp;</td>
          <td class="paramname"> <em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _argumentN_type &amp;&nbsp;</td>
          <td class="paramname"> <em>argN</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Prints <em>arg1</em> ... <em>argN</em> to a string using the format string specified by <em>format</em> and then return the string.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>format</em>&nbsp;</td><td>The format string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>argI</em>&nbsp;</td><td>I-th argument where I is 1,2, ... N </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the resulting string </dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Note that this function does not throw any exception. Instead, it silently ignores any error. and the printing stops as soon as an error is encountered. </dd></dl>

</div>
</div>
<a class="anchor" id="gaea363078f6b0fcb284bdd8384e7abce6"></a><!-- doxytag: member="lite::xprintf" ref="gaea363078f6b0fcb284bdd8384e7abce6" args="(std::basic_ostream&lt; _char_type, _traits_type &gt; &amp;os, const _char_type *format, const _argument1_type &amp;arg1,..., const _argumentN_type &amp;argN)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _char_type , typename _traits_type , typename _argument1_type , ... , typename _argumentN_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt;_char_type, _traits_type&gt;&amp; lite::xprintf </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; _char_type, _traits_type &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _char_type *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _argument1_type &amp;&nbsp;</td>
          <td class="paramname"> <em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _argumentN_type &amp;&nbsp;</td>
          <td class="paramname"> <em>argN</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Prints <em>arg1</em> ... <em>argN</em> to output stream <em>os</em> using the format string specified by <em>format</em> and then return the stream.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>os</em>&nbsp;</td><td>The target output stream </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>format</em>&nbsp;</td><td>The format string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>argI</em>&nbsp;</td><td>I-th argument where I is 1,2, ... N </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the same output stream <em>os</em> </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classlite_1_1format__error.html">format_error</a>,<a class="el" href="classlite_1_1argument__index__error.html">argument_index_error</a></em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga78f4d9a604b960439948d4821ee3ac03"></a><!-- doxytag: member="lite::xprintf_one" ref="ga78f4d9a604b960439948d4821ee3ac03" args="(std::basic_ostream&lt; _char_type, _traits_type &gt; &amp;os, const _char_type *fmt_begin, const _char_type *fmt_end, const _argument_type &amp;argument)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _char_type , typename _traits_type , typename _argument_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt; _char_type, _traits_type &gt; &amp; lite::xprintf_one </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; _char_type, _traits_type &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _char_type *&nbsp;</td>
          <td class="paramname"> <em>fmt_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _char_type *&nbsp;</td>
          <td class="paramname"> <em>fmt_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _argument_type &amp;&nbsp;</td>
          <td class="paramname"> <em>argument</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Prints the argument <em>argument</em> to output stream <em>os</em> using the user defined format string specified by the range [fmt_begin, fmt_end). The default implementation of this function ignores the format string and simply uses the &lt;&lt; operator to print <em>argument</em> to the output stream. This function can be overloaded to allow handling of user defined format strings. </p>

</div>
</div>
<a class="anchor" id="ga29a5c76fba4fac3428cab38d4d49b999"></a><!-- doxytag: member="lite::xprintf_range" ref="ga29a5c76fba4fac3428cab38d4d49b999" args="(std::basic_ostream&lt; _char_type, _traits_type &gt; &amp;os, const _char_type *format, _argument_iter_type first, _argument_iter_type last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _char_type , typename _traits_type , typename _argument_iter_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt; _char_type, _traits_type &gt; &amp; lite::xprintf_range </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; _char_type, _traits_type &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _char_type *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_argument_iter_type&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_argument_iter_type&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Prints the arguments in the range [<em>first</em>, <em>last</em>) to output stream <em>os</em> using the format string specified by <em>format</em> and then return the stream.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>os</em>&nbsp;</td><td>The target output stream </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>format</em>&nbsp;</td><td>pointer to the the format string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>iterator to the first argument </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>iterator to one past the last argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the same output stream <em>os</em> </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classlite_1_1format__error.html">format_error</a>,<a class="el" href="classlite_1_1argument__index__error.html">argument_index_error</a></em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4e320cb48472f5719c204d0060b28125"></a><!-- doxytag: member="lite::xprintf_range" ref="ga4e320cb48472f5719c204d0060b28125" args="(std::basic_ostream&lt; _char_type, _traits_type &gt; &amp;os, const _char_type *format_begin, const _char_type *format_end, _argument_iter_type first, _argument_iter_type last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _char_type , typename _traits_type , typename _argument_iter_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt; _char_type, _traits_type &gt; &amp; lite::xprintf_range </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; _char_type, _traits_type &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _char_type *&nbsp;</td>
          <td class="paramname"> <em>format_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _char_type *&nbsp;</td>
          <td class="paramname"> <em>format_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_argument_iter_type&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_argument_iter_type&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Prints the arguments in the range [<em>first</em>, <em>last</em>) to output stream <em>os</em> using the format string specified by the range [<em>format_begin</em>, <em>format_end</em>) and then return the stream.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>os</em>&nbsp;</td><td>The target output stream </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>format_begin</em>&nbsp;</td><td>pointer to the beginning of the format string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>format_end</em>&nbsp;</td><td>pointer to one past the end of the format string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>iterator to the first argument </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>iterator to one past the last argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the same output stream <em>os</em> </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classlite_1_1format__error.html">format_error</a>,<a class="el" href="classlite_1_1argument__index__error.html">argument_index_error</a></em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on Fri Nov 6 02:03:21 2009 for Lite by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.0 </small></address>
</body>
</html>
