<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/>
<title>Lite: Array Operations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="lite.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.0 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Array Operations<br/>
<small>
[<a class="el" href="group__array.html">lite array - A C++ Multidimensional Array Library</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlite_1_1array__comparator.html">lite::array_comparator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class defines a function object that can be used to compare two compatible arrays to define an ordering.  <a href="classlite_1_1array__comparator.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename size_type_ &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__array__operations.html#gae75c2a405afffef6e4b64e7ea1831372">lite::volume</a> (const size_type_ &amp;sz)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the total volume of an <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a> of the size <em>sz</em>.  <a href="#gae75c2a405afffef6e4b64e7ea1831372"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename value_type_ , int n0_..., int nN_&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const array&lt;...&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__array__operations.html#ga8ca9a46abc012ffa303e40c513e828bb">lite::from</a> (value_type_(&amp;a)[n0_]...[nN_])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">constructs a reference <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a> to a C <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a>.  <a href="#ga8ca9a46abc012ffa303e40c513e828bb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename iterator_type_ &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const array&lt;...&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__array__operations.html#ga67720b3fb898a69203d98e649f8d3349">lite::from</a> (iterator_type_ it, int n0..., int nN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a reference <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a> from a pointer (or any other appropriate random access iterator) with the specified dimension sizes.  <a href="#ga67720b3fb898a69203d98e649f8d3349"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename iterator_type_ , typename type0_... , typename typeN_ &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const array&lt;...&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__array__operations.html#gad9b894528ed07ec980f967a9d69439f8">lite::from</a> (iterator_type_ it, const pack&lt; type0_..., typeN_ &gt; &amp;size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a reference <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a> from a pointer (or any other appropriate random access iterator) with the specified size.  <a href="#gad9b894528ed07ec980f967a9d69439f8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename dst_array_type_ , typename src_signature_ , typename src_traits_type_ , typename src_rep_ &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const array&lt;...&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__array__operations.html#gada066bede8b32394da0de8f747c8b7c3">lite::array_cast</a> (const array&lt; src_signature_, src_traits_type_, src_rep_ &gt; &amp;ar)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Casts the <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a> <em>ar</em> to a compatible <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a> type that has the same signature and traits type as <em>dst_array_type_</em>.  <a href="#gada066bede8b32394da0de8f747c8b7c3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename char_type_ , typename char_traits_type_ , typename signature_ , typename traits_type_ , typename rep_ &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; char_type_, <br class="typebreak"/>
char_traits_type_ &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__array__operations.html#ga4ecfb3588bd987aae7e291f884072765">lite::operator&lt;&lt;</a> (std::basic_ostream&lt; char_type_, char_traits_type_ &gt; &amp;os, const array&lt; signature_, traits_type_, rep_ &gt; &amp;ar)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints the <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a> <em>ar</em> to the output stream <em>os</em>.  <a href="#ga4ecfb3588bd987aae7e291f884072765"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename char_type_ , typename char_traits_type_ , typename signature_ , typename traits_type_ , typename rep_ &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_istream&lt; char_type_, <br class="typebreak"/>
char_traits_type_ &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__array__operations.html#ga565afb00dfe14b36927896bd0d0bab18">lite::operator&gt;&gt;</a> (std::basic_istream&lt; char_type_, char_traits_type_ &gt; &amp;is, const array&lt; signature_, traits_type_, rep_ &gt; &amp;ar)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scans (reads) the <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a> <em>ar</em> from the input stream <em>is</em>.  <a href="#ga565afb00dfe14b36927896bd0d0bab18"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename char_type_ , typename char_traits_type_ , typename signature_ , typename traits_type_ , typename rep_ &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_istream&lt; char_type_, <br class="typebreak"/>
char_traits_type_ &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__array__operations.html#ga3aa0eaf152ba0305cef26eae060cb1f1">lite::operator&gt;&gt;</a> (std::basic_istream&lt; char_type_, char_traits_type_ &gt; &amp;is, array&lt; signature_, traits_type_, rep_ &gt; &amp;ar)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scans (reads) the <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a> <em>ar</em> from the input stream <em>is</em>.  <a href="#ga3aa0eaf152ba0305cef26eae060cb1f1"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The library provides a rich set of array operations. The next example provides a brief list of operations that are supported. In the example, the type <b>Array</b> could be any general array (single/multi dimensional with fixed or variable size), the type <b>Matrix</b> could be any 2-dimensional array with fixed or variable size dimensions and the type <b>Vector</b> could be any 1-dimensional array of fixed or variable size.</p>
<div class="fragment"><pre class="fragment">    <span class="comment">// general array operations:</span>

    <span class="keyword">typedef</span> array&lt;float[5][20][20]&gt; Array;

    Array A, A1, A2, B;
    <span class="keywordtype">float</span> c;
    <span class="keywordtype">bool</span> b;
    <span class="keywordtype">int</span> res;

    B = A;                  <span class="comment">//  copy A to B, possibly resizing B</span>
    swap(A, B);             <span class="comment">//  swap A and B</span>

    A = c;                  <span class="comment">//  A(i,j,k) = c</span>
    B = +A;                 <span class="comment">//? B(i,j,k) = +A(i,j,k)</span>
    B = -A;                 <span class="comment">//? B(i,j,k) = -A(i,j,k)</span>
    B = A + c;              <span class="comment">//? B(i,j,k) = A(i,j,k) + c</span>
    B = c + A;              <span class="comment">//? B(i,j,k) = c + A(i,j,k)</span>
    B = A + c;              <span class="comment">//? B(i,j,k) = A(i,j,k) + c</span>
    B = A - c;              <span class="comment">//? B(i,j,k) = A(i,j,k) - c</span>
    B = c - A;              <span class="comment">//? B(i,j,k) = c - A(i,j,k)</span>
    B = c * A;              <span class="comment">//? B(i,j,k) = c * A(i,j,k)</span>
    B = A * c;              <span class="comment">//? B(i,j,k) = A(i,j,k) * c</span>
    B = A / c;              <span class="comment">//? B(i,j,k) = A(i,j,k) / c</span>
    B = A / c;              <span class="comment">//? B(i,j,k) = A(i,j,k) / c</span>
    B = A1 + A2;            <span class="comment">//? B(i,j,k) = A1(i,j,k) + A2(i,j,k)                    </span>
    B = A1 - A2;            <span class="comment">//? B(i,j,k) = A1(i,j,k) - A2(i,j,k)</span>
    B = A1 - A2;            <span class="comment">//? B(i,j,k) = A1(i,j,k) - A2(i,j,k)</span>
    B = A1 | A2;            <span class="comment">//? B(i,j,k) = A1(i,j,k) * A2(i,j,k)</span>

    A += c;                 <span class="comment">//  A(i,j,k) += c</span>
    A -= c;                 <span class="comment">//  A(i,j,k) -= c</span>
    A *= c;                 <span class="comment">//  A(i,j,k) *= c</span>
    A /= c;                 <span class="comment">//  A(i,j,k) /= c</span>
    B += A;                 <span class="comment">//  B(i,j,k) += A(i,j,k)</span>
    B -= A;                 <span class="comment">//  B(i,j,k) -= A(i,j,k)</span>

    b = B &lt; A;              <span class="comment">//  true if B(i,j,k) &lt; A(i,j,k) for all i,j,k</span>
    b = B &lt;= A;             <span class="comment">//  true if B(i,j,k) &lt;= A(i,j,k) for all i,j,k</span>
    b = B == A;             <span class="comment">//  true if B(i,j,k) == A(i,j,k) for all i,j,k</span>
    b = B != A;             <span class="comment">//  is equivalent to !(B==A)</span>
    b = B &gt;= A;             <span class="comment">//  true if B(i,j,k) &gt;= A(i,j,k) for all i,j,k</span>
    b = B &gt; A;              <span class="comment">//  true if B(i,j,k) &gt; A(i,j,k) for all i,j,k</span>
    res = compare(B, A);    <span class="comment">//  lexicographically compare A and B. </span>
                            <span class="comment">//  returns -1 if B is before A, +1 if B is after A and 0 otherwise</span>

    c = norm(A);            <span class="comment">//  returns the sum of the squares of all of the elements</span>
    c = abs(A);             <span class="comment">//  returns sqrt(norm(A))</span>
    B = normalized(A);      <span class="comment">//  returns a scaled copy of A such that abs(normalized(A)) = 1</span>

    B = min(A1, A2);        <span class="comment">//? B(i,j,k) = min(A1(i,j,k), A2(i,j,k))</span>
    B = max(A1, A2);        <span class="comment">//? B(i,j,k) = max(A1(i,j,k), A2(i,j,k))</span>

    std::cin &gt;&gt; A;          <span class="comment">//  reads from a std::basic_istream</span>
    std::cout &lt;&lt; A;         <span class="comment">//  writes to a std::basic_ostream</span>

    B = apply&lt;std::negate&gt;(A);          <span class="comment">//? B(i,j,k) = -A(i,j,k)</span>
    B = apply(A, std::negate());        <span class="comment">//? B(i,j,k) = -A(i,j,k)</span>
    B = apply&lt;std::plus&gt;(A1, A2);       <span class="comment">//? B(i,j,k) = A1(i,j,k) + A2(i,j,k)</span>
    B = apply(A1, A2, std::plus());     <span class="comment">//? B(i,j,k) = A1(i,j,k) + A2(i,j,k)</span>

    <span class="comment">// matrix and vector operations:</span>

    <span class="keyword">typedef</span> array&lt;float[20][20]&gt; Matrix;
    <span class="keyword">typedef</span> array&lt;float[20]&gt; Vector;

    Matrix N, M, M1, M2;
    Vector U, V, V1, V2;

    c = V1 * V2;            <span class="comment">//  returns the inner product of V1 and V2</span>
    U = M * V;              <span class="comment">//  matrix-vector product (V is treated as a column vector)</span>
    U = V * M;              <span class="comment">//  vector-matrix product (V is treated as a row vector)</span>
    N = M1 * M2;            <span class="comment">//  matrix-matrix product (V is treated as a row vector)</span>
    N = M1 * M2;            <span class="comment">//  matrix-matrix product (V is treated as a row vector)</span>
    c = det(M);             <span class="comment">//  returns the determinant of M</span>
    N = inverse(M);         <span class="comment">//  returns the inverse of M</span>
    M = scale(V);           <span class="comment">//  returns a square matrix with V on the main diagonal</span>

    <span class="comment">// 2D specific geometric operations:</span>

    <span class="keyword">typedef</span> array&lt;float[2][2]&gt; Matrix2;
    <span class="keyword">typedef</span> array&lt;float[2]&gt; Vector2;

    Matrix2 M2;
    Vector2 u2, v2, w2;

    c = u2 % v2;            <span class="comment">//  returns the cross product of u2 and v2</span>
    M2 = rotation(v2, c);   <span class="comment">//  returns a rotation matrix that rotates c radians, v2 is ignored</span>
    M2 = rotation_n(v2, c); <span class="comment">//  same as rotation(v2, c)</span>

    <span class="comment">// 3D specific geometric operations:</span>

    <span class="keyword">typedef</span> array&lt;float[3][3]&gt; Matrix3;
    <span class="keyword">typedef</span> array&lt;float[3]&gt; Vector3;

    Matrix3 M3;
    Vector3 u3, v3, w3;

    w3 = u3 % v3;           <span class="comment">//  returns the cross product of u3 and v3</span>
    M3 = rotation(v3, c);   <span class="comment">//  returns a rotation matrix that rotates c radians around v3</span>
    M3 = rotation_n(v3, c); <span class="comment">//  slightly faster than rotation(v3, c) but v3 must be a unit vector.</span>
</pre></div><p> Note that the above operations can be used on any type that support the underlying operators. For example, to use the <code>compare()</code> function, the operator&lt; should be defined on the elements of the array.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><ul>
<li>Note that all of the operations that involve two arrays, require the two array to have matching signatures and traits. For example, you cannot add an array of type <code>array&lt;float</code>[10]&gt; with and array of type <code>array&lt;float</code>[1]&gt; even if the size of the second array is actually 10. To use two arrays with the same size but different signatures or different traits type, you first need to cast one of them using the <a class="el" href="group__array__operations.html#gada066bede8b32394da0de8f747c8b7c3" title="Casts the array ar to a compatible array type that has the same signature and traits...">lite::array_cast()</a>. For matrix and vector operations, only the relevant part of the signature is required to match. For example you can multiply an <code>array&lt;float</code>[1][10]&gt; by an <code>array&lt;float</code>[10]&gt; but not by an <code>array&lt;float</code>[1]&gt; event if the size of the second array is actually 10. You would first need to cast the second array to <code>array&lt;float</code>[10]&gt; using <a class="el" href="group__array__operations.html#gada066bede8b32394da0de8f747c8b7c3" title="Casts the array ar to a compatible array type that has the same signature and traits...">lite::array_cast()</a>.</li>
<li>All the operations the are marked with a <b>question mark</b> in their comment use lazy evaluation (see <a class="el" href="group__array__advanced.html#array_lazy">Lazy Evaluation</a>). Note that due to lazy evaluation, sometimes it is necessary to make a temporary copy of an array to ensure proper result. To do that you can use the lite::copy(). For example: <div class="fragment"><pre class="fragment">            array&lt;float[5][5]&gt; a;

            a = a[transpose()];         <span class="comment">// does not work correctly due to lazy evaluation</span>
            a = copy(a[transpose()]);   <span class="comment">// works fine. makes a temporary copy of a[transpose()]</span>
</pre></div></li>
<li>Note that when copying arrays using operator=(), the left array will be resized (if possible) before the actual copy.</li>
</ul>
</dd></dl>
<h2><a class="anchor" id="array_cast">
Array Casting</a></h2>
<p>For more information on array casting, see <a class="el" href="group__array__operations.html#gada066bede8b32394da0de8f747c8b7c3" title="Casts the array ar to a compatible array type that has the same signature and traits...">lite::array_cast()</a>.</p>
<h2><a class="anchor" id="array_io">
Array I/O</a></h2>
<p>For more information on reading/writing arrays to io streams, see <a class="el" href="group__array__operations.html#array_input">lite::operator&gt;&gt;()</a> and <a class="el" href="group__array__operations.html#array_output">lite::operator&lt;&lt;()</a>.</p>
<h2><a class="anchor" id="array_from">
Constructing Reference Arrays from C Arrays, Iterators or Pointers</a></h2>
<p>You can create a reference array from a C array, an appropriate random access iterator or a pointer using <a class="el" href="group__array__operations.html#ga8ca9a46abc012ffa303e40c513e828bb" title="constructs a reference array to a C array.">lite::from()</a>.</p>
<h2><a class="anchor" id="array_orering">
Ordering Array Objects</a></h2>
<p>If you ever need to define an ordering on array objects (e.g. to use <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">lite::array</a> as the key to a std::map) you can use <a class="el" href="classlite_1_1array__comparator.html" title="This class defines a function object that can be used to compare two compatible arrays...">lite::array_comparator</a>. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gada066bede8b32394da0de8f747c8b7c3"></a><!-- doxytag: member="lite::array_cast" ref="gada066bede8b32394da0de8f747c8b7c3" args="(const array&lt; src_signature_, src_traits_type_, src_rep_ &gt; &amp;ar)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename dst_array_type_ , typename src_signature_ , typename src_traits_type_ , typename src_rep_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const array&lt;...&gt; lite::array_cast </td>
          <td>(</td>
          <td class="paramtype">const array&lt; src_signature_, src_traits_type_, src_rep_ &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>ar</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Casts the <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a> <em>ar</em> to a compatible <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a> type that has the same signature and traits type as <em>dst_array_type_</em>. </p>
<p>The result of the cast is always a reference <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a> that points to the original <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a>. No copying is ever made. This function may throw a <a class="el" href="classlite_1_1size__mismatch__error.html" title="A mismatch between the sizes of two arrays in an operation or invalid size for a...">lite::size_mismatch_error</a> exception if the actual size of the <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a> <em>ar</em> does not match the signature type of <em>dst_array_type_</em>.</p>
<dl class="user"><dt><b>Example:</b></dt><dd></dd></dl>
<div class="fragment"><pre class="fragment">        array&lt;float[10]&gt; a;                     <span class="comment">// 1D array of constant size 10</span>
        array&lt;float[1]&gt; b(10);                  <span class="comment">// 1D array of non-constant size 10</span>

        a = b;                                  <span class="comment">// error: array signatures do not match.</span>
        a = <a class="code" href="group__array__operations.html#gada066bede8b32394da0de8f747c8b7c3" title="Casts the array ar to a compatible array type that has the same signature and traits...">array_cast</a>&lt;array&lt;float[10]&gt; &gt;(b);   <span class="comment">// works fine.</span>
        <a class="code" href="group__array__operations.html#gada066bede8b32394da0de8f747c8b7c3" title="Casts the array ar to a compatible array type that has the same signature and traits...">array_cast</a>&lt;array&lt;float[1]&gt; &gt;(a) = b;    <span class="comment">// produces the same result as the previous line.</span>
</pre></div><dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classlite_1_1size__mismatch__error.html" title="A mismatch between the sizes of two arrays in an operation or invalid size for a...">lite::size_mismatch_error</a></em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad9b894528ed07ec980f967a9d69439f8"></a><!-- doxytag: member="lite::from" ref="gad9b894528ed07ec980f967a9d69439f8" args="(iterator_type_ it, const pack&lt; type0_..., typeN_ &gt; &amp;size)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterator_type_ , typename type0_... , typename typeN_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const array&lt;...&gt; lite::from </td>
          <td>(</td>
          <td class="paramtype">iterator_type_&nbsp;</td>
          <td class="paramname"> <em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pack&lt; type0_..., typeN_ &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a reference <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a> from a pointer (or any other appropriate random access iterator) with the specified size. </p>
<dl class="user"><dt><b>Example:</b></dt><dd></dd></dl>
<div class="fragment"><pre class="fragment">    array&lt;float[3][3]&gt; a, c;
    std::vector&lt;float&gt; v(9);

    std::cin &gt;&gt; <a class="code" href="group__array__operations.html#ga8ca9a46abc012ffa303e40c513e828bb" title="constructs a reference array to a C array.">from</a>(v.begin(), a.size());  <span class="comment">// read v</span>
    std::cin &gt;&gt; a;                          <span class="comment">// read a</span>
    c = a*<a class="code" href="group__array__operations.html#ga8ca9a46abc012ffa303e40c513e828bb" title="constructs a reference array to a C array.">from</a>(v.begin(), a.size());        <span class="comment">// matrix multiplication</span>
</pre></div> 
</div>
</div>
<a class="anchor" id="ga67720b3fb898a69203d98e649f8d3349"></a><!-- doxytag: member="lite::from" ref="ga67720b3fb898a69203d98e649f8d3349" args="(iterator_type_ it, int n0..., int nN)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterator_type_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const array&lt;...&gt; lite::from </td>
          <td>(</td>
          <td class="paramtype">iterator_type_&nbsp;</td>
          <td class="paramname"> <em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n0...</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nN</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a reference <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a> from a pointer (or any other appropriate random access iterator) with the specified dimension sizes. </p>
<dl class="user"><dt><b>Example:</b></dt><dd></dd></dl>
<div class="fragment"><pre class="fragment">    array&lt;float[3][3]&gt; a, c;
    std::vector&lt;float&gt; v(9);

    std::cin &gt;&gt; <a class="code" href="group__array__operations.html#ga8ca9a46abc012ffa303e40c513e828bb" title="constructs a reference array to a C array.">from</a>(v.begin(), 3, 3);  <span class="comment">// read v</span>
    std::cin &gt;&gt; a;                      <span class="comment">// read a</span>
    c = a*<a class="code" href="group__array__operations.html#ga8ca9a46abc012ffa303e40c513e828bb" title="constructs a reference array to a C array.">from</a>(v.begin(), 3, 3);        <span class="comment">// matrix multiplication</span>
</pre></div> 
</div>
</div>
<a class="anchor" id="ga8ca9a46abc012ffa303e40c513e828bb"></a><!-- doxytag: member="lite::from" ref="ga8ca9a46abc012ffa303e40c513e828bb" args="(value_type_(&amp;a)[n0_]...[nN_])" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_type_ , int n0_..., int nN_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const array&lt;...&gt; lite::from </td>
          <td>(</td>
          <td class="paramtype">value_type_(&amp;)&nbsp;</td>
          <td class="paramname"> <em>a...</em>[n0_][nN_]</td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>constructs a reference <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a> to a C <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a>. </p>
<dl class="user"><dt><b>Example:</b></dt><dd></dd></dl>
<div class="fragment"><pre class="fragment">    array&lt;float[3][3]&gt; a, c;
    <span class="keywordtype">float</span> b[3][3];

    std::cin &gt;&gt; <a class="code" href="group__array__operations.html#ga8ca9a46abc012ffa303e40c513e828bb" title="constructs a reference array to a C array.">from</a>(b) &gt;&gt; a;   <span class="comment">// read a and b</span>
    c = a*<a class="code" href="group__array__operations.html#ga8ca9a46abc012ffa303e40c513e828bb" title="constructs a reference array to a C array.">from</a>(b);              <span class="comment">// matrix multiplication</span>
</pre></div> 
</div>
</div>
<a class="anchor" id="ga4ecfb3588bd987aae7e291f884072765"></a><!-- doxytag: member="lite::operator&lt;&lt;" ref="ga4ecfb3588bd987aae7e291f884072765" args="(std::basic_ostream&lt; char_type_, char_traits_type_ &gt; &amp;os, const array&lt; signature_, traits_type_, rep_ &gt; &amp;ar)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename char_type_ , typename char_traits_type_ , typename signature_ , typename traits_type_ , typename rep_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt;char_type_, char_traits_type_&gt;&amp; lite::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; char_type_, char_traits_type_ &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const array&lt; signature_, traits_type_, rep_ &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>ar</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints the <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a> <em>ar</em> to the output stream <em>os</em>. </p>
<p><a class="anchor" id="array_output"></a></p>
<p>If the field width value for <em>os</em> is set, it will be used to set the field width for each of the elements to be printed. Also if the <em>boolalpha</em> flags is set then the values of each dimension will be surrounded in a matching pair of square brackets.</p>
<dl class="user"><dt><b>Example:</b></dt><dd></dd></dl>
<div class="fragment"><pre class="fragment">        array&lt;int[3][3]&gt; m = 0;

        m[diagonal()] = 1;
        std::cout &lt;&lt; std::boolalpha  &lt;&lt; std::setw(2) &lt;&lt; m &lt;&lt; std::endl;
</pre></div><p> The output would be: </p>
<div class="fragment"><pre class="fragment">
        [ 
          [ 1  0  0]
          [ 0  1  0]
          [ 0  0  1]
        ]
    </pre></div> 
</div>
</div>
<a class="anchor" id="ga3aa0eaf152ba0305cef26eae060cb1f1"></a><!-- doxytag: member="lite::operator&gt;&gt;" ref="ga3aa0eaf152ba0305cef26eae060cb1f1" args="(std::basic_istream&lt; char_type_, char_traits_type_ &gt; &amp;is, array&lt; signature_, traits_type_, rep_ &gt; &amp;ar)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename char_type_ , typename char_traits_type_ , typename signature_ , typename traits_type_ , typename rep_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_istream&lt;char_type_, char_traits_type_&gt;&amp; lite::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_istream&lt; char_type_, char_traits_type_ &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; signature_, traits_type_, rep_ &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>ar</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scans (reads) the <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a> <em>ar</em> from the input stream <em>is</em>. </p>
<p><a class="anchor" id="array_input"></a></p>
<p>The values of each dimension could be surrounded in a matching pair of square brackets.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>All the consecutive line breaks and white space characters are treated as a single space.</dd></dl>
<dl class="user"><dt><b>Example:</b></dt><dd></dd></dl>
<div class="fragment"><pre class="fragment">        array&lt;int[3][3]&gt; m;
        std::cin &gt;&gt; m;
        std::cout &lt;&lt; m &lt;&lt; std::endl;
</pre></div><p> If the input is: </p>
<div class="fragment"><pre class="fragment">
        [ 
          [ 1  0  0]
          [ 0  1  0]
          [ 0  0  1]
        ]
    </pre></div><p> The output would be: </p>
<div class="fragment"><pre class="fragment">
        1 0 0
        0 1 0
        0 0 1
    </pre></div> 
</div>
</div>
<a class="anchor" id="ga565afb00dfe14b36927896bd0d0bab18"></a><!-- doxytag: member="lite::operator&gt;&gt;" ref="ga565afb00dfe14b36927896bd0d0bab18" args="(std::basic_istream&lt; char_type_, char_traits_type_ &gt; &amp;is, const array&lt; signature_, traits_type_, rep_ &gt; &amp;ar)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename char_type_ , typename char_traits_type_ , typename signature_ , typename traits_type_ , typename rep_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_istream&lt;char_type_, char_traits_type_&gt;&amp; lite::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_istream&lt; char_type_, char_traits_type_ &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const array&lt; signature_, traits_type_, rep_ &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>ar</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scans (reads) the <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a> <em>ar</em> from the input stream <em>is</em>. </p>
<p>The values of each dimension could be surrounded in a matching pair of square brackets.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><ul>
<li>All the consecutive line breaks and white space characters are treated as a single space.</li>
<li><em>ar</em> is declared const to allow reading into reference arrays.</li>
</ul>
</dd></dl>
<dl class="user"><dt><b>Example:</b></dt><dd></dd></dl>
<div class="fragment"><pre class="fragment">        array&lt;int[3][3]&gt; m=0;
        std::cin &gt;&gt; m[diagonal()];
        std::cout &lt;&lt; m &lt;&lt; std::endl;
</pre></div><p> If the input is: </p>
<div class="fragment"><pre class="fragment">
        [ 1 2 3 ]
    </pre></div><p> The output would be: </p>
<div class="fragment"><pre class="fragment">
        1 0 0
        0 2 0
        0 0 3
    </pre></div> 
</div>
</div>
<a class="anchor" id="gae75c2a405afffef6e4b64e7ea1831372"></a><!-- doxytag: member="lite::volume" ref="gae75c2a405afffef6e4b64e7ea1831372" args="(const size_type_ &amp;sz)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename size_type_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int lite::volume </td>
          <td>(</td>
          <td class="paramtype">const size_type_ &amp;&nbsp;</td>
          <td class="paramname"> <em>sz</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the total volume of an <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a> of the size <em>sz</em>. </p>
<dl class="user"><dt><b>Example:</b></dt><dd></dd></dl>
<div class="fragment"><pre class="fragment">        array&lt;float[1][1][5]&gt; a(10, 10, 5);

        std::cout &lt;&lt; <a class="code" href="group__array__operations.html#gae75c2a405afffef6e4b64e7ea1831372" title="Returns the total volume of an array of the size sz.">volume</a>(a.size()) &lt;&lt; std::endl;
</pre></div><p> The output would be: </p>
<div class="fragment"><pre class="fragment">
        500
    </pre></div> 
</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on Fri Nov 6 02:03:20 2009 for Lite by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.0 </small></address>
</body>
</html>
