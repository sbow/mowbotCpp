<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/>
<title>Lite: xscanf Family of Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="lite.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.0 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>xscanf Family of Functions<br/>
<small>
[<a class="el" href="group__xformat.html">lite xformat - A C++ printf/scanf style IO library</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _char_type , typename _traits_type , typename _argument1_type , ... , typename _argumentN_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_istream&lt; _char_type, <br class="typebreak"/>
_traits_type &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__xscanf.html#gae1219b61519ed7edb18ce863b2a829ce">lite::xscanf</a> (std::basic_istream&lt; _char_type, _traits_type &gt; &amp;is, const _char_type *format, _argument1_type &amp;arg1,..., _argumentN_type &amp;argN)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _char_type , typename _traits_type , typename _alloc_type , typename _argument1_type , ... , typename _argumentN_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ios_base::iostate&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__xscanf.html#gac24d32aab06b1085fab7caf38448f527">lite::xscanf</a> (const std::basic_string&lt; _char_type, _traits_type, _alloc_type &gt; &amp;str, const _char_type *format, _argument1_type &amp;arg1,..., _argumentN_type &amp;argN)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _char_type , typename _traits_type , typename _argument_iter_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_istream&lt; _char_type, <br class="typebreak"/>
_traits_type &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__xscanf.html#ga05c55dc3fd79f8a34734645486eabeaf">lite::xscanf_range</a> (std::basic_istream&lt; _char_type, _traits_type &gt; &amp;is, const _char_type *format_begin, const _char_type *format_end, _argument_iter_type first, _argument_iter_type last)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _char_type , typename _traits_type , typename _argument_iter_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_istream&lt; _char_type, <br class="typebreak"/>
_traits_type &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__xscanf.html#gafe9fc74e281bcea162277b7044d983f2">lite::xscanf_range</a> (std::basic_istream&lt; _char_type, _traits_type &gt; &amp;is, const _char_type *format, _argument_iter_type first, _argument_iter_type last)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _char_type , typename _traits_type , typename _argument_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_istream&lt; _char_type, <br class="typebreak"/>
_traits_type &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__xscanf.html#gadb4062148609526867d7c4e6c33717e9">lite::xscanf_one</a> (std::basic_istream&lt; _char_type, _traits_type &gt; &amp;is, const _char_type *fmt_begin, const _char_type *fmt_end, _argument_type &amp;argument)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Scans the arguments using the specified format string.</p>
<p>These functions use a scanf style format string which can be of Standard or Extended form. In both cases, each argument is scanned by a call to an appropriate overload of <a class="el" href="group__xscanf.html#gadb4062148609526867d7c4e6c33717e9">xscanf_one()</a> function.</p>
<p>The format string uses exactly the same pattern as the format strings used by <a class="el" href="group__xprintf.html#gaea363078f6b0fcb284bdd8384e7abce6">xprintf()</a>. You can refer to <a class="el" href="group__xprintf.html#gaea363078f6b0fcb284bdd8384e7abce6">xprintf()</a> for explanation of the format string. Although the format string changes the stream precision and flags the same way that it does for <a class="el" href="group__xprintf.html#gaea363078f6b0fcb284bdd8384e7abce6">xprintf()</a>, most of these changes have no effect except for a few like 'i','d','o','x', field width, etc.</p>
<p>Any white space in the format string may match zero or more white space in the input stream. The rest of the characters in the format string, excluding the format fields, should match the same character from the input stream otherwise a input_mismatch_error exception will be thrown.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>For an input stream, the field width specifies the maximum length of the next string to be read.</dd></dl>
<dl class="user"><dt><b>Example:</b></dt><dd><div class="fragment"><pre class="fragment">        <span class="keywordtype">int</span> i; <span class="keywordtype">float</span> f;
        <a class="code" href="group__xscanf.html#gae1219b61519ed7edb18ce863b2a829ce">xscanf</a>(std::cin, <span class="stringliteral">&quot;f=%f i=%d&quot;</span>, f, i);
        <a class="code" href="group__xscanf.html#gae1219b61519ed7edb18ce863b2a829ce">xscanf</a>(std::cin, <span class="stringliteral">&quot;f=%s i=%c&quot;</span>, f, i); <span class="comment">// gives the same result</span>
        
        Date d; <span class="comment">// assume that xscanf_one() is defined for the Date class.</span>
        <a class="code" href="group__xscanf.html#gae1219b61519ed7edb18ce863b2a829ce">xscanf</a>(std::cin, <span class="stringliteral">&quot;The date is : %{%m/%d/%y} &quot;</span>, d); <span class="comment">// uses the extended format</span>
</pre></div> </dd></dl>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gac24d32aab06b1085fab7caf38448f527"></a><!-- doxytag: member="lite::xscanf" ref="gac24d32aab06b1085fab7caf38448f527" args="(const std::basic_string&lt; _char_type, _traits_type, _alloc_type &gt; &amp;str, const _char_type *format, _argument1_type &amp;arg1,..., _argumentN_type &amp;argN)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _char_type , typename _traits_type , typename _alloc_type , typename _argument1_type , ... , typename _argumentN_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ios_base::iostate lite::xscanf </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; _char_type, _traits_type, _alloc_type &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _char_type *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_argument1_type &amp;&nbsp;</td>
          <td class="paramname"> <em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_argumentN_type &amp;&nbsp;</td>
          <td class="paramname"> <em>argN</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Scans <em>arg1</em> ... <em>argN</em> from the string <em>str</em> using the format string specified by <em>format</em> and then return the status.</p>
<p>This function fails if the input stream does not match the format string.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The source string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>format</em>&nbsp;</td><td>The format string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>argI</em>&nbsp;</td><td>I-th argument where I is 1,2, ... N </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the status </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classlite_1_1format__error.html">format_error</a>,<a class="el" href="classlite_1_1argument__index__error.html">argument_index_error</a>,<a class="el" href="classlite_1_1input__mismatch__error.html">input_mismatch_error</a></em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>To make sure that the <em>format</em> string matches the whole string and there are no extra characters at the end of the string, you can add an extra space to the end of the format string. The extra space will eat all the trailing white space and if there are no extra non-white space characters at the end, the return value should be <code>std::ios_base::eof_bit</code> . </dd></dl>

</div>
</div>
<a class="anchor" id="gae1219b61519ed7edb18ce863b2a829ce"></a><!-- doxytag: member="lite::xscanf" ref="gae1219b61519ed7edb18ce863b2a829ce" args="(std::basic_istream&lt; _char_type, _traits_type &gt; &amp;is, const _char_type *format, _argument1_type &amp;arg1,..., _argumentN_type &amp;argN)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _char_type , typename _traits_type , typename _argument1_type , ... , typename _argumentN_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_istream&lt;_char_type, _traits_type&gt;&amp; lite::xscanf </td>
          <td>(</td>
          <td class="paramtype">std::basic_istream&lt; _char_type, _traits_type &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _char_type *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_argument1_type &amp;&nbsp;</td>
          <td class="paramname"> <em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_argumentN_type &amp;&nbsp;</td>
          <td class="paramname"> <em>argN</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Scans <em>arg1</em> ... <em>argN</em> from the input stream <em>is</em> using the format string specified by <em>format</em> and then return the stream.</p>
<p>This function fails if the input stream does not match the format string.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>is</em>&nbsp;</td><td>The source input stream </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>format</em>&nbsp;</td><td>The format string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>argI</em>&nbsp;</td><td>I-th argument where I is 1,2, ... N </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the same input stream <em>is</em> </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classlite_1_1format__error.html">format_error</a>,<a class="el" href="classlite_1_1argument__index__error.html">argument_index_error</a>,<a class="el" href="classlite_1_1input__mismatch__error.html">input_mismatch_error</a></em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadb4062148609526867d7c4e6c33717e9"></a><!-- doxytag: member="lite::xscanf_one" ref="gadb4062148609526867d7c4e6c33717e9" args="(std::basic_istream&lt; _char_type, _traits_type &gt; &amp;is, const _char_type *fmt_begin, const _char_type *fmt_end, _argument_type &amp;argument)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _char_type , typename _traits_type , typename _argument_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_istream&lt; _char_type, _traits_type &gt; &amp; lite::xscanf_one </td>
          <td>(</td>
          <td class="paramtype">std::basic_istream&lt; _char_type, _traits_type &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _char_type *&nbsp;</td>
          <td class="paramname"> <em>fmt_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _char_type *&nbsp;</td>
          <td class="paramname"> <em>fmt_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_argument_type &amp;&nbsp;</td>
          <td class="paramname"> <em>argument</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Scans the argument <em>argument</em> from the input stream <em>is</em> using the user defined format string specified by the range [fmt_begin, fmt_end). The default implementation of this function ignores the format string and simply uses the &gt;&gt; operator to read <em>argument</em> from the input stream. This function can be overloaded to allow handling of user defined format strings. </p>

</div>
</div>
<a class="anchor" id="gafe9fc74e281bcea162277b7044d983f2"></a><!-- doxytag: member="lite::xscanf_range" ref="gafe9fc74e281bcea162277b7044d983f2" args="(std::basic_istream&lt; _char_type, _traits_type &gt; &amp;is, const _char_type *format, _argument_iter_type first, _argument_iter_type last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _char_type , typename _traits_type , typename _argument_iter_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_istream&lt; _char_type, _traits_type &gt; &amp; lite::xscanf_range </td>
          <td>(</td>
          <td class="paramtype">std::basic_istream&lt; _char_type, _traits_type &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _char_type *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_argument_iter_type&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_argument_iter_type&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Scans the arguments in the range [<em>arg1</em>, <em>argN</em>) from the input stream <em>is</em> using the format string specified by <em>format</em> and then return the stream.</p>
<p>This function fails if the input stream does not match the format string.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>is</em>&nbsp;</td><td>The source input stream </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>format</em>&nbsp;</td><td>The format string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The iterator pointing to the beginning of the range of arguments </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>The iterator pointing to one past the last argument in the range of arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the same input stream <em>is</em> </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classlite_1_1format__error.html">format_error</a>,<a class="el" href="classlite_1_1argument__index__error.html">argument_index_error</a>,<a class="el" href="classlite_1_1input__mismatch__error.html">input_mismatch_error</a></em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga05c55dc3fd79f8a34734645486eabeaf"></a><!-- doxytag: member="lite::xscanf_range" ref="ga05c55dc3fd79f8a34734645486eabeaf" args="(std::basic_istream&lt; _char_type, _traits_type &gt; &amp;is, const _char_type *format_begin, const _char_type *format_end, _argument_iter_type first, _argument_iter_type last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _char_type , typename _traits_type , typename _argument_iter_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_istream&lt; _char_type, _traits_type &gt; &amp; lite::xscanf_range </td>
          <td>(</td>
          <td class="paramtype">std::basic_istream&lt; _char_type, _traits_type &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _char_type *&nbsp;</td>
          <td class="paramname"> <em>format_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _char_type *&nbsp;</td>
          <td class="paramname"> <em>format_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_argument_iter_type&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_argument_iter_type&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Scans the arguments in the range [<em>arg1</em>, <em>argN</em>) from the input stream <em>is</em> using the format string specified by the range [<em>format_begin</em>, <em>format_end</em>) and then return the stream.</p>
<p>This function fails if the input stream does not match the format string.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>is</em>&nbsp;</td><td>The source input stream </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>format_begin</em>&nbsp;</td><td>Pointer to the beginning of the format string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>format_end</em>&nbsp;</td><td>Pointer to the end of the format string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The iterator pointing to the beginning of the range of arguments </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>The iterator pointing to one past the last argument in the range of arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the same input stream <em>is</em> </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classlite_1_1format__error.html">format_error</a>,<a class="el" href="classlite_1_1argument__index__error.html">argument_index_error</a>,<a class="el" href="classlite_1_1input__mismatch__error.html">input_mismatch_error</a></em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on Fri Nov 6 02:03:21 2009 for Lite by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.0 </small></address>
</body>
</html>
