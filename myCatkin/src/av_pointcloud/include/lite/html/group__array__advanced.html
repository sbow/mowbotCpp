<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/>
<title>Lite: Array Internals (Advanced)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="lite.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.0 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Array Internals (Advanced)<br/>
<small>
[<a class="el" href="group__array.html">lite array - A C++ Multidimensional Array Library</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlite_1_1c__iterator.html">lite::c_iterator&lt; value_type_ &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class implements an iterator that returns the same value everywhere.  <a href="classlite_1_1c__iterator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlite_1_1u__iterator.html">lite::u_iterator&lt; base_iter_type_, func_type_, is_static_ &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class implements an iterator that returns the result of applying a function object to the return value of another iterator.  <a href="classlite_1_1u__iterator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlite_1_1b__iterator.html">lite::b_iterator&lt; left_base_iterator_type_, right_base_iterator_type_, func_type_, is_static_ &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class implements an iterator that returns the result of applying a binary function object to the return value of two other iterators.  <a href="classlite_1_1b__iterator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlite_1_1size__transformer.html">lite::size_transformer&lt; transform_type_, input_size_type_ &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This can be used to apply a transform object of type <em>transform_type_</em> to a size object of type <em>input_size_type_</em>.  <a href="structlite_1_1size__transformer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlite_1_1iterator__transformer.html">lite::iterator_transformer&lt; transform_type_, input_iterator_type_, input_size_type_ &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This can be used to apply a transform object of type <em>transform_type_</em> to a pair of iterator object and size object respectively of types <em>input_size_type_</em> and <em>input_size_type_</em>.  <a href="structlite_1_1iterator__transformer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlite_1_1array__signature__traits.html">lite::array_signature_traits&lt; signature_, base_iterator_type_ &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This can be used to extract information from <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a> signatures and get the appropriate iterator type and size type for a signature.  <a href="structlite_1_1array__signature__traits.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlite_1_1default__array__traits.html">lite::default_array_traits</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the default <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a> traits type used by the class <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">lite::array</a>.See <a class="el" href="group__array__advanced.html#array_traits">Array Traits</a> for more information.  <a href="structlite_1_1default__array__traits.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlite_1_1reference__rep.html">lite::reference_rep&lt; iterator_type_ &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is a tag type that can be used to specify reference representation for an <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a>.  <a href="classlite_1_1reference__rep.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlite_1_1internal__rep.html">lite::internal_rep&lt; reversed_ &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is a tag type that can be used to specify internal representation for an <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a>.  <a href="classlite_1_1internal__rep.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlite_1_1hybrid__rep.html">lite::hybrid_rep&lt; reversed_, internal_buf_size_ &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is a tag type that can be used to specify hybrid representation for an <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a>.  <a href="classlite_1_1hybrid__rep.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlite_1_1s__iterator.html">lite::s_iterator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An <code><a class="el" href="classlite_1_1s__iterator.html" title="An s_iterator is used to represent a general multidimensional strided iterator using...">s_iterator</a></code> is used to represent a general multidimensional strided iterator using a stl style iterator and stride lengths for each dimension.  <a href="classlite_1_1s__iterator.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga96bbe207cf4044ddd6ac0079bcf2609b"></a><!-- doxytag: member="array_advanced::make_c_iterator" ref="ga96bbe207cf4044ddd6ac0079bcf2609b" args="(const value_type_ &amp;val)" -->
template&lt;class value_type_ &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">LITE_INLINE c_iterator<br class="typebreak"/>
&lt; value_type_ &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__array__advanced.html#ga96bbe207cf4044ddd6ac0079bcf2609b">lite::make_c_iterator</a> (const value_type_ &amp;val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs and returns a <a class="el" href="classlite_1_1c__iterator.html" title="This class implements an iterator that returns the same value everywhere.">lite::c_iterator</a> that returns <em>val</em> everywhere. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gacba2c5c5bf87aefe0f76dee0b2dc37ef"></a><!-- doxytag: member="array_advanced::make_u_iterator" ref="gacba2c5c5bf87aefe0f76dee0b2dc37ef" args="(const base_iter_type_ &amp;it)" -->
template&lt;typename func_type_ , typename base_iter_type_ &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">LITE_INLINE u_iterator<br class="typebreak"/>
&lt; base_iter_type_, func_type_, <br class="typebreak"/>
true &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__array__advanced.html#gacba2c5c5bf87aefe0f76dee0b2dc37ef">lite::make_u_iterator</a> (const base_iter_type_ &amp;it)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a <a class="el" href="classlite_1_1u__iterator.html" title="This class implements an iterator that returns the result of applying a function...">lite::u_iterator</a> from a base iterator <em>it</em> and a static function object of type <em>func_type_</em>. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga2df4ee35eeb32e5adc2eb8bf77e10f37"></a><!-- doxytag: member="array_advanced::make_u_iterator" ref="ga2df4ee35eeb32e5adc2eb8bf77e10f37" args="(const base_iter_type_ &amp;it, const func_type_ &amp;func)" -->
template&lt;typename func_type_ , typename base_iter_type_ &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">LITE_INLINE u_iterator<br class="typebreak"/>
&lt; base_iter_type_, func_type_, <br class="typebreak"/>
false &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__array__advanced.html#ga2df4ee35eeb32e5adc2eb8bf77e10f37">lite::make_u_iterator</a> (const base_iter_type_ &amp;it, const func_type_ &amp;func)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a <a class="el" href="classlite_1_1u__iterator.html" title="This class implements an iterator that returns the result of applying a function...">lite::u_iterator</a> from a base iterator <em>it</em> and function object <em>func</em>. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gae6a79728f8cfa5ebe774ce4fd4394548"></a><!-- doxytag: member="array_advanced::make_b_iterator" ref="gae6a79728f8cfa5ebe774ce4fd4394548" args="(const left_base_iterator_type_ &amp;left_it, const right_base_iterator_type_ &amp;right_it)" -->
template&lt;typename func_type_ , typename left_base_iterator_type_ , typename right_base_iterator_type_ &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">LITE_INLINE b_iterator<br class="typebreak"/>
&lt; left_base_iterator_type_, <br class="typebreak"/>
right_base_iterator_type_, <br class="typebreak"/>
func_type_, true &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__array__advanced.html#gae6a79728f8cfa5ebe774ce4fd4394548">lite::make_b_iterator</a> (const left_base_iterator_type_ &amp;left_it, const right_base_iterator_type_ &amp;right_it)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a <a class="el" href="classlite_1_1b__iterator.html" title="This class implements an iterator that returns the result of applying a binary function...">lite::b_iterator</a> from base iterators <em>left_it</em> and <em>right_it</em> and a static function object of type <em>func_type_</em>. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga8412cdbe188c46d88331421fc0209794"></a><!-- doxytag: member="array_advanced::make_b_iterator" ref="ga8412cdbe188c46d88331421fc0209794" args="(const left_base_iterator_type_ &amp;left_it, const right_base_iterator_type_ &amp;right_it, const func_type_ &amp;func)" -->
template&lt;typename func_type_ , typename left_base_iterator_type_ , typename right_base_iterator_type_ &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">LITE_INLINE b_iterator<br class="typebreak"/>
&lt; left_base_iterator_type_, <br class="typebreak"/>
right_base_iterator_type_, <br class="typebreak"/>
func_type_, false &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__array__advanced.html#ga8412cdbe188c46d88331421fc0209794">lite::make_b_iterator</a> (const left_base_iterator_type_ &amp;left_it, const right_base_iterator_type_ &amp;right_it, const func_type_ &amp;func)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a <a class="el" href="classlite_1_1b__iterator.html" title="This class implements an iterator that returns the result of applying a binary function...">lite::b_iterator</a> from the base iterators <em>left_it</em> and <em>right_it</em> and function object <em>func</em>. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga45b68d7034f660180513afeceae1e6a5"></a><!-- doxytag: member="array_advanced::for_each" ref="ga45b68d7034f660180513afeceae1e6a5" args="(const iterator_type_ &amp;iter, const size_type_ &amp;size)" -->
template&lt;typename iterator_type_ , typename size_type_ &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">LITE_INLINE void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5">lite::for_each</a> (const iterator_type_ &amp;iter, const size_type_ &amp;size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluates every element of the <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a> pointed by <em>iter</em> and of size <em>size</em>. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga3f3563b9c1ff9f1bf689a1e88abf2da8"></a><!-- doxytag: member="array_advanced::for_each" ref="ga3f3563b9c1ff9f1bf689a1e88abf2da8" args="(const iterator_type_ &amp;iter, function_type_ &amp;func, const size_type_ &amp;size)" -->
template&lt;typename iterator_type_ , typename function_type_ , typename size_type_ &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">LITE_INLINE void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__array__advanced.html#ga3f3563b9c1ff9f1bf689a1e88abf2da8">lite::for_each</a> (const iterator_type_ &amp;iter, function_type_ &amp;func, const size_type_ &amp;size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies the function object <em>func</em> to every element of the <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a> pointed by <em>iter</em> and of size <em>size</em>. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gaa06fb495ed4b4707d300252b466de9e7"></a><!-- doxytag: member="array_advanced::for_each_c" ref="gaa06fb495ed4b4707d300252b466de9e7" args="(const iterator_type_ &amp;iter, const size_type_ &amp;size)" -->
template&lt;typename iterator_type_ , typename size_type_ &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">LITE_INLINE bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7">lite::for_each_c</a> (const iterator_type_ &amp;iter, const size_type_ &amp;size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluates every element of the <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a> pointed by <em>iter</em> and of size <em>size</em> while the elements evaluate to true. Returns true if all the elements evaluated to true. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga596e2aeadf8570bcef339376e0fdc5e9"></a><!-- doxytag: member="array_advanced::for_each_c" ref="ga596e2aeadf8570bcef339376e0fdc5e9" args="(const iterator_type_ &amp;iter, function_type_ &amp;func, const size_type_ &amp;size)" -->
template&lt;typename iterator_type_ , typename function_type_ , typename size_type_ &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">LITE_INLINE bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__array__advanced.html#ga596e2aeadf8570bcef339376e0fdc5e9">lite::for_each_c</a> (const iterator_type_ &amp;iter, function_type_ &amp;func, const size_type_ &amp;size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies the function object <em>func</em> to every element of the <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a> pointed by <em>iter</em> and of size <em>size</em>, while the function object evaluates to true. Returns true if the function object evaluates to true for all the elements. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gae4c4d93cf48d887d0631808c5363e811"></a><!-- doxytag: member="array_advanced::for_each" ref="gae4c4d93cf48d887d0631808c5363e811" args="(const array&lt; signature_, traits_type_, rep_ &gt; &amp;a)" -->
template&lt;typename signature_ , typename traits_type_ , typename rep_ &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">LITE_INLINE void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__array__advanced.html#gae4c4d93cf48d887d0631808c5363e811">lite::for_each</a> (const array&lt; signature_, traits_type_, rep_ &gt; &amp;a)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluates every element of the <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a> <em>a</em>. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga869f2a4f0d0db22d30f917953422cca4"></a><!-- doxytag: member="array_advanced::for_each" ref="ga869f2a4f0d0db22d30f917953422cca4" args="(array&lt; signature_, traits_type_, rep_ &gt; &amp;a)" -->
template&lt;typename signature_ , typename traits_type_ , typename rep_ &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">LITE_INLINE void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__array__advanced.html#ga869f2a4f0d0db22d30f917953422cca4">lite::for_each</a> (array&lt; signature_, traits_type_, rep_ &gt; &amp;a)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluates every element of the <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a> <em>a</em>. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gaeec716d4a871ade50986b09a0bcee5e3"></a><!-- doxytag: member="array_advanced::for_each" ref="gaeec716d4a871ade50986b09a0bcee5e3" args="(const array&lt; signature_, traits_type_, rep_ &gt; &amp;a, function_type_ &amp;func)" -->
template&lt;typename signature_ , typename traits_type_ , typename rep_ , typename function_type_ &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">LITE_INLINE void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__array__advanced.html#gaeec716d4a871ade50986b09a0bcee5e3">lite::for_each</a> (const array&lt; signature_, traits_type_, rep_ &gt; &amp;a, function_type_ &amp;func)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies the function object <em>func</em> to every element of the <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a> <em>a</em>. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga5a02857b5f1087fd848c950e383ef78b"></a><!-- doxytag: member="array_advanced::for_each" ref="ga5a02857b5f1087fd848c950e383ef78b" args="(array&lt; signature_, traits_type_, rep_ &gt; &amp;a, function_type_ &amp;func)" -->
template&lt;typename signature_ , typename traits_type_ , typename rep_ , typename function_type_ &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">LITE_INLINE void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__array__advanced.html#ga5a02857b5f1087fd848c950e383ef78b">lite::for_each</a> (array&lt; signature_, traits_type_, rep_ &gt; &amp;a, function_type_ &amp;func)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies the function object <em>func</em> to every element of the <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a> <em>a</em>. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gadbfa18f6b6deaeec17a9b7af8d8823c9"></a><!-- doxytag: member="array_advanced::for_each_c" ref="gadbfa18f6b6deaeec17a9b7af8d8823c9" args="(const array&lt; signature_, traits_type_, rep_ &gt; &amp;a)" -->
template&lt;typename signature_ , typename traits_type_ , typename rep_ &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">LITE_INLINE bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__array__advanced.html#gadbfa18f6b6deaeec17a9b7af8d8823c9">lite::for_each_c</a> (const array&lt; signature_, traits_type_, rep_ &gt; &amp;a)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluates every element of the <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a> <em>a</em> while the elements evaluate to true. Returns true if all the elements evaluated to true. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga16a9897094cfe85dc560540d919866c0"></a><!-- doxytag: member="array_advanced::for_each_c" ref="ga16a9897094cfe85dc560540d919866c0" args="(array&lt; signature_, traits_type_, rep_ &gt; &amp;a)" -->
template&lt;typename signature_ , typename traits_type_ , typename rep_ &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">LITE_INLINE bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__array__advanced.html#ga16a9897094cfe85dc560540d919866c0">lite::for_each_c</a> (array&lt; signature_, traits_type_, rep_ &gt; &amp;a)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluates every element of the <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a> <em>a</em> while the elements evaluate to true. Returns true if all the elements evaluated to true. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga8bee7c5910cadbc08e99ed4b170fe54c"></a><!-- doxytag: member="array_advanced::for_each_c" ref="ga8bee7c5910cadbc08e99ed4b170fe54c" args="(const array&lt; signature_, traits_type_, rep_ &gt; &amp;a, function_type_ &amp;func)" -->
template&lt;typename signature_ , typename traits_type_ , typename rep_ , typename function_type_ &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">LITE_INLINE bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__array__advanced.html#ga8bee7c5910cadbc08e99ed4b170fe54c">lite::for_each_c</a> (const array&lt; signature_, traits_type_, rep_ &gt; &amp;a, function_type_ &amp;func)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies the function object <em>func</em> to every element of the <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a> <em>a</em> while the function object evaluates to true. Returns true if the function object evaluates to true for all the elements. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gaabe64179bd450168e3afdab57dcfc197"></a><!-- doxytag: member="array_advanced::for_each_c" ref="gaabe64179bd450168e3afdab57dcfc197" args="(array&lt; signature_, traits_type_, rep_ &gt; &amp;a, function_type_ &amp;func)" -->
template&lt;typename signature_ , typename traits_type_ , typename rep_ , typename function_type_ &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">LITE_INLINE bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__array__advanced.html#gaabe64179bd450168e3afdab57dcfc197">lite::for_each_c</a> (array&lt; signature_, traits_type_, rep_ &gt; &amp;a, function_type_ &amp;func)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies the function object <em>func</em> to every element of the <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">array</a> <em>a</em> while the function object evaluates to true. Returns true if the function object evaluates to true for all the elements. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This section contains advanced information about the internal representation of arrays, array traits type and defining new transforms among other things.</p>
<h2><a class="anchor" id="array_reps">
Array Representation (Advanced)</a></h2>
<p>There are two category of array representation as explained in <a class="el" href="group__array__class.html#array_reps_brief">Array Representations</a> :</p>
<ul>
<li><a class="el" href="group__array__class.html#array_primary_cat">Primary Arrays</a></li>
<li><a class="el" href="group__array__class.html#array_reference_cat">Reference Arrays</a></li>
</ul>
<p>The third template parameter of <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">lite::array</a> specifies the representation type of the array: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span>&lt;
    <span class="keyword">typename</span> signature_, 
    <span class="keyword">typename</span> traits_type_ = default_array_traits, 
    <span class="keyword">typename</span> rep_ = <span class="keyword">typename</span> traits_type_::template representation_type&lt;signature_&gt;::type&gt;
<span class="keyword">class </span>array;
</pre></div><p> If not specified explicitly, the appropriate representation type is chosen automatically by the <em>traits_type_</em>. This is usually appropriate for primary arrays. However, sometimes it is necessary to supply this argument explicitly (for example to define a reference array). The argument is usually just a tag type. The actual representation is implemented by specializing the class <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">lite::array</a> for that specific tag type. The following 3 representation types are defined in the library:</p>
<ul>
<li><a class="el" href="classlite_1_1internal__rep.html" title="This is a tag type that can be used to specify internal representation for an array...">lite::internal_rep</a> <a class="el" href="group__array__advanced.html#array_internal">Internal Representation</a></li>
<li><a class="el" href="classlite_1_1hybrid__rep.html" title="This is a tag type that can be used to specify hybrid representation for an array...">lite::hybrid_rep</a> <a class="el" href="group__array__advanced.html#array_hybrid">Hybrid Representation</a></li>
<li><a class="el" href="classlite_1_1reference__rep.html" title="This is a tag type that can be used to specify reference representation for an array...">lite::reference_rep</a> <a class="el" href="group__array__advanced.html#array_reference">Reference Representation</a></li>
</ul>
<p>Other user-defined representations can also be defined by defining new representation tags and further specializing the class <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">lite::array</a> for those tags.</p>
<h3><a class="anchor" id="array_internal">
Internal Representation</a></h3>
<p>The internal representation is specified by specifying lite::interna_rep as the representation tag of the <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">lite::array</a>. It has the following declaration: </p>
<div class="fragment"><pre class="fragment">        <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> reversed_&gt;
        <span class="keyword">class </span>internal_rep;
</pre></div><p>The content of the array is stored as part of the array object itself (thus the name <em>internal_rep</em>). The array <b>must</b> have only fixed size dimensions. The size of the array object will be exactly the same as the size of the storage required for the array as there is no other information stored within the array object (zero overhead). The array objects of with representation are POD object according to C++0x definition (see C++ standard, 3.9:10). These are light weight objects that can be efficiently copied and passed around as value objects. The <a class="el" href="structlite_1_1default__array__traits.html" title="This is the default array traits type used by the class lite::array.See Array Traits...">lite::default_array_traits</a> automatically chooses this representation for small (both single and multidimensional) arrays of fixed size.</p>
<p>if <em>reversed_</em> is true then the array will be stored in the reverse order of dimensions (see <a class="el" href="group__array__advanced.html#array_storage">Array Storage</a>).</p>
<p>For example the following, declares a column-major 5 by 5 matrix:</p>
<div class="fragment"><pre class="fragment">        array&lt;float[5][5], default_array_traits, internal_rep&lt;true&gt; &gt; a;
</pre></div><h3><a class="anchor" id="array_hybrid">
Hybrid Representation</a></h3>
<p>The hybrid representation is specified by specifying <a class="el" href="classlite_1_1hybrid__rep.html" title="This is a tag type that can be used to specify hybrid representation for an array...">lite::hybrid_rep</a> as the representation tag of the <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">lite::array</a>. It has the following declaration: </p>
<div class="fragment"><pre class="fragment">        <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> reversed_, <span class="keywordtype">int</span> <span class="keywordtype">int</span>ernal_buf_size_&gt;
        <span class="keyword">class </span>hybrid_rep;
</pre></div><p>The array object will contain an internal buffer of size <em>internal_buf_size_</em>. The size is in terms of the number of elements of an array. The content of the array will be stored in the internal buffer if it fits. If the array has more than <em>internal_buf_size_</em> elements then it will be allocated externally on the heap. The array can have a mix of fixed and variable size dimensions. In addition to the internal buffer, there is an iterator and a size object maintained internally by the array object. The <a class="el" href="structlite_1_1default__array__traits.html" title="This is the default array traits type used by the class lite::array.See Array Traits...">lite::default_array_traits</a> automatically chooses this representation for large arrays and arrays with at least one dimension with non-const size.</p>
<p>A hybrid array which at least one non-constant size dimension is initially empty unless a size with non-zero volume is specified for it in the constructor. The function <a class="el" href="classlite_1_1array.html#aee5b07bdadc4a1189d3cb1aebf3adb05" title="Releases the memory allocated for the array and set the size to 0.">lite::array::release()</a> can be used to release the memory that is allocated to the array. Even for a fixed size array, a call to <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">lite::array</a>:release() still releases the memory, so you cannot dereference or use the array until you call <a class="el" href="classlite_1_1array.html#a1bf880541296b7d2375fbb0273547f6f" title="Resizes the array dimensions to the specified sizes.">lite::array::resize()</a> to reallocate it again. A fixed size array is automatically allocated upon construction.</p>
<p>if <em>reversed_</em> is true then the array will be stored in the reverse order of dimensions (see <a class="el" href="group__array__advanced.html#array_storage">Array Storage</a>).</p>
<p>For example the following, declares a column-major square matrix of variable size with an internal buffer of 1024 elements:</p>
<div class="fragment"><pre class="fragment">        <span class="keywordtype">int</span> n;
        std::cin &gt;&gt; n;
        array&lt;float[1][1], default_array_traits, hybrid_rep&lt;true, 1024&gt; &gt; a(n ,n);
</pre></div><p>In the above example, the array will be stored in the internal buffer if (n &lt;= 32).</p>
<h3><a class="anchor" id="array_reference">
Reference Representation</a></h3>
<p>The reference representation is specified by specifying <a class="el" href="classlite_1_1reference__rep.html" title="This is a tag type that can be used to specify reference representation for an array...">lite::reference_rep</a> as the representation tag of the <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">lite::array</a>. It has the following declaration: </p>
<div class="fragment"><pre class="fragment">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator_type_&gt;
        <span class="keyword">class </span>reference_rep;
</pre></div><p>The array object will contain only an iterator of type <em>iterator_type_</em> and a size object of the type appropriate for the array signature. The <em>iterator_type_</em> should satisfy the requirements of a muti-dimensional iterator (see <a class="el" href="group__array__advanced.html#array_iterators">Multi-Dimensional Iterators</a>).</p>
<p>Note that the specialization of class <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">lite::array</a> for this representation provides an almost totally different set of constructors (See <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">lite::array</a> for details).</p>
<p>For an array with this representation, all typedef that stat with <code>const_</code> are exactly the same as those without it. Also all the member functions and operators are declared const. Furthermore, An array with this representation must always be declared as const when used as a return type.</p>
<p>For example the following, declares a reference array to another array:</p>
<div class="fragment"><pre class="fragment">        <span class="keyword">typedef</span> array&lt;float[5][5]&gt; A;
        <span class="keyword">typedef</span> array&lt;float[5][5], default_array_traits, reference_rep&lt;A::iterator&gt; &gt; A_Ref;

        A a;
        A_Ref a_ref = a;

        a_ref(2,3) = 5;     <span class="comment">// a_ref can be used as an alias for a</span>
        <span class="comment">// the previous line is equivalent to:</span>
        a(2,3) = 5;
</pre></div><h2><a class="anchor" id="array_storage">
Array Storage</a></h2>
<p>There are two storage types that can be specified for internal and hybrid representations:</p>
<ul>
<li><b>Forward Storage:</b> This is the default type in which consecutive elements of the last dimension are adjacent in memory and then the dimension before it and so on. This is the generalization of row major storage and is what is used by the C/C++ by default.</li>
<li><b>Reverse Storage:</b> With this storage, consecutive elements of the first dimension are adjacent in memory and then the second dimension and so on. This is the generalization of column major storage and is what is used in Fortran by default.</li>
</ul>
<p>For example the following, declares a column-major 5 by 5 matrix:</p>
<div class="fragment"><pre class="fragment">        array&lt;float[5][5], default_array_traits, internal_rep&lt;true&gt; &gt; a;
</pre></div><h2><a class="anchor" id="array_temporary">
Temporary Arrays</a></h2>
<p>There are times that you need to make a copy of another array for temporary use in a function or return a temporary array object from a function. In those cases, it is better to use an array type that is more appropriate for temporary storage to improve performance.</p>
<p>A temporary array type that uses the <a class="el" href="group__array__advanced.html#array_hybrid">Hybrid Representation</a>, usually has a much larger internal buffer so as to avoid allocation/deallocation of memory from heap. For any array type, compatible temporary array types are available as member typedefs as shown in the following example. The following example shows a function that computes the inverse of a matrix using Gauss-Jordan elimination:</p>
<div class="fragment"><pre class="fragment"><span class="comment">// compute the inverse of matrix a</span>
<span class="keyword">template</span>&lt;<span class="keyword">typename</span> value_type_, <span class="keywordtype">int</span> n_, <span class="keyword">typename</span> traits_type_, <span class="keyword">typename</span> rep_&gt;
<span class="keyword">const</span> array&lt;value_type_[n_][n_], traits_type_&gt;::temporary_array
inverse(<span class="keyword">const</span> array&lt;value_type_[n_][n_], traits_type_, rep_&gt;&amp; a)
{
    <span class="keyword">using</span> std::abs;

    <span class="keyword">typedef</span> array&lt;value_type_[n_][n_], traits_type_, rep_&gt; a_type;
    <span class="keyword">typedef</span> <span class="keyword">typename</span> a_type::temporary_array temporary_type;

    <span class="keyword">const</span> <span class="keywordtype">int</span> n = a.size().i0;
    temporary_type result(a.size());
    temporary_type aa =a;

    result = value_type_();

    result[diagonal()] = value_type_(1);

    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; i++) {
        <span class="keyword">const</span> block&lt;0,1&gt; blk(0, n-i);
        <span class="keywordtype">int</span> i_max = i;
        value_type_ val_max = abs(aa(i, i));

        <span class="comment">// find the strongest row</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i2 = i+1; i2&lt;n; i2++)
            <span class="keywordflow">if</span> (abs(aa(i2, i)) &gt; val_max) {
                i_max = i2;
                val_max = abs(aa(i2, i));
            }

        <span class="comment">// swap row i_max with row i</span>
        <span class="keywordflow">if</span> (i_max != i) {
            <span class="keyword">typename</span> transform_traits&lt;temporary_type, row&gt;::temporary_array res_tmp;

            res_tmp = result[<a class="code" href="group__array__transforms.html#gac13d5a020f69071131362062cbb527cb" title="This transform, when applied to an array of dimension N, returns a reference array...">row</a>(i)];
            result[<a class="code" href="group__array__transforms.html#gac13d5a020f69071131362062cbb527cb" title="This transform, when applied to an array of dimension N, returns a reference array...">row</a>(i)] = result[<a class="code" href="group__array__transforms.html#gac13d5a020f69071131362062cbb527cb" title="This transform, when applied to an array of dimension N, returns a reference array...">row</a>(i_max)];
            result[<a class="code" href="group__array__transforms.html#gac13d5a020f69071131362062cbb527cb" title="This transform, when applied to an array of dimension N, returns a reference array...">row</a>(i_max)] = res_tmp; 

            <span class="keyword">typename</span> transform_traits&lt;temporary_type, block&lt;0,1&gt; &gt;::temporary_array org_tmp;
                
            org_tmp = aa[blk(i,i)];
            aa[blk(i,i)] = aa[blk(i_max, i)];
            aa[blk(i_max,i)] = org_tmp; 
        }

        <span class="comment">// if a singular matrix return a zero matrix</span>
        <span class="keywordflow">if</span> (aa(i, i) == value_type_()) {
            result = value_type_();
            <span class="keywordflow">break</span>;
        }

        <span class="comment">// normalize the row</span>
        value_type_ factor = value_type_(1)/aa(i, i);

        result[<a class="code" href="group__array__transforms.html#gac13d5a020f69071131362062cbb527cb" title="This transform, when applied to an array of dimension N, returns a reference array...">row</a>(i)] *= factor;
        aa[blk(i, i)] *= factor;

        value_type_ epsilon = std::numeric_limits&lt;value_type_&gt;::epsilon()*aa(i, i)*n;

        <span class="comment">// simplify the column in the lower triangle</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i2 = i+1; i2&lt;n; i2++) 
            <span class="keywordflow">if</span> (abs(aa(i2, i)) &gt; epsilon) {
                result[<a class="code" href="group__array__transforms.html#gac13d5a020f69071131362062cbb527cb" title="This transform, when applied to an array of dimension N, returns a reference array...">row</a>(i2)] -= aa(i2, i)*result[<a class="code" href="group__array__transforms.html#gac13d5a020f69071131362062cbb527cb" title="This transform, when applied to an array of dimension N, returns a reference array...">row</a>(i)];
                aa[blk(i2,i)] -= aa(i2, i)*aa[blk(i,i)];
            }
    }

    <span class="comment">// simplify the upper triangle</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = n-1; i&gt;=0; i--) {
        value_type_ epsilon = std::numeric_limits&lt;value_type_&gt;::epsilon()*aa(i, i)*n;

        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i2 = 0; i2&lt;i; i2++) 
            <span class="keywordflow">if</span> (abs(aa(i2, i)) &gt; epsilon) 
                <span class="comment">// we don&apos;t need to update the original here as it won&apos;t be used any more!</span>
                result[<a class="code" href="group__array__transforms.html#gac13d5a020f69071131362062cbb527cb" title="This transform, when applied to an array of dimension N, returns a reference array...">row</a>(i2)] -= aa(i2, i)*result[<a class="code" href="group__array__transforms.html#gac13d5a020f69071131362062cbb527cb" title="This transform, when applied to an array of dimension N, returns a reference array...">row</a>(i)];
    }

    <span class="keywordflow">return</span> result;
}
</pre></div><h2><a class="anchor" id="array_traits">
Array Traits</a></h2>
<p>The second template parameter of the class <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">lite::array</a> specifies a traits type: </p>
<div class="fragment"><pre class="fragment">        <span class="keyword">template</span>&lt;
            <span class="keyword">typename</span> signature_, 
            <span class="keyword">typename</span> traits_type_ = default_array_traits, 
            <span class="keyword">typename</span> rep_ = <span class="keyword">typename</span> traits_type_::template representation_type&lt;signature_&gt;::type&gt;
        <span class="keyword">class </span>array;
</pre></div><p>The primary purpose of a traits class is to choose the proper array representation based on the array signature. It can be also use to specify other user-defined policies.</p>
<p>An array traits type should provide the following interface: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">struct </span>some_array_traits
{
    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> signature_&gt;
    <span class="keyword">struct </span>representation_type
    {
        <span class="comment">// This is the default representation to be used for arrays</span>
        <span class="keyword">typedef</span> ??? type;

        <span class="comment">// This is the default representation to be used for temporary arrays</span>
        <span class="keyword">typedef</span> ??? temporary_type;

        <span class="comment">// This is the default representation to be used for temporary arrays with forward storage</span>
        <span class="keyword">typedef</span> ??? fwd_temporary_type;

        <span class="comment">// This is the default representation to be used for temporary arrays with reverse storage</span>
        <span class="keyword">typedef</span> ??? rev_temporary_type;
    };
};
</pre></div><p>The <a class="el" href="structlite_1_1default__array__traits.html" title="This is the default array traits type used by the class lite::array.See Array Traits...">lite::default_array_traits</a> is the only pre-defined array traits type.</p>
<h2><a class="anchor" id="array_iterators">
Multi-Dimensional Iterators</a></h2>
<p>A multi-dimensional iterator is an iterator that can move along more than one dimension. A multidimensional array can be fully represented by a multidimensional iterator pointing to the start of the array and a size object specifying the size of the array along each dimension. the lite:array::begin() returns a multidimensional iterator pointing to the start of the array. All multidimensional iterators should provide the following operations (assume <code>Iter</code> is a multidimensional iterator type):</p>
<div class="fragment"><pre class="fragment">    <span class="comment">// Index through the iterator \a it using the indices \a i0 to \a iN.</span>
    std::iterator_traits&lt;Iter&gt;::reference at(Iter it, <span class="keywordtype">int</span> i0 ..., <span class="keywordtype">int</span> iM);

    <span class="comment">// Increment the iterator \a it along dimension \a dim_ by one position.</span>
    <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim_&gt;
    <span class="keywordtype">void</span> inc(Iter it);

    <span class="comment">// Decrement the iterator \a it along dimension \a dim_ by one position.</span>
    <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim_&gt;
    <span class="keywordtype">void</span> dec(Iter it);

    <span class="comment">// Move the iterator \a it along dimension \a dim_ by \a diff positions.</span>
    <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim_&gt;
    <span class="keywordtype">void</span> shift(Iter it, <span class="keywordtype">int</span> diff);
</pre></div><p>In addition to the above operations, the class std::iterator_traits should be specialized to provide correct typedefs just like a stl style iterator.</p>
<p>Note that the <code>at()</code> function may take any number of indices from 0 to N where N is the number of dimensions of the iterator <em>it</em>. If M indices are provides such that (M &lt; N) then then the provided indices will be used for the last M dimensions and for the first N-M dimensions an index of 0 will be assumed. For example:</p>
<div class="fragment"><pre class="fragment">        <span class="keyword">typedef</span> array&lt;float[5][6][7]&gt; A;
        A a;

        A::iterator it = a.begin();

        at(it, 5) = -1;                     <span class="comment">// set a(0,0,5) to -1</span>
        at(it, 0, 5) = -1;                  <span class="comment">// set a(0,0,5) to -1</span>
        at(it, 0, 0, 5) = -1;               <span class="comment">// set a(0,0,5) to -1</span>
        
        inc&lt;2&gt;(it);
        at(it) = -1;                        <span class="comment">// set a(0,0,1) to -1</span>

        shift&lt;1&gt;(it, 3);
        at(it, 1, 0, 0) = -1;               <span class="comment">// set a(1,3,1) to -1</span>

        shift&lt;1&gt;(it, -2);                   
        at(it, -1) = -1;                     <span class="comment">// set a(0,1,0) to -1</span>
</pre></div><p>Note that any iterator used by any <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">lite::array</a> object should satisfy all the requirements of a multidimensional iterator. For example:</p>
<div class="fragment"><pre class="fragment">        <span class="keyword">typedef</span> array&lt;float[5][6]&gt; A;
        A a, b, c;

        std::cout &lt;&lt; at((2*a+b+c).begin(), 0, 1);
        <span class="comment">// is equivalent to:</span>
        std::cout &lt;&lt; 2*a(0,1)+b(0,1)+c(0,1);

        std::cout &lt;&lt; at(a[<a class="code" href="group__array__transforms.html#gac13d5a020f69071131362062cbb527cb" title="This transform, when applied to an array of dimension N, returns a reference array...">row</a>(1)].begin(), 0, 1);
        <span class="comment">// is equivalent to:</span>
        std::cout &lt;&lt; a(1, 1);
</pre></div><p>The following multidimensional iterator types are provided by the library:</p>
<ul>
<li><b>s_iterator</b> see <a class="el" href="classlite_1_1s__iterator.html" title="An s_iterator is used to represent a general multidimensional strided iterator using...">lite::s_iterator</a></li>
<li><b>c_iterator</b> see <a class="el" href="classlite_1_1c__iterator.html" title="This class implements an iterator that returns the same value everywhere.">lite::c_iterator</a></li>
<li><b>u_iterator</b> see <a class="el" href="classlite_1_1u__iterator.html" title="This class implements an iterator that returns the result of applying a function...">lite::u_iterator</a></li>
<li><b>b_iterator</b> see <a class="el" href="classlite_1_1b__iterator.html" title="This class implements an iterator that returns the result of applying a binary function...">lite::b_iterator</a></li>
</ul>
<p>You can define your own iterator type by implementing the requirement of a generalized iterator. Most of the array operations use the above iterator types with appropriate function objects to achieve their functionality.</p>
<h2><a class="anchor" id="array_transforms_advanced">
Defining New Transforms</a></h2>
<p>In order to define a new transform, you need to implement the specialization of the following two types for your transform type:</p>
<ul>
<li><a class="el" href="structlite_1_1size__transformer.html" title="This can be used to apply a transform object of type transform_type_ to a size object...">lite::size_transformer</a> : This is used to apply a transform object to a size object</li>
<li><a class="el" href="structlite_1_1iterator__transformer.html" title="This can be used to apply a transform object of type transform_type_ to a pair of...">lite::iterator_transformer</a> : This is used to apply a transform object to an iterator object</li>
</ul>
<p>Together, the above two transformers are used to apply a transform object to an array object. The transform is applied to the iterator and the size of the original array and then a new reference array is created from the resulting iterator and resulting size. The resulting array uses the <a class="el" href="group__array__advanced.html#array_reference">Reference Representation</a>.</p>
<p>The following pseudo definitions specify the interface that each of the two transformers should implement:</p>
<div class="fragment"><pre class="fragment">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_, <span class="keyword">typename</span> input_<span class="keywordtype">size_t</span>ype_&gt;
        <span class="keyword">struct </span>size_transformer
        {
        <span class="keyword">public</span>:
            <span class="comment">// The type of the resulting size object after applying the transform</span>
            <span class="keyword">typedef</span> ??? size_type;

            <span class="comment">// Apply the transform to the size object org and store the result in res.</span>
            <span class="keyword">static</span> <span class="keywordtype">void</span> transform(<span class="keyword">const</span> input_size_type_&amp; org, size_type&amp; res);

            <span class="comment">// Apply the transform object trans to the size object org and store the result in res.</span>
            <span class="keyword">static</span> <span class="keywordtype">void</span> transform(<span class="keyword">const</span> transform_type&amp; trans, <span class="keyword">const</span> input_size_type_&amp; org, size_type&amp; res);
        };

        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> transform_type_, <span class="keyword">typename</span> input_iterator_type_, <span class="keyword">typename</span> input_<span class="keywordtype">size_t</span>ype_&gt;
        <span class="keyword">struct </span>iterator_transformer
        {
        <span class="keyword">public</span>:
            <span class="comment">// The type of the resulting iterator object after applying the transform</span>
            <span class="keyword">typedef</span> ??? iterator_type;

            <span class="comment">// Apply the transform to the iterator object org and store the result in res.</span>
            <span class="keyword">static</span> <span class="keywordtype">void</span> transform(
                <span class="keyword">const</span> input_iterator_type&amp; org, 
                iterator_type&amp; res);

            <span class="comment">// Apply the transform object trans to the iterator object org and store the result in res.</span>
            <span class="keyword">static</span> <span class="keywordtype">void</span> transform(
                <span class="keyword">const</span> transform_type_&amp; trans, 
                <span class="keyword">const</span> input_iterator_type&amp; org, 
                iterator_type&amp; res);

            <span class="comment">// Apply the transform object trans to the iterator object org that is used together with </span>
            <span class="comment">// size object sz and store the result in res.</span>
            <span class="keyword">static</span> <span class="keywordtype">void</span> transform(
                <span class="keyword">const</span> transform_type_&amp; trans, 
                <span class="keyword">const</span> input_iterator_type&amp; org, 
                <span class="keyword">const</span> input_size_type_&amp; sz,
                iterator_type&amp; res);
        };
</pre></div><p>In order to define a new transform, in addition to defining a type for your transform objects, you need to specialize and implement the <a class="el" href="structlite_1_1size__transformer.html" title="This can be used to apply a transform object of type transform_type_ to a size object...">lite::size_transformer</a> and <a class="el" href="structlite_1_1iterator__transformer.html" title="This can be used to apply a transform object of type transform_type_ to a pair of...">lite::iterator_transformer</a> for you new transform type. For <a class="el" href="classlite_1_1c__iterator.html" title="This class implements an iterator that returns the same value everywhere.">lite::c_iterator</a>, <a class="el" href="classlite_1_1u__iterator.html" title="This class implements an iterator that returns the result of applying a function...">lite::u_iterator</a> and <a class="el" href="classlite_1_1b__iterator.html" title="This class implements an iterator that returns the result of applying a binary function...">lite::b_iterator</a>, there are already specializations in place that do the following by default:</p>
<ul>
<li>For <a class="el" href="classlite_1_1c__iterator.html" title="This class implements an iterator that returns the same value everywhere.">lite::c_iterator</a>, the default transformer does nothing and returns the same iterator</li>
<li>For <a class="el" href="classlite_1_1u__iterator.html" title="This class implements an iterator that returns the result of applying a function...">lite::u_iterator</a>, the default transformer applies the transform object to the base iterator and creates a new <a class="el" href="classlite_1_1u__iterator.html" title="This class implements an iterator that returns the result of applying a function...">lite::u_iterator</a> using the transformed base iterator and the same function object.</li>
<li>For <a class="el" href="classlite_1_1b__iterator.html" title="This class implements an iterator that returns the result of applying a binary function...">lite::b_iterator</a>, the default transformer applies the transform object to the both of the left and right base iterators and then creates a new <a class="el" href="classlite_1_1b__iterator.html" title="This class implements an iterator that returns the result of applying a binary function...">lite::b_iterator</a> using the transformed base iterators and the same function object.</li>
</ul>
<p>Therefore, if the above default behavior works well for your transform type (which is usually the case), you only need to define an iterator transformer for <a class="el" href="classlite_1_1s__iterator.html" title="An s_iterator is used to represent a general multidimensional strided iterator using...">lite::s_iterator</a>.</p>
<p>The following example shows the details of how a transform object is applied to an array:</p>
<div class="fragment"><pre class="fragment">        <span class="keywordtype">int</span> n;

        std::cin &gt;&gt; n;

        <span class="keyword">typedef</span> array&lt;float[1][1]&gt; A;

        A a(n, n);

        transform_traits&lt;A, row&gt;::array a_row_ref1 = a[<a class="code" href="group__array__transforms.html#gac13d5a020f69071131362062cbb527cb" title="This transform, when applied to an array of dimension N, returns a reference array...">row</a>(1)]; 

        <span class="comment">// the previous line is equivalent to the following code:</span>

        <span class="keyword">typedef</span> size_transformer&lt;row, A::size_type&gt; ST; 
        <span class="keyword">typedef</span> iterator_transformer&lt;row, A::iterator, A::size_type&gt; IT;

        ST::size_type sz;
        IT:iterator_type it;
        <a class="code" href="group__array__transforms.html#gac13d5a020f69071131362062cbb527cb" title="This transform, when applied to an array of dimension N, returns a reference array...">row</a> r(1);

        ST::transform(r, a.size(), sz);
        IT::transform(r, a.begin(), it);

        <span class="keyword">typedef</span> lite::detail::size_to_signature&lt;ST::size_type, std::iterator_traits&lt;A::iterator&gt;::value_type&gt;::type Sig;

        array&lt;Sig, A::traits_type, reference_rep&lt;IT::iterator_type&gt; &gt; a_row_ref2(it, sz);
</pre></div><p>The specialization of class <a class="el" href="classlite_1_1array.html" title="This class represents a general sinlge/multidimensional array with constant/variable...">lite::array</a> for <a class="el" href="classlite_1_1reference__rep.html" title="This is a tag type that can be used to specify reference representation for an array...">lite::reference_rep</a> has a special constructor that can be used to simplify the above code:</p>
<div class="fragment"><pre class="fragment">        <span class="keywordtype">int</span> n;

        std::cin &gt;&gt; n;

        <span class="keyword">typedef</span> array&lt;float[1][1]&gt; A;

        A a(n, n);

        transform_traits&lt;A, row&gt;::array a_row_ref1 = a[<a class="code" href="group__array__transforms.html#gac13d5a020f69071131362062cbb527cb" title="This transform, when applied to an array of dimension N, returns a reference array...">row</a>(1)]; 

        <span class="comment">// the previous line is equivalent to the following code:</span>

        <span class="keyword">typedef</span> size_transformer&lt;row, A::size_type&gt; ST; 
        <span class="keyword">typedef</span> iterator_transformer&lt;row, A::iterator, A::size_type&gt; IT;
        <span class="keyword">typedef</span> lite::detail::size_to_signature&lt;ST::size_type, std::iterator_traits&lt;IT&gt;::value_type&gt;::type Sig;

        array&lt;Sig, A::traits_type, reference_rep&lt;IT::iterator_type&gt; &gt; a_row_ref2(a.begin(), a.size(), <a class="code" href="group__array__transforms.html#gac13d5a020f69071131362062cbb527cb" title="This transform, when applied to an array of dimension N, returns a reference array...">row</a>(1));
</pre></div><p>Note that you do not need to specialize and implement the <a class="el" href="structlite_1_1transform__traits.html" title="This class provides information about applying a transform object to an array object...">lite::transform_traits</a> as it uses a generic definition that depends on <a class="el" href="structlite_1_1size__transformer.html" title="This can be used to apply a transform object of type transform_type_ to a size object...">lite::size_transformer</a> and <a class="el" href="structlite_1_1iterator__transformer.html" title="This can be used to apply a transform object of type transform_type_ to a pair of...">lite::iterator_transformer</a>.</p>
<h2><a class="anchor" id="array_lazy">
Lazy Evaluation</a></h2>
<p>Many of the array operations do not actually compute their result but instead return a reference array that computes the result on demand (lazy evaluation). The resulting reference array uses a combination of <a class="el" href="classlite_1_1c__iterator.html" title="This class implements an iterator that returns the same value everywhere.">lite::c_iterator</a>, <a class="el" href="classlite_1_1u__iterator.html" title="This class implements an iterator that returns the result of applying a function...">lite::u_iterator</a> or <a class="el" href="classlite_1_1b__iterator.html" title="This class implements an iterator that returns the result of applying a binary function...">lite::b_iterator</a> and a function object.</p>
<p>You can use the lite::apply() (See the example in <a class="el" href="group__array__operations.html">Array Operations</a>) to create a reference array that applies a function object to one or two other arrays.</p>
<p>Most of the array operations that actually compute their result use the <a class="el" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">lite::for_each()</a> or <a class="el" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">lite::for_each_c()</a>.</p>
<h2><a class="anchor" id="array_operations_advanced">
Array Operations and Evaluation</a></h2>
<p>The <a class="el" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">lite::for_each()</a> and <a class="el" href="group__array__advanced.html#gaa06fb495ed4b4707d300252b466de9e7" title="Evaluates every element of the array pointed by iter and of size size while the elements...">lite::for_each_c()</a> family of functions lie at the heart of the library. Almost all array operations are eventually performed by a call to one of the overloads of these two functions. The for_each functions are heavily specialized/optimized to unroll loops with fixed/variable number of iterations.</p>
<p>For example, consider the following function:</p>
<div class="fragment"><pre class="fragment">        <span class="keywordtype">void</span> foo(<span class="keywordtype">int</span> n)
        {
            <span class="keyword">const</span> <span class="keywordtype">int</span> max_m = 2048;
            <span class="keyword">const</span> <span class="keywordtype">float</span> c = 3;

            <span class="keyword">typedef</span> array&lt;float[3]&gt; Vec;

            Vec v1[max_m], v2[max_m];

            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;max_m; i++) {
                init(v1[i]);
                init(v2[i]);
            }

            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; i++)
                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;n; k++)
                    v1[k] = v2[k]+c*v2[k+1];

            std::cout &lt;&lt; v1[0]; &lt;&lt; std::endl;   <span class="comment">// to prevent dead code elimination</span>
        }
</pre></div><p> The <a class="el" href="group__array__advanced.html#ga45b68d7034f660180513afeceae1e6a5" title="Evaluates every element of the array pointed by iter and of size size.">lite::for_each()</a> function is called by the assignment operator to evaluate the array expression and to store the result in <code>v1[k]</code>. The following is the assembly code generated for the the inner loop by MSVC++ 2009: </p>
<div class="fragment"><pre class="fragment">
        00401ECB  cmp         edx,esi 
        00401ECD  jge         code_gen+1A4h (401F14h) 
        00401ECF  lea         eax,[edx+edx*2] 
        00401ED2  add         eax,eax 
        00401ED4  mov         ecx,esi 
        00401ED6  add         eax,eax 
        00401ED8  sub         ecx,edx 
        00401EDA  fld         dword ptr [esp+eax+14h] 
        00401EDE  add         eax,0Ch 
        00401EE1  sub         ecx,1 
        00401EE4  fmul        st,st(1) 
        00401EE6  fadd        dword ptr [esp+eax-4] 
        00401EEA  fstp        dword ptr [esp+eax+5FFCh] 
        00401EF1  fld         dword ptr [esp+eax+0Ch] 
        00401EF5  fmul        st,st(1) 
        00401EF7  fadd        dword ptr [esp+eax] 
        00401EFA  fstp        dword ptr [esp+eax+6000h] 
        00401F01  fld         dword ptr [esp+eax+10h] 
        00401F05  fmul        st,st(1) 
        00401F07  fadd        dword ptr [esp+eax+4] 
        00401F0B  fstp        dword ptr [esp+eax+6004h] 
        00401F12  jne         code_gen+16Ah (401EDAh) 
    </pre></div><p>As you can see, the whole expression <code>v1[k] = v2[k]+c*v2[k+1]</code> has been fully inlined and optimized. The above assembly code is almost identical to the assembly code generated for a hand written function that does not use the array library.</p>
<p>A few of the functions like the 2D and 3D version of the lite::det() and lite::inverse() are implemented explicitly to ensure optimal performance.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd><p class="startdd">performance and forward/reverse storage </p>
<p>performance notes, code samples, etc. </p>
<p class="enddd">function objects? </p>
</dd></dl>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on Fri Nov 6 02:03:21 2009 for Lite by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.0 </small></address>
</body>
</html>
