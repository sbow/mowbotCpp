/***********************************************************************************************************
    array.hpp
    Copyright Saeed Alaei 2007-2009.
    Version : 3.505
    Generated on: Fri Nov 06 02:03:07 2009

    Warning: This file is generated. If you need to make a change, modify the template.
    To generate the documentation, run Doxygen on this file.

    Permission is hereby granted, free of charge, to any person or organization
    obtaining a copy of the software and accompanying documentation covered by
    this license (the "Software") to use, reproduce, display, distribute,
    execute, and transmit the Software, and to prepare derivative works of the
    Software, and to permit third-parties to whom the Software is furnished to
    do so, all subject to the following:

    The copyright notices in the Software and this entire statement, including
    the above license grant, this restriction and the following disclaimer,
    must be included in all copies of the Software, in whole or in part, and
    all derivative works of the Software, unless such copies or derivative
    works are solely in the form of machine-executable object code generated by
    a source language processor.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
    SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
    FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
    ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.

    Trivia: 
    This whole file was written from scratch from 9/4/2009 to 9/10/2009 excluding the documentation.
***********************************************************************************************************/

/* 
FUTURE TODO:
    - (high) add the dimension selection for for_each functions 
    - (medium) add resize error checking
    - (very low) add xformat formating
    - (very low) do something about internal_rep with variable length abuse!
    - (very low) elaborate the default_array_traits
    - (very low) add stl style vector operations.
    - (very low) add specialized operations for 0-dimension arrays.
*/

/*!
    \ifnot COMMON
	\mainpage Lite array

	See \ref array.

    \author Saeed Alaei 
    <a href="http://www.google.com/search?hl=en&q=saeed+alaei&btnI=I'm+Feeling+Lucky">(home page)</a>

    \par Copyright
	Permission is hereby granted, free of charge, to any person or organization
	obtaining a copy of the software and accompanying documentation covered by
	this license (the "Software") to use, reproduce, display, distribute,
	execute, and transmit the Software, and to prepare derivative works of the
	Software, and to permit third-parties to whom the Software is furnished to
	do so, all subject to the following:
	
    \par
	The copyright notices in the Software and this entire statement, including
	the above license grant, this restriction and the following disclaimer,
	must be included in all copies of the Software, in whole or in part, and
	all derivative works of the Software, unless such copies or derivative
	works are solely in the form of machine-executable object code generated by
	a source language processor.

	\par
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
	SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
	FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
	ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
	DEALINGS IN THE SOFTWARE.

    \endif
*/

/*! 
	\file array.hpp
	\defgroup array lite array - A C++ Multidimensional Array Library

	This is a header only library that provides support for fixed/variable size single and multidimensional 
    arrays. It provides specialized functions for small and large vectors and matrices and general arrays 
    through a unified interface and intuitive syntax. 
    
    \section array_rational Design Rationale
	The following are the design goals for the array library:
    - The specializations for small/large vectors and matrices should provide all the necessary functionality
        for mathematical programming.
    - The syntax should be intuitive and should be what one would expect.
    - The library should add zero or minimal overhead and optimize for performance.
    - It should be general enough and fully extensible. It should provide different layers of 
        abstraction and allow for future extensions. 
        If it lacks a feature, it should provide the right framework necessary to
        implement that feature as a seamless user extension or as a future addition to the library.

    \section array_tutorial Tutorial
    An array of fixed size can be declared by providing the signature of the array as the template argument of
    the class lite::array. For example:
    
    \code
    array<float[10][10]> a;

    for (int i=0; i<10; i++)
        for (int j=0; j<10; j++)
            m(i, j) = i+j;

    std::cout << m << std::endl;
    \endcode
    
    For arrays with non-constant dimension sizes, one can specify 1 as the size of the dimension 
    with non-constant size. For example:
    
    \code
    int n;
    std:::cin >> n;
    array<float[1][4][4]> a(n, 4, 4);
    std::cin >> a; // read the array from std::cin
    \endcode

    Most of the mathematical operations that make sense for arrays are also defined. For example:

    \code
    array<float[5][10][10]> a, b, c; 
    
    // ...
    
    c += 1.5*a + 3*b + 1;
    \endcode

    Matrix and vector operations are defined for 1 and 2 dimensional arrays. 
    Specialized operations are also provided for arrays and vector of length 2 and 3 
    (i.e. 2d and 3d geometric operations).

    \code
    array<float[3][3]> m; 
    array<float[3]> v1, v2; 
    
    // ...

    v2 += m*v1 + v2+ 1.5;       // matrix-vector multiplication
    m = m*m;                    // matrix-matrix multiplication
    m = inverse(m);             // matrix inverse
    float d = det(m);           // matrix determinant
    m = rotation(v2, 3.14);     // rotation matrix of 180 degrees around v2
    v1 = m*v1;                  // rotate v1
    v3 = v1%v2;                 // compute the cross product of v1 and v2
    float inner = v1*v2;        // inner product
    // etc ...
    \endcode

    A rich set of transformations are also provided along with an extensible framework to add 
    new types of transformations. For example:

    \code
    array<float[10][10][10]> a; 
    array<float[10][10]> m1, m2, m3; 
    array<float[5]> v1; 
    
    // ...

    for (int i=0; i<10; i++)
        for (int j=0; j<10; j++)
            m3(i, j) = m1[row(i)]*m2[column(j)];
    
    m2[transpose()] = m3;
    m1 = 0;
    m1[diagonal()] += 1;        // add 1 to the diagonal of m1 
    a[row(2)] += 4*a[row(3)]+1; // add 4 times the row 3 plus 1 to row 2. Each row is actually a 10x10 array.
    a[row(2)] += (4*a+1)[row(3)]; // this is as efficient as the previous line due to to lazy evaluation.

    block<5,0,0> blk;           // specifies a vector of size 5 along the first dimension 
                                // while dropping the other two dimensions
    a[blk(2,3,4)] += v1;        // the block will start at index (2,3,4). 
                                // The result of the left hand side is a reference vector of size 5.
    int k;
    std::cin >> k;
    block<0,1,1> blk(0,k,k);    // specifies a k by k matrix on the 2nd and 3rd dimensions
                                // while dropping the first dimension
    a[blk(2,2,2)][diagonal()] += 1; // adds 1 to the diagonal of the k by k matrix at index (2,2,2) after 
                                    // dropping the first dimension
    \endcode

    The library uses lazy evaluation where feasible. For example the expression 1.5*a+3*b+1 does 
    not evaluate the result by itself. It, however, returns a reference array such that when it is 
    evaluated at any point it will evaluate the result at that point on demand. The library is aware of the 
    evaluation costs and will use a temporary array to make copies of its arguments when doing so will 
    improve the performance. For example:
    \code
    int n;
    std::cin >> n;
    array<float[1][1]> m1(n,n), m2(n,n), m3(n,n); 
    array<float[1]> v1(n), v2(n); 
    
    // ...

    m3 = m1*m2;                 // m1 is used directly but m2 is copied to a local column-major matrix
                                // to utilize cache (m2 is row-major)
    m3 = m1*m2[transpose()];    // m1 is row major and m2 column major so they are used directly.
    m3 = (2*m1+1)*m2;           // (2*m1+1) is fully evaluated first.
    m3 = (2*m1+1)*m2[column(0)];// (2*m1+1) is evaluated lazily on demand but m2[column(1)] 
                                // is fully evaluated and cached because its elements are not adjacent 
                                // in memory and may not utilize cache well.
    v1 = (2*v21+1)*m2[column(0)];// no local copy is made. Both arguments of * are evaluated lazily on demand.
    \endcode
    It is also aware of the storage order of the element of the arrays involved in an expression. 
    It tries to evaluate the expressions in the order that maximizes CPU cache utilization.

    The library is heavily specialized and optimized to take advantage of fixed sizes and compile 
    time information and adds zero or minimal overhead. For example an object of type array<int[2]> 
    contains only a fixed size array of size 2. In other words, sizeof(array<int[2]>)==sizeof(int[2]). 
    So, it is a light weight object that for example can be used to represent a coordinate in a 2D space. 
    The library takes advantage of the fixed sizes also to unroll the loops whenever possible using 
    meta-template technics. 
    The library has been designed to aid the compiler in optimization as much as possible. 
    The performance of the code produced by this library using a good optimizing compiler (e.g. MSVC++ 8)
    is the same as the performance of an optimized handwritten code using primitive arrays. 
    See \ref array_performance for more information.

    \section array_inro Introduction
    A general multi-dimensional array can be represented by a multi-dimensional random access iterator 
    pointing to the start of the array and a size tuple specifying how much the array extends along
    each dimension. The random access iterator should be capable of moving freely in every dimension. 

    In order to use the library effectively, it is helpful to have an understanding of the internal 
    representation of arrays. 

    The rest of the introduction is organized 
    as follows:

    - \ref array_class
    - \ref array_operations
    - \ref array_transforms

    In order to use the library effectively, it is helpful to have an understanding of the internal 
    representation of arrays. The following section provide a brief introduction to the internals 
    of the library:

    - \ref array_advanced 

    In order to change the limits of the library (e.g. to increase the maximum number 
    of dimensions supported, etc) and/or to regenerate the header file from the template file, 
    you should read the following section: 
    
    - \ref array_misc

    To get more information on the performance of this library and various kinds of optimization that are
    incorporated see the following section:

	- \ref array_performance 
*/

/*!
	\defgroup array_class Array Class
	\ingroup array
    
    You can use the lite::array class to represent a general sinlge/multidimensional array 
    with constant/variable size dimensions. The array elements could be of any type that has an appropriate
    default constructor and an assignment operator. 

    The lite::array class provides several specializations. 
    The following pseudo definition explains the (almost) common interface of all the specializations. 
    There are other features specific to some of the specializations 
    that are not included below but are explained in lite::array.

    \code
template<
    typename signature_, 
    typename traits_type_ = default_array_traits, 
    typename rep_ = typename traits_type_::template representation_type<signature_>::type>
class array<signature_, traits_type_, rep_>
{
public:
    typedef signature_ signature;
    typedef traits_type_ traits_type; 
    typedef ??? value_type;
    typedef ??? iterator;
    typedef ??? size_type;
    typedef ??? const_iterator;
    typedef ??? reference;
    typedef ??? const_reference;

    typedef ??? temporary_array; 
    typedef ??? fwd_temporary_array; 
    typedef ??? rev_temporary_array;

    static const int dimensions = ???; 

    array();

    array(const array& other);

    // constructs an array by copying from other
    template<typename other_rep_>
    array(const array<signature_, traits_type_, other_rep_>& other);

    // constructs an array with the given dimension sizes
    explicit array(int n0, ..., int nN);

    // constructs an array with the given size
    explicit array(const size_type& size);

    // constructs an array using the provided values
    array(const value_type& a0, ..., const value_type& aT);

    array& operator=(const array& other);

    template<typename other_rep_>
    array& operator=(const array<signature_, traits_type_, other_rep_>& other);

    const_iterator begin() const;

    iterator begin();

    size_type size() const;

    const_reference operator()(int i0, ..., int iN) const;

    reference operator()(int i0, ..., int iN);

    const_reference operator[](int i0) const;

    reference operator[](int i0);

    template<typename transform_type_>
    const typename transform_traits<array, transform_type_>::const_array
    operator[](const transform_type_& trans) const;

    template<typename transform_type_>
    const typename transform_traits<array, transform_type_>::array
    operator[](const transform_type_& trans);

    void resize(int n0, ..., int nN);

    void resize(const size_type& sz);

    void release();
};    
    \endcode

    \section array_decl Array Declaration, Construction and Size

    To declare an array simply provide the array signature as the template parameter of the lite::array class.
    Any dimension that is declared with size 1 will have a variable size. 
    Other dimensions will have fixed sizes. The size of the dimensions that have a non-constant size can 
    be specified as a constructor argument or later by calling the lite::array::resize(). For example:

    \code
        array<float[10][10]> m1;
        array<float[3]> v;

        int n;
        
        std::cin >> n;
        
        array<float[10][1][1]> m2(10, n, n); // 10 by n by n array
        array<float[10][1][1]> m3; 

        m3.resize(10, n, n);
    \endcode

    The size information of an array type \c A is represented by an object of type \a A::size_type. This
    is a an object of template class lite::pack and has an \c int element corresponding 
    to each dimension of the array holding the size of that dimension. You can also use a size object to 
    construct or resize and array. For example:
    
    \code 
        typedef array<float[1][10]> A;
        A::size_type sz(10, 10);

        A m1(sz), m2;

        std::cin >> sz;
        m2.resize(sz);
        std::cin >> m2;

        A::size_type sz2 = m2.size(); 

        if (sz2 != m1.size()) { // size objects can be compared
            // error
        }

        for (int i=0; i < sz.i0; i++)
            for (int j=0; j < sz.i1; j++)
                m1(i,j)= i+j;

        assert(sizeof(sz)==sizeof(int)); // true because sz.i1 is a static const member and won't occupy 
                                         // space in the object. However, sz.i1 is a non-static member of sz
    \endcode
    
    To get the current size of an array, you can call lite::array::size(). 

    Fixed size arrays can also be filled with some value at construction time:
    \code
        array<float[20][5]> m1 = 4.1; 
        // is equivalent to
        array<float[20][5]> m2; 
        m2 = 4.1;
    \endcode

    You can also provide the initial value of elements of small 1-dimensional arrays (vectors) as 
    a constructor parameter. For example:
    
    \code
        array<float[2]> v2(1.1, 2.2); 
        array<float[3]> v3(1.1, 2.2, 3.3); 
        // is equivalent to
        array<float[2]> u2; 
        u2[0] = 1.1; u2[1] = 2.2;
    \endcode

    Dimensions that have a fixed size are declared as constant elements of the lite::pack and won't occupy 
    memory in the \c size_type (see lite::pack for more information on constant element).
    Arrays with fixed size are allocated at the time of construction. Arrays with variable size 
    are allocated once you construct or resize them with a non-zero size. 

    \remark When you resize an array, the old content of the array will be lost and the new array elements 
    might be uninitialized.

    \section array_access Accessing Array Elements

    You can access the element of an array using lite::array::operator()(). For 1-dimensional arrays you can
    also use the lite::array::operator[](int) as seen in the previous examples.

    \section array_traits_brief Array Traits
    This parameter takes a traits class the is used to choose the proper representation type for an array
    based on its signature and possibly to specify other policies. 
    You normally don't to specify this parameter and the default value of 
    lite::default_array_traits should be fine. For more information see \ref array_traits.

    \section array_reps_brief Array Representations
    The last template parameter of the class lite::array specifies the representation type of the array. 
    Normally, you don't need to specify this parameter and the default value works fine. However, should
    you need to change the default array storage order or to use a non-default representation for another 
    reason, you may need to specify a different value for this parameter. 
    
    Basically, there are two category of array representation types. <b>primary arrays</b> 
    and <b>reference arrays</b>. Each category is explained bellow:
    
    \subsection array_primary_cat Primary Arrays
  
    Whenever you declare an array by itself (as in all the previous examples), the array class chooses a primary
    representation. Primary arrays are standalone objects that (in most cases) own their storage. The storage
    might be allocated internally as part of the array object (see \ref array_internal) if the array has 
    only fixed size dimensions and is not too large. 
    Or it might be allocated on the heap (see \ref array_hybrid) if it has a non-constant size 
    dimension or is too large.

    \subsection array_reference_cat Reference Arrays

    Reference arrays are usually returned as a result of applying an operation or applying a transformation
    to another array. They are virtual arrays that don't own their storage and usually reference all or parts 
    of another array or arrays. For example:

    \code
        array<float[10][10]> a, b;
        
        std::cout << (5*a).size();
        std::cout << (a+b)(5,5);
    \endcode
    
    In the above example <c>(a+b)</c> returns a reference array that computes each of its elements 
    <b>on-demand</b> by adding the corresponding element of \c a and \c b. 
    Some reference arrays (like the previous example) are read-only. 
    Other reference arrays like the following example allow modification of the original array through the 
    reference array:

    \code
        array<float[10][10]> a, b;
        
        a[row(0)] += 3*b[row(1)];
    \endcode

    The expression <c>a[row(0)]</c> returns a reference array to the first row of \c a.
    see \ref array_reference for more information on the standard representation type for reference arrays.
*/

/*!
	\defgroup array_operations Array Operations
	\ingroup array

    The library provides a rich set of array operations. The next example provides a brief list 
    of operations that are supported. In the example, the type \b Array could be any general
    array (single/multi dimensional with fixed or variable size), 
    the type \b Matrix could be any 2-dimensional array with fixed or variable size dimensions 
    and the type \b Vector could be any 1-dimensional array of fixed or variable size.

    \code 
    // general array operations:

    typedef array<float[5][20][20]> Array;

    Array A, A1, A2, B;
    float c;
    bool b;
    int res;

    B = A;                  //  copy A to B, possibly resizing B
    swap(A, B);             //  swap A and B

    A = c;                  //  A(i,j,k) = c
    B = +A;                 //? B(i,j,k) = +A(i,j,k)
    B = -A;                 //? B(i,j,k) = -A(i,j,k)
    B = A + c;              //? B(i,j,k) = A(i,j,k) + c
    B = c + A;              //? B(i,j,k) = c + A(i,j,k)
    B = A + c;              //? B(i,j,k) = A(i,j,k) + c
    B = A - c;              //? B(i,j,k) = A(i,j,k) - c
    B = c - A;              //? B(i,j,k) = c - A(i,j,k)
    B = c * A;              //? B(i,j,k) = c * A(i,j,k)
    B = A * c;              //? B(i,j,k) = A(i,j,k) * c
    B = A / c;              //? B(i,j,k) = A(i,j,k) / c
    B = A / c;              //? B(i,j,k) = A(i,j,k) / c
    B = A1 + A2;            //? B(i,j,k) = A1(i,j,k) + A2(i,j,k)                    
    B = A1 - A2;            //? B(i,j,k) = A1(i,j,k) - A2(i,j,k)
    B = A1 - A2;            //? B(i,j,k) = A1(i,j,k) - A2(i,j,k)
    B = A1 | A2;            //? B(i,j,k) = A1(i,j,k) * A2(i,j,k)

    A += c;                 //  A(i,j,k) += c
    A -= c;                 //  A(i,j,k) -= c
    A *= c;                 //  A(i,j,k) *= c
    A /= c;                 //  A(i,j,k) /= c
    B += A;                 //  B(i,j,k) += A(i,j,k)
    B -= A;                 //  B(i,j,k) -= A(i,j,k)

    b = B < A;              //  true if B(i,j,k) < A(i,j,k) for all i,j,k
    b = B <= A;             //  true if B(i,j,k) <= A(i,j,k) for all i,j,k
    b = B == A;             //  true if B(i,j,k) == A(i,j,k) for all i,j,k
    b = B != A;             //  is equivalent to !(B==A)
    b = B >= A;             //  true if B(i,j,k) >= A(i,j,k) for all i,j,k
    b = B > A;              //  true if B(i,j,k) > A(i,j,k) for all i,j,k
    res = compare(B, A);    //  lexicographically compare A and B. 
                            //  returns -1 if B is before A, +1 if B is after A and 0 otherwise

    c = norm(A);            //  returns the sum of the squares of all of the elements
    c = abs(A);             //  returns sqrt(norm(A))
    B = normalized(A);      //  returns a scaled copy of A such that abs(normalized(A)) = 1

    B = min(A1, A2);        //? B(i,j,k) = min(A1(i,j,k), A2(i,j,k))
    B = max(A1, A2);        //? B(i,j,k) = max(A1(i,j,k), A2(i,j,k))

    std::cin >> A;          //  reads from a std::basic_istream
    std::cout << A;         //  writes to a std::basic_ostream

    B = apply<std::negate>(A);          //? B(i,j,k) = -A(i,j,k)
    B = apply(A, std::negate());        //? B(i,j,k) = -A(i,j,k)
    B = apply<std::plus>(A1, A2);       //? B(i,j,k) = A1(i,j,k) + A2(i,j,k)
    B = apply(A1, A2, std::plus());     //? B(i,j,k) = A1(i,j,k) + A2(i,j,k)

    // matrix and vector operations:

    typedef array<float[20][20]> Matrix;
    typedef array<float[20]> Vector;

    Matrix N, M, M1, M2;
    Vector U, V, V1, V2;

    c = V1 * V2;            //  returns the inner product of V1 and V2
    U = M * V;              //  matrix-vector product (V is treated as a column vector)
    U = V * M;              //  vector-matrix product (V is treated as a row vector)
    N = M1 * M2;            //  matrix-matrix product (V is treated as a row vector)
    N = M1 * M2;            //  matrix-matrix product (V is treated as a row vector)
    c = det(M);             //  returns the determinant of M
    N = inverse(M);         //  returns the inverse of M
    M = scale(V);           //  returns a square matrix with V on the main diagonal

    // 2D specific geometric operations:

    typedef array<float[2][2]> Matrix2;
    typedef array<float[2]> Vector2;

    Matrix2 M2;
    Vector2 u2, v2, w2;

    c = u2 % v2;            //  returns the cross product of u2 and v2
    M2 = rotation(v2, c);   //  returns a rotation matrix that rotates c radians, v2 is ignored
    M2 = rotation_n(v2, c); //  same as rotation(v2, c)

    // 3D specific geometric operations:

    typedef array<float[3][3]> Matrix3;
    typedef array<float[3]> Vector3;

    Matrix3 M3;
    Vector3 u3, v3, w3;

    w3 = u3 % v3;           //  returns the cross product of u3 and v3
    M3 = rotation(v3, c);   //  returns a rotation matrix that rotates c radians around v3
    M3 = rotation_n(v3, c); //  slightly faster than rotation(v3, c) but v3 must be a unit vector.

    \endcode
    Note that the above operations can be used on any type that support the underlying operators. 
    For example, to use the \c compare() function, the operator< should be defined on the elements 
    of the array.

    \remark
    - Note that all of the operations that involve two arrays, require the two array to have matching 
        signatures and traits. For example, you cannot add an array of type \c array<float[10]> with
        and array of type \c array<float[1]> even if the size of the second array is actually 10. To use two
        arrays with the same size but different signatures or different traits type, you first need to cast
        one of them using the lite::array_cast(). For matrix and vector operations, only the relevant part 
        of the signature is required to match. For example you can multiply an \c array<float[1][10]> by 
        an \c array<float[10]> but not by an \c array<float[1]> event if the size of the second array
        is actually 10. 
        You would first need to cast the second array to \c array<float[10]> using lite::array_cast().
    - All the operations the are marked with a <b>question mark</b> in their comment use lazy evaluation
        (see \ref array_lazy). Note that due to lazy evaluation, sometimes it is necessary to make a 
        temporary copy of an array to ensure proper result. To do that you can use the lite::copy(). 
        For example:
        \code
            array<float[5][5]> a;

            a = a[transpose()];         // does not work correctly due to lazy evaluation
            a = copy(a[transpose()]);   // works fine. makes a temporary copy of a[transpose()]
        \endcode
    - Note that when copying arrays using operator=(), the left array will be resized (if possible) before
        the actual copy.

    \section array_cast Array Casting
    For more information on array casting, see lite::array_cast().

    \section array_io Array I/O
    For more information on reading/writing arrays to io streams, 
    see \ref array_input "lite::operator>>()" and \ref array_output "lite::operator<<()".

    \section array_from Constructing Reference Arrays from C Arrays, Iterators or Pointers
    You can create a reference array from a C array, an appropriate random access iterator 
    or a pointer using lite::from().

    \section array_orering Ordering Array Objects
    If you ever need to define an ordering on array objects 
    (e.g. to use lite::array as the key to a std::map) you can use lite::array_comparator.
*/

/*!
	\defgroup array_transforms Array Transformations
	\ingroup array

    An array transform usually creates a reference array that references all or part of another array. 
    All the predefined transforms return a mutable reference array 
    that can be used to modify the original array however in general this is not a requirement and
    a user-defined array may return an immutable array. 
    The lite::array::operator[](const transform_type_&) can be used to apply a transform object 
    to an array object. For example:
    \code
    array<float[3][3]> a;

    a[row(0)] = 1;
    \endcode
    
    In the above example, the <c>a[row(0)]</c> returns an array with signature <c>float[3]</c>. Sometimes, 
    you may need to store a reference array to use it later. 
    To do that you need to know the type of the reference array object that is returned as the result. 
    The lite::transform_traits can be used to get the type of the array that results from 
    applying a transform type to an array type (See lite::transform_traits for more information). 
    For example:

    \code
    typedef array<float[3][3]> Array;
    Array a;

    transform_traits<Array, row>::array r = a[row(0)];

    r = 1;
    \endcode
     
    The following are the predefined transforms:
    - lite::row
    - lite::column
    - lite::plane
    - lite::diagonal
    - lite::transpose
    - lite::block

    You can import the namespace lite::transforms to import only the predefined transforms 
    from the #lite namespace.

    For more information on how to define new transforms see \ref array_transforms_advanced.
*/

/*!
	\defgroup array_advanced Array Internals (Advanced)
	\ingroup array

    This section contains advanced information about the internal representation of arrays, 
    array traits type and defining new transforms among other things.

    \section array_reps Array Representation (Advanced)
    There are two category of array representation as explained in \ref array_reps_brief :
    - \ref array_primary_cat
    - \ref array_reference_cat

    The third template parameter of lite::array specifies the representation type of the array:
    \code
template<
    typename signature_, 
    typename traits_type_ = default_array_traits, 
    typename rep_ = typename traits_type_::template representation_type<signature_>::type>
class array;
    \endcode
    If not specified explicitly, the appropriate representation type is chosen automatically by the 
    \a traits_type_. This is usually appropriate for primary arrays. However, sometimes it is necessary
    to supply this argument explicitly (for example to define a reference array). 
    The argument is usually just a tag type. The actual representation is implemented by specializing the
    class lite::array for that specific tag type. 
    The following 3 representation types are defined in the library:

    - lite::internal_rep \ref array_internal 
    - lite::hybrid_rep \ref array_hybrid
    - lite::reference_rep \ref array_reference
    
    Other user-defined representations can also be defined by defining new representation tags 
    and further specializing the class lite::array for those tags.

    \subsection array_internal Internal Representation

    The internal representation is specified by specifying lite::interna_rep as the representation tag of the
    lite::array. It has the following declaration:
    \code
        template<bool reversed_>
        class internal_rep;
    \endcode

    The content of the array is stored as part of the array object itself (thus the name \e internal_rep).
    The array \b must have only fixed size dimensions. The size of the array object will be exactly the
    same as the size of the storage required for the array as there is no other information stored within
    the array object (zero overhead). The array objects of with representation 
    are POD object according to C++0x definition (see C++ standard, 3.9:10). 
    These are light weight objects that can be efficiently copied and passed around as value objects. 
    The lite::default_array_traits automatically chooses this representation for small 
    (both single and multidimensional) arrays of fixed size.

    if \a reversed_ is true then the array will be stored in the reverse order of dimensions 
    (see \ref array_storage).

    For example the following, declares a column-major 5 by 5 matrix:

    \code
        array<float[5][5], default_array_traits, internal_rep<true> > a;
    \endcode
    
    \subsection array_hybrid Hybrid Representation

    The hybrid representation is specified by specifying lite::hybrid_rep as the representation tag of the
    lite::array. It has the following declaration:
    \code
        template<bool reversed_, int internal_buf_size_>
        class hybrid_rep;
    \endcode

    The array object will contain an internal buffer of size \a internal_buf_size_. 
    The size is in terms of the number of elements of an array.
    The content of the array will be stored in the internal buffer if it fits. If the array 
    has more than \a internal_buf_size_ elements then it will be allocated externally on the heap. 
    The array can have a mix of fixed and variable size dimensions. 
    In addition to the internal buffer, there is an iterator and a size object maintained internally 
    by the array object. The lite::default_array_traits automatically chooses this representation for large
    arrays and arrays with at least one dimension with non-const size.

    A hybrid array which at least one non-constant size dimension is initially empty unless 
    a size with non-zero volume is specified for it in the constructor. 
    The function lite::array::release() can be used to release the memory that is allocated to the array.
    Even for a fixed size array, a call to lite::array:release() still releases the memory, so 
    you cannot dereference or use the array until you call lite::array::resize() to reallocate it again.
    A fixed size array is automatically allocated upon construction.

    if \a reversed_ is true then the array will be stored in the reverse order of dimensions 
    (see \ref array_storage).
    
    For example the following, declares a column-major square matrix of variable size with 
    an internal buffer of 1024 elements:

    \code
        int n;
        std::cin >> n;
        array<float[1][1], default_array_traits, hybrid_rep<true, 1024> > a(n ,n);
    \endcode

    In the above example, the array will be stored in the internal buffer if (n <= 32).

    \subsection array_reference Reference Representation

    The reference representation is specified by specifying lite::reference_rep 
    as the representation tag of the lite::array. It has the following declaration:
    \code
        template<typename iterator_type_>
        class reference_rep;
    \endcode

    The array object will contain only an iterator of type \a iterator_type_ and a size object of the type
    appropriate for the array signature. The \a iterator_type_ should satisfy the requirements of a
    muti-dimensional iterator (see \ref array_iterators).

    Note that the specialization of class lite::array for this representation provides an almost totally
    different set of constructors (See lite::array for details). 
    
    For an array with this representation, all typedef that stat with <c>const_</c> are exactly the same
    as those without it. Also all the member functions and operators are declared const.
    Furthermore, An array with this representation must always be declared as const 
    when used as a return type.

    For example the following, declares a reference array to another array:

    \code
        typedef array<float[5][5]> A;
        typedef array<float[5][5], default_array_traits, reference_rep<A::iterator> > A_Ref;

        A a;
        A_Ref a_ref = a;

        a_ref(2,3) = 5;     // a_ref can be used as an alias for a
        // the previous line is equivalent to:
        a(2,3) = 5;
    \endcode

    \section array_storage Array Storage
    There are two storage types that can be  specified for internal and hybrid representations:

    - <b>Forward Storage:</b> This is the default type in which consecutive elements of the last dimension
        are adjacent in memory and then the dimension before it and so on. This is the generalization of 
        row major storage and is what is used by the C/C++ by default. 
    - <b>Reverse Storage:</b> With this storage, consecutive elements of the first dimension
        are adjacent in memory and then the second dimension and so on. This is the generalization of 
        column major storage and is what is used in Fortran by default.

    For example the following, declares a column-major 5 by 5 matrix:

    \code
        array<float[5][5], default_array_traits, internal_rep<true> > a;
    \endcode
    
    \section array_temporary Temporary Arrays
    There are times that you need to make a copy of another array for temporary use in a function or 
    return a temporary array object from a function. In those cases, it is better to use an 
    array type that is more appropriate for temporary storage to improve performance.

    A temporary array type that uses the \ref array_hybrid, usually has a much larger internal buffer so as
    to avoid allocation/deallocation of memory from heap. 
    For any array type, compatible temporary array types are available as member typedefs 
    as shown in the following example. The following example shows a function that computes the inverse 
    of a matrix using Gauss-Jordan elimination:

    \code
// compute the inverse of matrix a
template<typename value_type_, int n_, typename traits_type_, typename rep_>
const array<value_type_[n_][n_], traits_type_>::temporary_array
inverse(const array<value_type_[n_][n_], traits_type_, rep_>& a)
{
    using std::abs;

    typedef array<value_type_[n_][n_], traits_type_, rep_> a_type;
    typedef typename a_type::temporary_array temporary_type;

    const int n = a.size().i0;
    temporary_type result(a.size());
    temporary_type aa =a;

    result = value_type_();

    result[diagonal()] = value_type_(1);

    for (int i=0; i<n; i++) {
        const block<0,1> blk(0, n-i);
        int i_max = i;
        value_type_ val_max = abs(aa(i, i));

        // find the strongest row
        for (int i2 = i+1; i2<n; i2++)
            if (abs(aa(i2, i)) > val_max) {
                i_max = i2;
                val_max = abs(aa(i2, i));
            }

        // swap row i_max with row i
        if (i_max != i) {
            typename transform_traits<temporary_type, row>::temporary_array res_tmp;

            res_tmp = result[row(i)];
            result[row(i)] = result[row(i_max)];
            result[row(i_max)] = res_tmp; 

            typename transform_traits<temporary_type, block<0,1> >::temporary_array org_tmp;
                
            org_tmp = aa[blk(i,i)];
            aa[blk(i,i)] = aa[blk(i_max, i)];
            aa[blk(i_max,i)] = org_tmp; 
        }

        // if a singular matrix return a zero matrix
        if (aa(i, i) == value_type_()) {
            result = value_type_();
            break;
        }

        // normalize the row
        value_type_ factor = value_type_(1)/aa(i, i);

        result[row(i)] *= factor;
        aa[blk(i, i)] *= factor;

        value_type_ epsilon = std::numeric_limits<value_type_>::epsilon()*aa(i, i)*n;

        // simplify the column in the lower triangle
        for (int i2 = i+1; i2<n; i2++) 
            if (abs(aa(i2, i)) > epsilon) {
                result[row(i2)] -= aa(i2, i)*result[row(i)];
                aa[blk(i2,i)] -= aa(i2, i)*aa[blk(i,i)];
            }
    }

    // simplify the upper triangle
    for (int i = n-1; i>=0; i--) {
        value_type_ epsilon = std::numeric_limits<value_type_>::epsilon()*aa(i, i)*n;

        for (int i2 = 0; i2<i; i2++) 
            if (abs(aa(i2, i)) > epsilon) 
                // we don't need to update the original here as it won't be used any more!
                result[row(i2)] -= aa(i2, i)*result[row(i)];
    }

    return result;
}
    \endcode

    \section array_traits Array Traits
    The second template parameter of the class lite::array specifies a traits type:
    \code
        template<
            typename signature_, 
            typename traits_type_ = default_array_traits, 
            typename rep_ = typename traits_type_::template representation_type<signature_>::type>
        class array;
    \endcode

    The primary purpose of a traits class is to choose the proper array representation based on the array
    signature. It can be also use to specify other user-defined policies. 

    An array traits type should provide the following interface:
    \code
struct some_array_traits
{
    template<typename signature_>
    struct representation_type
    {
        // This is the default representation to be used for arrays
        typedef ??? type;

        // This is the default representation to be used for temporary arrays
        typedef ??? temporary_type;

        // This is the default representation to be used for temporary arrays with forward storage
        typedef ??? fwd_temporary_type;

        // This is the default representation to be used for temporary arrays with reverse storage
        typedef ??? rev_temporary_type;
    };
};
    \endcode

    The lite::default_array_traits is the only pre-defined array traits type. 

    \section array_iterators Multi-Dimensional Iterators
    A multi-dimensional iterator is an iterator that can move along more than one dimension. 
    A multidimensional array can be fully represented by a multidimensional iterator pointing to the 
    start of the array and a size object specifying the size of the array along each dimension. 
    the lite:array::begin() returns a multidimensional iterator pointing to the start of the array.
    All multidimensional iterators should provide the following operations 
    (assume \c Iter is a multidimensional iterator type):

    \code
    // Index through the iterator \a it using the indices \a i0 to \a iN.
    std::iterator_traits<Iter>::reference at(Iter it, int i0 ..., int iM);

    // Increment the iterator \a it along dimension \a dim_ by one position.
    template<int dim_>
    void inc(Iter it);

    // Decrement the iterator \a it along dimension \a dim_ by one position.
    template<int dim_>
    void dec(Iter it);

    // Move the iterator \a it along dimension \a dim_ by \a diff positions.
    template<int dim_>
    void shift(Iter it, int diff);
    \endcode

    In addition to the above operations, the class std::iterator_traits should be specialized 
    to provide correct typedefs just like a stl style iterator.

    Note that the <c>at()</c> function may take any number of indices from 0 to N where N is the 
    number of dimensions of the iterator \a it. If M indices are provides such that (M < N) then
    then the provided indices will be used for the last M dimensions and for the first N-M dimensions an
    index of 0 will be assumed. For example:
    
    \code
        typedef array<float[5][6][7]> A;
        A a;

        A::iterator it = a.begin();

        at(it, 5) = -1;                     // set a(0,0,5) to -1
        at(it, 0, 5) = -1;                  // set a(0,0,5) to -1
        at(it, 0, 0, 5) = -1;               // set a(0,0,5) to -1
        
        inc<2>(it);
        at(it) = -1;                        // set a(0,0,1) to -1

        shift<1>(it, 3);
        at(it, 1, 0, 0) = -1;               // set a(1,3,1) to -1

        shift<1>(it, -2);                   
        at(it, -1) = -1;                     // set a(0,1,0) to -1
    \endcode

    Note that any iterator used by any lite::array object should satisfy all the requirements of 
    a multidimensional iterator. For example:

    \code
        typedef array<float[5][6]> A;
        A a, b, c;

        std::cout << at((2*a+b+c).begin(), 0, 1);
        // is equivalent to:
        std::cout << 2*a(0,1)+b(0,1)+c(0,1);

        std::cout << at(a[row(1)].begin(), 0, 1);
        // is equivalent to:
        std::cout << a(1, 1);
    \endcode

    The following multidimensional iterator types are provided by the library:

    - \b s_iterator see lite::s_iterator
    - \b c_iterator see lite::c_iterator
    - \b u_iterator see lite::u_iterator
    - \b b_iterator see lite::b_iterator

    You can define your own iterator type by implementing the requirement of a generalized iterator.
    Most of the array operations use the above iterator types with appropriate function objects to achieve 
    their functionality.

    \section array_transforms_advanced Defining New Transforms

    In order to define a new transform, you need to implement the specialization of the following 
    two types for your transform type:

    - lite::size_transformer : This is used to apply a transform object to a size object
    - lite::iterator_transformer : This is used to apply a transform object to an iterator object

    Together, the above two transformers are used to apply a transform object to an array object.
    The transform is applied to the iterator and the size of the original array and then a new reference
    array is created from the resulting iterator and resulting size. 
    The resulting array uses the \ref array_reference. 

    The following pseudo definitions specify the interface 
    that each of the two transformers should implement:

    \code
        template<typename transform_type_, typename input_size_type_>
        struct size_transformer
        {
        public:
            // The type of the resulting size object after applying the transform
            typedef ??? size_type;

            // Apply the transform to the size object org and store the result in res.
            static void transform(const input_size_type_& org, size_type& res);

            // Apply the transform object trans to the size object org and store the result in res.
            static void transform(const transform_type& trans, const input_size_type_& org, size_type& res);
        };

        template<typename transform_type_, typename input_iterator_type_, typename input_size_type_>
        struct iterator_transformer
        {
        public:
            // The type of the resulting iterator object after applying the transform
            typedef ??? iterator_type;

            // Apply the transform to the iterator object org and store the result in res.
            static void transform(
                const input_iterator_type& org, 
                iterator_type& res);

            // Apply the transform object trans to the iterator object org and store the result in res.
            static void transform(
                const transform_type_& trans, 
                const input_iterator_type& org, 
                iterator_type& res);

            // Apply the transform object trans to the iterator object org that is used together with 
            // size object sz and store the result in res.
            static void transform(
                const transform_type_& trans, 
                const input_iterator_type& org, 
                const input_size_type_& sz,
                iterator_type& res);
        };
    \endcode

    In order to define a new transform, in addition to defining a type for your transform objects, you
    need to specialize and implement the lite::size_transformer and lite::iterator_transformer 
    for you new transform type. For lite::c_iterator, lite::u_iterator and lite::b_iterator, 
    there are already specializations in place that do the following by default:

    - For lite::c_iterator, the default transformer does nothing and returns the same iterator
    - For lite::u_iterator, the default transformer applies the transform object to the base iterator
        and creates a new lite::u_iterator using the transformed base iterator and the same function object.
    - For lite::b_iterator, the default transformer applies the transform object to the both of the 
        left and right base iterators and then creates a new lite::b_iterator 
        using the transformed base iterators and the same function object.

    Therefore, if the above default behavior works well for your transform type 
    (which is usually the case), you only need to define an iterator transformer for lite::s_iterator. 

    The following example shows the details of how a transform object is applied to an array:

    \code
        int n;

        std::cin >> n;

        typedef array<float[1][1]> A;

        A a(n, n);

        transform_traits<A, row>::array a_row_ref1 = a[row(1)]; 

        // the previous line is equivalent to the following code:

        typedef size_transformer<row, A::size_type> ST; 
        typedef iterator_transformer<row, A::iterator, A::size_type> IT;

        ST::size_type sz;
        IT:iterator_type it;
        row r(1);

        ST::transform(r, a.size(), sz);
        IT::transform(r, a.begin(), it);

        typedef lite::detail::size_to_signature<ST::size_type, std::iterator_traits<A::iterator>::value_type>::type Sig;

        array<Sig, A::traits_type, reference_rep<IT::iterator_type> > a_row_ref2(it, sz);
    \endcode

    The specialization of class lite::array for lite::reference_rep has a special constructor 
    that can be used to simplify the above code:

    \code
        int n;

        std::cin >> n;

        typedef array<float[1][1]> A;

        A a(n, n);

        transform_traits<A, row>::array a_row_ref1 = a[row(1)]; 

        // the previous line is equivalent to the following code:

        typedef size_transformer<row, A::size_type> ST; 
        typedef iterator_transformer<row, A::iterator, A::size_type> IT;
        typedef lite::detail::size_to_signature<ST::size_type, std::iterator_traits<IT>::value_type>::type Sig;

        array<Sig, A::traits_type, reference_rep<IT::iterator_type> > a_row_ref2(a.begin(), a.size(), row(1));
    \endcode

    Note that you do not need to specialize and implement the lite::transform_traits as it uses a generic
    definition that depends on lite::size_transformer and lite::iterator_transformer.

    \section array_lazy Lazy Evaluation
    Many of the array operations do not actually compute their result but instead return a reference array 
    that computes the result on demand (lazy evaluation). The resulting reference array uses a 
    combination of lite::c_iterator, lite::u_iterator or lite::b_iterator and a function object.

    You can use the lite::apply() (See the example in \ref array_operations) to create a reference array 
    that applies a function object to one or two other arrays.

    Most of the array operations that actually compute their result use the lite::for_each() or 
    lite::for_each_c().

    \section array_operations_advanced Array Operations and Evaluation
    The lite::for_each() and lite::for_each_c() family of functions lie at the heart of the library.
    Almost all array operations are eventually performed by a call to one of the overloads of these two 
    functions. The for_each functions are heavily specialized/optimized 
    to unroll loops with fixed/variable number of iterations. 

    For example, consider the following function:
    
    \code
        void foo(int n)
        {
            const int max_m = 2048;
            const float c = 3;

            typedef array<float[3]> Vec;

            Vec v1[max_m], v2[max_m];

            for (int i=0; i<max_m; i++) {
                init(v1[i]);
                init(v2[i]);
            }

            for (int i=0; i<n; i++)
                for (int k=0; k<n; k++)
                    v1[k] = v2[k]+c*v2[k+1];

            std::cout << v1[0]; << std::endl;   // to prevent dead code elimination
        }
    \endcode
    The lite::for_each() function is called by the assignment operator to evaluate the array expression 
    and to store the result in <c>v1[k]</c>. 
    The following is the assembly code generated for the the inner loop by MSVC++ 2009:
    \verbatim
        00401ECB  cmp         edx,esi 
        00401ECD  jge         code_gen+1A4h (401F14h) 
        00401ECF  lea         eax,[edx+edx*2] 
        00401ED2  add         eax,eax 
        00401ED4  mov         ecx,esi 
        00401ED6  add         eax,eax 
        00401ED8  sub         ecx,edx 
        00401EDA  fld         dword ptr [esp+eax+14h] 
        00401EDE  add         eax,0Ch 
        00401EE1  sub         ecx,1 
        00401EE4  fmul        st,st(1) 
        00401EE6  fadd        dword ptr [esp+eax-4] 
        00401EEA  fstp        dword ptr [esp+eax+5FFCh] 
        00401EF1  fld         dword ptr [esp+eax+0Ch] 
        00401EF5  fmul        st,st(1) 
        00401EF7  fadd        dword ptr [esp+eax] 
        00401EFA  fstp        dword ptr [esp+eax+6000h] 
        00401F01  fld         dword ptr [esp+eax+10h] 
        00401F05  fmul        st,st(1) 
        00401F07  fadd        dword ptr [esp+eax+4] 
        00401F0B  fstp        dword ptr [esp+eax+6004h] 
        00401F12  jne         code_gen+16Ah (401EDAh) 
    \endverbatim

    As you can see, the whole expression <c>v1[k] = v2[k]+c*v2[k+1]</c> has been fully inlined and optimized. 
    The above assembly code is almost identical to the assembly code generated 
    for a hand written function that does not use the array library.

    A few of the functions like the 2D and 3D version of the lite::det() and lite::inverse() 
    are implemented explicitly to ensure optimal performance.

    \todo performance and forward/reverse storage 
    \todo performance notes, code samples, etc.
    \todo function objects?
*/

/*!
	\defgroup array_tools Tool Classes
	\ingroup array
*/

/*!
	\defgroup array_misc Miscellaneous
	\ingroup array

    \section array_template_params Changing the Limists and Regenerating The Header File.

    There are several parameters declared at the top of the file <c>array.hpp.template</c> that can be 
    tweaked for example to change the maximum number of dimensions supported. There is also a macro constant
    defined corresponding to each of these parameters. You can refer to the documentation of the macro to
    find out about the purpose of each parameter. 
    The following is the list of parameters and the corresponding macros:

    - max_dims : #LITE_ARRAY_MAX_DIMS
    - max_packs : #LITE_ARRAY_MAX_PACKS
    - max_vector_args : #LITE_ARRAY_MAX_VECTOR_ARGS
    - max_iterator_args : #LITE_ARRAY_MAX_ITERATOR_ARGS
    - max_static_unroll_length : #LITE_ARRAY_MAX_STATIC_UNROLL_LENGTH
    - max_dynamic_unroll_depth : #LITE_ARRAY_MAX_DYNAMIC_UNROLL_DEPTH
    - iversion : #LITE_ARRAY_VERSION
    - fversion : #LITE_ARRAY_VERSION_STR
*/

/*!
	\defgroup array_exceptions Exceptions
	\ingroup array

    The library performs some size checking to make sure the size of the arrays used in expressions match
    and throws a lite::size_mismatch_error on error. This may incur some performance overhead. 
    You can define the NDEBUG macro before including the header file to disable all error checking.
*/

/*!
	\defgroup array_benchmark Benchmarks
	\ingroup array

    \todo add the benchmark results.
*/


#ifndef LITE_ARRAY_HPP
#define LITE_ARRAY_HPP

#include <exception>
#include <stdexcept>
#include <iterator>
#include <algorithm>
#include <iostream>
#include <iomanip>
#include <limits>
#include <cmath>
#include <cstdlib>

/***********************************************************************************************************/
/* common configuration ************************************************************************************/
/***********************************************************************************************************/

#ifdef LITE_INLINE
#undef LITE_INLINE
#endif

/*! 
    \brief The maximum number of dimensions for arrays.
    \ingroup array_misc
*/
#define LITE_ARRAY_MAX_DIMS 3

/*! 
    \brief The maximum number of elements in a lite::pack.
    \ingroup array_misc
*/
#define LITE_ARRAY_MAX_PACKS 4

/*! 
    \brief The maximum size of fixed size vectors (1D arrays) which can be initialized using a constructor.
    \ingroup array_misc

    \par Example 

    \code
        array<double[2]> a(2.3, 4.5);
        array<double[3]> a(2.3, 4.5, 4.6);
        array<double[9]> a(1, 2, ..., 9); // error: more than LITE_ARRAY_MAX_VECTOR_ARGS number of args.
    \endcode
*/
#define LITE_ARRAY_MAX_VECTOR_ARGS 5

/*! 
    \brief The maximum number of arguments that will be passed from the constructor of a reference array 
        to its iterator object verbatim.

    \ingroup array_misc
    \todo Add an example
*/
#define LITE_ARRAY_MAX_ITERATOR_ARGS 3

/*! 
    \brief For all array operations in which the innermost loop has a constant number of iterations which is 
        no more than LITE_ARRAY_MAX_STATIC_UNROLL_LENGTH the innermost loop is fully unrolled.

    \ingroup array_misc
*/
#define LITE_ARRAY_MAX_STATIC_UNROLL_LENGTH 5

/*! 
    \brief For all array operations in which the innermost loop has a non-constant number of iterations 
        or has more than LITE_ARRAY_MAX_STATIC_UNROLL_LENGTH number of iterations, 
        the innermost loop is dynamically unrolled in \f$2^k\f$ iterations at a time where k is at most
        #LITE_ARRAY_MAX_DYNAMIC_UNROLL_DEPTH .

    \ingroup array_misc
*/
#define LITE_ARRAY_MAX_DYNAMIC_UNROLL_DEPTH 4

/*! 
    \brief Integral version number of the library. 
    \ingroup array_misc
*/
#define LITE_ARRAY_VERSION 3505

/*! 
    \brief An string representation of the version number of the library. 
    \ingroup array_misc
*/
#define LITE_ARRAY_VERSION_STR "3.505"

#define LITE_ARRAY_USE(x) ((void)(x))

#ifndef __LINE__ // true when Doxygen is processing the file
#define DOCUMENTATION_ONLY
#endif 

/***********************************************************************************************************/
/* MSVC++ configuration ************************************************************************************/
/***********************************************************************************************************/

#ifdef _MSC_VER

#if _MSC_VER < 1300
#error visual c++ .net 7.1 (2003) or newer is required
#endif // _MSC_VER < 1300 

#pragma	warning(push)
#pragma	warning(disable	: 4127)	// conditional_c expression is constant
#pragma inline_recursion(on)
#pragma inline_depth(200)

#define LITE_INLINE __forceinline

#ifndef NDEBUG
#pragma message ("lite/array.hpp: Warning! Possible performance penalty due to assertions. Define NDEBUG to disable.")
#endif

#endif // _MSC_VER

/***********************************************************************************************************/
/* GCC configuration ***************************************************************************************/
/***********************************************************************************************************/

#ifdef __GNUC__

#define LITE_INLINE  inline __attribute__((always_inline))

#ifndef LITE_ARRAY_NO_HINT
#warning "Use the following compiler switches to get a good performance: -finline-limit=1234567 --param large-function-growth=1234567 --param max-inline-insns-single=1234567"
#warning "Define LITE_ARRAY_NO_HINT to disable the previous warning."
#endif 

#ifndef NDEBUG
#warning "lite/array.hpp: Possible performance penalty due to assertions. Define NDEBUG to disable."
#endif

#endif // __GNUC__

/***********************************************************************************************************/
/* generic configuration ***********************************************************************************/
/***********************************************************************************************************/

#ifndef LITE_INLINE
#define LITE_INLINE inline
#endif

/***********************************************************************************************************/
/* error checking/debug level ******************************************************************************/
/***********************************************************************************************************/

#ifdef NDEBUG
#define LITE_ARRAY_SIZE_CHECK(size1, size2, msg)
#else
#define LITE_ARRAY_SIZE_CHECK(size1, size2, msg) lite_array_size_check(size1, size2, msg)
#endif

/***********************************************************************************************************/
/* namespace lite ******************************************************************************************/
/***********************************************************************************************************/

//! Contains all the #lite classes and functions.
namespace lite
{

template<typename type_, type_ value_>
class constant;

template<
    typename type0_ = void ,
    typename type1_ = void ,
    typename type2_ = void ,
    typename type3_ = void 
    >
class pack;

template<
    typename pack_type_,
    bool keep0_ =false,
    bool keep1_ =false,
    bool keep2_ =false,
    bool keep3_ =false
    >
class sub_pack;

// class s_iterator; // the pack class is used directly instead

template<typename _value_type>
class c_iterator; // const_iterator

template<
    typename base_iter_type_, 
    typename func_type_, 
    bool is_static_ =true>
class u_iterator; // unary iterator

template<
    typename left_base_iter_type_, 
    typename right_base_iter_type_, 
    typename func_type_, 
    bool is_static_=true>
class b_iterator; // binary_iterator

template<typename signature_, typename base_iterator_type_=void>
struct array_signature_traits;

template<typename iterator_type_>
class reference_rep;

template<bool reversed_>
class internal_rep;

template<bool reversed_, int internal_buf_size_>
class hybrid_rep;

struct default_array_traits;

template<
    typename signature_, 
    typename traits_type_ = default_array_traits, 
    typename rep_ = typename traits_type_::template representation_type<signature_>::type>
class array;

template<typename signature_, typename traits_type_ = default_array_traits>
struct array_helper;

template<typename trans_type_, typename size_type_>
struct size_transformer;

template<typename trans_type_, typename iter_type_, typename size_type_>
struct iterator_transformer;

template<typename array_type_, typename trans_type_, typename enabler_=void>
struct transform_traits;

template<int dim_>
class plane;

/*!
    \brief 
    This transform, when applied to an array of dimension N, 
    returns a reference array of dimension N-1 by fixing the index at dimension 0.

    \ingroup array_transforms

    When applied to a 2-dimensional array, it returns a reference to a row.
    \par Example:

    \code
        array<float[3][4]> a;    // a 3x4 array

        a[row(2)] = -1;       // left hand side is a float[4] reference array 

        // the above line is equivalent to:

        for (int j=0; j<a.size().i1; j++)
            a(2, j) = -1;
    \endcode
*/
typedef plane<0> row;

/*!
    \brief 
    This transform, when applied to an array of dimension N (N must be at least 2), 
    returns a reference array of dimension N-1 by fixing the index at dimension 0.

    \ingroup array_transforms
    
    When applied to a 2-dimensional array, it returns a reference to a column.
    \par Example:

    \code
        array<float[3][4]> a;    // a 3x4 array

        a[column(2)] = -1;       // left hand side is a float[3] reference array 

        // the above line is equivalent to:

        for (int i=0; i<a.size().i0; i++)
            a(i, 2) = -1;
    \endcode
*/
typedef plane<1> column;

class diagonal;

class transpose;

template<
    int n0_ = -2,
    int n1_ = -2,
    int n2_ = -2
    >
class block;

class array_comparator;

class size_mismatch_error;

/*! 
    \brief Imports all the array transforms.
	\ingroup array_transforms
	This namespace includes all the predefined transforms. 
    
    This namespace can be used to import the 
    transforms without importing the whole #lite namespace.
*/
namespace transforms 
{
using ::lite::plane;
using ::lite::row;
using ::lite::column;
using ::lite::diagonal;
using ::lite::transpose;
using ::lite::block;
using ::lite::transform_traits;
};

/***********************************************************************************************************/
/* implementation helpers **********************************************************************************/
/***********************************************************************************************************/

namespace detail
{

/***********************************************************************************************************/
/* enable_if ***********************************************************************************************/
/***********************************************************************************************************/

template<bool cond_, typename type_ =void>
struct enable_if;

template<typename type_>
struct enable_if<false, type_>
{};

template<typename type_>
struct enable_if<true, type_>
{
    typedef type_ type;
};

/***********************************************************************************************************/
/* type_if *************************************************************************************************/
/***********************************************************************************************************/

template<bool cond_, typename true_type_, typename false_type_>
struct type_if;

template<typename true_type_, typename false_type_>
struct type_if<true, true_type_, false_type_>
{
    typedef true_type_ type;
};

template<typename true_type_, typename false_type_>
struct type_if<false, true_type_, false_type_>
{
    typedef false_type_ type;
};

struct invalid_argument {};

/***********************************************************************************************************/
/* same_type ***********************************************************************************************/
/***********************************************************************************************************/

template<typename left_type_, typename right_type_>
struct same_type
{
    static const bool result = false;
};

template<typename type_>
struct same_type<type_, type_>
{
    static const bool result = true;
};

/***********************************************************************************************************/
/* defined *************************************************************************************************/
/***********************************************************************************************************/

template<typename type_>
struct defined
{
    static const bool value = true;
};

/***********************************************************************************************************/
/* compile_time_assert **************************************************************************************/
/***********************************************************************************************************/

template<bool cond_>
struct compile_time_assert;

template<>
struct compile_time_assert<true>
{
    typedef void verified;
};

/***********************************************************************************************************/
/* remove **************************************************************************************************/
/***********************************************************************************************************/

template<typename type_, typename stencil_, typename other_>
struct remove_4
{
    typedef type_ type;
    typedef other_ other;
};

template<typename type_, typename stencil_, typename other_>
struct remove_4<volatile type_, volatile stencil_, other_>
{
    typedef type_ type;
    typedef volatile other_ other;
};

/***********************************************************************************************************/

template<typename type_, typename stencil_, typename other_>
struct remove_3
{
    typedef typename remove_4<type_, stencil_, other_>::type type;
    typedef typename remove_4<type_, stencil_, other_>::other other;
};

template<typename type_, typename stencil_, typename other_>
struct remove_3<const type_, const stencil_, other_>
{
    typedef typename remove_4<type_, stencil_, other_>::type type;
    typedef const typename remove_4<type_, stencil_, other_>::other other;
};

/***********************************************************************************************************/

template<typename type_, typename stencil_, typename other_>
struct remove_2
{
    typedef typename remove_3<type_, stencil_, other_>::type type;
    typedef typename remove_3<type_, stencil_, other_>::other other;
};

template<typename type_, typename stencil_, typename other_>
struct remove_2<type_*, stencil_*, other_>
{
    typedef typename remove_3<type_, stencil_, other_>::type type;
    typedef typename remove_3<type_, stencil_, other_>::other* other;
};

/***********************************************************************************************************/

template<typename type_, typename stencil_, typename other_>
struct remove_1
{
    typedef typename remove_2<type_, stencil_, other_>::type type;
    typedef typename remove_2<type_, stencil_, other_>::other other;
};

template<typename type_, typename stencil_, typename other_>
struct remove_1<type_&, stencil_&, other_>
{
    typedef typename remove_2<type_, stencil_, other_>::type type;
    typedef typename remove_2<type_, stencil_, other_>::other& other;
};

/***********************************************************************************************************/

template<typename type_, typename stencil_, typename other_=int>
struct remove
{
    typedef typename remove_1<type_, stencil_, other_>::type type;
    typedef typename remove_1<type_, stencil_, other_>::other other;
};

/***********************************************************************************************************/
/* size_to_signature ***************************************************************************************/
/***********************************************************************************************************/

template<typename dim_type_>
struct dim_type_to_sig;

template<>
struct dim_type_to_sig<int>
{ static const int n = 1; };

template<int n_>
struct dim_type_to_sig<constant<int, n_> >
{ static const int n = n_; };

template<typename size_type_, typename value_type_>
struct size_to_signature;


template<
    typename value_type_>
struct size_to_signature<pack<
    >,
    value_type_>
{
    typedef value_type_ type
    ;
};

template<
    typename type0_,
    typename value_type_>
struct size_to_signature<pack<
    type0_
    >,
    value_type_>
{
    typedef value_type_ type
        [dim_type_to_sig<type0_>::n]
    ;
};

template<
    typename type0_,
    typename type1_,
    typename value_type_>
struct size_to_signature<pack<
    type0_,
    type1_
    >,
    value_type_>
{
    typedef value_type_ type
        [dim_type_to_sig<type0_>::n]
        [dim_type_to_sig<type1_>::n]
    ;
};

template<
    typename type0_,
    typename type1_,
    typename type2_,
    typename value_type_>
struct size_to_signature<pack<
    type0_,
    type1_,
    type2_
    >,
    value_type_>
{
    typedef value_type_ type
        [dim_type_to_sig<type0_>::n]
        [dim_type_to_sig<type1_>::n]
        [dim_type_to_sig<type2_>::n]
    ;
};

} // namespace detail

/***********************************************************************************************************/
/* size_mismatch_error *************************************************************************************/
/***********************************************************************************************************/

/*! 
	\brief A mismatch between the sizes of two arrays in an operation or invalid size for a single array.

	\ingroup array_exceptions
*/
class size_mismatch_error
    : public std::runtime_error
{
public:
    size_mismatch_error(const std::string& msg ="")
        : std::runtime_error(msg) 
    {}

    ~size_mismatch_error() throw() {}
};

/***********************************************************************************************************/
/* pack ****************************************************************************************************/
/***********************************************************************************************************/

/*! 
    \brief This class can be used to encapsulate an element of a lite::pack as a constant element.

    \ingroup array_tools
    
    Encapsulating a pack element with this class tells the pack object not to allocate memory 
    for that element. See lite::pack for a more information.

    \param type_ specifies the type of the element
    \param value_ specifies the constant value of the element.

    \remark since a constant element is implement as a static const member of the pack with an in class 
    initializer, the \a type_ should be of integral type.
*/
template<typename type_, type_ value_>
class constant 
{
public:
    typedef type_ type; //!< element type
    static const type_ value = value_; //!< element value
};

template<typename type_, type_ value_>
const type_ constant<type_, value_>::value;

#ifdef DOCUMENTATION_ONLY
/*!
    \brief 
    This is a general tuple class that can pack together elements of different types. Furthermore, 
    individual elements can be marked as constant so that they won't occupy memory in the pack object.

    \ingroup array_tools
    A pack object can have from 0 upto #LITE_ARRAY_MAX_PACKS elements (see \ref array_template_params on
    how to change the limits). The elements are declared public and names \c i0, \c i1 ...  
    For any X in [0,N], If the type of element \c iX  which we denote by \a typeX_ 
    is \c lite::constant<typeX__,valueX_> then the element iX will be a static const of type \a typeX__ 
    and with the constant value of \a valueX_.
    Otherwise it will be a normal class member of type \a typeX_. The name of the element X variable 
    is \a iX . The following is te pseudo class definition of the pack class.

    \code 
template<typename type0_ ... , typename typeN_>
class pack
{
public:
    static const int n = N+1; 

    typedef ??? type0; // type of element 0
            .
            .
            .
    typedef ??? typeN; // type of element N

    static const bool is_const0 = ???; // true if element 0 is a static constant
            .
            .
            .
    static const bool is_constN = ???; // true if element 0 is a static constant

    static const bool is_all_const = ???; // true if all elements are static constant and the pack is empty

    // if element 0 is constant then:
    static const type0 i0 = value0_; 
    // otherwise:
    type0 i0;
            .
            .
            .
    // if element N is constant then:
    static const typeN iN = valueN_; 
    // otherwise:
    typeN iN;

    pack();
    
    pack(const type0& a0);

    pack(const type0& a0, ... , const typeN& aN);

    template<typename other_type0_, ... , typename other_typeN_>
    pack(const pack<other_type0_, ... , other_typeN_>& other);

    pack& 
    operator= (const pack& other);

    template<typename other_type0_, ... , typename other_typeN_>
    pack& 
    operator= (const pack<other_type0_, ... , other_typeN_>& other);

    void set(const type0& a0, ... , const typeN& aN);
};

\endcode 
    \par Example:

\code 
    pack<int, constant<int, 5>, std::string> p(1, 0, "hello");

    std::cout << p << std::endl;
\endcode 
    The output would be:
\verbatim
    1 5 hello
\endverbatim
*/
template<typename type0_ ..., typename typeN_>
class pack
{
public:
    static const int n = N+1; //!< The number of element is the pack (i.e. the number of template parameters)

    typedef ... typeX; //!< type of element X where (0<= X <= N)

    static const bool is_constX = ...; //!< true if element X is a static const where (0<= X <= N)

    static const bool is_all_const = ...; //!< true if all elements are static const and the pack is empty

    static const typeX iX = valueX_; //!< definition of element X if marked as constant where (0<= X <= N)
    
    typeX iX; //!< definition of element X if not marked as constant where (0<= X <= N)

    //! All non-static elements are initialized to their default value
    pack();
    
    //! All non-static elements are initialized to their default value except \a i0 is initialized to \a a0
    pack(const type0& a0);

    //! All non-static elements are initialized to the corresponding supplied value. The rest are ignored.
    pack(const type0& a0, ... , const typeN& aN);

    //! All non-static elements are initialized to the corresponding supplied value. The rest are ignored.
    template<typename other_type0_, ... , typename other_typeN_>
    pack(const pack<other_type0_, ... , other_typeN_>& other);

    //! All non-static elements are copied from \a other.
    pack& 
    operator= (const pack& other);

    //! All non-static elements are copied from \a other.
    template<typename other_type0_, ... , typename other_typeN_>
    pack& 
    operator= (const pack<other_type0_, ... , other_typeN_>& other);

    //! All non-static elements are set to the corresponding supplied value.
    void set(const type0& a0, ... , const typeN& aN);
};

#else // DOCUMENTATION_ONLY

template<
    typename type0_,
    typename type1_,
    typename type2_,
    typename type3_
    >
class pack
{
public:
    static const int n = 4;

    typedef type0_ type0;
    typedef type1_ type1;
    typedef type2_ type2;
    typedef type3_ type3;

    static const bool is_const0 = false;
    static const bool is_const1 = false;
    static const bool is_const2 = false;
    static const bool is_const3 = false;
    static const bool is_all_const = false;
    type0 i0;
    type1 i1;
    type2 i2;
    type3 i3;

    LITE_INLINE pack() 
        : i0(),i1(),i2(),i3()    {}
    
    LITE_INLINE pack(const type0& a0)
        : i0(a0) 
     {}

    LITE_INLINE pack(
        const type0& a0,
        const type1& a1,
        const type2& a2,
        const type3& a3
        ) : i0(a0), i1(a1), i2(a2), i3(a3) {}

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ ,
        typename other_type3_ 
    >
    LITE_INLINE pack(const pack<
        other_type0_,
        other_type1_,
        other_type2_,
        other_type3_
        >& other) : i0(other.i0), i1(other.i1), i2(other.i2), i3(other.i3)    {}

    LITE_INLINE pack& 
    operator= (const pack& other) 
    {
        i0 = other.i0;
        i1 = other.i1;
        i2 = other.i2;
        i3 = other.i3;
        return *this;
    }

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ ,
        typename other_type3_ 
    >
    LITE_INLINE pack&  
    operator=(const pack<
        other_type0_,
        other_type1_,
        other_type2_,
        other_type3_
        >& other) 
    {
        i0 = other.i0;
        i1 = other.i1;
        i2 = other.i2;
        i3 = other.i3;
        return *this;
    }

    LITE_INLINE void set(
        const type0& a0,
        const type1& a1,
        const type2& a2,
        const type3& a3
        ) 
    {
            i0 = a0;
            i1 = a1;
            i2 = a2;
            i3 = a3;
    }
};


/***********************************************************************************************************/
template<
    typename type0_, type0_ value0_,
    typename type1_,
    typename type2_,
    typename type3_
    >
class pack<
    constant<type0_, value0_>,
    type1_,
    type2_,
    type3_
    >
{
public:
    static const int n = 4;

    typedef type0_ type0;
    typedef type1_ type1;
    typedef type2_ type2;
    typedef type3_ type3;

    static const bool is_const0 = true;
    static const bool is_const1 = false;
    static const bool is_const2 = false;
    static const bool is_const3 = false;
    static const bool is_all_const = false;
    static const type0 i0 = value0_;
    type1 i1;
    type2 i2;
    type3 i3;

    LITE_INLINE pack() 
        : i1(),i2(),i3()    {}
    
    LITE_INLINE pack(const type0& )
     {}

    LITE_INLINE pack(
        const type0& ,
        const type1& a1,
        const type2& a2,
        const type3& a3
        ) : i1(a1), i2(a2), i3(a3) {}

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ ,
        typename other_type3_ 
    >
    LITE_INLINE pack(const pack<
        other_type0_,
        other_type1_,
        other_type2_,
        other_type3_
        >& other) : i1(other.i1), i2(other.i2), i3(other.i3)    {}

    LITE_INLINE pack& 
    operator= (const pack& other) 
    {
        i1 = other.i1;
        i2 = other.i2;
        i3 = other.i3;
        return *this;
    }

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ ,
        typename other_type3_ 
    >
    LITE_INLINE pack&  
    operator=(const pack<
        other_type0_,
        other_type1_,
        other_type2_,
        other_type3_
        >& other) 
    {
        i1 = other.i1;
        i2 = other.i2;
        i3 = other.i3;
        return *this;
    }

    LITE_INLINE void set(
        const type0& ,
        const type1& a1,
        const type2& a2,
        const type3& a3
        ) 
    {
            i1 = a1;
            i2 = a2;
            i3 = a3;
    }
};


template<
    typename type0_, type0_ value0_,
    typename type1_,
    typename type2_,
    typename type3_
    >
const type0_ pack<
    constant<type0_, value0_>,
    type1_,
    type2_,
    type3_
    >::i0;

/***********************************************************************************************************/
template<
    typename type0_,
    typename type1_, type1_ value1_,
    typename type2_,
    typename type3_
    >
class pack<
    type0_,
    constant<type1_, value1_>,
    type2_,
    type3_
    >
{
public:
    static const int n = 4;

    typedef type0_ type0;
    typedef type1_ type1;
    typedef type2_ type2;
    typedef type3_ type3;

    static const bool is_const0 = false;
    static const bool is_const1 = true;
    static const bool is_const2 = false;
    static const bool is_const3 = false;
    static const bool is_all_const = false;
    type0 i0;
    static const type1 i1 = value1_;
    type2 i2;
    type3 i3;

    LITE_INLINE pack() 
        : i0(),i2(),i3()    {}
    
    LITE_INLINE pack(const type0& a0)
        : i0(a0) 
     {}

    LITE_INLINE pack(
        const type0& a0,
        const type1& ,
        const type2& a2,
        const type3& a3
        ) : i0(a0), i2(a2), i3(a3) {}

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ ,
        typename other_type3_ 
    >
    LITE_INLINE pack(const pack<
        other_type0_,
        other_type1_,
        other_type2_,
        other_type3_
        >& other) : i0(other.i0), i2(other.i2), i3(other.i3)    {}

    LITE_INLINE pack& 
    operator= (const pack& other) 
    {
        i0 = other.i0;
        i2 = other.i2;
        i3 = other.i3;
        return *this;
    }

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ ,
        typename other_type3_ 
    >
    LITE_INLINE pack&  
    operator=(const pack<
        other_type0_,
        other_type1_,
        other_type2_,
        other_type3_
        >& other) 
    {
        i0 = other.i0;
        i2 = other.i2;
        i3 = other.i3;
        return *this;
    }

    LITE_INLINE void set(
        const type0& a0,
        const type1& ,
        const type2& a2,
        const type3& a3
        ) 
    {
            i0 = a0;
            i2 = a2;
            i3 = a3;
    }
};


template<
    typename type0_,
    typename type1_, type1_ value1_,
    typename type2_,
    typename type3_
    >
const type1_ pack<
    type0_,
    constant<type1_, value1_>,
    type2_,
    type3_
    >::i1;

/***********************************************************************************************************/
template<
    typename type0_, type0_ value0_,
    typename type1_, type1_ value1_,
    typename type2_,
    typename type3_
    >
class pack<
    constant<type0_, value0_>,
    constant<type1_, value1_>,
    type2_,
    type3_
    >
{
public:
    static const int n = 4;

    typedef type0_ type0;
    typedef type1_ type1;
    typedef type2_ type2;
    typedef type3_ type3;

    static const bool is_const0 = true;
    static const bool is_const1 = true;
    static const bool is_const2 = false;
    static const bool is_const3 = false;
    static const bool is_all_const = false;
    static const type0 i0 = value0_;
    static const type1 i1 = value1_;
    type2 i2;
    type3 i3;

    LITE_INLINE pack() 
        : i2(),i3()    {}
    
    LITE_INLINE pack(const type0& )
     {}

    LITE_INLINE pack(
        const type0& ,
        const type1& ,
        const type2& a2,
        const type3& a3
        ) : i2(a2), i3(a3) {}

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ ,
        typename other_type3_ 
    >
    LITE_INLINE pack(const pack<
        other_type0_,
        other_type1_,
        other_type2_,
        other_type3_
        >& other) : i2(other.i2), i3(other.i3)    {}

    LITE_INLINE pack& 
    operator= (const pack& other) 
    {
        i2 = other.i2;
        i3 = other.i3;
        return *this;
    }

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ ,
        typename other_type3_ 
    >
    LITE_INLINE pack&  
    operator=(const pack<
        other_type0_,
        other_type1_,
        other_type2_,
        other_type3_
        >& other) 
    {
        i2 = other.i2;
        i3 = other.i3;
        return *this;
    }

    LITE_INLINE void set(
        const type0& ,
        const type1& ,
        const type2& a2,
        const type3& a3
        ) 
    {
            i2 = a2;
            i3 = a3;
    }
};


template<
    typename type0_, type0_ value0_,
    typename type1_, type1_ value1_,
    typename type2_,
    typename type3_
    >
const type0_ pack<
    constant<type0_, value0_>,
    constant<type1_, value1_>,
    type2_,
    type3_
    >::i0;

template<
    typename type0_, type0_ value0_,
    typename type1_, type1_ value1_,
    typename type2_,
    typename type3_
    >
const type1_ pack<
    constant<type0_, value0_>,
    constant<type1_, value1_>,
    type2_,
    type3_
    >::i1;

/***********************************************************************************************************/
template<
    typename type0_,
    typename type1_,
    typename type2_, type2_ value2_,
    typename type3_
    >
class pack<
    type0_,
    type1_,
    constant<type2_, value2_>,
    type3_
    >
{
public:
    static const int n = 4;

    typedef type0_ type0;
    typedef type1_ type1;
    typedef type2_ type2;
    typedef type3_ type3;

    static const bool is_const0 = false;
    static const bool is_const1 = false;
    static const bool is_const2 = true;
    static const bool is_const3 = false;
    static const bool is_all_const = false;
    type0 i0;
    type1 i1;
    static const type2 i2 = value2_;
    type3 i3;

    LITE_INLINE pack() 
        : i0(),i1(),i3()    {}
    
    LITE_INLINE pack(const type0& a0)
        : i0(a0) 
     {}

    LITE_INLINE pack(
        const type0& a0,
        const type1& a1,
        const type2& ,
        const type3& a3
        ) : i0(a0), i1(a1), i3(a3) {}

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ ,
        typename other_type3_ 
    >
    LITE_INLINE pack(const pack<
        other_type0_,
        other_type1_,
        other_type2_,
        other_type3_
        >& other) : i0(other.i0), i1(other.i1), i3(other.i3)    {}

    LITE_INLINE pack& 
    operator= (const pack& other) 
    {
        i0 = other.i0;
        i1 = other.i1;
        i3 = other.i3;
        return *this;
    }

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ ,
        typename other_type3_ 
    >
    LITE_INLINE pack&  
    operator=(const pack<
        other_type0_,
        other_type1_,
        other_type2_,
        other_type3_
        >& other) 
    {
        i0 = other.i0;
        i1 = other.i1;
        i3 = other.i3;
        return *this;
    }

    LITE_INLINE void set(
        const type0& a0,
        const type1& a1,
        const type2& ,
        const type3& a3
        ) 
    {
            i0 = a0;
            i1 = a1;
            i3 = a3;
    }
};


template<
    typename type0_,
    typename type1_,
    typename type2_, type2_ value2_,
    typename type3_
    >
const type2_ pack<
    type0_,
    type1_,
    constant<type2_, value2_>,
    type3_
    >::i2;

/***********************************************************************************************************/
template<
    typename type0_, type0_ value0_,
    typename type1_,
    typename type2_, type2_ value2_,
    typename type3_
    >
class pack<
    constant<type0_, value0_>,
    type1_,
    constant<type2_, value2_>,
    type3_
    >
{
public:
    static const int n = 4;

    typedef type0_ type0;
    typedef type1_ type1;
    typedef type2_ type2;
    typedef type3_ type3;

    static const bool is_const0 = true;
    static const bool is_const1 = false;
    static const bool is_const2 = true;
    static const bool is_const3 = false;
    static const bool is_all_const = false;
    static const type0 i0 = value0_;
    type1 i1;
    static const type2 i2 = value2_;
    type3 i3;

    LITE_INLINE pack() 
        : i1(),i3()    {}
    
    LITE_INLINE pack(const type0& )
     {}

    LITE_INLINE pack(
        const type0& ,
        const type1& a1,
        const type2& ,
        const type3& a3
        ) : i1(a1), i3(a3) {}

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ ,
        typename other_type3_ 
    >
    LITE_INLINE pack(const pack<
        other_type0_,
        other_type1_,
        other_type2_,
        other_type3_
        >& other) : i1(other.i1), i3(other.i3)    {}

    LITE_INLINE pack& 
    operator= (const pack& other) 
    {
        i1 = other.i1;
        i3 = other.i3;
        return *this;
    }

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ ,
        typename other_type3_ 
    >
    LITE_INLINE pack&  
    operator=(const pack<
        other_type0_,
        other_type1_,
        other_type2_,
        other_type3_
        >& other) 
    {
        i1 = other.i1;
        i3 = other.i3;
        return *this;
    }

    LITE_INLINE void set(
        const type0& ,
        const type1& a1,
        const type2& ,
        const type3& a3
        ) 
    {
            i1 = a1;
            i3 = a3;
    }
};


template<
    typename type0_, type0_ value0_,
    typename type1_,
    typename type2_, type2_ value2_,
    typename type3_
    >
const type0_ pack<
    constant<type0_, value0_>,
    type1_,
    constant<type2_, value2_>,
    type3_
    >::i0;

template<
    typename type0_, type0_ value0_,
    typename type1_,
    typename type2_, type2_ value2_,
    typename type3_
    >
const type2_ pack<
    constant<type0_, value0_>,
    type1_,
    constant<type2_, value2_>,
    type3_
    >::i2;

/***********************************************************************************************************/
template<
    typename type0_,
    typename type1_, type1_ value1_,
    typename type2_, type2_ value2_,
    typename type3_
    >
class pack<
    type0_,
    constant<type1_, value1_>,
    constant<type2_, value2_>,
    type3_
    >
{
public:
    static const int n = 4;

    typedef type0_ type0;
    typedef type1_ type1;
    typedef type2_ type2;
    typedef type3_ type3;

    static const bool is_const0 = false;
    static const bool is_const1 = true;
    static const bool is_const2 = true;
    static const bool is_const3 = false;
    static const bool is_all_const = false;
    type0 i0;
    static const type1 i1 = value1_;
    static const type2 i2 = value2_;
    type3 i3;

    LITE_INLINE pack() 
        : i0(),i3()    {}
    
    LITE_INLINE pack(const type0& a0)
        : i0(a0) 
     {}

    LITE_INLINE pack(
        const type0& a0,
        const type1& ,
        const type2& ,
        const type3& a3
        ) : i0(a0), i3(a3) {}

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ ,
        typename other_type3_ 
    >
    LITE_INLINE pack(const pack<
        other_type0_,
        other_type1_,
        other_type2_,
        other_type3_
        >& other) : i0(other.i0), i3(other.i3)    {}

    LITE_INLINE pack& 
    operator= (const pack& other) 
    {
        i0 = other.i0;
        i3 = other.i3;
        return *this;
    }

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ ,
        typename other_type3_ 
    >
    LITE_INLINE pack&  
    operator=(const pack<
        other_type0_,
        other_type1_,
        other_type2_,
        other_type3_
        >& other) 
    {
        i0 = other.i0;
        i3 = other.i3;
        return *this;
    }

    LITE_INLINE void set(
        const type0& a0,
        const type1& ,
        const type2& ,
        const type3& a3
        ) 
    {
            i0 = a0;
            i3 = a3;
    }
};


template<
    typename type0_,
    typename type1_, type1_ value1_,
    typename type2_, type2_ value2_,
    typename type3_
    >
const type1_ pack<
    type0_,
    constant<type1_, value1_>,
    constant<type2_, value2_>,
    type3_
    >::i1;

template<
    typename type0_,
    typename type1_, type1_ value1_,
    typename type2_, type2_ value2_,
    typename type3_
    >
const type2_ pack<
    type0_,
    constant<type1_, value1_>,
    constant<type2_, value2_>,
    type3_
    >::i2;

/***********************************************************************************************************/
template<
    typename type0_, type0_ value0_,
    typename type1_, type1_ value1_,
    typename type2_, type2_ value2_,
    typename type3_
    >
class pack<
    constant<type0_, value0_>,
    constant<type1_, value1_>,
    constant<type2_, value2_>,
    type3_
    >
{
public:
    static const int n = 4;

    typedef type0_ type0;
    typedef type1_ type1;
    typedef type2_ type2;
    typedef type3_ type3;

    static const bool is_const0 = true;
    static const bool is_const1 = true;
    static const bool is_const2 = true;
    static const bool is_const3 = false;
    static const bool is_all_const = false;
    static const type0 i0 = value0_;
    static const type1 i1 = value1_;
    static const type2 i2 = value2_;
    type3 i3;

    LITE_INLINE pack() 
        : i3()    {}
    
    LITE_INLINE pack(const type0& )
     {}

    LITE_INLINE pack(
        const type0& ,
        const type1& ,
        const type2& ,
        const type3& a3
        ) : i3(a3) {}

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ ,
        typename other_type3_ 
    >
    LITE_INLINE pack(const pack<
        other_type0_,
        other_type1_,
        other_type2_,
        other_type3_
        >& other) : i3(other.i3)    {}

    LITE_INLINE pack& 
    operator= (const pack& other) 
    {
        i3 = other.i3;
        return *this;
    }

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ ,
        typename other_type3_ 
    >
    LITE_INLINE pack&  
    operator=(const pack<
        other_type0_,
        other_type1_,
        other_type2_,
        other_type3_
        >& other) 
    {
        i3 = other.i3;
        return *this;
    }

    LITE_INLINE void set(
        const type0& ,
        const type1& ,
        const type2& ,
        const type3& a3
        ) 
    {
            i3 = a3;
    }
};


template<
    typename type0_, type0_ value0_,
    typename type1_, type1_ value1_,
    typename type2_, type2_ value2_,
    typename type3_
    >
const type0_ pack<
    constant<type0_, value0_>,
    constant<type1_, value1_>,
    constant<type2_, value2_>,
    type3_
    >::i0;

template<
    typename type0_, type0_ value0_,
    typename type1_, type1_ value1_,
    typename type2_, type2_ value2_,
    typename type3_
    >
const type1_ pack<
    constant<type0_, value0_>,
    constant<type1_, value1_>,
    constant<type2_, value2_>,
    type3_
    >::i1;

template<
    typename type0_, type0_ value0_,
    typename type1_, type1_ value1_,
    typename type2_, type2_ value2_,
    typename type3_
    >
const type2_ pack<
    constant<type0_, value0_>,
    constant<type1_, value1_>,
    constant<type2_, value2_>,
    type3_
    >::i2;

/***********************************************************************************************************/
template<
    typename type0_,
    typename type1_,
    typename type2_,
    typename type3_, type3_ value3_
    >
class pack<
    type0_,
    type1_,
    type2_,
    constant<type3_, value3_>
    >
{
public:
    static const int n = 4;

    typedef type0_ type0;
    typedef type1_ type1;
    typedef type2_ type2;
    typedef type3_ type3;

    static const bool is_const0 = false;
    static const bool is_const1 = false;
    static const bool is_const2 = false;
    static const bool is_const3 = true;
    static const bool is_all_const = false;
    type0 i0;
    type1 i1;
    type2 i2;
    static const type3 i3 = value3_;

    LITE_INLINE pack() 
        : i0(),i1(),i2()    {}
    
    LITE_INLINE pack(const type0& a0)
        : i0(a0) 
     {}

    LITE_INLINE pack(
        const type0& a0,
        const type1& a1,
        const type2& a2,
        const type3& 
        ) : i0(a0), i1(a1), i2(a2) {}

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ ,
        typename other_type3_ 
    >
    LITE_INLINE pack(const pack<
        other_type0_,
        other_type1_,
        other_type2_,
        other_type3_
        >& other) : i0(other.i0), i1(other.i1), i2(other.i2)    {}

    LITE_INLINE pack& 
    operator= (const pack& other) 
    {
        i0 = other.i0;
        i1 = other.i1;
        i2 = other.i2;
        return *this;
    }

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ ,
        typename other_type3_ 
    >
    LITE_INLINE pack&  
    operator=(const pack<
        other_type0_,
        other_type1_,
        other_type2_,
        other_type3_
        >& other) 
    {
        i0 = other.i0;
        i1 = other.i1;
        i2 = other.i2;
        return *this;
    }

    LITE_INLINE void set(
        const type0& a0,
        const type1& a1,
        const type2& a2,
        const type3& 
        ) 
    {
            i0 = a0;
            i1 = a1;
            i2 = a2;
    }
};


template<
    typename type0_,
    typename type1_,
    typename type2_,
    typename type3_, type3_ value3_
    >
const type3_ pack<
    type0_,
    type1_,
    type2_,
    constant<type3_, value3_>
    >::i3;

/***********************************************************************************************************/
template<
    typename type0_, type0_ value0_,
    typename type1_,
    typename type2_,
    typename type3_, type3_ value3_
    >
class pack<
    constant<type0_, value0_>,
    type1_,
    type2_,
    constant<type3_, value3_>
    >
{
public:
    static const int n = 4;

    typedef type0_ type0;
    typedef type1_ type1;
    typedef type2_ type2;
    typedef type3_ type3;

    static const bool is_const0 = true;
    static const bool is_const1 = false;
    static const bool is_const2 = false;
    static const bool is_const3 = true;
    static const bool is_all_const = false;
    static const type0 i0 = value0_;
    type1 i1;
    type2 i2;
    static const type3 i3 = value3_;

    LITE_INLINE pack() 
        : i1(),i2()    {}
    
    LITE_INLINE pack(const type0& )
     {}

    LITE_INLINE pack(
        const type0& ,
        const type1& a1,
        const type2& a2,
        const type3& 
        ) : i1(a1), i2(a2) {}

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ ,
        typename other_type3_ 
    >
    LITE_INLINE pack(const pack<
        other_type0_,
        other_type1_,
        other_type2_,
        other_type3_
        >& other) : i1(other.i1), i2(other.i2)    {}

    LITE_INLINE pack& 
    operator= (const pack& other) 
    {
        i1 = other.i1;
        i2 = other.i2;
        return *this;
    }

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ ,
        typename other_type3_ 
    >
    LITE_INLINE pack&  
    operator=(const pack<
        other_type0_,
        other_type1_,
        other_type2_,
        other_type3_
        >& other) 
    {
        i1 = other.i1;
        i2 = other.i2;
        return *this;
    }

    LITE_INLINE void set(
        const type0& ,
        const type1& a1,
        const type2& a2,
        const type3& 
        ) 
    {
            i1 = a1;
            i2 = a2;
    }
};


template<
    typename type0_, type0_ value0_,
    typename type1_,
    typename type2_,
    typename type3_, type3_ value3_
    >
const type0_ pack<
    constant<type0_, value0_>,
    type1_,
    type2_,
    constant<type3_, value3_>
    >::i0;

template<
    typename type0_, type0_ value0_,
    typename type1_,
    typename type2_,
    typename type3_, type3_ value3_
    >
const type3_ pack<
    constant<type0_, value0_>,
    type1_,
    type2_,
    constant<type3_, value3_>
    >::i3;

/***********************************************************************************************************/
template<
    typename type0_,
    typename type1_, type1_ value1_,
    typename type2_,
    typename type3_, type3_ value3_
    >
class pack<
    type0_,
    constant<type1_, value1_>,
    type2_,
    constant<type3_, value3_>
    >
{
public:
    static const int n = 4;

    typedef type0_ type0;
    typedef type1_ type1;
    typedef type2_ type2;
    typedef type3_ type3;

    static const bool is_const0 = false;
    static const bool is_const1 = true;
    static const bool is_const2 = false;
    static const bool is_const3 = true;
    static const bool is_all_const = false;
    type0 i0;
    static const type1 i1 = value1_;
    type2 i2;
    static const type3 i3 = value3_;

    LITE_INLINE pack() 
        : i0(),i2()    {}
    
    LITE_INLINE pack(const type0& a0)
        : i0(a0) 
     {}

    LITE_INLINE pack(
        const type0& a0,
        const type1& ,
        const type2& a2,
        const type3& 
        ) : i0(a0), i2(a2) {}

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ ,
        typename other_type3_ 
    >
    LITE_INLINE pack(const pack<
        other_type0_,
        other_type1_,
        other_type2_,
        other_type3_
        >& other) : i0(other.i0), i2(other.i2)    {}

    LITE_INLINE pack& 
    operator= (const pack& other) 
    {
        i0 = other.i0;
        i2 = other.i2;
        return *this;
    }

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ ,
        typename other_type3_ 
    >
    LITE_INLINE pack&  
    operator=(const pack<
        other_type0_,
        other_type1_,
        other_type2_,
        other_type3_
        >& other) 
    {
        i0 = other.i0;
        i2 = other.i2;
        return *this;
    }

    LITE_INLINE void set(
        const type0& a0,
        const type1& ,
        const type2& a2,
        const type3& 
        ) 
    {
            i0 = a0;
            i2 = a2;
    }
};


template<
    typename type0_,
    typename type1_, type1_ value1_,
    typename type2_,
    typename type3_, type3_ value3_
    >
const type1_ pack<
    type0_,
    constant<type1_, value1_>,
    type2_,
    constant<type3_, value3_>
    >::i1;

template<
    typename type0_,
    typename type1_, type1_ value1_,
    typename type2_,
    typename type3_, type3_ value3_
    >
const type3_ pack<
    type0_,
    constant<type1_, value1_>,
    type2_,
    constant<type3_, value3_>
    >::i3;

/***********************************************************************************************************/
template<
    typename type0_, type0_ value0_,
    typename type1_, type1_ value1_,
    typename type2_,
    typename type3_, type3_ value3_
    >
class pack<
    constant<type0_, value0_>,
    constant<type1_, value1_>,
    type2_,
    constant<type3_, value3_>
    >
{
public:
    static const int n = 4;

    typedef type0_ type0;
    typedef type1_ type1;
    typedef type2_ type2;
    typedef type3_ type3;

    static const bool is_const0 = true;
    static const bool is_const1 = true;
    static const bool is_const2 = false;
    static const bool is_const3 = true;
    static const bool is_all_const = false;
    static const type0 i0 = value0_;
    static const type1 i1 = value1_;
    type2 i2;
    static const type3 i3 = value3_;

    LITE_INLINE pack() 
        : i2()    {}
    
    LITE_INLINE pack(const type0& )
     {}

    LITE_INLINE pack(
        const type0& ,
        const type1& ,
        const type2& a2,
        const type3& 
        ) : i2(a2) {}

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ ,
        typename other_type3_ 
    >
    LITE_INLINE pack(const pack<
        other_type0_,
        other_type1_,
        other_type2_,
        other_type3_
        >& other) : i2(other.i2)    {}

    LITE_INLINE pack& 
    operator= (const pack& other) 
    {
        i2 = other.i2;
        return *this;
    }

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ ,
        typename other_type3_ 
    >
    LITE_INLINE pack&  
    operator=(const pack<
        other_type0_,
        other_type1_,
        other_type2_,
        other_type3_
        >& other) 
    {
        i2 = other.i2;
        return *this;
    }

    LITE_INLINE void set(
        const type0& ,
        const type1& ,
        const type2& a2,
        const type3& 
        ) 
    {
            i2 = a2;
    }
};


template<
    typename type0_, type0_ value0_,
    typename type1_, type1_ value1_,
    typename type2_,
    typename type3_, type3_ value3_
    >
const type0_ pack<
    constant<type0_, value0_>,
    constant<type1_, value1_>,
    type2_,
    constant<type3_, value3_>
    >::i0;

template<
    typename type0_, type0_ value0_,
    typename type1_, type1_ value1_,
    typename type2_,
    typename type3_, type3_ value3_
    >
const type1_ pack<
    constant<type0_, value0_>,
    constant<type1_, value1_>,
    type2_,
    constant<type3_, value3_>
    >::i1;

template<
    typename type0_, type0_ value0_,
    typename type1_, type1_ value1_,
    typename type2_,
    typename type3_, type3_ value3_
    >
const type3_ pack<
    constant<type0_, value0_>,
    constant<type1_, value1_>,
    type2_,
    constant<type3_, value3_>
    >::i3;

/***********************************************************************************************************/
template<
    typename type0_,
    typename type1_,
    typename type2_, type2_ value2_,
    typename type3_, type3_ value3_
    >
class pack<
    type0_,
    type1_,
    constant<type2_, value2_>,
    constant<type3_, value3_>
    >
{
public:
    static const int n = 4;

    typedef type0_ type0;
    typedef type1_ type1;
    typedef type2_ type2;
    typedef type3_ type3;

    static const bool is_const0 = false;
    static const bool is_const1 = false;
    static const bool is_const2 = true;
    static const bool is_const3 = true;
    static const bool is_all_const = false;
    type0 i0;
    type1 i1;
    static const type2 i2 = value2_;
    static const type3 i3 = value3_;

    LITE_INLINE pack() 
        : i0(),i1()    {}
    
    LITE_INLINE pack(const type0& a0)
        : i0(a0) 
     {}

    LITE_INLINE pack(
        const type0& a0,
        const type1& a1,
        const type2& ,
        const type3& 
        ) : i0(a0), i1(a1) {}

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ ,
        typename other_type3_ 
    >
    LITE_INLINE pack(const pack<
        other_type0_,
        other_type1_,
        other_type2_,
        other_type3_
        >& other) : i0(other.i0), i1(other.i1)    {}

    LITE_INLINE pack& 
    operator= (const pack& other) 
    {
        i0 = other.i0;
        i1 = other.i1;
        return *this;
    }

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ ,
        typename other_type3_ 
    >
    LITE_INLINE pack&  
    operator=(const pack<
        other_type0_,
        other_type1_,
        other_type2_,
        other_type3_
        >& other) 
    {
        i0 = other.i0;
        i1 = other.i1;
        return *this;
    }

    LITE_INLINE void set(
        const type0& a0,
        const type1& a1,
        const type2& ,
        const type3& 
        ) 
    {
            i0 = a0;
            i1 = a1;
    }
};


template<
    typename type0_,
    typename type1_,
    typename type2_, type2_ value2_,
    typename type3_, type3_ value3_
    >
const type2_ pack<
    type0_,
    type1_,
    constant<type2_, value2_>,
    constant<type3_, value3_>
    >::i2;

template<
    typename type0_,
    typename type1_,
    typename type2_, type2_ value2_,
    typename type3_, type3_ value3_
    >
const type3_ pack<
    type0_,
    type1_,
    constant<type2_, value2_>,
    constant<type3_, value3_>
    >::i3;

/***********************************************************************************************************/
template<
    typename type0_, type0_ value0_,
    typename type1_,
    typename type2_, type2_ value2_,
    typename type3_, type3_ value3_
    >
class pack<
    constant<type0_, value0_>,
    type1_,
    constant<type2_, value2_>,
    constant<type3_, value3_>
    >
{
public:
    static const int n = 4;

    typedef type0_ type0;
    typedef type1_ type1;
    typedef type2_ type2;
    typedef type3_ type3;

    static const bool is_const0 = true;
    static const bool is_const1 = false;
    static const bool is_const2 = true;
    static const bool is_const3 = true;
    static const bool is_all_const = false;
    static const type0 i0 = value0_;
    type1 i1;
    static const type2 i2 = value2_;
    static const type3 i3 = value3_;

    LITE_INLINE pack() 
        : i1()    {}
    
    LITE_INLINE pack(const type0& )
     {}

    LITE_INLINE pack(
        const type0& ,
        const type1& a1,
        const type2& ,
        const type3& 
        ) : i1(a1) {}

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ ,
        typename other_type3_ 
    >
    LITE_INLINE pack(const pack<
        other_type0_,
        other_type1_,
        other_type2_,
        other_type3_
        >& other) : i1(other.i1)    {}

    LITE_INLINE pack& 
    operator= (const pack& other) 
    {
        i1 = other.i1;
        return *this;
    }

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ ,
        typename other_type3_ 
    >
    LITE_INLINE pack&  
    operator=(const pack<
        other_type0_,
        other_type1_,
        other_type2_,
        other_type3_
        >& other) 
    {
        i1 = other.i1;
        return *this;
    }

    LITE_INLINE void set(
        const type0& ,
        const type1& a1,
        const type2& ,
        const type3& 
        ) 
    {
            i1 = a1;
    }
};


template<
    typename type0_, type0_ value0_,
    typename type1_,
    typename type2_, type2_ value2_,
    typename type3_, type3_ value3_
    >
const type0_ pack<
    constant<type0_, value0_>,
    type1_,
    constant<type2_, value2_>,
    constant<type3_, value3_>
    >::i0;

template<
    typename type0_, type0_ value0_,
    typename type1_,
    typename type2_, type2_ value2_,
    typename type3_, type3_ value3_
    >
const type2_ pack<
    constant<type0_, value0_>,
    type1_,
    constant<type2_, value2_>,
    constant<type3_, value3_>
    >::i2;

template<
    typename type0_, type0_ value0_,
    typename type1_,
    typename type2_, type2_ value2_,
    typename type3_, type3_ value3_
    >
const type3_ pack<
    constant<type0_, value0_>,
    type1_,
    constant<type2_, value2_>,
    constant<type3_, value3_>
    >::i3;

/***********************************************************************************************************/
template<
    typename type0_,
    typename type1_, type1_ value1_,
    typename type2_, type2_ value2_,
    typename type3_, type3_ value3_
    >
class pack<
    type0_,
    constant<type1_, value1_>,
    constant<type2_, value2_>,
    constant<type3_, value3_>
    >
{
public:
    static const int n = 4;

    typedef type0_ type0;
    typedef type1_ type1;
    typedef type2_ type2;
    typedef type3_ type3;

    static const bool is_const0 = false;
    static const bool is_const1 = true;
    static const bool is_const2 = true;
    static const bool is_const3 = true;
    static const bool is_all_const = false;
    type0 i0;
    static const type1 i1 = value1_;
    static const type2 i2 = value2_;
    static const type3 i3 = value3_;

    LITE_INLINE pack() 
        : i0()    {}
    
    LITE_INLINE pack(const type0& a0)
        : i0(a0) 
     {}

    LITE_INLINE pack(
        const type0& a0,
        const type1& ,
        const type2& ,
        const type3& 
        ) : i0(a0) {}

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ ,
        typename other_type3_ 
    >
    LITE_INLINE pack(const pack<
        other_type0_,
        other_type1_,
        other_type2_,
        other_type3_
        >& other) : i0(other.i0)    {}

    LITE_INLINE pack& 
    operator= (const pack& other) 
    {
        i0 = other.i0;
        return *this;
    }

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ ,
        typename other_type3_ 
    >
    LITE_INLINE pack&  
    operator=(const pack<
        other_type0_,
        other_type1_,
        other_type2_,
        other_type3_
        >& other) 
    {
        i0 = other.i0;
        return *this;
    }

    LITE_INLINE void set(
        const type0& a0,
        const type1& ,
        const type2& ,
        const type3& 
        ) 
    {
            i0 = a0;
    }
};


template<
    typename type0_,
    typename type1_, type1_ value1_,
    typename type2_, type2_ value2_,
    typename type3_, type3_ value3_
    >
const type1_ pack<
    type0_,
    constant<type1_, value1_>,
    constant<type2_, value2_>,
    constant<type3_, value3_>
    >::i1;

template<
    typename type0_,
    typename type1_, type1_ value1_,
    typename type2_, type2_ value2_,
    typename type3_, type3_ value3_
    >
const type2_ pack<
    type0_,
    constant<type1_, value1_>,
    constant<type2_, value2_>,
    constant<type3_, value3_>
    >::i2;

template<
    typename type0_,
    typename type1_, type1_ value1_,
    typename type2_, type2_ value2_,
    typename type3_, type3_ value3_
    >
const type3_ pack<
    type0_,
    constant<type1_, value1_>,
    constant<type2_, value2_>,
    constant<type3_, value3_>
    >::i3;

/***********************************************************************************************************/
template<
    typename type0_, type0_ value0_,
    typename type1_, type1_ value1_,
    typename type2_, type2_ value2_,
    typename type3_, type3_ value3_
    >
class pack<
    constant<type0_, value0_>,
    constant<type1_, value1_>,
    constant<type2_, value2_>,
    constant<type3_, value3_>
    >
{
public:
    static const int n = 4;

    typedef type0_ type0;
    typedef type1_ type1;
    typedef type2_ type2;
    typedef type3_ type3;

    static const bool is_const0 = true;
    static const bool is_const1 = true;
    static const bool is_const2 = true;
    static const bool is_const3 = true;
    static const bool is_all_const = true;
    static const type0 i0 = value0_;
    static const type1 i1 = value1_;
    static const type2 i2 = value2_;
    static const type3 i3 = value3_;

    LITE_INLINE pack() 
             {}
    
    LITE_INLINE pack(const type0& )
     {}

    LITE_INLINE pack(
        const type0& ,
        const type1& ,
        const type2& ,
        const type3& 
        )  {}

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ ,
        typename other_type3_ 
    >
    LITE_INLINE pack(const pack<
        other_type0_,
        other_type1_,
        other_type2_,
        other_type3_
        >& )     {}

    LITE_INLINE pack& 
    operator= (const pack& ) 
    {
        return *this;
    }

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ ,
        typename other_type3_ 
    >
    LITE_INLINE pack&  
    operator=(const pack<
        other_type0_,
        other_type1_,
        other_type2_,
        other_type3_
        >& ) 
    {
        return *this;
    }

    LITE_INLINE void set(
        const type0& ,
        const type1& ,
        const type2& ,
        const type3& 
        ) 
    {
    }
};


template<
    typename type0_, type0_ value0_,
    typename type1_, type1_ value1_,
    typename type2_, type2_ value2_,
    typename type3_, type3_ value3_
    >
const type0_ pack<
    constant<type0_, value0_>,
    constant<type1_, value1_>,
    constant<type2_, value2_>,
    constant<type3_, value3_>
    >::i0;

template<
    typename type0_, type0_ value0_,
    typename type1_, type1_ value1_,
    typename type2_, type2_ value2_,
    typename type3_, type3_ value3_
    >
const type1_ pack<
    constant<type0_, value0_>,
    constant<type1_, value1_>,
    constant<type2_, value2_>,
    constant<type3_, value3_>
    >::i1;

template<
    typename type0_, type0_ value0_,
    typename type1_, type1_ value1_,
    typename type2_, type2_ value2_,
    typename type3_, type3_ value3_
    >
const type2_ pack<
    constant<type0_, value0_>,
    constant<type1_, value1_>,
    constant<type2_, value2_>,
    constant<type3_, value3_>
    >::i2;

template<
    typename type0_, type0_ value0_,
    typename type1_, type1_ value1_,
    typename type2_, type2_ value2_,
    typename type3_, type3_ value3_
    >
const type3_ pack<
    constant<type0_, value0_>,
    constant<type1_, value1_>,
    constant<type2_, value2_>,
    constant<type3_, value3_>
    >::i3;

/***********************************************************************************************************/
template<
    typename type0_,
    typename type1_,
    typename type2_
    >
class pack<
    type0_,
    type1_,
    type2_
    >
{
public:
    static const int n = 3;

    typedef type0_ type0;
    typedef type1_ type1;
    typedef type2_ type2;

    static const bool is_const0 = false;
    static const bool is_const1 = false;
    static const bool is_const2 = false;
    static const bool is_all_const = false;
    type0 i0;
    type1 i1;
    type2 i2;

    LITE_INLINE pack() 
        : i0(),i1(),i2()    {}
    
    LITE_INLINE pack(const type0& a0)
        : i0(a0) 
     {}

    LITE_INLINE pack(
        const type0& a0,
        const type1& a1,
        const type2& a2
        ) : i0(a0), i1(a1), i2(a2) {}

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ 
    >
    LITE_INLINE pack(const pack<
        other_type0_,
        other_type1_,
        other_type2_
        >& other) : i0(other.i0), i1(other.i1), i2(other.i2)    {}

    LITE_INLINE pack& 
    operator= (const pack& other) 
    {
        i0 = other.i0;
        i1 = other.i1;
        i2 = other.i2;
        return *this;
    }

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ 
    >
    LITE_INLINE pack&  
    operator=(const pack<
        other_type0_,
        other_type1_,
        other_type2_
        >& other) 
    {
        i0 = other.i0;
        i1 = other.i1;
        i2 = other.i2;
        return *this;
    }

    LITE_INLINE void set(
        const type0& a0,
        const type1& a1,
        const type2& a2
        ) 
    {
            i0 = a0;
            i1 = a1;
            i2 = a2;
    }
};


/***********************************************************************************************************/
template<
    typename type0_, type0_ value0_,
    typename type1_,
    typename type2_
    >
class pack<
    constant<type0_, value0_>,
    type1_,
    type2_
    >
{
public:
    static const int n = 3;

    typedef type0_ type0;
    typedef type1_ type1;
    typedef type2_ type2;

    static const bool is_const0 = true;
    static const bool is_const1 = false;
    static const bool is_const2 = false;
    static const bool is_all_const = false;
    static const type0 i0 = value0_;
    type1 i1;
    type2 i2;

    LITE_INLINE pack() 
        : i1(),i2()    {}
    
    LITE_INLINE pack(const type0& )
     {}

    LITE_INLINE pack(
        const type0& ,
        const type1& a1,
        const type2& a2
        ) : i1(a1), i2(a2) {}

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ 
    >
    LITE_INLINE pack(const pack<
        other_type0_,
        other_type1_,
        other_type2_
        >& other) : i1(other.i1), i2(other.i2)    {}

    LITE_INLINE pack& 
    operator= (const pack& other) 
    {
        i1 = other.i1;
        i2 = other.i2;
        return *this;
    }

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ 
    >
    LITE_INLINE pack&  
    operator=(const pack<
        other_type0_,
        other_type1_,
        other_type2_
        >& other) 
    {
        i1 = other.i1;
        i2 = other.i2;
        return *this;
    }

    LITE_INLINE void set(
        const type0& ,
        const type1& a1,
        const type2& a2
        ) 
    {
            i1 = a1;
            i2 = a2;
    }
};


template<
    typename type0_, type0_ value0_,
    typename type1_,
    typename type2_
    >
const type0_ pack<
    constant<type0_, value0_>,
    type1_,
    type2_
    >::i0;

/***********************************************************************************************************/
template<
    typename type0_,
    typename type1_, type1_ value1_,
    typename type2_
    >
class pack<
    type0_,
    constant<type1_, value1_>,
    type2_
    >
{
public:
    static const int n = 3;

    typedef type0_ type0;
    typedef type1_ type1;
    typedef type2_ type2;

    static const bool is_const0 = false;
    static const bool is_const1 = true;
    static const bool is_const2 = false;
    static const bool is_all_const = false;
    type0 i0;
    static const type1 i1 = value1_;
    type2 i2;

    LITE_INLINE pack() 
        : i0(),i2()    {}
    
    LITE_INLINE pack(const type0& a0)
        : i0(a0) 
     {}

    LITE_INLINE pack(
        const type0& a0,
        const type1& ,
        const type2& a2
        ) : i0(a0), i2(a2) {}

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ 
    >
    LITE_INLINE pack(const pack<
        other_type0_,
        other_type1_,
        other_type2_
        >& other) : i0(other.i0), i2(other.i2)    {}

    LITE_INLINE pack& 
    operator= (const pack& other) 
    {
        i0 = other.i0;
        i2 = other.i2;
        return *this;
    }

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ 
    >
    LITE_INLINE pack&  
    operator=(const pack<
        other_type0_,
        other_type1_,
        other_type2_
        >& other) 
    {
        i0 = other.i0;
        i2 = other.i2;
        return *this;
    }

    LITE_INLINE void set(
        const type0& a0,
        const type1& ,
        const type2& a2
        ) 
    {
            i0 = a0;
            i2 = a2;
    }
};


template<
    typename type0_,
    typename type1_, type1_ value1_,
    typename type2_
    >
const type1_ pack<
    type0_,
    constant<type1_, value1_>,
    type2_
    >::i1;

/***********************************************************************************************************/
template<
    typename type0_, type0_ value0_,
    typename type1_, type1_ value1_,
    typename type2_
    >
class pack<
    constant<type0_, value0_>,
    constant<type1_, value1_>,
    type2_
    >
{
public:
    static const int n = 3;

    typedef type0_ type0;
    typedef type1_ type1;
    typedef type2_ type2;

    static const bool is_const0 = true;
    static const bool is_const1 = true;
    static const bool is_const2 = false;
    static const bool is_all_const = false;
    static const type0 i0 = value0_;
    static const type1 i1 = value1_;
    type2 i2;

    LITE_INLINE pack() 
        : i2()    {}
    
    LITE_INLINE pack(const type0& )
     {}

    LITE_INLINE pack(
        const type0& ,
        const type1& ,
        const type2& a2
        ) : i2(a2) {}

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ 
    >
    LITE_INLINE pack(const pack<
        other_type0_,
        other_type1_,
        other_type2_
        >& other) : i2(other.i2)    {}

    LITE_INLINE pack& 
    operator= (const pack& other) 
    {
        i2 = other.i2;
        return *this;
    }

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ 
    >
    LITE_INLINE pack&  
    operator=(const pack<
        other_type0_,
        other_type1_,
        other_type2_
        >& other) 
    {
        i2 = other.i2;
        return *this;
    }

    LITE_INLINE void set(
        const type0& ,
        const type1& ,
        const type2& a2
        ) 
    {
            i2 = a2;
    }
};


template<
    typename type0_, type0_ value0_,
    typename type1_, type1_ value1_,
    typename type2_
    >
const type0_ pack<
    constant<type0_, value0_>,
    constant<type1_, value1_>,
    type2_
    >::i0;

template<
    typename type0_, type0_ value0_,
    typename type1_, type1_ value1_,
    typename type2_
    >
const type1_ pack<
    constant<type0_, value0_>,
    constant<type1_, value1_>,
    type2_
    >::i1;

/***********************************************************************************************************/
template<
    typename type0_,
    typename type1_,
    typename type2_, type2_ value2_
    >
class pack<
    type0_,
    type1_,
    constant<type2_, value2_>
    >
{
public:
    static const int n = 3;

    typedef type0_ type0;
    typedef type1_ type1;
    typedef type2_ type2;

    static const bool is_const0 = false;
    static const bool is_const1 = false;
    static const bool is_const2 = true;
    static const bool is_all_const = false;
    type0 i0;
    type1 i1;
    static const type2 i2 = value2_;

    LITE_INLINE pack() 
        : i0(),i1()    {}
    
    LITE_INLINE pack(const type0& a0)
        : i0(a0) 
     {}

    LITE_INLINE pack(
        const type0& a0,
        const type1& a1,
        const type2& 
        ) : i0(a0), i1(a1) {}

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ 
    >
    LITE_INLINE pack(const pack<
        other_type0_,
        other_type1_,
        other_type2_
        >& other) : i0(other.i0), i1(other.i1)    {}

    LITE_INLINE pack& 
    operator= (const pack& other) 
    {
        i0 = other.i0;
        i1 = other.i1;
        return *this;
    }

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ 
    >
    LITE_INLINE pack&  
    operator=(const pack<
        other_type0_,
        other_type1_,
        other_type2_
        >& other) 
    {
        i0 = other.i0;
        i1 = other.i1;
        return *this;
    }

    LITE_INLINE void set(
        const type0& a0,
        const type1& a1,
        const type2& 
        ) 
    {
            i0 = a0;
            i1 = a1;
    }
};


template<
    typename type0_,
    typename type1_,
    typename type2_, type2_ value2_
    >
const type2_ pack<
    type0_,
    type1_,
    constant<type2_, value2_>
    >::i2;

/***********************************************************************************************************/
template<
    typename type0_, type0_ value0_,
    typename type1_,
    typename type2_, type2_ value2_
    >
class pack<
    constant<type0_, value0_>,
    type1_,
    constant<type2_, value2_>
    >
{
public:
    static const int n = 3;

    typedef type0_ type0;
    typedef type1_ type1;
    typedef type2_ type2;

    static const bool is_const0 = true;
    static const bool is_const1 = false;
    static const bool is_const2 = true;
    static const bool is_all_const = false;
    static const type0 i0 = value0_;
    type1 i1;
    static const type2 i2 = value2_;

    LITE_INLINE pack() 
        : i1()    {}
    
    LITE_INLINE pack(const type0& )
     {}

    LITE_INLINE pack(
        const type0& ,
        const type1& a1,
        const type2& 
        ) : i1(a1) {}

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ 
    >
    LITE_INLINE pack(const pack<
        other_type0_,
        other_type1_,
        other_type2_
        >& other) : i1(other.i1)    {}

    LITE_INLINE pack& 
    operator= (const pack& other) 
    {
        i1 = other.i1;
        return *this;
    }

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ 
    >
    LITE_INLINE pack&  
    operator=(const pack<
        other_type0_,
        other_type1_,
        other_type2_
        >& other) 
    {
        i1 = other.i1;
        return *this;
    }

    LITE_INLINE void set(
        const type0& ,
        const type1& a1,
        const type2& 
        ) 
    {
            i1 = a1;
    }
};


template<
    typename type0_, type0_ value0_,
    typename type1_,
    typename type2_, type2_ value2_
    >
const type0_ pack<
    constant<type0_, value0_>,
    type1_,
    constant<type2_, value2_>
    >::i0;

template<
    typename type0_, type0_ value0_,
    typename type1_,
    typename type2_, type2_ value2_
    >
const type2_ pack<
    constant<type0_, value0_>,
    type1_,
    constant<type2_, value2_>
    >::i2;

/***********************************************************************************************************/
template<
    typename type0_,
    typename type1_, type1_ value1_,
    typename type2_, type2_ value2_
    >
class pack<
    type0_,
    constant<type1_, value1_>,
    constant<type2_, value2_>
    >
{
public:
    static const int n = 3;

    typedef type0_ type0;
    typedef type1_ type1;
    typedef type2_ type2;

    static const bool is_const0 = false;
    static const bool is_const1 = true;
    static const bool is_const2 = true;
    static const bool is_all_const = false;
    type0 i0;
    static const type1 i1 = value1_;
    static const type2 i2 = value2_;

    LITE_INLINE pack() 
        : i0()    {}
    
    LITE_INLINE pack(const type0& a0)
        : i0(a0) 
     {}

    LITE_INLINE pack(
        const type0& a0,
        const type1& ,
        const type2& 
        ) : i0(a0) {}

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ 
    >
    LITE_INLINE pack(const pack<
        other_type0_,
        other_type1_,
        other_type2_
        >& other) : i0(other.i0)    {}

    LITE_INLINE pack& 
    operator= (const pack& other) 
    {
        i0 = other.i0;
        return *this;
    }

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ 
    >
    LITE_INLINE pack&  
    operator=(const pack<
        other_type0_,
        other_type1_,
        other_type2_
        >& other) 
    {
        i0 = other.i0;
        return *this;
    }

    LITE_INLINE void set(
        const type0& a0,
        const type1& ,
        const type2& 
        ) 
    {
            i0 = a0;
    }
};


template<
    typename type0_,
    typename type1_, type1_ value1_,
    typename type2_, type2_ value2_
    >
const type1_ pack<
    type0_,
    constant<type1_, value1_>,
    constant<type2_, value2_>
    >::i1;

template<
    typename type0_,
    typename type1_, type1_ value1_,
    typename type2_, type2_ value2_
    >
const type2_ pack<
    type0_,
    constant<type1_, value1_>,
    constant<type2_, value2_>
    >::i2;

/***********************************************************************************************************/
template<
    typename type0_, type0_ value0_,
    typename type1_, type1_ value1_,
    typename type2_, type2_ value2_
    >
class pack<
    constant<type0_, value0_>,
    constant<type1_, value1_>,
    constant<type2_, value2_>
    >
{
public:
    static const int n = 3;

    typedef type0_ type0;
    typedef type1_ type1;
    typedef type2_ type2;

    static const bool is_const0 = true;
    static const bool is_const1 = true;
    static const bool is_const2 = true;
    static const bool is_all_const = true;
    static const type0 i0 = value0_;
    static const type1 i1 = value1_;
    static const type2 i2 = value2_;

    LITE_INLINE pack() 
             {}
    
    LITE_INLINE pack(const type0& )
     {}

    LITE_INLINE pack(
        const type0& ,
        const type1& ,
        const type2& 
        )  {}

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ 
    >
    LITE_INLINE pack(const pack<
        other_type0_,
        other_type1_,
        other_type2_
        >& )     {}

    LITE_INLINE pack& 
    operator= (const pack& ) 
    {
        return *this;
    }

    template<
        typename other_type0_ ,
        typename other_type1_ ,
        typename other_type2_ 
    >
    LITE_INLINE pack&  
    operator=(const pack<
        other_type0_,
        other_type1_,
        other_type2_
        >& ) 
    {
        return *this;
    }

    LITE_INLINE void set(
        const type0& ,
        const type1& ,
        const type2& 
        ) 
    {
    }
};


template<
    typename type0_, type0_ value0_,
    typename type1_, type1_ value1_,
    typename type2_, type2_ value2_
    >
const type0_ pack<
    constant<type0_, value0_>,
    constant<type1_, value1_>,
    constant<type2_, value2_>
    >::i0;

template<
    typename type0_, type0_ value0_,
    typename type1_, type1_ value1_,
    typename type2_, type2_ value2_
    >
const type1_ pack<
    constant<type0_, value0_>,
    constant<type1_, value1_>,
    constant<type2_, value2_>
    >::i1;

template<
    typename type0_, type0_ value0_,
    typename type1_, type1_ value1_,
    typename type2_, type2_ value2_
    >
const type2_ pack<
    constant<type0_, value0_>,
    constant<type1_, value1_>,
    constant<type2_, value2_>
    >::i2;

/***********************************************************************************************************/
template<
    typename type0_,
    typename type1_
    >
class pack<
    type0_,
    type1_
    >
{
public:
    static const int n = 2;

    typedef type0_ type0;
    typedef type1_ type1;

    static const bool is_const0 = false;
    static const bool is_const1 = false;
    static const bool is_all_const = false;
    type0 i0;
    type1 i1;

    LITE_INLINE pack() 
        : i0(),i1()    {}
    
    LITE_INLINE pack(const type0& a0)
        : i0(a0) 
     {}

    LITE_INLINE pack(
        const type0& a0,
        const type1& a1
        ) : i0(a0), i1(a1) {}

    template<
        typename other_type0_ ,
        typename other_type1_ 
    >
    LITE_INLINE pack(const pack<
        other_type0_,
        other_type1_
        >& other) : i0(other.i0), i1(other.i1)    {}

    LITE_INLINE pack& 
    operator= (const pack& other) 
    {
        i0 = other.i0;
        i1 = other.i1;
        return *this;
    }

    template<
        typename other_type0_ ,
        typename other_type1_ 
    >
    LITE_INLINE pack&  
    operator=(const pack<
        other_type0_,
        other_type1_
        >& other) 
    {
        i0 = other.i0;
        i1 = other.i1;
        return *this;
    }

    LITE_INLINE void set(
        const type0& a0,
        const type1& a1
        ) 
    {
            i0 = a0;
            i1 = a1;
    }
};


/***********************************************************************************************************/
template<
    typename type0_, type0_ value0_,
    typename type1_
    >
class pack<
    constant<type0_, value0_>,
    type1_
    >
{
public:
    static const int n = 2;

    typedef type0_ type0;
    typedef type1_ type1;

    static const bool is_const0 = true;
    static const bool is_const1 = false;
    static const bool is_all_const = false;
    static const type0 i0 = value0_;
    type1 i1;

    LITE_INLINE pack() 
        : i1()    {}
    
    LITE_INLINE pack(const type0& )
     {}

    LITE_INLINE pack(
        const type0& ,
        const type1& a1
        ) : i1(a1) {}

    template<
        typename other_type0_ ,
        typename other_type1_ 
    >
    LITE_INLINE pack(const pack<
        other_type0_,
        other_type1_
        >& other) : i1(other.i1)    {}

    LITE_INLINE pack& 
    operator= (const pack& other) 
    {
        i1 = other.i1;
        return *this;
    }

    template<
        typename other_type0_ ,
        typename other_type1_ 
    >
    LITE_INLINE pack&  
    operator=(const pack<
        other_type0_,
        other_type1_
        >& other) 
    {
        i1 = other.i1;
        return *this;
    }

    LITE_INLINE void set(
        const type0& ,
        const type1& a1
        ) 
    {
            i1 = a1;
    }
};


template<
    typename type0_, type0_ value0_,
    typename type1_
    >
const type0_ pack<
    constant<type0_, value0_>,
    type1_
    >::i0;

/***********************************************************************************************************/
template<
    typename type0_,
    typename type1_, type1_ value1_
    >
class pack<
    type0_,
    constant<type1_, value1_>
    >
{
public:
    static const int n = 2;

    typedef type0_ type0;
    typedef type1_ type1;

    static const bool is_const0 = false;
    static const bool is_const1 = true;
    static const bool is_all_const = false;
    type0 i0;
    static const type1 i1 = value1_;

    LITE_INLINE pack() 
        : i0()    {}
    
    LITE_INLINE pack(const type0& a0)
        : i0(a0) 
     {}

    LITE_INLINE pack(
        const type0& a0,
        const type1& 
        ) : i0(a0) {}

    template<
        typename other_type0_ ,
        typename other_type1_ 
    >
    LITE_INLINE pack(const pack<
        other_type0_,
        other_type1_
        >& other) : i0(other.i0)    {}

    LITE_INLINE pack& 
    operator= (const pack& other) 
    {
        i0 = other.i0;
        return *this;
    }

    template<
        typename other_type0_ ,
        typename other_type1_ 
    >
    LITE_INLINE pack&  
    operator=(const pack<
        other_type0_,
        other_type1_
        >& other) 
    {
        i0 = other.i0;
        return *this;
    }

    LITE_INLINE void set(
        const type0& a0,
        const type1& 
        ) 
    {
            i0 = a0;
    }
};


template<
    typename type0_,
    typename type1_, type1_ value1_
    >
const type1_ pack<
    type0_,
    constant<type1_, value1_>
    >::i1;

/***********************************************************************************************************/
template<
    typename type0_, type0_ value0_,
    typename type1_, type1_ value1_
    >
class pack<
    constant<type0_, value0_>,
    constant<type1_, value1_>
    >
{
public:
    static const int n = 2;

    typedef type0_ type0;
    typedef type1_ type1;

    static const bool is_const0 = true;
    static const bool is_const1 = true;
    static const bool is_all_const = true;
    static const type0 i0 = value0_;
    static const type1 i1 = value1_;

    LITE_INLINE pack() 
             {}
    
    LITE_INLINE pack(const type0& )
     {}

    LITE_INLINE pack(
        const type0& ,
        const type1& 
        )  {}

    template<
        typename other_type0_ ,
        typename other_type1_ 
    >
    LITE_INLINE pack(const pack<
        other_type0_,
        other_type1_
        >& )     {}

    LITE_INLINE pack& 
    operator= (const pack& ) 
    {
        return *this;
    }

    template<
        typename other_type0_ ,
        typename other_type1_ 
    >
    LITE_INLINE pack&  
    operator=(const pack<
        other_type0_,
        other_type1_
        >& ) 
    {
        return *this;
    }

    LITE_INLINE void set(
        const type0& ,
        const type1& 
        ) 
    {
    }
};


template<
    typename type0_, type0_ value0_,
    typename type1_, type1_ value1_
    >
const type0_ pack<
    constant<type0_, value0_>,
    constant<type1_, value1_>
    >::i0;

template<
    typename type0_, type0_ value0_,
    typename type1_, type1_ value1_
    >
const type1_ pack<
    constant<type0_, value0_>,
    constant<type1_, value1_>
    >::i1;

/***********************************************************************************************************/
template<
    typename type0_
    >
class pack<
    type0_
    >
{
public:
    static const int n = 1;

    typedef type0_ type0;

    static const bool is_const0 = false;
    static const bool is_all_const = false;
    type0 i0;

    LITE_INLINE pack() 
        : i0()    {}
    

    LITE_INLINE pack(
        const type0& a0
        ) : i0(a0) {}

    template<
        typename other_type0_ 
    >
    LITE_INLINE pack(const pack<
        other_type0_
        >& other) : i0(other.i0)    {}

    LITE_INLINE pack& 
    operator= (const pack& other) 
    {
        i0 = other.i0;
        return *this;
    }

    template<
        typename other_type0_ 
    >
    LITE_INLINE pack&  
    operator=(const pack<
        other_type0_
        >& other) 
    {
        i0 = other.i0;
        return *this;
    }

    LITE_INLINE void set(
        const type0& a0
        ) 
    {
            i0 = a0;
    }
};


/***********************************************************************************************************/
template<
    typename type0_, type0_ value0_
    >
class pack<
    constant<type0_, value0_>
    >
{
public:
    static const int n = 1;

    typedef type0_ type0;

    static const bool is_const0 = true;
    static const bool is_all_const = true;
    static const type0 i0 = value0_;

    LITE_INLINE pack() 
             {}
    

    LITE_INLINE pack(
        const type0& 
        )  {}

    template<
        typename other_type0_ 
    >
    LITE_INLINE pack(const pack<
        other_type0_
        >& )     {}

    LITE_INLINE pack& 
    operator= (const pack& ) 
    {
        return *this;
    }

    template<
        typename other_type0_ 
    >
    LITE_INLINE pack&  
    operator=(const pack<
        other_type0_
        >& ) 
    {
        return *this;
    }

    LITE_INLINE void set(
        const type0& 
        ) 
    {
    }
};


template<
    typename type0_, type0_ value0_
    >
const type0_ pack<
    constant<type0_, value0_>
    >::i0;

/***********************************************************************************************************/


/***********************************************************************************************************/

template<>
class pack<>
{
public:
    static const int n = 0;

    LITE_INLINE pack() {}

    LITE_INLINE pack(const pack&) {}

    LITE_INLINE pack& operator= (const pack&) 
    { return *this; }

    LITE_INLINE void set() 
    {}
};

#endif // !DOCUMENTATION_ONLY

/***********************************************************************************************************/
/* sub_pack ************************************************************************************************/
/***********************************************************************************************************/

#ifdef DOCUMENTATION_ONLY
/*!
    \brief This class can be used to define and extract a subset of element of a pack as another pack.

    \ingroup array_tools
    
    The following is te pseudo class definition of the sub_pack class.

    \code 
template<typename type0_, ..., typename typeN_, bool keep0_, ..., bool keepN_>
class sub_pack<pack<type0_, ... , typeN_>, keep0_, ..., keepN_>
{
public:
    typedef pack<type0_, ... , typeN_> input_pack_type;

    typedef pack<???> type; // for each X in in [0, N], typeX_ is included only if keepX_ is true.

    static void set(type& res, input_pack_type::type0 a0, ..., input_pack_type::typeN aN);

    static void set(type& res, const input_pack_type& org);
};
    \endcode 
    \par Example:

    \code 
        typedef pack<int, constant<int, 5>, std::string> Pack;
        typedef sub_pack<Pack, true, true, false> SubPack;

        Pack p(1, 0, "hello");
        SubPack::type sub_p;

        SubPack::set(sub_p, p);
        std::cout << p << std::endl;
        std::cout << sub_p << std::endl;
    \endcode 
    The output would be:
    \verbatim
        1 5 hello
        1 5
    \endverbatim
*/
template<typename pack_type_, bool keep0_ ..., bool keepN_>
class sub_pack
{
public:
    typedef pack_type_ input_pack_type; //!< The original pack type

    typedef pack<...> type; //!< The subset pack type

    //! Set the elements of res using only the corresponding elements from \a a0 to \a aN
    static void set(type& res, input_pack_type::type0 a0, ..., input_pack_type::typeN aN);

    //! Set the elements of res using only the corresponding elements from \a org
    static void set(type& res, const input_pack_type& org);
};

#else // DOCUMENTATION_ONLY


template<
    >
class sub_pack<
    pack<
    >
    >
{
public:
    typedef pack<
    > input_pack_type;

    typedef pack<
    > type;

    static LITE_INLINE void set(
        type& res
        ) 
    {
        res.set();
    }

    static LITE_INLINE void set(type& res, const input_pack_type& org)
    {
        res.set();
        LITE_ARRAY_USE(org);
    }
};

/***********************************************************************************************************/

template<
    typename type0_
    >
class sub_pack<
    pack<
        type0_
    >,
    false
    >
{
public:
    typedef pack<
        type0_
    > input_pack_type;

    typedef pack<
    > type;

    static LITE_INLINE void set(
        type& res,
        const typename input_pack_type::type0& 
        ) 
    {
        res.set();
    }

    static LITE_INLINE void set(type& res, const input_pack_type& org)
    {
        res.set();
        LITE_ARRAY_USE(org);
    }
};

/***********************************************************************************************************/

template<
    typename type0_
    >
class sub_pack<
    pack<
        type0_
    >,
    true
    >
{
public:
    typedef pack<
        type0_
    > input_pack_type;

    typedef pack<
        type0_
    > type;

    static LITE_INLINE void set(
        type& res,
        const typename input_pack_type::type0& a0
        ) 
    {
        res.set(a0);
    }

    static LITE_INLINE void set(type& res, const input_pack_type& org)
    {
        res.set(org.i0);
        LITE_ARRAY_USE(org);
    }
};

/***********************************************************************************************************/

template<
    typename type0_,
    typename type1_
    >
class sub_pack<
    pack<
        type0_,
        type1_
    >,
    false,
    false
    >
{
public:
    typedef pack<
        type0_,
        type1_
    > input_pack_type;

    typedef pack<
    > type;

    static LITE_INLINE void set(
        type& res,
        const typename input_pack_type::type0& ,
        const typename input_pack_type::type1& 
        ) 
    {
        res.set();
    }

    static LITE_INLINE void set(type& res, const input_pack_type& org)
    {
        res.set();
        LITE_ARRAY_USE(org);
    }
};

/***********************************************************************************************************/

template<
    typename type0_,
    typename type1_
    >
class sub_pack<
    pack<
        type0_,
        type1_
    >,
    true,
    false
    >
{
public:
    typedef pack<
        type0_,
        type1_
    > input_pack_type;

    typedef pack<
        type0_
    > type;

    static LITE_INLINE void set(
        type& res,
        const typename input_pack_type::type0& a0,
        const typename input_pack_type::type1& 
        ) 
    {
        res.set(a0);
    }

    static LITE_INLINE void set(type& res, const input_pack_type& org)
    {
        res.set(org.i0);
        LITE_ARRAY_USE(org);
    }
};

/***********************************************************************************************************/

template<
    typename type0_,
    typename type1_
    >
class sub_pack<
    pack<
        type0_,
        type1_
    >,
    false,
    true
    >
{
public:
    typedef pack<
        type0_,
        type1_
    > input_pack_type;

    typedef pack<
        type1_
    > type;

    static LITE_INLINE void set(
        type& res,
        const typename input_pack_type::type0& ,
        const typename input_pack_type::type1& a1
        ) 
    {
        res.set(a1);
    }

    static LITE_INLINE void set(type& res, const input_pack_type& org)
    {
        res.set(org.i1);
        LITE_ARRAY_USE(org);
    }
};

/***********************************************************************************************************/

template<
    typename type0_,
    typename type1_
    >
class sub_pack<
    pack<
        type0_,
        type1_
    >,
    true,
    true
    >
{
public:
    typedef pack<
        type0_,
        type1_
    > input_pack_type;

    typedef pack<
        type0_,
        type1_
    > type;

    static LITE_INLINE void set(
        type& res,
        const typename input_pack_type::type0& a0,
        const typename input_pack_type::type1& a1
        ) 
    {
        res.set(a0,a1);
    }

    static LITE_INLINE void set(type& res, const input_pack_type& org)
    {
        res.set(org.i0,org.i1);
        LITE_ARRAY_USE(org);
    }
};

/***********************************************************************************************************/

template<
    typename type0_,
    typename type1_,
    typename type2_
    >
class sub_pack<
    pack<
        type0_,
        type1_,
        type2_
    >,
    false,
    false,
    false
    >
{
public:
    typedef pack<
        type0_,
        type1_,
        type2_
    > input_pack_type;

    typedef pack<
    > type;

    static LITE_INLINE void set(
        type& res,
        const typename input_pack_type::type0& ,
        const typename input_pack_type::type1& ,
        const typename input_pack_type::type2& 
        ) 
    {
        res.set();
    }

    static LITE_INLINE void set(type& res, const input_pack_type& org)
    {
        res.set();
        LITE_ARRAY_USE(org);
    }
};

/***********************************************************************************************************/

template<
    typename type0_,
    typename type1_,
    typename type2_
    >
class sub_pack<
    pack<
        type0_,
        type1_,
        type2_
    >,
    true,
    false,
    false
    >
{
public:
    typedef pack<
        type0_,
        type1_,
        type2_
    > input_pack_type;

    typedef pack<
        type0_
    > type;

    static LITE_INLINE void set(
        type& res,
        const typename input_pack_type::type0& a0,
        const typename input_pack_type::type1& ,
        const typename input_pack_type::type2& 
        ) 
    {
        res.set(a0);
    }

    static LITE_INLINE void set(type& res, const input_pack_type& org)
    {
        res.set(org.i0);
        LITE_ARRAY_USE(org);
    }
};

/***********************************************************************************************************/

template<
    typename type0_,
    typename type1_,
    typename type2_
    >
class sub_pack<
    pack<
        type0_,
        type1_,
        type2_
    >,
    false,
    true,
    false
    >
{
public:
    typedef pack<
        type0_,
        type1_,
        type2_
    > input_pack_type;

    typedef pack<
        type1_
    > type;

    static LITE_INLINE void set(
        type& res,
        const typename input_pack_type::type0& ,
        const typename input_pack_type::type1& a1,
        const typename input_pack_type::type2& 
        ) 
    {
        res.set(a1);
    }

    static LITE_INLINE void set(type& res, const input_pack_type& org)
    {
        res.set(org.i1);
        LITE_ARRAY_USE(org);
    }
};

/***********************************************************************************************************/

template<
    typename type0_,
    typename type1_,
    typename type2_
    >
class sub_pack<
    pack<
        type0_,
        type1_,
        type2_
    >,
    true,
    true,
    false
    >
{
public:
    typedef pack<
        type0_,
        type1_,
        type2_
    > input_pack_type;

    typedef pack<
        type0_,
        type1_
    > type;

    static LITE_INLINE void set(
        type& res,
        const typename input_pack_type::type0& a0,
        const typename input_pack_type::type1& a1,
        const typename input_pack_type::type2& 
        ) 
    {
        res.set(a0,a1);
    }

    static LITE_INLINE void set(type& res, const input_pack_type& org)
    {
        res.set(org.i0,org.i1);
        LITE_ARRAY_USE(org);
    }
};

/***********************************************************************************************************/

template<
    typename type0_,
    typename type1_,
    typename type2_
    >
class sub_pack<
    pack<
        type0_,
        type1_,
        type2_
    >,
    false,
    false,
    true
    >
{
public:
    typedef pack<
        type0_,
        type1_,
        type2_
    > input_pack_type;

    typedef pack<
        type2_
    > type;

    static LITE_INLINE void set(
        type& res,
        const typename input_pack_type::type0& ,
        const typename input_pack_type::type1& ,
        const typename input_pack_type::type2& a2
        ) 
    {
        res.set(a2);
    }

    static LITE_INLINE void set(type& res, const input_pack_type& org)
    {
        res.set(org.i2);
        LITE_ARRAY_USE(org);
    }
};

/***********************************************************************************************************/

template<
    typename type0_,
    typename type1_,
    typename type2_
    >
class sub_pack<
    pack<
        type0_,
        type1_,
        type2_
    >,
    true,
    false,
    true
    >
{
public:
    typedef pack<
        type0_,
        type1_,
        type2_
    > input_pack_type;

    typedef pack<
        type0_,
        type2_
    > type;

    static LITE_INLINE void set(
        type& res,
        const typename input_pack_type::type0& a0,
        const typename input_pack_type::type1& ,
        const typename input_pack_type::type2& a2
        ) 
    {
        res.set(a0,a2);
    }

    static LITE_INLINE void set(type& res, const input_pack_type& org)
    {
        res.set(org.i0,org.i2);
        LITE_ARRAY_USE(org);
    }
};

/***********************************************************************************************************/

template<
    typename type0_,
    typename type1_,
    typename type2_
    >
class sub_pack<
    pack<
        type0_,
        type1_,
        type2_
    >,
    false,
    true,
    true
    >
{
public:
    typedef pack<
        type0_,
        type1_,
        type2_
    > input_pack_type;

    typedef pack<
        type1_,
        type2_
    > type;

    static LITE_INLINE void set(
        type& res,
        const typename input_pack_type::type0& ,
        const typename input_pack_type::type1& a1,
        const typename input_pack_type::type2& a2
        ) 
    {
        res.set(a1,a2);
    }

    static LITE_INLINE void set(type& res, const input_pack_type& org)
    {
        res.set(org.i1,org.i2);
        LITE_ARRAY_USE(org);
    }
};

/***********************************************************************************************************/

template<
    typename type0_,
    typename type1_,
    typename type2_
    >
class sub_pack<
    pack<
        type0_,
        type1_,
        type2_
    >,
    true,
    true,
    true
    >
{
public:
    typedef pack<
        type0_,
        type1_,
        type2_
    > input_pack_type;

    typedef pack<
        type0_,
        type1_,
        type2_
    > type;

    static LITE_INLINE void set(
        type& res,
        const typename input_pack_type::type0& a0,
        const typename input_pack_type::type1& a1,
        const typename input_pack_type::type2& a2
        ) 
    {
        res.set(a0,a1,a2);
    }

    static LITE_INLINE void set(type& res, const input_pack_type& org)
    {
        res.set(org.i0,org.i1,org.i2);
        LITE_ARRAY_USE(org);
    }
};

/***********************************************************************************************************/

template<
    typename type0_,
    typename type1_,
    typename type2_,
    typename type3_
    >
class sub_pack<
    pack<
        type0_,
        type1_,
        type2_,
        type3_
    >,
    false,
    false,
    false,
    false
    >
{
public:
    typedef pack<
        type0_,
        type1_,
        type2_,
        type3_
    > input_pack_type;

    typedef pack<
    > type;

    static LITE_INLINE void set(
        type& res,
        const typename input_pack_type::type0& ,
        const typename input_pack_type::type1& ,
        const typename input_pack_type::type2& ,
        const typename input_pack_type::type3& 
        ) 
    {
        res.set();
    }

    static LITE_INLINE void set(type& res, const input_pack_type& org)
    {
        res.set();
        LITE_ARRAY_USE(org);
    }
};

/***********************************************************************************************************/

template<
    typename type0_,
    typename type1_,
    typename type2_,
    typename type3_
    >
class sub_pack<
    pack<
        type0_,
        type1_,
        type2_,
        type3_
    >,
    true,
    false,
    false,
    false
    >
{
public:
    typedef pack<
        type0_,
        type1_,
        type2_,
        type3_
    > input_pack_type;

    typedef pack<
        type0_
    > type;

    static LITE_INLINE void set(
        type& res,
        const typename input_pack_type::type0& a0,
        const typename input_pack_type::type1& ,
        const typename input_pack_type::type2& ,
        const typename input_pack_type::type3& 
        ) 
    {
        res.set(a0);
    }

    static LITE_INLINE void set(type& res, const input_pack_type& org)
    {
        res.set(org.i0);
        LITE_ARRAY_USE(org);
    }
};

/***********************************************************************************************************/

template<
    typename type0_,
    typename type1_,
    typename type2_,
    typename type3_
    >
class sub_pack<
    pack<
        type0_,
        type1_,
        type2_,
        type3_
    >,
    false,
    true,
    false,
    false
    >
{
public:
    typedef pack<
        type0_,
        type1_,
        type2_,
        type3_
    > input_pack_type;

    typedef pack<
        type1_
    > type;

    static LITE_INLINE void set(
        type& res,
        const typename input_pack_type::type0& ,
        const typename input_pack_type::type1& a1,
        const typename input_pack_type::type2& ,
        const typename input_pack_type::type3& 
        ) 
    {
        res.set(a1);
    }

    static LITE_INLINE void set(type& res, const input_pack_type& org)
    {
        res.set(org.i1);
        LITE_ARRAY_USE(org);
    }
};

/***********************************************************************************************************/

template<
    typename type0_,
    typename type1_,
    typename type2_,
    typename type3_
    >
class sub_pack<
    pack<
        type0_,
        type1_,
        type2_,
        type3_
    >,
    true,
    true,
    false,
    false
    >
{
public:
    typedef pack<
        type0_,
        type1_,
        type2_,
        type3_
    > input_pack_type;

    typedef pack<
        type0_,
        type1_
    > type;

    static LITE_INLINE void set(
        type& res,
        const typename input_pack_type::type0& a0,
        const typename input_pack_type::type1& a1,
        const typename input_pack_type::type2& ,
        const typename input_pack_type::type3& 
        ) 
    {
        res.set(a0,a1);
    }

    static LITE_INLINE void set(type& res, const input_pack_type& org)
    {
        res.set(org.i0,org.i1);
        LITE_ARRAY_USE(org);
    }
};

/***********************************************************************************************************/

template<
    typename type0_,
    typename type1_,
    typename type2_,
    typename type3_
    >
class sub_pack<
    pack<
        type0_,
        type1_,
        type2_,
        type3_
    >,
    false,
    false,
    true,
    false
    >
{
public:
    typedef pack<
        type0_,
        type1_,
        type2_,
        type3_
    > input_pack_type;

    typedef pack<
        type2_
    > type;

    static LITE_INLINE void set(
        type& res,
        const typename input_pack_type::type0& ,
        const typename input_pack_type::type1& ,
        const typename input_pack_type::type2& a2,
        const typename input_pack_type::type3& 
        ) 
    {
        res.set(a2);
    }

    static LITE_INLINE void set(type& res, const input_pack_type& org)
    {
        res.set(org.i2);
        LITE_ARRAY_USE(org);
    }
};

/***********************************************************************************************************/

template<
    typename type0_,
    typename type1_,
    typename type2_,
    typename type3_
    >
class sub_pack<
    pack<
        type0_,
        type1_,
        type2_,
        type3_
    >,
    true,
    false,
    true,
    false
    >
{
public:
    typedef pack<
        type0_,
        type1_,
        type2_,
        type3_
    > input_pack_type;

    typedef pack<
        type0_,
        type2_
    > type;

    static LITE_INLINE void set(
        type& res,
        const typename input_pack_type::type0& a0,
        const typename input_pack_type::type1& ,
        const typename input_pack_type::type2& a2,
        const typename input_pack_type::type3& 
        ) 
    {
        res.set(a0,a2);
    }

    static LITE_INLINE void set(type& res, const input_pack_type& org)
    {
        res.set(org.i0,org.i2);
        LITE_ARRAY_USE(org);
    }
};

/***********************************************************************************************************/

template<
    typename type0_,
    typename type1_,
    typename type2_,
    typename type3_
    >
class sub_pack<
    pack<
        type0_,
        type1_,
        type2_,
        type3_
    >,
    false,
    true,
    true,
    false
    >
{
public:
    typedef pack<
        type0_,
        type1_,
        type2_,
        type3_
    > input_pack_type;

    typedef pack<
        type1_,
        type2_
    > type;

    static LITE_INLINE void set(
        type& res,
        const typename input_pack_type::type0& ,
        const typename input_pack_type::type1& a1,
        const typename input_pack_type::type2& a2,
        const typename input_pack_type::type3& 
        ) 
    {
        res.set(a1,a2);
    }

    static LITE_INLINE void set(type& res, const input_pack_type& org)
    {
        res.set(org.i1,org.i2);
        LITE_ARRAY_USE(org);
    }
};

/***********************************************************************************************************/

template<
    typename type0_,
    typename type1_,
    typename type2_,
    typename type3_
    >
class sub_pack<
    pack<
        type0_,
        type1_,
        type2_,
        type3_
    >,
    true,
    true,
    true,
    false
    >
{
public:
    typedef pack<
        type0_,
        type1_,
        type2_,
        type3_
    > input_pack_type;

    typedef pack<
        type0_,
        type1_,
        type2_
    > type;

    static LITE_INLINE void set(
        type& res,
        const typename input_pack_type::type0& a0,
        const typename input_pack_type::type1& a1,
        const typename input_pack_type::type2& a2,
        const typename input_pack_type::type3& 
        ) 
    {
        res.set(a0,a1,a2);
    }

    static LITE_INLINE void set(type& res, const input_pack_type& org)
    {
        res.set(org.i0,org.i1,org.i2);
        LITE_ARRAY_USE(org);
    }
};

/***********************************************************************************************************/

template<
    typename type0_,
    typename type1_,
    typename type2_,
    typename type3_
    >
class sub_pack<
    pack<
        type0_,
        type1_,
        type2_,
        type3_
    >,
    false,
    false,
    false,
    true
    >
{
public:
    typedef pack<
        type0_,
        type1_,
        type2_,
        type3_
    > input_pack_type;

    typedef pack<
        type3_
    > type;

    static LITE_INLINE void set(
        type& res,
        const typename input_pack_type::type0& ,
        const typename input_pack_type::type1& ,
        const typename input_pack_type::type2& ,
        const typename input_pack_type::type3& a3
        ) 
    {
        res.set(a3);
    }

    static LITE_INLINE void set(type& res, const input_pack_type& org)
    {
        res.set(org.i3);
        LITE_ARRAY_USE(org);
    }
};

/***********************************************************************************************************/

template<
    typename type0_,
    typename type1_,
    typename type2_,
    typename type3_
    >
class sub_pack<
    pack<
        type0_,
        type1_,
        type2_,
        type3_
    >,
    true,
    false,
    false,
    true
    >
{
public:
    typedef pack<
        type0_,
        type1_,
        type2_,
        type3_
    > input_pack_type;

    typedef pack<
        type0_,
        type3_
    > type;

    static LITE_INLINE void set(
        type& res,
        const typename input_pack_type::type0& a0,
        const typename input_pack_type::type1& ,
        const typename input_pack_type::type2& ,
        const typename input_pack_type::type3& a3
        ) 
    {
        res.set(a0,a3);
    }

    static LITE_INLINE void set(type& res, const input_pack_type& org)
    {
        res.set(org.i0,org.i3);
        LITE_ARRAY_USE(org);
    }
};

/***********************************************************************************************************/

template<
    typename type0_,
    typename type1_,
    typename type2_,
    typename type3_
    >
class sub_pack<
    pack<
        type0_,
        type1_,
        type2_,
        type3_
    >,
    false,
    true,
    false,
    true
    >
{
public:
    typedef pack<
        type0_,
        type1_,
        type2_,
        type3_
    > input_pack_type;

    typedef pack<
        type1_,
        type3_
    > type;

    static LITE_INLINE void set(
        type& res,
        const typename input_pack_type::type0& ,
        const typename input_pack_type::type1& a1,
        const typename input_pack_type::type2& ,
        const typename input_pack_type::type3& a3
        ) 
    {
        res.set(a1,a3);
    }

    static LITE_INLINE void set(type& res, const input_pack_type& org)
    {
        res.set(org.i1,org.i3);
        LITE_ARRAY_USE(org);
    }
};

/***********************************************************************************************************/

template<
    typename type0_,
    typename type1_,
    typename type2_,
    typename type3_
    >
class sub_pack<
    pack<
        type0_,
        type1_,
        type2_,
        type3_
    >,
    true,
    true,
    false,
    true
    >
{
public:
    typedef pack<
        type0_,
        type1_,
        type2_,
        type3_
    > input_pack_type;

    typedef pack<
        type0_,
        type1_,
        type3_
    > type;

    static LITE_INLINE void set(
        type& res,
        const typename input_pack_type::type0& a0,
        const typename input_pack_type::type1& a1,
        const typename input_pack_type::type2& ,
        const typename input_pack_type::type3& a3
        ) 
    {
        res.set(a0,a1,a3);
    }

    static LITE_INLINE void set(type& res, const input_pack_type& org)
    {
        res.set(org.i0,org.i1,org.i3);
        LITE_ARRAY_USE(org);
    }
};

/***********************************************************************************************************/

template<
    typename type0_,
    typename type1_,
    typename type2_,
    typename type3_
    >
class sub_pack<
    pack<
        type0_,
        type1_,
        type2_,
        type3_
    >,
    false,
    false,
    true,
    true
    >
{
public:
    typedef pack<
        type0_,
        type1_,
        type2_,
        type3_
    > input_pack_type;

    typedef pack<
        type2_,
        type3_
    > type;

    static LITE_INLINE void set(
        type& res,
        const typename input_pack_type::type0& ,
        const typename input_pack_type::type1& ,
        const typename input_pack_type::type2& a2,
        const typename input_pack_type::type3& a3
        ) 
    {
        res.set(a2,a3);
    }

    static LITE_INLINE void set(type& res, const input_pack_type& org)
    {
        res.set(org.i2,org.i3);
        LITE_ARRAY_USE(org);
    }
};

/***********************************************************************************************************/

template<
    typename type0_,
    typename type1_,
    typename type2_,
    typename type3_
    >
class sub_pack<
    pack<
        type0_,
        type1_,
        type2_,
        type3_
    >,
    true,
    false,
    true,
    true
    >
{
public:
    typedef pack<
        type0_,
        type1_,
        type2_,
        type3_
    > input_pack_type;

    typedef pack<
        type0_,
        type2_,
        type3_
    > type;

    static LITE_INLINE void set(
        type& res,
        const typename input_pack_type::type0& a0,
        const typename input_pack_type::type1& ,
        const typename input_pack_type::type2& a2,
        const typename input_pack_type::type3& a3
        ) 
    {
        res.set(a0,a2,a3);
    }

    static LITE_INLINE void set(type& res, const input_pack_type& org)
    {
        res.set(org.i0,org.i2,org.i3);
        LITE_ARRAY_USE(org);
    }
};

/***********************************************************************************************************/

template<
    typename type0_,
    typename type1_,
    typename type2_,
    typename type3_
    >
class sub_pack<
    pack<
        type0_,
        type1_,
        type2_,
        type3_
    >,
    false,
    true,
    true,
    true
    >
{
public:
    typedef pack<
        type0_,
        type1_,
        type2_,
        type3_
    > input_pack_type;

    typedef pack<
        type1_,
        type2_,
        type3_
    > type;

    static LITE_INLINE void set(
        type& res,
        const typename input_pack_type::type0& ,
        const typename input_pack_type::type1& a1,
        const typename input_pack_type::type2& a2,
        const typename input_pack_type::type3& a3
        ) 
    {
        res.set(a1,a2,a3);
    }

    static LITE_INLINE void set(type& res, const input_pack_type& org)
    {
        res.set(org.i1,org.i2,org.i3);
        LITE_ARRAY_USE(org);
    }
};

/***********************************************************************************************************/

template<
    typename type0_,
    typename type1_,
    typename type2_,
    typename type3_
    >
class sub_pack<
    pack<
        type0_,
        type1_,
        type2_,
        type3_
    >,
    true,
    true,
    true,
    true
    >
{
public:
    typedef pack<
        type0_,
        type1_,
        type2_,
        type3_
    > input_pack_type;

    typedef pack<
        type0_,
        type1_,
        type2_,
        type3_
    > type;

    static LITE_INLINE void set(
        type& res,
        const typename input_pack_type::type0& a0,
        const typename input_pack_type::type1& a1,
        const typename input_pack_type::type2& a2,
        const typename input_pack_type::type3& a3
        ) 
    {
        res.set(a0,a1,a2,a3);
    }

    static LITE_INLINE void set(type& res, const input_pack_type& org)
    {
        res.set(org.i0,org.i1,org.i2,org.i3);
        LITE_ARRAY_USE(org);
    }
};

/***********************************************************************************************************/

#endif // !DOCUMENTATION_ONLY

/***********************************************************************************************************/
/* get_type ************************************************************************************************/
/***********************************************************************************************************/

#ifdef DOCUMENTATION_ONLY
/*!
    \brief This class can be used to retrieve the type of the elements of a pack type.

    \ingroup array_tools

    This is useful if the index
    of the element is computed as the result of a compile time expression.
    \par Example:

    \code 
        typedef pack<int, constant<int, 5>, std::string> Pack;

        Pack p(1, 0, "hello");
        get_type<1, Pack>::type& ref = p.i1;
        std::cout << ref << std::endl;
    \endcode 
    The output would be:
    \verbatim
        5
    \endverbatim
*/
template<int index_, typename type_>
struct get_type
{
    typedef ... type; //!< This is the same type as \a type_::typeX assuming that X is the \a index_ .
};

#else // DOCUMENTATION_ONLY


template<int index_, typename type_>
struct get_type;

template<typename type_>
struct get_type<0, type_>
{
    typedef typename type_::type0 type;
};
template<typename type_>
struct get_type<1, type_>
{
    typedef typename type_::type1 type;
};
template<typename type_>
struct get_type<2, type_>
{
    typedef typename type_::type2 type;
};
template<typename type_>
struct get_type<3, type_>
{
    typedef typename type_::type3 type;
};

#endif // !DOCUMENTATION_ONLY

/***********************************************************************************************************/
/* get *****************************************************************************************************/
/***********************************************************************************************************/

#ifdef DOCUMENTATION_ONLY
/*!
    \ingroup array_tools
    This can be used to retrieve the elements of a pack type. This is useful if the index
    of the element is computed as the result of a compile time expression.
    \par Example:

    \code 
        typedef pack<int, constant<int, 5>, std::string> Pack;

        Pack p(1, 0, "hello");
        get_type<1, Pack>::type& ref = get<1>(p);
        std::cout << ref << std::endl;
    \endcode 
    The output would be:
    \verbatim
        5
    \endverbatim
*/
template<int index_, typename type_>
typename get_type<index_, type_>::type get(const type_& a);

#else // DOCUMENTATION_ONLY

template<int index_, typename type_>
LITE_INLINE 
typename detail::enable_if<index_==0, typename get_type<index_, type_>::type>::type 
get(const type_& a)
{
    LITE_ARRAY_USE(a);
    return a.i0;
};

template<int index_, typename type_>
LITE_INLINE 
typename detail::enable_if<index_==1, typename get_type<index_, type_>::type>::type 
get(const type_& a)
{
    LITE_ARRAY_USE(a);
    return a.i1;
};

template<int index_, typename type_>
LITE_INLINE 
typename detail::enable_if<index_==2, typename get_type<index_, type_>::type>::type 
get(const type_& a)
{
    LITE_ARRAY_USE(a);
    return a.i2;
};

template<int index_, typename type_>
LITE_INLINE 
typename detail::enable_if<index_==3, typename get_type<index_, type_>::type>::type 
get(const type_& a)
{
    LITE_ARRAY_USE(a);
    return a.i3;
};


#endif // DOCUMENTATION_ONLY
/***********************************************************************************************************/
/* set *****************************************************************************************************/
/***********************************************************************************************************/

#ifdef DOCUMENTATION_ONLY
/*!
    \ingroup array_tools
    This can be used to set the elements of a pack type. This is useful if the index
    of the element is computed as the result of a compile time expression or if the element might be a 
    static const. If the element specified by \a index_ is a static const then this function does nothing.
    \par Example:

    \code 
        typedef pack<int, constant<int, 5>, std::string> Pack;

        Pack p(1, 0, "hello");
        set<0>(p, 10);
        set<1>(p, 11);      // has no effect
        set<2>(p, "bye");
        std::cout << p << std::endl;
    \endcode 
    The output would be:
    \verbatim
        10 5 bye
    \endverbatim
*/
template<int index_, typename type_,  typename value_type_>
void set(type_& a, const value_type_& v);

#else // DOCUMENTATION_ONLY


template<int index_, typename type_,  typename value_type_>
LITE_INLINE 
typename detail::enable_if<index_==0 && type_::is_const0>::type 
set(type_&, const value_type_&)
{}

template<int index_, typename type_,  typename value_type_>
LITE_INLINE 
typename detail::enable_if<index_==0 && !type_::is_const0>::type 
set(type_& a, const value_type_& v)
{
    a.i0 = v;
}

template<int index_, typename type_,  typename value_type_>
LITE_INLINE 
typename detail::enable_if<index_==1 && type_::is_const1>::type 
set(type_&, const value_type_&)
{}

template<int index_, typename type_,  typename value_type_>
LITE_INLINE 
typename detail::enable_if<index_==1 && !type_::is_const1>::type 
set(type_& a, const value_type_& v)
{
    a.i1 = v;
}

template<int index_, typename type_,  typename value_type_>
LITE_INLINE 
typename detail::enable_if<index_==2 && type_::is_const2>::type 
set(type_&, const value_type_&)
{}

template<int index_, typename type_,  typename value_type_>
LITE_INLINE 
typename detail::enable_if<index_==2 && !type_::is_const2>::type 
set(type_& a, const value_type_& v)
{
    a.i2 = v;
}

template<int index_, typename type_,  typename value_type_>
LITE_INLINE 
typename detail::enable_if<index_==3 && type_::is_const3>::type 
set(type_&, const value_type_&)
{}

template<int index_, typename type_,  typename value_type_>
LITE_INLINE 
typename detail::enable_if<index_==3 && !type_::is_const3>::type 
set(type_& a, const value_type_& v)
{
    a.i3 = v;
}

#endif // DOCUMENTATION_ONLY
/***********************************************************************************************************/
/* pack, operator< *****************************************************************************************/
/***********************************************************************************************************/
#ifdef DOCUMENTATION_ONLY
/*!
    \ingroup array_tools
    Compares the elements of \a a and \a b lexicographically and returns true only if \a < \a b .
    Note that \a a and \a b could be of different pack types but they should contain the same number of elements.
*/
template<typename l_type0_, ..., typename l_typeN_, typename r_type0_, ..., typename r_typeN_>
bool operator<(const pack<l_type0_, ..., l_typeN_>&a, const pack<r_type0_, ..., r_typeN_>& b);
#endif // DOCUMENTATION_ONLY

LITE_INLINE
bool operator<(const pack<>&, const pack<>&)
{ 
    return false;
}

template<
    typename l_type0_,
    typename r_type0_ 
>
LITE_INLINE
bool operator<(
    const pack<l_type0_>& a,
    const pack<r_type0_>& b)
{
    return a.i0<b.i0;
    LITE_ARRAY_USE(a);
    LITE_ARRAY_USE(b);
}

template<
    typename l_type0_,
    typename l_type1_,
    typename r_type0_, 
    typename r_type1_ 
>
LITE_INLINE
bool operator<(
    const pack<l_type0_, l_type1_>& a,
    const pack<r_type0_, r_type1_>& b)
{
    return a.i0<b.i0 && a.i1<b.i1;
    LITE_ARRAY_USE(a);
    LITE_ARRAY_USE(b);
}

template<
    typename l_type0_,
    typename l_type1_,
    typename l_type2_,
    typename r_type0_, 
    typename r_type1_, 
    typename r_type2_ 
>
LITE_INLINE
bool operator<(
    const pack<l_type0_, l_type1_, l_type2_>& a,
    const pack<r_type0_, r_type1_, r_type2_>& b)
{
    return a.i0<b.i0 && a.i1<b.i1 && a.i2<b.i2;
    LITE_ARRAY_USE(a);
    LITE_ARRAY_USE(b);
}

/***********************************************************************************************************/
/* pack, operator<= ****************************************************************************************/
/***********************************************************************************************************/
#ifdef DOCUMENTATION_ONLY
/*!
    \ingroup array_tools
    Compares the elements of \a a and \a b lexicographically and returns true only if \a <= \a b .
    Note that \a a and \a b could be of different pack types but they should contain the same number of elements.
*/
template<typename l_type0_, ..., typename l_typeN_, typename r_type0_, ..., typename r_typeN_>
bool operator<=(const pack<l_type0_, ..., l_typeN_>&a, const pack<r_type0_, ..., r_typeN_>& b);
#endif // DOCUMENTATION_ONLY

LITE_INLINE
bool operator<=(const pack<>&, const pack<>&)
{ 
    return true;
}

template<
    typename l_type0_,
    typename r_type0_ 
>
LITE_INLINE
bool operator<=(
    const pack<l_type0_>& a,
    const pack<r_type0_>& b)
{
    return a.i0<=b.i0;
    LITE_ARRAY_USE(a);
    LITE_ARRAY_USE(b);
}

template<
    typename l_type0_,
    typename l_type1_,
    typename r_type0_, 
    typename r_type1_ 
>
LITE_INLINE
bool operator<=(
    const pack<l_type0_, l_type1_>& a,
    const pack<r_type0_, r_type1_>& b)
{
    return a.i0<=b.i0 && a.i1<=b.i1;
    LITE_ARRAY_USE(a);
    LITE_ARRAY_USE(b);
}

template<
    typename l_type0_,
    typename l_type1_,
    typename l_type2_,
    typename r_type0_, 
    typename r_type1_, 
    typename r_type2_ 
>
LITE_INLINE
bool operator<=(
    const pack<l_type0_, l_type1_, l_type2_>& a,
    const pack<r_type0_, r_type1_, r_type2_>& b)
{
    return a.i0<=b.i0 && a.i1<=b.i1 && a.i2<=b.i2;
    LITE_ARRAY_USE(a);
    LITE_ARRAY_USE(b);
}

/***********************************************************************************************************/
/* pack, operator== ****************************************************************************************/
/***********************************************************************************************************/
#ifdef DOCUMENTATION_ONLY
/*!
    \ingroup array_tools
    Compares the elements of \a a and \a b lexicographically and returns true only if \a == \a b .
    Note that \a a and \a b could be of different pack types but they should contain the same number of elements.
*/
template<typename l_type0_, ..., typename l_typeN_, typename r_type0_, ..., typename r_typeN_>
bool operator==(const pack<l_type0_, ..., l_typeN_>&a, const pack<r_type0_, ..., r_typeN_>& b);
#endif // DOCUMENTATION_ONLY

LITE_INLINE
bool operator==(const pack<>&, const pack<>&)
{ 
    return true;
}

template<
    typename l_type0_,
    typename r_type0_ 
>
LITE_INLINE
bool operator==(
    const pack<l_type0_>& a,
    const pack<r_type0_>& b)
{
    return a.i0==b.i0;
    LITE_ARRAY_USE(a);
    LITE_ARRAY_USE(b);
}

template<
    typename l_type0_,
    typename l_type1_,
    typename r_type0_, 
    typename r_type1_ 
>
LITE_INLINE
bool operator==(
    const pack<l_type0_, l_type1_>& a,
    const pack<r_type0_, r_type1_>& b)
{
    return a.i0==b.i0 && a.i1==b.i1;
    LITE_ARRAY_USE(a);
    LITE_ARRAY_USE(b);
}

template<
    typename l_type0_,
    typename l_type1_,
    typename l_type2_,
    typename r_type0_, 
    typename r_type1_, 
    typename r_type2_ 
>
LITE_INLINE
bool operator==(
    const pack<l_type0_, l_type1_, l_type2_>& a,
    const pack<r_type0_, r_type1_, r_type2_>& b)
{
    return a.i0==b.i0 && a.i1==b.i1 && a.i2==b.i2;
    LITE_ARRAY_USE(a);
    LITE_ARRAY_USE(b);
}

/***********************************************************************************************************/
/* pack, operator>= ****************************************************************************************/
/***********************************************************************************************************/
#ifdef DOCUMENTATION_ONLY
/*!
    \ingroup array_tools
    Compares the elements of \a a and \a b lexicographically and returns true only if \a >= \a b .
    Note that \a a and \a b could be of different pack types but they should contain the same number of elements.
*/
template<typename l_type0_, ..., typename l_typeN_, typename r_type0_, ..., typename r_typeN_>
bool operator>=(const pack<l_type0_, ..., l_typeN_>&a, const pack<r_type0_, ..., r_typeN_>& b);
#endif // DOCUMENTATION_ONLY

LITE_INLINE
bool operator>=(const pack<>&, const pack<>&)
{ 
    return true;
}

template<
    typename l_type0_,
    typename r_type0_ 
>
LITE_INLINE
bool operator>=(
    const pack<l_type0_>& a,
    const pack<r_type0_>& b)
{
    return a.i0>=b.i0;
    LITE_ARRAY_USE(a);
    LITE_ARRAY_USE(b);
}

template<
    typename l_type0_,
    typename l_type1_,
    typename r_type0_, 
    typename r_type1_ 
>
LITE_INLINE
bool operator>=(
    const pack<l_type0_, l_type1_>& a,
    const pack<r_type0_, r_type1_>& b)
{
    return a.i0>=b.i0 && a.i1>=b.i1;
    LITE_ARRAY_USE(a);
    LITE_ARRAY_USE(b);
}

template<
    typename l_type0_,
    typename l_type1_,
    typename l_type2_,
    typename r_type0_, 
    typename r_type1_, 
    typename r_type2_ 
>
LITE_INLINE
bool operator>=(
    const pack<l_type0_, l_type1_, l_type2_>& a,
    const pack<r_type0_, r_type1_, r_type2_>& b)
{
    return a.i0>=b.i0 && a.i1>=b.i1 && a.i2>=b.i2;
    LITE_ARRAY_USE(a);
    LITE_ARRAY_USE(b);
}

/***********************************************************************************************************/
/* pack, operator> *****************************************************************************************/
/***********************************************************************************************************/
#ifdef DOCUMENTATION_ONLY
/*!
    \ingroup array_tools
    Compares the elements of \a a and \a b lexicographically and returns true only if \a > \a b .
    Note that \a a and \a b could be of different pack types but they should contain the same number of elements.
*/
template<typename l_type0_, ..., typename l_typeN_, typename r_type0_, ..., typename r_typeN_>
bool operator>(const pack<l_type0_, ..., l_typeN_>&a, const pack<r_type0_, ..., r_typeN_>& b);
#endif // DOCUMENTATION_ONLY

LITE_INLINE
bool operator>(const pack<>&, const pack<>&)
{ 
    return false;
}

template<
    typename l_type0_,
    typename r_type0_ 
>
LITE_INLINE
bool operator>(
    const pack<l_type0_>& a,
    const pack<r_type0_>& b)
{
    return a.i0>b.i0;
    LITE_ARRAY_USE(a);
    LITE_ARRAY_USE(b);
}

template<
    typename l_type0_,
    typename l_type1_,
    typename r_type0_, 
    typename r_type1_ 
>
LITE_INLINE
bool operator>(
    const pack<l_type0_, l_type1_>& a,
    const pack<r_type0_, r_type1_>& b)
{
    return a.i0>b.i0 && a.i1>b.i1;
    LITE_ARRAY_USE(a);
    LITE_ARRAY_USE(b);
}

template<
    typename l_type0_,
    typename l_type1_,
    typename l_type2_,
    typename r_type0_, 
    typename r_type1_, 
    typename r_type2_ 
>
LITE_INLINE
bool operator>(
    const pack<l_type0_, l_type1_, l_type2_>& a,
    const pack<r_type0_, r_type1_, r_type2_>& b)
{
    return a.i0>b.i0 && a.i1>b.i1 && a.i2>b.i2;
    LITE_ARRAY_USE(a);
    LITE_ARRAY_USE(b);
}


/***********************************************************************************************************/
/* pack, operator!= ****************************************************************************************/
/***********************************************************************************************************/

#ifdef DOCUMENTATION_ONLY

/*!
    \ingroup array_tools
    Compares the elements of \a a and \a b lexicographically and returns true only if !(\a a == \a b) .
    Note that \a a and \a b could be of different pack types but they should contain the same number of elements.
*/
template<typename l_type0_, ..., typename l_typeN_, typename r_type0_, ..., typename r_typeN_>
bool operator!=(const pack<l_type0_, ..., l_typeN_>&a, const pack<r_type0_, ..., r_typeN_>& b);

#else // DOCUMENTATION_ONLY

LITE_INLINE
bool operator!=(const pack<>&, const pack<>&)
{ 
    return false;
}

template<
    typename l_type0_,
    typename r_type0_ 
>
LITE_INLINE
bool operator!=(
    const pack<l_type0_>& a,
    const pack<r_type0_>& b)
{
    return !(a==b);
}

template<
    typename l_type0_,
    typename l_type1_,
    typename r_type0_, 
    typename r_type1_ 
>
LITE_INLINE
bool operator!=(
    const pack<l_type0_,l_type1_>& a,
    const pack<r_type0_,r_type1_>& b)
{
    return !(a==b);
}

template<
    typename l_type0_,
    typename l_type1_,
    typename l_type2_,
    typename r_type0_, 
    typename r_type1_, 
    typename r_type2_ 
>
LITE_INLINE
bool operator!=(
    const pack<l_type0_,l_type1_,l_type2_>& a,
    const pack<r_type0_,r_type1_,r_type2_>& b)
{
    return !(a==b);
}


#endif // !DOCUMENTATION_ONLY
/***********************************************************************************************************/
/* pack io, operator<< *************************************************************************************/
/***********************************************************************************************************/

#ifdef DOCUMENTATION_ONLY

/*!
    \brief Prints the pack \a p to the output stream \a os.

    \ingroup array_tools
    \anchor array_pack_output

    If the field width value for \a os is set, it will be 
    used to set the field width for each of the elements to be printed. 
    Also if the \a boolalpha flags is set then the output will be surrounded 
    in a matching pair of square brackets.

    \par Example:

    \code 
        pack<int, constant<int, 5>, int> p(1, 0, 11);
        std::cout << std::boolalpha  << std::setw(2) << p << std::endl;
    \endcode 
    The output would be:
    \verbatim
        [ 1  5 11]
    \endverbatim
*/
template<typename char_type_, typename traits_type_, typename type0_, ..., typename typeN_>
std::basic_ostream<char_type_, traits_type_>&
operator<<(
    std::basic_ostream<char_type_, traits_type_>& os, 
    const pack<type0_, ..., typeN_>& p);

#else // DOCUMENTATION_ONLY


template<
    typename char_type_,
    typename traits_type_
    >
std::basic_ostream<char_type_, traits_type_>&
operator<<(
    std::basic_ostream<char_type_, traits_type_>& os, 
    const pack<>& p)
{
    std::streamsize width = os.width();
    bool punct = (os.flags() & std::ios_base::boolalpha) != 0;

    os.width(0);

    if (punct)
        os << '[';


    if (punct)
        os << ']';
    return os;

    LITE_ARRAY_USE(p);
}


template<
    typename char_type_,
    typename traits_type_,
    typename type0_
    >
std::basic_ostream<char_type_, traits_type_>&
operator<<(
    std::basic_ostream<char_type_, traits_type_>& os, 
    const pack<type0_>& p)
{
    std::streamsize width = os.width();
    bool punct = (os.flags() & std::ios_base::boolalpha) != 0;

    os.width(0);

    if (punct)
        os << '[';

    os.width(width); os << p.i0;

    if (punct)
        os << ']';
    return os;

    LITE_ARRAY_USE(p);
}


template<
    typename char_type_,
    typename traits_type_,
    typename type0_,
    typename type1_
    >
std::basic_ostream<char_type_, traits_type_>&
operator<<(
    std::basic_ostream<char_type_, traits_type_>& os, 
    const pack<type0_,type1_>& p)
{
    std::streamsize width = os.width();
    bool punct = (os.flags() & std::ios_base::boolalpha) != 0;

    os.width(0);

    if (punct)
        os << '[';

    os.width(width); os << p.i0; os << ' ';
    os.width(width); os << p.i1;

    if (punct)
        os << ']';
    return os;

    LITE_ARRAY_USE(p);
}


template<
    typename char_type_,
    typename traits_type_,
    typename type0_,
    typename type1_,
    typename type2_
    >
std::basic_ostream<char_type_, traits_type_>&
operator<<(
    std::basic_ostream<char_type_, traits_type_>& os, 
    const pack<type0_,type1_,type2_>& p)
{
    std::streamsize width = os.width();
    bool punct = (os.flags() & std::ios_base::boolalpha) != 0;

    os.width(0);

    if (punct)
        os << '[';

    os.width(width); os << p.i0; os << ' ';
    os.width(width); os << p.i1; os << ' ';
    os.width(width); os << p.i2;

    if (punct)
        os << ']';
    return os;

    LITE_ARRAY_USE(p);
}


template<
    typename char_type_,
    typename traits_type_,
    typename type0_,
    typename type1_,
    typename type2_,
    typename type3_
    >
std::basic_ostream<char_type_, traits_type_>&
operator<<(
    std::basic_ostream<char_type_, traits_type_>& os, 
    const pack<type0_,type1_,type2_,type3_>& p)
{
    std::streamsize width = os.width();
    bool punct = (os.flags() & std::ios_base::boolalpha) != 0;

    os.width(0);

    if (punct)
        os << '[';

    os.width(width); os << p.i0; os << ' ';
    os.width(width); os << p.i1; os << ' ';
    os.width(width); os << p.i2; os << ' ';
    os.width(width); os << p.i3;

    if (punct)
        os << ']';
    return os;

    LITE_ARRAY_USE(p);
}


#endif // !DOCUMENTATION_ONLY
/***********************************************************************************************************/
/* pack io, operator>> *************************************************************************************/
/***********************************************************************************************************/

#ifdef DOCUMENTATION_ONLY

/*!
    \brief Scans (reads) the pack \a p from the input stream \a is.

    \ingroup array_tools
    \anchor array_pack_input
     
    The input could be surrounded in a matching pair of square brackets. 
    The constant elements are read from the input stream but their input value will be ignored.

    \par Example:

    \code 
        pack<int, constant<int, 5>, int> p;
        std::cin >> p;
        std::cout << p << std::endl;
    \endcode 
    If the input is:
    \verbatim
        [1 2 3]
    \endverbatim
    The output would be:
    \verbatim
        [1 5 3]
    \endverbatim
*/
template<typename char_type_, typename traits_type_, typename type0_, ..., typename typeN_>
std::basic_istream<char_type_, traits_type_>&
operator>>(
    std::basic_istream<char_type_, traits_type_>& is, 
    pack<type0_, ..., typeN_>& p);

#else // DOCUMENTATION_ONLY


template<
    typename char_type_,
    typename traits_type_
    >
std::basic_istream<char_type_, traits_type_>&
operator>>(
    std::basic_ostream<char_type_, traits_type_>& is, 
    pack<>& p)
{
    char_type_ ch;

    if (!(is >> ch))
        return is;
        
    bool fancy = is.narrow(ch, '\0') == '[';

    if (!fancy)
        is.putback(ch);


    ch = char_type_();
    if (fancy && !(is >> ch && is.narrow(ch, '\0') == ']')) {
        is.setstate(std::ios_base::failbit);
        return is;
    }
    
    p.set();
    return is;
    LITE_ARRAY_USE(p);
}


template<
    typename char_type_,
    typename traits_type_,
    typename type0_
    >
std::basic_istream<char_type_, traits_type_>&
operator>>(
    std::basic_ostream<char_type_, traits_type_>& is, 
    pack<type0_>& p)
{
    char_type_ ch;

    if (!(is >> ch))
        return is;
        
    bool fancy = is.narrow(ch, '\0') == '[';

    if (!fancy)
        is.putback(ch);

    type0_ i0; is >> i0;

    ch = char_type_();
    if (fancy && !(is >> ch && is.narrow(ch, '\0') == ']')) {
        is.setstate(std::ios_base::failbit);
        return is;
    }
    
    p.set(i0);
    return is;
}


template<
    typename char_type_,
    typename traits_type_,
    typename type0_,
    typename type1_
    >
std::basic_istream<char_type_, traits_type_>&
operator>>(
    std::basic_ostream<char_type_, traits_type_>& is, 
    pack<type0_,type1_>& p)
{
    char_type_ ch;

    if (!(is >> ch))
        return is;
        
    bool fancy = is.narrow(ch, '\0') == '[';

    if (!fancy)
        is.putback(ch);

    type0_ i0; is >> i0;
    type1_ i1; is >> i1;

    ch = char_type_();
    if (fancy && !(is >> ch && is.narrow(ch, '\0') == ']')) {
        is.setstate(std::ios_base::failbit);
        return is;
    }
    
    p.set(i0, i1);
    return is;
}


template<
    typename char_type_,
    typename traits_type_,
    typename type0_,
    typename type1_,
    typename type2_
    >
std::basic_istream<char_type_, traits_type_>&
operator>>(
    std::basic_ostream<char_type_, traits_type_>& is, 
    pack<type0_,type1_,type2_>& p)
{
    char_type_ ch;

    if (!(is >> ch))
        return is;
        
    bool fancy = is.narrow(ch, '\0') == '[';

    if (!fancy)
        is.putback(ch);

    type0_ i0; is >> i0;
    type1_ i1; is >> i1;
    type2_ i2; is >> i2;

    ch = char_type_();
    if (fancy && !(is >> ch && is.narrow(ch, '\0') == ']')) {
        is.setstate(std::ios_base::failbit);
        return is;
    }
    
    p.set(i0, i1, i2);
    return is;
}


template<
    typename char_type_,
    typename traits_type_,
    typename type0_,
    typename type1_,
    typename type2_,
    typename type3_
    >
std::basic_istream<char_type_, traits_type_>&
operator>>(
    std::basic_ostream<char_type_, traits_type_>& is, 
    pack<type0_,type1_,type2_,type3_>& p)
{
    char_type_ ch;

    if (!(is >> ch))
        return is;
        
    bool fancy = is.narrow(ch, '\0') == '[';

    if (!fancy)
        is.putback(ch);

    type0_ i0; is >> i0;
    type1_ i1; is >> i1;
    type2_ i2; is >> i2;
    type3_ i3; is >> i3;

    ch = char_type_();
    if (fancy && !(is >> ch && is.narrow(ch, '\0') == ']')) {
        is.setstate(std::ios_base::failbit);
        return is;
    }
    
    p.set(i0, i1, i2, i3);
    return is;
}


#endif // !DOCUMENTATION_ONLY

/***********************************************************************************************************/
/* error checking functions ********************************************************************************/
/***********************************************************************************************************/

/*!
    \ingroup array_tools
    This function will throw a lite::size_mismatch_error exception containing the message \a msg if \a a != \a b.
*/
template<typename left_size_type_, typename right_size_type_>
void lite_array_size_check(const left_size_type_& a, const right_size_type_& b, const std::string& msg)
{
    if (a != b)
        throw size_mismatch_error(msg);
}

} // namespace lite

/***********************************************************************************************************/
/* iterator_traits<pack<...> > *****************************************************************************/
/***********************************************************************************************************/

namespace std
{
    template<
            typename type0_,
            typename type1_,
            typename type2_,
            typename type3_
            >
    struct iterator_traits<lite::pack<
            type0_,
            type1_,
            type2_,
            type3_
        > >
        : public iterator_traits<type0_>
    {};
} // namespace std

namespace lite
{ 

/***********************************************************************************************************/
/* s_iterator **********************************************************************************************/
/***********************************************************************************************************/

/*!
    \class lite::s_iterator
    \brief 
    An \c s_iterator is used to represent a general multidimensional strided iterator using a stl style 
    iterator and stride lengths for each dimension. 
    
    \ingroup array_advanced

    The \c s_iterator is not actually a separate class or type. 
    It is represented by a lite::pack object. The first element of the pack (element 0) stores a pointer or 
    another type of stl style iterator. The elements 1 to N store the stride values for the dimensions 1
    to N respectively. The type of each of the stride elements is:
    - either \c int for non-constant size strides
    - or <c>lite::constant<int, _stride></c> for a constant size stride of lenght \c _stride.

    All the required operations (i.e. <c>at()</c>, <c>inc()</c>, <c>dec()</c>, <c>shift()</c>) 
    are also defined.

    For example:
    \code
        array<float[3][4][5]> a;

        // Below is the actual type of the iterator for array a
        pack<float*, constant<int, 20>, constant<int, 5>, constant<int, 1> > it_a;  
        
        it_a = a.begin();
        at(it_a, 1, 2, 3) = -1;
        // the previous line is equivalent to:
        a(1, 2, 3) = -1;

        array<float[1][1][5]> b(3, 4, 5);

        // Below is the actual type of the iterator for array b
        pack<float*, int, constant<int, 5>, constant<int, 1> > it_b = b.begin();
    \endcode
*/

/***********************************************************************************************************/
/* s_iterator, at() ****************************************************************************************/
/***********************************************************************************************************/

template<
    typename iter_type_
    >
LITE_INLINE 
typename std::iterator_traits<pack<
    iter_type_
    > >::reference 
at(const pack<
    iter_type_
    >& it
    )
{
    return *(it.i0);
}
template<
    typename iter_type_,
    typename ind_type0_
    >
LITE_INLINE 
typename std::iterator_traits<pack<
    iter_type_,
    ind_type0_
    > >::reference 
at(const pack<
    iter_type_,
    ind_type0_
    >& it
    )
{
    return *(it.i0);
}
template<
    typename iter_type_,
    typename ind_type0_
    >
LITE_INLINE 
typename std::iterator_traits<pack<
    iter_type_,
    ind_type0_
    > >::reference 
at(const pack<
    iter_type_,
    ind_type0_
    >& it,
    int ind0
    )
{
    return *(it.i0+ind0*it.i1);
}
template<
    typename iter_type_,
    typename ind_type0_,
    typename ind_type1_
    >
LITE_INLINE 
typename std::iterator_traits<pack<
    iter_type_,
    ind_type0_,
    ind_type1_
    > >::reference 
at(const pack<
    iter_type_,
    ind_type0_,
    ind_type1_
    >& it
    )
{
    return *(it.i0);
}
template<
    typename iter_type_,
    typename ind_type0_,
    typename ind_type1_
    >
LITE_INLINE 
typename std::iterator_traits<pack<
    iter_type_,
    ind_type0_,
    ind_type1_
    > >::reference 
at(const pack<
    iter_type_,
    ind_type0_,
    ind_type1_
    >& it,
    int ind0
    )
{
    return *(it.i0+ind0*it.i2);
}
template<
    typename iter_type_,
    typename ind_type0_,
    typename ind_type1_
    >
LITE_INLINE 
typename std::iterator_traits<pack<
    iter_type_,
    ind_type0_,
    ind_type1_
    > >::reference 
at(const pack<
    iter_type_,
    ind_type0_,
    ind_type1_
    >& it,
    int ind0,
    int ind1
    )
{
    return *(it.i0+ind0*it.i1+ind1*it.i2);
}
template<
    typename iter_type_,
    typename ind_type0_,
    typename ind_type1_,
    typename ind_type2_
    >
LITE_INLINE 
typename std::iterator_traits<pack<
    iter_type_,
    ind_type0_,
    ind_type1_,
    ind_type2_
    > >::reference 
at(const pack<
    iter_type_,
    ind_type0_,
    ind_type1_,
    ind_type2_
    >& it
    )
{
    return *(it.i0);
}
template<
    typename iter_type_,
    typename ind_type0_,
    typename ind_type1_,
    typename ind_type2_
    >
LITE_INLINE 
typename std::iterator_traits<pack<
    iter_type_,
    ind_type0_,
    ind_type1_,
    ind_type2_
    > >::reference 
at(const pack<
    iter_type_,
    ind_type0_,
    ind_type1_,
    ind_type2_
    >& it,
    int ind0
    )
{
    return *(it.i0+ind0*it.i3);
}
template<
    typename iter_type_,
    typename ind_type0_,
    typename ind_type1_,
    typename ind_type2_
    >
LITE_INLINE 
typename std::iterator_traits<pack<
    iter_type_,
    ind_type0_,
    ind_type1_,
    ind_type2_
    > >::reference 
at(const pack<
    iter_type_,
    ind_type0_,
    ind_type1_,
    ind_type2_
    >& it,
    int ind0,
    int ind1
    )
{
    return *(it.i0+ind0*it.i2+ind1*it.i3);
}
template<
    typename iter_type_,
    typename ind_type0_,
    typename ind_type1_,
    typename ind_type2_
    >
LITE_INLINE 
typename std::iterator_traits<pack<
    iter_type_,
    ind_type0_,
    ind_type1_,
    ind_type2_
    > >::reference 
at(const pack<
    iter_type_,
    ind_type0_,
    ind_type1_,
    ind_type2_
    >& it,
    int ind0,
    int ind1,
    int ind2
    )
{
    return *(it.i0+ind0*it.i1+ind1*it.i2+ind2*it.i3);
}

/***********************************************************************************************************/
/* s_iterator, inc() ***************************************************************************************/
/***********************************************************************************************************/

template<
    int dim_, 
    typename iter_type_,
    typename ind_type0_,
    typename ind_type1_,
    typename ind_type2_
    >
LITE_INLINE 
typename detail::enable_if<dim_==0, void>::type 
inc(pack<
    iter_type_,
    ind_type0_,
    ind_type1_,
    ind_type2_
    >& it)
{
    it.i0 += it.i1;
}

template<
    int dim_, 
    typename iter_type_,
    typename ind_type0_,
    typename ind_type1_,
    typename ind_type2_
    >
LITE_INLINE 
typename detail::enable_if<dim_==1, void>::type 
inc(pack<
    iter_type_,
    ind_type0_,
    ind_type1_,
    ind_type2_
    >& it)
{
    it.i0 += it.i2;
}

template<
    int dim_, 
    typename iter_type_,
    typename ind_type0_,
    typename ind_type1_,
    typename ind_type2_
    >
LITE_INLINE 
typename detail::enable_if<dim_==2, void>::type 
inc(pack<
    iter_type_,
    ind_type0_,
    ind_type1_,
    ind_type2_
    >& it)
{
    it.i0 += it.i3;
}


/***********************************************************************************************************/
/* s_iterator, dec() ***************************************************************************************/
/***********************************************************************************************************/

template<
    int dim_, 
    typename iter_type_,
    typename ind_type0_,
    typename ind_type1_,
    typename ind_type2_
    >
LITE_INLINE 
typename detail::enable_if<dim_==0, void>::type 
dec(pack<
    iter_type_,
    ind_type0_,
    ind_type1_,
    ind_type2_
    >& it)
{
    it.i0 -= it.i1;
}

template<
    int dim_, 
    typename iter_type_,
    typename ind_type0_,
    typename ind_type1_,
    typename ind_type2_
    >
LITE_INLINE 
typename detail::enable_if<dim_==1, void>::type 
dec(pack<
    iter_type_,
    ind_type0_,
    ind_type1_,
    ind_type2_
    >& it)
{
    it.i0 -= it.i2;
}

template<
    int dim_, 
    typename iter_type_,
    typename ind_type0_,
    typename ind_type1_,
    typename ind_type2_
    >
LITE_INLINE 
typename detail::enable_if<dim_==2, void>::type 
dec(pack<
    iter_type_,
    ind_type0_,
    ind_type1_,
    ind_type2_
    >& it)
{
    it.i0 -= it.i3;
}


/***********************************************************************************************************/
/* s_iterator, shift() *************************************************************************************/
/***********************************************************************************************************/

template<
    int dim_, 
    typename iter_type_,
    typename ind_type0_,
    typename ind_type1_,
    typename ind_type2_
    >
LITE_INLINE 
typename detail::enable_if<dim_==0, void>::type 
shift(pack<
    iter_type_,
    ind_type0_,
    ind_type1_,
    ind_type2_
    >& it,
    int diff)
{
    it.i0 += diff*it.i1;
}

template<
    int dim_, 
    typename iter_type_,
    typename ind_type0_,
    typename ind_type1_,
    typename ind_type2_
    >
LITE_INLINE 
typename detail::enable_if<dim_==1, void>::type 
shift(pack<
    iter_type_,
    ind_type0_,
    ind_type1_,
    ind_type2_
    >& it,
    int diff)
{
    it.i0 += diff*it.i2;
}

template<
    int dim_, 
    typename iter_type_,
    typename ind_type0_,
    typename ind_type1_,
    typename ind_type2_
    >
LITE_INLINE 
typename detail::enable_if<dim_==2, void>::type 
shift(pack<
    iter_type_,
    ind_type0_,
    ind_type1_,
    ind_type2_
    >& it,
    int diff)
{
    it.i0 += diff*it.i3;
}


/***********************************************************************************************************/
/* c_iterator **********************************************************************************************/
/***********************************************************************************************************/

/*!
    \brief This class implements an iterator that returns the same value everywhere.

    \ingroup array_advanced

    The value can be specified as a constructor argument.

    \par Example:

    \code
        c_iterator<float> it(1.5f);

        std::cout << at(it) << std::endl;
        std::cout << at(it, 2, 3, 4) << std::endl;
        shift<2>(it, -5);
        std::cout << at(it, 2, 3, 4) << std::endl;

        typedef array<float[2][2], default_traits_type, reference_rep<c_iterator<float> > A;

        A a(it, A::size_type());

        std::cout << a << std::endl;
    \endcode
    The output would be:
    \verbatim
        1.5
        1.5
        1.5
        1.5 1.5
        1.5 1.5
    \endverbatim
*/
template<class value_type_>
class c_iterator
{
public:
    typedef std::random_access_iterator_tag iterator_category; 
    typedef value_type_ value_type;
    typedef ptrdiff_t difference_type;
    typedef const value_type_* pointer;
    typedef const value_type_& reference;

    LITE_INLINE c_iterator() {}

    //! Construct a c_iterator that returns \a value everywhere
    LITE_INLINE c_iterator(const value_type& value) : value(value) {}

    LITE_INLINE c_iterator(const c_iterator& other) : value(other.value) {}

    template<class other_value_type_>
    LITE_INLINE c_iterator(const c_iterator<other_value_type_>& other) : value(other.value) {}

    LITE_INLINE c_iterator& operator=(const c_iterator& other) 
    {
        value = other.value;
        return *this;
    }

    template<class other_value_type_>
    LITE_INLINE c_iterator& operator=(const c_iterator<other_value_type_>& other)
    {
        value = other.value;
        return *this;
    }

    //! This variable stores the value that is returned by c_iterator
    value_type value;
};

/*!
    \brief Constructs and returns a lite::c_iterator that returns \a val everywhere.

    \ingroup array_advanced
*/
template<class value_type_>
LITE_INLINE c_iterator<value_type_> 
make_c_iterator(const value_type_& val)
{
    return c_iterator<value_type_>(val);
}

/***********************************************************************************************************/
/* c_iterator, at() ****************************************************************************************/
/***********************************************************************************************************/

template<typename value_type_>
LITE_INLINE 
typename std::iterator_traits<c_iterator<value_type_> >::reference
at(const c_iterator<value_type_>& it )
{
    return it.value;
}
template<typename value_type_>
LITE_INLINE 
typename std::iterator_traits<c_iterator<value_type_> >::reference
at(const c_iterator<value_type_>& it, int )
{
    return it.value;
}
template<typename value_type_>
LITE_INLINE 
typename std::iterator_traits<c_iterator<value_type_> >::reference
at(const c_iterator<value_type_>& it, int , int )
{
    return it.value;
}
template<typename value_type_>
LITE_INLINE 
typename std::iterator_traits<c_iterator<value_type_> >::reference
at(const c_iterator<value_type_>& it, int , int , int )
{
    return it.value;
}

/***********************************************************************************************************/
/* c_iterator, inc() ***************************************************************************************/
/***********************************************************************************************************/

template<int dim_, typename value_type_>
LITE_INLINE void inc(c_iterator<value_type_>&) {}

/***********************************************************************************************************/
/* c_iterator, dec() ***************************************************************************************/
/***********************************************************************************************************/

template<int dim_, typename value_type_>
LITE_INLINE void dec(c_iterator<value_type_>&) {}

/***********************************************************************************************************/
/* c_iterator, shift() *************************************************************************************/
/***********************************************************************************************************/

template<int dim_, typename value_type_>
LITE_INLINE void shift(c_iterator<value_type_>&, int) {}

/***********************************************************************************************************/
/* u_iterator **********************************************************************************************/
/***********************************************************************************************************/

#ifdef DOCUMENTATION_ONLY
/*!
    \brief 
    This class implements an iterator that returns the result of applying a function object
    to the return value of another iterator.

    \ingroup array_advanced

    The type \a base_iter_type_ specifies the type of the underlying iterator. 
    The type \a func_type_ specifies the type of the function object that is applied to the return 
    value of the base iterator. If \a is_static_ is true then the function object will be a static member
    of the u_iterator object and thus won't occupy any memory in the u_iterator object.
    If \a is_static_ is false then the function object will be a regular member
    of the u_iterator object and thus will occupy memory in the u_iterator object.

    All the required operations (i.e. <c>at()</c>, <c>inc()</c>, <c>dec()</c>, <c>shift()</c>) 
    are also defined.

    \par Example:

    \code
        typedef array<float[2][2]> A;

        A a;
        
        typedef u_iterator<A::iterator, lite::square, true> Iter; 
        typedef array<float[2][2], default_array_traits, reference_rep<Iter> > B;

        B b(Iter(a.begin()), a.size());

        std::cin >> a; 
        std::cout << b << std::endl;
    \endcode
    Assuming that the input is:
    \verbatim
        1 2
        3 4
    \endverbatim
    The output would be:
    \verbatim
        1 4
        9 16
    \endverbatim
*/
template<typename base_iter_type_, typename func_type_, bool is_static_ =true>
class u_iterator
{
public:
    typedef base_iter_type_ base_iterator_type;
    typedef func_type_ function_type;
    static const bool is_static = is_static_;

    typedef std::random_access_iterator_tag iterator_category;
    typedef typename detail::remove<typename func_type_::result_type, const volatile int&>::type value_type;
    typedef ptrdiff_t difference_type;
    typedef typename func_type_::result_type reference;
    typedef typename detail::remove<typename func_type_::result_type, int&>::type* pointer;

    LITE_INLINE u_iterator();

    //! Creates a u_iterator with the base iterator \a base_iter
    template<class other_base_iter_type_>
    LITE_INLINE u_iterator(const other_base_iter_type_& base_iter);

    /*! 
        \brief Creates a u_iterator with the base iterator \a base_iter and the function object \a func.

        \remark This constructor is defined only if \a is_static_ is false.
    */
    template<class other_base_iter_type_>
    LITE_INLINE u_iterator(const other_base_iter_type_& base_iter, const function_type& func);

    LITE_INLINE u_iterator(const u_iterator& other);

    template<class other_base_iter_type_>
    LITE_INLINE u_iterator(const u_iterator<other_base_iter_type_, func_type_, is_static_>& other);

    LITE_INLINE u_iterator& operator=(const u_iterator& other);

    template<typename other_base_iter_type_>
    LITE_INLINE u_iterator& operator=(const u_iterator<other_base_iter_type_, func_type_, is_static_>& other);

    //! This variable stores the base iterator
    base_iterator_type base_iterator;

    //! This variable stores the function object. It will be a static member if \a is_static_ is true.
    function_type function;
};

#endif // DOCUMENTATION_ONLY

/***********************************************************************************************************/
/* u_iterator - unary iterator (static) ********************************************************************/
/***********************************************************************************************************/

#ifndef DOCUMENTATION_ONLY

template<typename base_iter_type_, typename func_type_>
class u_iterator<base_iter_type_, func_type_, true>
{
public:
    typedef base_iter_type_ base_iterator_type;
    typedef func_type_ function_type;
    static const bool is_static = true;

    typedef std::random_access_iterator_tag iterator_category;
    typedef typename detail::remove<typename func_type_::result_type, const volatile int&>::type value_type;
    typedef ptrdiff_t difference_type;
    typedef typename func_type_::result_type reference;
    typedef typename detail::remove<typename func_type_::result_type, int&>::type* pointer;

    LITE_INLINE u_iterator() {}

    template<class other_base_iter_type_>
    LITE_INLINE u_iterator(const other_base_iter_type_& base_iter)
        : base_iterator(base_iter) {}

    LITE_INLINE u_iterator(const u_iterator& other)
        : base_iterator(other.base_iterator) {}

    template<class other_base_iter_type_>
    LITE_INLINE u_iterator(const u_iterator<other_base_iter_type_, func_type_, true>& other)
        : base_iterator(other.base_iterator) {}

    LITE_INLINE u_iterator& operator=(const u_iterator& other)
    {
        base_iterator = other.base_iterator;
        return *this;
    }

    template<typename other_base_iter_type_>
    LITE_INLINE u_iterator& operator=(const u_iterator<other_base_iter_type_, func_type_, true>& other)
    {
        base_iterator = other.base_iterator;
        return *this;
    }

    base_iterator_type base_iterator;
    static function_type function;
};

template<typename base_iter_type_, typename func_type_>
typename u_iterator<base_iter_type_, func_type_, true>::function_type
u_iterator<base_iter_type_, func_type_, true>::function;

#endif // !DOCUMENTATION_ONLY

/*!
    \brief 
    Creates a lite::u_iterator from a base iterator \a it 
    and a static function object of type \a func_type_.

    \ingroup array_advanced
*/
template<typename func_type_, typename base_iter_type_>
LITE_INLINE u_iterator<base_iter_type_, func_type_, true>
make_u_iterator(const base_iter_type_& it)
{
    return u_iterator<base_iter_type_, func_type_, true>(it);
}

/***********************************************************************************************************/
/* u_iterator - unary iterator (non-static) ****************************************************************/
/***********************************************************************************************************/

#ifndef DOCUMENTATION_ONLY

template<typename base_iter_type_, typename func_type_>
class u_iterator<base_iter_type_, func_type_, false>
{
public:
    typedef base_iter_type_ base_iterator_type;
    typedef func_type_ function_type;
    static const bool is_static = false;

    typedef std::random_access_iterator_tag iterator_category;
    typedef typename detail::remove<typename func_type_::result_type, const volatile int&>::type value_type;
    typedef ptrdiff_t difference_type;
    typedef typename func_type_::result_type reference;
    typedef typename detail::remove<typename func_type_::result_type, int&>::type* pointer;

    LITE_INLINE u_iterator() {}

    template<class other_base_iter_type_>
    LITE_INLINE u_iterator(const other_base_iter_type_& base_iter, const function_type& func =function_type())
        : base_iterator(base_iter), function(func) {}

    LITE_INLINE u_iterator(const u_iterator& other)
        : base_iterator(other.base_iterator), function(other.function) {}

    template<typename other_base_iter_type_>
    LITE_INLINE u_iterator(const u_iterator<other_base_iter_type_, func_type_, false>& other)
        : base_iterator(other.base_iterator), function(other.function) {}

    LITE_INLINE u_iterator& operator=(const u_iterator& other)
    {
        base_iterator = other.base_iterator;
        function = other.function;
        return *this;
    }

    template<typename other_base_iter_type_>
    LITE_INLINE u_iterator& operator=(const u_iterator<other_base_iter_type_, func_type_, false>& other)
    {
        base_iterator = other.base_iterator;
        function = other.function;
        return *this;
    }

    base_iterator_type base_iterator;
    function_type function;
};

#endif // !DOCUMENTATION_ONLY

/*!
    \brief Creates a lite::u_iterator from a base iterator \a it and function object \a func

    \ingroup array_advanced
*/
template<typename func_type_, typename base_iter_type_>
LITE_INLINE u_iterator<base_iter_type_, func_type_, false>
make_u_iterator(const base_iter_type_& it, const func_type_& func)
{
    return u_iterator<base_iter_type_, func_type_, false>(it, func);
}

/***********************************************************************************************************/
/* u_iterator, at() ****************************************************************************************/
/***********************************************************************************************************/

template<typename base_iter_type_, typename func_type_, bool is_static_>
LITE_INLINE 
typename u_iterator<base_iter_type_, func_type_, is_static_>::reference
at(const u_iterator<base_iter_type_, func_type_, is_static_>& it
    )
{
    return it.function(at(it.base_iterator 
    ));
}
template<typename base_iter_type_, typename func_type_, bool is_static_>
LITE_INLINE 
typename u_iterator<base_iter_type_, func_type_, is_static_>::reference
at(const u_iterator<base_iter_type_, func_type_, is_static_>& it,
    int ind0
    )
{
    return it.function(at(it.base_iterator, 
        ind0
    ));
}
template<typename base_iter_type_, typename func_type_, bool is_static_>
LITE_INLINE 
typename u_iterator<base_iter_type_, func_type_, is_static_>::reference
at(const u_iterator<base_iter_type_, func_type_, is_static_>& it,
    int ind0,
    int ind1
    )
{
    return it.function(at(it.base_iterator, 
        ind0,
        ind1
    ));
}
template<typename base_iter_type_, typename func_type_, bool is_static_>
LITE_INLINE 
typename u_iterator<base_iter_type_, func_type_, is_static_>::reference
at(const u_iterator<base_iter_type_, func_type_, is_static_>& it,
    int ind0,
    int ind1,
    int ind2
    )
{
    return it.function(at(it.base_iterator, 
        ind0,
        ind1,
        ind2
    ));
}

/***********************************************************************************************************/
/* u_iterator, inc() ***************************************************************************************/
/***********************************************************************************************************/

template<int dim_, typename base_iter_type_, typename func_type_, bool is_static_>
LITE_INLINE void inc(u_iterator<base_iter_type_, func_type_, is_static_>& it) 
{
    inc<dim_>(it.base_iterator);
}

/***********************************************************************************************************/
/* u_iterator, dec() ***************************************************************************************/
/***********************************************************************************************************/

template<int dim_, typename base_iter_type_, typename func_type_, bool is_static_>
LITE_INLINE void dec(u_iterator<base_iter_type_, func_type_, is_static_>& it) 
{
    dec<dim_>(it.base_iterator);
}

/***********************************************************************************************************/
/* u_iterator, shift() *************************************************************************************/
/***********************************************************************************************************/

template<int dim_, typename base_iter_type_, typename func_type_, bool is_static_>
LITE_INLINE void shift(u_iterator<base_iter_type_, func_type_, is_static_>& it, int diff) 
{
    shift<dim_>(it.base_iterator, diff);
}

/***********************************************************************************************************/
/* b_iterator **********************************************************************************************/
/***********************************************************************************************************/

#ifdef DOCUMENTATION_ONLY
/*!
    \brief 
    This class implements an iterator that returns the result of applying a binary function object
    to the return value of two other iterators.

    \ingroup array_advanced

    The type \a left_base_iter_type_ and \a right_base_iter_type_ specify the type of 
    the underlying iterators. 
    The type \a func_type_ specifies the type of the binary function object that is applied to the return 
    value of the the two bsae iterators. 
    If \a is_static_ is true then the function object will be a static member
    of the b_iterator object and thus won't occupy any memory in the b_iterator object.
    If \a is_static_ is false then the function object will be a regular member
    of the b_iterator object and thus will occupy memory in the b_iterator object.

    All the required operations (i.e. <c>at()</c>, <c>inc()</c>, <c>dec()</c>, <c>shift()</c>) 
    are also defined.

    \par Example:

    \code
        typedef array<float[2][2]> A;

        A a1, a2;

        typedef b_iterator<A::iterator, A::iterator, lite::plus, true> Iter; 
        typedef array<float[2][2], default_array_traits, reference_rep<Iter> > B;

        B b(Iter(a1.begin(), a2.begin()), a1.size());

        std::cin >> a1 >> a2; 
        std::cout << b << std::endl;
    \endcode
    Assuming that the input is:
    \verbatim
        1 2
        3 4
        1 10
        10 1
    \endverbatim
    The output would be:
    \verbatim
        2 12
        13 5
    \endverbatim
*/

template<
    typename left_base_iterator_type_, 
    typename right_base_iterator_type_, 
    typename func_type_, 
    bool is_static_ =true>
class b_iterator
{
public:
    typedef left_base_iterator_type_ left_base_iterator_type;
    typedef right_base_iterator_type_ right_base_iterator_type;
    typedef func_type_ function_type;
    static const bool is_static = is_static_;

    typedef std::random_access_iterator_tag iterator_category;
    typedef typename detail::remove<typename func_type_::result_type, const volatile int&>::type value_type;
    typedef ptrdiff_t difference_type;
    typedef typename func_type_::result_type reference;
    typedef typename detail::remove<typename func_type_::result_type, int&>::type* pointer;

    LITE_INLINE b_iterator() {}

    
    //! Creates a b_iterator from the base iterators \a lbase_iter and \a rbase_iter
    template<typename other_left_base_iterator_type_, typename other_right_base_iterator_type_>
    LITE_INLINE b_iterator(
        const other_left_base_iterator_type_& lbase_iter, 
        const other_right_base_iterator_type_& rbase_iter);

    LITE_INLINE b_iterator(const b_iterator& other);

    /*! 
        \brief 
        Creates a b_iterator with the base iterators \a lbase_iter and \a rbase_iter 
        and the function object \a func.

        \remark This constructor is defined only if \a is_static_ is false.
    */
    template<typename other_left_base_iterator_type_, typename other_right_base_iterator_type_>
    LITE_INLINE b_iterator(
        const b_iterator<
            other_left_base_iterator_type_, 
            other_right_base_iterator_type_, 
            func_type_, 
            is_static_>& other);

    template<typename other_left_base_iterator_type_, typename other_right_base_iterator_type_>
    LITE_INLINE b_iterator(
        const other_left_base_iterator_type_& lbase_iter, 
        const other_right_base_iterator_type_& rbase_iter, 
        const function_type& func);


    LITE_INLINE b_iterator& operator=(const b_iterator& other);

    template<typename other_left_base_iterator_type_, typename other_right_base_iterator_type_>
    LITE_INLINE b_iterator& 
    operator=(const b_iterator<
        other_left_base_iterator_type_, 
        other_right_base_iterator_type_, 
        func_type_, 
        is_static_>& other);
    
    //! This variable stores the left base iterator
    left_base_iterator_type left_base_iterator;

    //! This variable stores the right base iterator
    right_base_iterator_type right_base_iterator;

    //! This variable stores the function object. It will be a static member if \a is_static_ is true.
    function_type function;
};


#endif // DOCUMENTATION_ONLY

/***********************************************************************************************************/
/* b_iterator - binary iterator (static) *******************************************************************/
/***********************************************************************************************************/

#ifndef DOCUMENTATION_ONLY

template<typename left_base_iterator_type_, typename right_base_iterator_type_, typename func_type_>
class b_iterator<left_base_iterator_type_, right_base_iterator_type_, func_type_, true>
{
public:
    typedef left_base_iterator_type_ left_base_iterator_type;
    typedef right_base_iterator_type_ right_base_iterator_type;
    typedef func_type_ function_type;
    static const bool is_static = true;

    typedef std::random_access_iterator_tag iterator_category;
    typedef typename detail::remove<typename func_type_::result_type, const volatile int&>::type value_type;
    typedef ptrdiff_t difference_type;
    typedef typename func_type_::result_type reference;
    typedef typename detail::remove<typename func_type_::result_type, int&>::type* pointer;

    LITE_INLINE b_iterator() {}

    template<typename other_left_base_iterator_type_, typename other_right_base_iterator_type_>
    LITE_INLINE b_iterator(
        const other_left_base_iterator_type_& lbase_iter, 
        const other_right_base_iterator_type_& rbase_iter)
        : left_base_iterator(lbase_iter), right_base_iterator(rbase_iter) {}

    LITE_INLINE b_iterator(const b_iterator& other)
        : left_base_iterator(other.left_base_iterator), 
        right_base_iterator(other.right_base_iterator)
    {}

    template<typename other_left_base_iterator_type_, typename other_right_base_iterator_type_>
    LITE_INLINE b_iterator(
        const b_iterator<
            other_left_base_iterator_type_, 
            other_right_base_iterator_type_, 
            func_type_, 
            true>& other)
        : left_base_iterator(other.left_base_iterator), 
        right_base_iterator(other.right_base_iterator)
    {}

    LITE_INLINE b_iterator& operator=(const b_iterator& other)
    {
        left_base_iterator = other.left_base_iterator;
        right_base_iterator = other.right_base_iterator;
        return *this;
    }

    template<typename other_left_base_iterator_type_, typename other_right_base_iterator_type_>
    LITE_INLINE b_iterator& 
    operator=(const b_iterator<
        other_left_base_iterator_type_, 
        other_right_base_iterator_type_, 
        func_type_, 
        true>& other)
    {
        left_base_iterator = other.left_base_iterator;
        right_base_iterator = other.right_base_iterator;
        return *this;
    }
    
    left_base_iterator_type left_base_iterator;
    right_base_iterator_type right_base_iterator;
    static function_type function;
};

template<typename left_base_iterator_type_, typename right_base_iterator_type_, typename func_type_>
typename b_iterator<left_base_iterator_type_, right_base_iterator_type_, func_type_, true>::function_type
b_iterator<left_base_iterator_type_, right_base_iterator_type_, func_type_, true>::function;

#endif // !DOCUMENTATION_ONLY

/*!
    \brief 
    Creates a lite::b_iterator from base iterators \a left_it and \a right_it
    and a static function object of type \a func_type_.

    \ingroup array_advanced
*/
template<typename func_type_, typename left_base_iterator_type_, typename right_base_iterator_type_>
LITE_INLINE b_iterator<left_base_iterator_type_, right_base_iterator_type_, func_type_, true>
make_b_iterator(
    const left_base_iterator_type_& left_it, 
    const right_base_iterator_type_& right_it)
{
    return b_iterator<left_base_iterator_type_, right_base_iterator_type_, func_type_, true>
        (left_it, right_it);
}

/***********************************************************************************************************/
/* b_iterator - binary iterator (non-static) ***************************************************************/
/***********************************************************************************************************/

#ifndef DOCUMENTATION_ONLY

template<typename left_base_iterator_type_, typename right_base_iterator_type_, typename func_type_>
class b_iterator<left_base_iterator_type_, right_base_iterator_type_, func_type_, false>
{
public:
    typedef left_base_iterator_type_ left_base_iterator_type;
    typedef right_base_iterator_type_ right_base_iterator_type;
    typedef func_type_ function_type;
    static const bool is_static = false;

    typedef std::random_access_iterator_tag iterator_category;
    typedef typename detail::remove<typename func_type_::result_type, const volatile int&>::type value_type;
    typedef ptrdiff_t difference_type;
    typedef typename func_type_::result_type reference;
    typedef typename detail::remove<typename func_type_::result_type, int&>::type* pointer;

    LITE_INLINE b_iterator() {}

    template<typename other_left_base_iterator_type_, typename other_right_base_iterator_type_>
    LITE_INLINE b_iterator(
        const other_left_base_iterator_type_& lbase_iter, 
        const other_right_base_iterator_type_& rbase_iter, 
        const function_type& func = function_type())
        : left_base_iterator(lbase_iter), right_base_iterator(rbase_iter), function(func) {}

    LITE_INLINE b_iterator(const b_iterator& other)
        : left_base_iterator(other.left_base_iterator), 
        right_base_iterator(other.right_base_iterator), 
        function(other.function) 
    {}

    template<typename other_left_base_iterator_type_, typename other_right_base_iterator_type_>
    LITE_INLINE b_iterator(
        const b_iterator<
            other_left_base_iterator_type_, 
            other_right_base_iterator_type_, 
            func_type_, 
            false>& other)
        : left_base_iterator(other.left_base_iterator), 
        right_base_iterator(other.right_base_iterator), 
        function(other.function) 
    {}

    LITE_INLINE b_iterator& operator=(const b_iterator& other)
    {
        left_base_iterator = other.left_base_iterator;
        right_base_iterator = other.right_base_iterator;
        function = other.function;
        return *this;
    }

    template<typename other_left_base_iterator_type_, typename other_right_base_iterator_type_>
    LITE_INLINE b_iterator& 
    operator=(const b_iterator<
        other_left_base_iterator_type_, 
        other_right_base_iterator_type_, 
        func_type_, 
        false>& other)
    {
        left_base_iterator = other.left_base_iterator;
        right_base_iterator = other.right_base_iterator;
        function = other.function;
        return *this;
    }
    
    left_base_iterator_type left_base_iterator;
    right_base_iterator_type right_base_iterator;
    function_type function;
};

#endif // DOCUMENTATION_ONLY

/*!
    \brief 
    Creates a lite::b_iterator from the base iterators \a left_it and \a right_it 
    and function object \a func.

    \ingroup array_advanced
*/
template<typename func_type_, typename left_base_iterator_type_, typename right_base_iterator_type_>
LITE_INLINE b_iterator<left_base_iterator_type_, right_base_iterator_type_, func_type_, false>
make_b_iterator(
    const left_base_iterator_type_& left_it, 
    const right_base_iterator_type_& right_it, 
    const func_type_& func)
{
    return b_iterator<left_base_iterator_type_, right_base_iterator_type_, func_type_, false>
        (left_it, right_it, func);
}

/***********************************************************************************************************/
/* b_iterator, at() ****************************************************************************************/
/***********************************************************************************************************/

template<typename left_base_iter_type_, typename right_base_iter_type_, typename func_type_, bool is_static_>
LITE_INLINE
typename b_iterator<left_base_iter_type_, right_base_iter_type_, func_type_, is_static_>::reference
at(const b_iterator<left_base_iter_type_, right_base_iter_type_, func_type_, is_static_>& it
    )
{
    return it.function(
        at(it.left_base_iterator 
        ),
        at(it.right_base_iterator 
        )
    );
}
template<typename left_base_iter_type_, typename right_base_iter_type_, typename func_type_, bool is_static_>
LITE_INLINE
typename b_iterator<left_base_iter_type_, right_base_iter_type_, func_type_, is_static_>::reference
at(const b_iterator<left_base_iter_type_, right_base_iter_type_, func_type_, is_static_>& it,
    int ind0
    )
{
    return it.function(
        at(it.left_base_iterator, 
        ind0
        ),
        at(it.right_base_iterator, 
        ind0
        )
    );
}
template<typename left_base_iter_type_, typename right_base_iter_type_, typename func_type_, bool is_static_>
LITE_INLINE
typename b_iterator<left_base_iter_type_, right_base_iter_type_, func_type_, is_static_>::reference
at(const b_iterator<left_base_iter_type_, right_base_iter_type_, func_type_, is_static_>& it,
    int ind0,
    int ind1
    )
{
    return it.function(
        at(it.left_base_iterator, 
        ind0,
        ind1
        ),
        at(it.right_base_iterator, 
        ind0,
        ind1
        )
    );
}
template<typename left_base_iter_type_, typename right_base_iter_type_, typename func_type_, bool is_static_>
LITE_INLINE
typename b_iterator<left_base_iter_type_, right_base_iter_type_, func_type_, is_static_>::reference
at(const b_iterator<left_base_iter_type_, right_base_iter_type_, func_type_, is_static_>& it,
    int ind0,
    int ind1,
    int ind2
    )
{
    return it.function(
        at(it.left_base_iterator, 
        ind0,
        ind1,
        ind2
        ),
        at(it.right_base_iterator, 
        ind0,
        ind1,
        ind2
        )
    );
}

/***********************************************************************************************************/
/* b_iterator, inc() ***************************************************************************************/
/***********************************************************************************************************/

template<
    int dim_, 
    typename left_base_iter_type_, 
    typename right_base_iter_type_, 
    typename func_type_, 
    bool is_static_>
LITE_INLINE void inc(b_iterator<left_base_iter_type_, right_base_iter_type_, func_type_, is_static_>& it) 
{
    inc<dim_>(it.left_base_iterator);
    inc<dim_>(it.right_base_iterator);
}

/***********************************************************************************************************/
/* b_iterator, dec() ***************************************************************************************/
/***********************************************************************************************************/

template<
    int dim_, 
    typename left_base_iter_type_, 
    typename right_base_iter_type_, 
    typename func_type_, 
    bool is_static_>
LITE_INLINE void dec(b_iterator<left_base_iter_type_, right_base_iter_type_, func_type_, is_static_>& it) 
{
    dec<dim_>(it.left_base_iterator);
    dec<dim_>(it.right_base_iterator);
}

/***********************************************************************************************************/
/* b_iterator, shift() *************************************************************************************/
/***********************************************************************************************************/

template<
    int dim_, 
    typename left_base_iter_type_, 
    typename right_base_iter_type_, 
    typename func_type_, 
    bool is_static_>
LITE_INLINE 
void shift(b_iterator<left_base_iter_type_, right_base_iter_type_, func_type_, is_static_>& it, int diff) 
{
    shift<dim_>(it.left_base_iterator, diff);
    shift<dim_>(it.right_base_iterator, diff);
}

/***********************************************************************************************************/
/* size_transformer ****************************************************************************************/
/***********************************************************************************************************/

#ifdef DOCUMENTATION_ONLY

/*!
    \brief 
    This can be used to apply a transform object of type \a transform_type_ 
    to a size object of type \a input_size_type_.
    
    \ingroup array_advanced

    See \ref array_transforms_advanced for more information and examples.
*/
template<typename transform_type_, typename input_size_type_>
struct size_transformer
{
public:
    //! The type of the resulting size object after applying the transform
    typedef ??? size_type;

    /*!
        \brief Apply the transform to the size object \a org and store the result in \a res.

        \remark 
        This overload of the transform() function is optional. Not all transforms provide this overload.
        It is recommended that you provide this overloaded version if an actual transform object 
        does not carry any information required for applying the transform (e.g. like lite::transpose).
    */
    static void transform(const input_size_type_& org, size_type& res);

    /*!
        \brief Apply the transform object \a trans to the size object \a org and store the result in \a res.
    */
    static void transform(const transform_type& trans, const input_size_type_& org, size_type& res);
};

#endif // DOCUMENTATION_ONLY

/***********************************************************************************************************/
/* iterator_transformer ************************************************************************************/
/***********************************************************************************************************/

#ifdef DOCUMENTATION_ONLY

/*!
    \brief 
    This can be used to apply a transform object of type \a transform_type_ 
    to a pair of iterator object and size object respectively of 
    types \a input_size_type_ and \a input_size_type_.
    
    \ingroup array_advanced

    See \ref array_transforms_advanced for more information and examples.
*/
template<typename transform_type_, typename input_iterator_type_, typename input_size_type_>
struct iterator_transformer
{
public:
    //! The type of the resulting iterator object after applying the transform
    typedef ??? iterator_type;

    /*!
        \brief Apply the transform to the iterator object \a org and store the result in \a res.

        \remark 
        This overload of the transform() function is optional. Not all transforms provide this overload.
        It is recommended that you provide this overloaded version if an actual transform object 
        does not carry any information required for applying the transform and also a size object 
        is not required (e.g. like lite::transpose).
    */
    static void transform(
        const input_iterator_type& org, 
        iterator_type& res);

    /*!
        \brief 
        Apply the transform object \a trans to the iterator object \a org and store the result in \a res.

        \remark 
        This overload of the transform() function is optional. Not all transforms provide this overload.
        It is recommended that you provide this overloaded version if a size object 
        is not required (e.g. like all the predefined transforms).
    */
    static void transform(
        const transform_type_& trans, 
        const input_iterator_type& org, 
        iterator_type& res);

    /*!
        \brief 
        Apply the transform object \a trans to the iterator object \a org that is used together with 
        size object \a sz and store the result in \a res.
    */
    static void transform(
        const transform_type_& trans, 
        const input_iterator_type& org, 
        const input_size_type_& sz,
        iterator_type& res);
};

#endif // DOCUMENTATION_ONLY

/***********************************************************************************************************/
/* iterator_transformer, c_iterator ************************************************************************/
/***********************************************************************************************************/

template<typename transform_type_, typename value_type_, typename input_size_type_>
struct iterator_transformer<transform_type_, c_iterator<value_type_>, input_size_type_>
{
public:
    typedef c_iterator<value_type_> input_iterator_type;
    typedef input_iterator_type iterator_type;

    static LITE_INLINE void transform(
        const input_iterator_type& org, 
        iterator_type& res)
    {
        res.value = org.value;
    }

    static LITE_INLINE void transform(
        const transform_type_&, 
        const input_iterator_type& org, 
        iterator_type& res)
    {
        res.value = org.value;
    }

    static LITE_INLINE void transform(
        const transform_type_&, 
        const input_iterator_type& org, 
        const input_size_type_&,
        iterator_type& res)
    {
        res.value = org.value;
    }
};

/***********************************************************************************************************/
/* iterator_transformer, u_iterator ************************************************************************/
/***********************************************************************************************************/

template<
    typename transform_type_,
    typename base_iter_type_, 
    typename func_type_, 
    typename input_size_type_>
struct iterator_transformer<
    transform_type_, 
    u_iterator<base_iter_type_, func_type_, true>, 
    input_size_type_>
{
public:
    typedef iterator_transformer<transform_type_, base_iter_type_, input_size_type_> base_transformer;

    typedef u_iterator<base_iter_type_, func_type_, true> input_iterator_type;
    typedef u_iterator<typename base_transformer::iterator_type, func_type_, true> iterator_type;

    static LITE_INLINE void transform(
        const input_iterator_type& org, 
        iterator_type& res)
    {
        base_transformer::transform(org.base_iterator, res.base_iterator);
    }

    static LITE_INLINE void transform(
        const transform_type_& trans, 
        const input_iterator_type& org, 
        iterator_type& res)
    {
        base_transformer::transform(trans, org.base_iterator, res.base_iterator);
    }

    static LITE_INLINE void transform(
        const transform_type_& trans, 
        const input_iterator_type& org, 
        const input_size_type_& sz,
        iterator_type& res)
    {
        base_transformer::transform(trans, org.base_iterator, sz, res.base_iterator);
    }
};

/***********************************************************************************************************/

template<
    typename transform_type_,
    typename base_iter_type_, 
    typename func_type_, 
    typename input_size_type_>
struct iterator_transformer<
    transform_type_, 
    u_iterator<base_iter_type_, func_type_, false>, 
    input_size_type_>
{
public:
    typedef iterator_transformer<transform_type_, base_iter_type_, input_size_type_> base_transformer;

    typedef u_iterator<base_iter_type_, func_type_, false> input_iterator_type;
    typedef u_iterator<typename base_transformer::iterator_type, func_type_, false> iterator_type;

    static LITE_INLINE void transform(
        const input_iterator_type& org, 
        iterator_type& res)
    {
        base_transformer::transform(org.base_iterator, res.base_iterator);
        res.function = org.function;
    }

    static LITE_INLINE void transform(
        const transform_type_& trans, 
        const input_iterator_type& org, 
        iterator_type& res)
    {
        base_transformer::transform(trans, org.base_iterator, res.base_iterator);
        res.function = org.function;
    }

    static LITE_INLINE void transform(
        const transform_type_& trans, 
        const input_iterator_type& org, 
        const input_size_type_& sz,
        iterator_type& res)
    {
        base_transformer::transform(trans, org.base_iterator, sz, res.base_iterator);
        res.function = org.function;
    }
};

/***********************************************************************************************************/
/* iterator_transformer, b_iterator ************************************************************************/
/***********************************************************************************************************/

template<
    typename transform_type_,
    typename left_base_iter_type_, 
    typename right_base_iter_type_, 
    typename func_type_, 
    typename input_size_type_>
struct iterator_transformer<
    transform_type_, 
    b_iterator<left_base_iter_type_, right_base_iter_type_, func_type_, true>, 
    input_size_type_>
{
public:
    typedef iterator_transformer<transform_type_, left_base_iter_type_, input_size_type_> 
        left_base_transformer;

    typedef iterator_transformer<transform_type_, right_base_iter_type_, input_size_type_> 
        right_base_transformer;

    typedef b_iterator<left_base_iter_type_, right_base_iter_type_, func_type_, true> input_iterator_type;

    typedef b_iterator<
        typename left_base_transformer::iterator_type, 
        typename right_base_transformer::iterator_type, 
        func_type_, 
        true> 
        iterator_type;

    static LITE_INLINE void transform(
        const input_iterator_type& org, 
        iterator_type& res)
    {
        left_base_transformer::transform(org.left_base_iterator, res.left_base_iterator);
        right_base_transformer::transform(org.right_base_iterator, res.right_base_iterator);
    }

    static LITE_INLINE void transform(
        const transform_type_& trans, 
        const input_iterator_type& org, 
        iterator_type& res)
    {
        left_base_transformer::transform(trans, org.left_base_iterator, res.left_base_iterator);
        right_base_transformer::transform(trans, org.right_base_iterator, res.right_base_iterator);
    }

    static LITE_INLINE void transform(
        const transform_type_& trans, 
        const input_iterator_type& org, 
        const input_size_type_& sz,
        iterator_type& res)
    {
        left_base_transformer::transform(trans, org.left_base_iterator, sz, res.left_base_iterator);
        right_base_transformer::transform(trans, org.right_base_iterator, sz, res.right_base_iterator);
    }
};

/***********************************************************************************************************/

template<
    typename transform_type_,
    typename left_base_iter_type_, 
    typename right_base_iter_type_, 
    typename func_type_, 
    typename input_size_type_>
struct iterator_transformer<
    transform_type_, 
    b_iterator<left_base_iter_type_, right_base_iter_type_, func_type_, false>, 
    input_size_type_>
{
public:
    typedef iterator_transformer<transform_type_, left_base_iter_type_, input_size_type_> 
        left_base_transformer;

    typedef iterator_transformer<transform_type_, right_base_iter_type_, input_size_type_> 
        right_base_transformer;

    typedef b_iterator<left_base_iter_type_, right_base_iter_type_, func_type_, false> input_iterator_type;

    typedef b_iterator<
        typename left_base_transformer::iterator_type, 
        typename right_base_transformer::iterator_type, 
        func_type_, 
        false> 
        iterator_type;

    static LITE_INLINE void transform(
        const input_iterator_type& org, 
        iterator_type& res)
    {
        left_base_transformer::transform(org.left_base_iterator, res.left_base_iterator);
        right_base_transformer::transform(org.right_base_iterator, res.right_base_iterator);
        res.function = org.function;
    }

    static LITE_INLINE void transform(
        const transform_type_& trans, 
        const input_iterator_type& org, 
        iterator_type& res)
    {
        left_base_transformer::transform(trans, org.left_base_iterator, res.left_base_iterator);
        right_base_transformer::transform(trans, org.right_base_iterator, res.right_base_iterator);
        res.function = org.function;
    }

    static LITE_INLINE void transform(
        const transform_type_& trans, 
        const input_iterator_type& org, 
        const input_size_type_& sz,
        iterator_type& res)
    {
        left_base_transformer::transform(trans, org.left_base_iterator, sz, res.left_base_iterator);
        right_base_transformer::transform(trans, org.right_base_iterator, sz, res.right_base_iterator);
        res.function = org.function;
    }
};

/***********************************************************************************************************/
/* plane ***************************************************************************************************/
/***********************************************************************************************************/

/*!
    \brief 
    This transform, when applied to an array of dimension N, 
    returns a reference array of dimension N-1 by fixing the index at dimension \a dim_.

    \ingroup array_transforms

    Note that dimensions are numbered starting from 0.

    \par Example:

    \code
        array<float[3][4][5]> a;    // a 3x4x5 array

        a[plane<1>(2)] = -1;       // left hand side is a 3x5 reference array 

        // the above line is equivalent to:

        for (int i=0; i<a.size().i0; i++)
            for (int k=0; k<a.size().i2; k++)
                a(i, 2, k) = -1;
    \endcode

*/
template<int dim_>
class plane
{
public:
    //! Creates a plane that fixes the index at dimension \a dim_ to \a index.
    LITE_INLINE plane(int index =0) : index(index) {}

    LITE_INLINE plane(const plane& other) : index(other.index) {}

    LITE_INLINE plane& operator=(const plane& other) { index = other.index; return *this; }

    //! The index at dimension \a dim_
    int index;
};

/***********************************************************************************************************/
/* size_transformer, plane *********************************************************************************/
/***********************************************************************************************************/

template<
    typename type0_
    >
struct size_transformer<
    plane<0>, 
    pack<
        type0_
    > >
{
public:
    typedef plane<0> transform_type;

    typedef pack<
        type0_
        > input_size_type;

    typedef sub_pack<
        input_size_type,
        false
        > sub_pack_type;

    typedef typename sub_pack_type::type size_type;

    static LITE_INLINE void transform(const input_size_type& org, size_type& res)
    {
        sub_pack_type::set(res, org);
    }

    static LITE_INLINE void transform(const transform_type&, const input_size_type& org, size_type& res)
    {
        sub_pack_type::set(res, org);
    }
};

/***********************************************************************************************************/
template<
    typename type0_,
    typename type1_
    >
struct size_transformer<
    plane<0>, 
    pack<
        type0_,
        type1_
    > >
{
public:
    typedef plane<0> transform_type;

    typedef pack<
        type0_,
        type1_
        > input_size_type;

    typedef sub_pack<
        input_size_type,
        false,
        true
        > sub_pack_type;

    typedef typename sub_pack_type::type size_type;

    static LITE_INLINE void transform(const input_size_type& org, size_type& res)
    {
        sub_pack_type::set(res, org);
    }

    static LITE_INLINE void transform(const transform_type&, const input_size_type& org, size_type& res)
    {
        sub_pack_type::set(res, org);
    }
};

/***********************************************************************************************************/
template<
    typename type0_,
    typename type1_,
    typename type2_
    >
struct size_transformer<
    plane<0>, 
    pack<
        type0_,
        type1_,
        type2_
    > >
{
public:
    typedef plane<0> transform_type;

    typedef pack<
        type0_,
        type1_,
        type2_
        > input_size_type;

    typedef sub_pack<
        input_size_type,
        false,
        true,
        true
        > sub_pack_type;

    typedef typename sub_pack_type::type size_type;

    static LITE_INLINE void transform(const input_size_type& org, size_type& res)
    {
        sub_pack_type::set(res, org);
    }

    static LITE_INLINE void transform(const transform_type&, const input_size_type& org, size_type& res)
    {
        sub_pack_type::set(res, org);
    }
};

/***********************************************************************************************************/
template<
    typename type0_,
    typename type1_
    >
struct size_transformer<
    plane<1>, 
    pack<
        type0_,
        type1_
    > >
{
public:
    typedef plane<1> transform_type;

    typedef pack<
        type0_,
        type1_
        > input_size_type;

    typedef sub_pack<
        input_size_type,
        true,
        false
        > sub_pack_type;

    typedef typename sub_pack_type::type size_type;

    static LITE_INLINE void transform(const input_size_type& org, size_type& res)
    {
        sub_pack_type::set(res, org);
    }

    static LITE_INLINE void transform(const transform_type&, const input_size_type& org, size_type& res)
    {
        sub_pack_type::set(res, org);
    }
};

/***********************************************************************************************************/
template<
    typename type0_,
    typename type1_,
    typename type2_
    >
struct size_transformer<
    plane<1>, 
    pack<
        type0_,
        type1_,
        type2_
    > >
{
public:
    typedef plane<1> transform_type;

    typedef pack<
        type0_,
        type1_,
        type2_
        > input_size_type;

    typedef sub_pack<
        input_size_type,
        true,
        false,
        true
        > sub_pack_type;

    typedef typename sub_pack_type::type size_type;

    static LITE_INLINE void transform(const input_size_type& org, size_type& res)
    {
        sub_pack_type::set(res, org);
    }

    static LITE_INLINE void transform(const transform_type&, const input_size_type& org, size_type& res)
    {
        sub_pack_type::set(res, org);
    }
};

/***********************************************************************************************************/
template<
    typename type0_,
    typename type1_,
    typename type2_
    >
struct size_transformer<
    plane<2>, 
    pack<
        type0_,
        type1_,
        type2_
    > >
{
public:
    typedef plane<2> transform_type;

    typedef pack<
        type0_,
        type1_,
        type2_
        > input_size_type;

    typedef sub_pack<
        input_size_type,
        true,
        true,
        false
        > sub_pack_type;

    typedef typename sub_pack_type::type size_type;

    static LITE_INLINE void transform(const input_size_type& org, size_type& res)
    {
        sub_pack_type::set(res, org);
    }

    static LITE_INLINE void transform(const transform_type&, const input_size_type& org, size_type& res)
    {
        sub_pack_type::set(res, org);
    }
};

/***********************************************************************************************************/

/***********************************************************************************************************/
/* iterator_transformer, plane *****************************************************************************/
/***********************************************************************************************************/

template<
    typename base_iter_type_,
    typename type0_,
    typename input_size_type_>
struct iterator_transformer<
    plane<0>, 
    pack<
        base_iter_type_,
        type0_
    >,
    input_size_type_>
{
public:
    typedef plane<0> transform_type;

    typedef pack<
        base_iter_type_,
        type0_
        > input_iterator_type;

    typedef input_size_type_ input_size_type;

    typedef sub_pack<
        input_iterator_type,
        true,
        false
        > sub_pack_type;

    typedef typename sub_pack_type::type iterator_type;

    static LITE_INLINE void transform(
        const input_iterator_type& org, 
        iterator_type& res)
    {
        sub_pack_type::set(res, org);
    }

    static LITE_INLINE void transform(
        const transform_type& trans, 
        const input_iterator_type& org, 
        iterator_type& res)
    {
        sub_pack_type::set(res, org.i0+trans.index*org.i1, org.i1);
    }

    static LITE_INLINE void transform(
        const transform_type& trans, 
        const input_iterator_type& org, 
        const input_size_type&,
        iterator_type& res)
    {
        sub_pack_type::set(res, org.i0+trans.index*org.i1, org.i1);
    }
};

/***********************************************************************************************************/
template<
    typename base_iter_type_,
    typename type0_,
    typename type1_,
    typename input_size_type_>
struct iterator_transformer<
    plane<0>, 
    pack<
        base_iter_type_,
        type0_,
        type1_
    >,
    input_size_type_>
{
public:
    typedef plane<0> transform_type;

    typedef pack<
        base_iter_type_,
        type0_,
        type1_
        > input_iterator_type;

    typedef input_size_type_ input_size_type;

    typedef sub_pack<
        input_iterator_type,
        true,
        false,
        true
        > sub_pack_type;

    typedef typename sub_pack_type::type iterator_type;

    static LITE_INLINE void transform(
        const input_iterator_type& org, 
        iterator_type& res)
    {
        sub_pack_type::set(res, org);
    }

    static LITE_INLINE void transform(
        const transform_type& trans, 
        const input_iterator_type& org, 
        iterator_type& res)
    {
        sub_pack_type::set(res, org.i0+trans.index*org.i1, org.i1, org.i2);
    }

    static LITE_INLINE void transform(
        const transform_type& trans, 
        const input_iterator_type& org, 
        const input_size_type&,
        iterator_type& res)
    {
        sub_pack_type::set(res, org.i0+trans.index*org.i1, org.i1, org.i2);
    }
};

/***********************************************************************************************************/
template<
    typename base_iter_type_,
    typename type0_,
    typename type1_,
    typename type2_,
    typename input_size_type_>
struct iterator_transformer<
    plane<0>, 
    pack<
        base_iter_type_,
        type0_,
        type1_,
        type2_
    >,
    input_size_type_>
{
public:
    typedef plane<0> transform_type;

    typedef pack<
        base_iter_type_,
        type0_,
        type1_,
        type2_
        > input_iterator_type;

    typedef input_size_type_ input_size_type;

    typedef sub_pack<
        input_iterator_type,
        true,
        false,
        true,
        true
        > sub_pack_type;

    typedef typename sub_pack_type::type iterator_type;

    static LITE_INLINE void transform(
        const input_iterator_type& org, 
        iterator_type& res)
    {
        sub_pack_type::set(res, org);
    }

    static LITE_INLINE void transform(
        const transform_type& trans, 
        const input_iterator_type& org, 
        iterator_type& res)
    {
        sub_pack_type::set(res, org.i0+trans.index*org.i1, org.i1, org.i2, org.i3);
    }

    static LITE_INLINE void transform(
        const transform_type& trans, 
        const input_iterator_type& org, 
        const input_size_type&,
        iterator_type& res)
    {
        sub_pack_type::set(res, org.i0+trans.index*org.i1, org.i1, org.i2, org.i3);
    }
};

/***********************************************************************************************************/
template<
    typename base_iter_type_,
    typename type0_,
    typename type1_,
    typename input_size_type_>
struct iterator_transformer<
    plane<1>, 
    pack<
        base_iter_type_,
        type0_,
        type1_
    >,
    input_size_type_>
{
public:
    typedef plane<1> transform_type;

    typedef pack<
        base_iter_type_,
        type0_,
        type1_
        > input_iterator_type;

    typedef input_size_type_ input_size_type;

    typedef sub_pack<
        input_iterator_type,
        true,
        true,
        false
        > sub_pack_type;

    typedef typename sub_pack_type::type iterator_type;

    static LITE_INLINE void transform(
        const input_iterator_type& org, 
        iterator_type& res)
    {
        sub_pack_type::set(res, org);
    }

    static LITE_INLINE void transform(
        const transform_type& trans, 
        const input_iterator_type& org, 
        iterator_type& res)
    {
        sub_pack_type::set(res, org.i0+trans.index*org.i2, org.i1, org.i2);
    }

    static LITE_INLINE void transform(
        const transform_type& trans, 
        const input_iterator_type& org, 
        const input_size_type&,
        iterator_type& res)
    {
        sub_pack_type::set(res, org.i0+trans.index*org.i2, org.i1, org.i2);
    }
};

/***********************************************************************************************************/
template<
    typename base_iter_type_,
    typename type0_,
    typename type1_,
    typename type2_,
    typename input_size_type_>
struct iterator_transformer<
    plane<1>, 
    pack<
        base_iter_type_,
        type0_,
        type1_,
        type2_
    >,
    input_size_type_>
{
public:
    typedef plane<1> transform_type;

    typedef pack<
        base_iter_type_,
        type0_,
        type1_,
        type2_
        > input_iterator_type;

    typedef input_size_type_ input_size_type;

    typedef sub_pack<
        input_iterator_type,
        true,
        true,
        false,
        true
        > sub_pack_type;

    typedef typename sub_pack_type::type iterator_type;

    static LITE_INLINE void transform(
        const input_iterator_type& org, 
        iterator_type& res)
    {
        sub_pack_type::set(res, org);
    }

    static LITE_INLINE void transform(
        const transform_type& trans, 
        const input_iterator_type& org, 
        iterator_type& res)
    {
        sub_pack_type::set(res, org.i0+trans.index*org.i2, org.i1, org.i2, org.i3);
    }

    static LITE_INLINE void transform(
        const transform_type& trans, 
        const input_iterator_type& org, 
        const input_size_type&,
        iterator_type& res)
    {
        sub_pack_type::set(res, org.i0+trans.index*org.i2, org.i1, org.i2, org.i3);
    }
};

/***********************************************************************************************************/
template<
    typename base_iter_type_,
    typename type0_,
    typename type1_,
    typename type2_,
    typename input_size_type_>
struct iterator_transformer<
    plane<2>, 
    pack<
        base_iter_type_,
        type0_,
        type1_,
        type2_
    >,
    input_size_type_>
{
public:
    typedef plane<2> transform_type;

    typedef pack<
        base_iter_type_,
        type0_,
        type1_,
        type2_
        > input_iterator_type;

    typedef input_size_type_ input_size_type;

    typedef sub_pack<
        input_iterator_type,
        true,
        true,
        true,
        false
        > sub_pack_type;

    typedef typename sub_pack_type::type iterator_type;

    static LITE_INLINE void transform(
        const input_iterator_type& org, 
        iterator_type& res)
    {
        sub_pack_type::set(res, org);
    }

    static LITE_INLINE void transform(
        const transform_type& trans, 
        const input_iterator_type& org, 
        iterator_type& res)
    {
        sub_pack_type::set(res, org.i0+trans.index*org.i3, org.i1, org.i2, org.i3);
    }

    static LITE_INLINE void transform(
        const transform_type& trans, 
        const input_iterator_type& org, 
        const input_size_type&,
        iterator_type& res)
    {
        sub_pack_type::set(res, org.i0+trans.index*org.i3, org.i1, org.i2, org.i3);
    }
};

/***********************************************************************************************************/

/***********************************************************************************************************/
/* diagonal ************************************************************************************************/
/***********************************************************************************************************/

/*!
    \brief 
    This transform returns a 1-D reference array that corresponds to the main diagonal of the array.

    \ingroup array_transforms

    \remark
    When applied to a 0-D or 1-D array, it returns a reference to the array itself. 

    \par Example:

    \code
        array<float[6][4][5]> a;    // a 6x4x5 array

        a[diagonal()] = -1;         // left hand side is a float[4] reference array 

        // the above line is equivalent to:

        const int n = std::min(a.size().i0, std::min(a.size().i1, a.size().i2)); // n will be 4

        for (int i=0; i<n; i++)
            a(i, i, i) = -1;
    \endcode
*/
class diagonal
{
public:
    LITE_INLINE diagonal() {}

    LITE_INLINE diagonal(const diagonal&) {}

    LITE_INLINE diagonal& operator=(const diagonal&) { return *this; }
};

/***********************************************************************************************************/
/* size_transformer, diagonal ******************************************************************************/
/***********************************************************************************************************/

template<>
struct size_transformer<diagonal, pack<> >
{
public:
    typedef diagonal transform_type;
    typedef pack<> input_size_type;
    typedef pack<> size_type;

    static LITE_INLINE void transform(const input_size_type&, size_type&)
    {}

    static LITE_INLINE void transform(const transform_type&, const input_size_type&, size_type&)
    {}
};

/***********************************************************************************************************/

template<
    typename type0_
    >
struct size_transformer<
    diagonal, 
    pack<
        type0_
    > >
{
private:
    static const int n0_ = 
        detail::type_if<detail::same_type<type0_, int>::result, constant<int, 0>, type0_>::type::value;

    static const int min_upto_0_ = n0_;

    static const int min_dim_size_ = min_upto_0_;

    static const bool has_var_size_ =
        detail::same_type<type0_, int>::result
        ;

public:
    typedef diagonal transform_type;

    typedef pack<
        type0_
        > input_size_type;


    typedef pack<
        typename detail::type_if<has_var_size_, int, constant<int, min_dim_size_> >::type
        > size_type;

    static LITE_INLINE void transform(const input_size_type& org, size_type& res)
    {
        const int min_upto_0 = res.i0;

        res.set(min_upto_0);
        LITE_ARRAY_USE(org);
    }

    static LITE_INLINE void transform(const transform_type&, const input_size_type& org, size_type& res)
    {
        const int min_upto_0 = res.i0;

        res.set(min_upto_0);
        LITE_ARRAY_USE(org);
    }
};

/***********************************************************************************************************/
template<
    typename type0_,
    typename type1_
    >
struct size_transformer<
    diagonal, 
    pack<
        type0_,
        type1_
    > >
{
private:
    static const int n0_ = 
        detail::type_if<detail::same_type<type0_, int>::result, constant<int, 0>, type0_>::type::value;
    static const int n1_ = 
        detail::type_if<detail::same_type<type1_, int>::result, constant<int, 0>, type1_>::type::value;

    static const int min_upto_0_ = n0_;
    static const int min_upto_1_ = min_upto_0_ < n1_ ? min_upto_0_ : n1_;

    static const int min_dim_size_ = min_upto_1_;

    static const bool has_var_size_ =
        detail::same_type<type0_, int>::result||
        detail::same_type<type1_, int>::result
        ;

public:
    typedef diagonal transform_type;

    typedef pack<
        type0_,
        type1_
        > input_size_type;


    typedef pack<
        typename detail::type_if<has_var_size_, int, constant<int, min_dim_size_> >::type
        > size_type;

    static LITE_INLINE void transform(const input_size_type& org, size_type& res)
    {
        const int min_upto_0 = res.i0;
        const int min_upto_1 = min_upto_0 < res.i1 ? min_upto_0 : res.i1;

        res.set(min_upto_1);
        LITE_ARRAY_USE(org);
    }

    static LITE_INLINE void transform(const transform_type&, const input_size_type& org, size_type& res)
    {
        const int min_upto_0 = res.i0;
        const int min_upto_1 = min_upto_0 < org.i1 ? min_upto_0 : org.i1;

        res.set(min_upto_1);
        LITE_ARRAY_USE(org);
    }
};

/***********************************************************************************************************/
template<
    typename type0_,
    typename type1_,
    typename type2_
    >
struct size_transformer<
    diagonal, 
    pack<
        type0_,
        type1_,
        type2_
    > >
{
private:
    static const int n0_ = 
        detail::type_if<detail::same_type<type0_, int>::result, constant<int, 0>, type0_>::type::value;
    static const int n1_ = 
        detail::type_if<detail::same_type<type1_, int>::result, constant<int, 0>, type1_>::type::value;
    static const int n2_ = 
        detail::type_if<detail::same_type<type2_, int>::result, constant<int, 0>, type2_>::type::value;

    static const int min_upto_0_ = n0_;
    static const int min_upto_1_ = min_upto_0_ < n1_ ? min_upto_0_ : n1_;
    static const int min_upto_2_ = min_upto_1_ < n2_ ? min_upto_1_ : n2_;

    static const int min_dim_size_ = min_upto_2_;

    static const bool has_var_size_ =
        detail::same_type<type0_, int>::result||
        detail::same_type<type1_, int>::result||
        detail::same_type<type2_, int>::result
        ;

public:
    typedef diagonal transform_type;

    typedef pack<
        type0_,
        type1_,
        type2_
        > input_size_type;


    typedef pack<
        typename detail::type_if<has_var_size_, int, constant<int, min_dim_size_> >::type
        > size_type;

    static LITE_INLINE void transform(const input_size_type& org, size_type& res)
    {
        const int min_upto_0 = res.i0;
        const int min_upto_1 = min_upto_0 < res.i1 ? min_upto_0 : res.i1;
        const int min_upto_2 = min_upto_1 < res.i2 ? min_upto_1 : res.i2;

        res.set(min_upto_2);
        LITE_ARRAY_USE(org);
    }

    static LITE_INLINE void transform(const transform_type&, const input_size_type& org, size_type& res)
    {
        const int min_upto_0 = res.i0;
        const int min_upto_1 = min_upto_0 < org.i1 ? min_upto_0 : org.i1;
        const int min_upto_2 = min_upto_1 < org.i2 ? min_upto_1 : org.i2;

        res.set(min_upto_2);
        LITE_ARRAY_USE(org);
    }
};

/***********************************************************************************************************/

/***********************************************************************************************************/
/* iterator_transformer, diagonal **************************************************************************/
/***********************************************************************************************************/


template<typename base_iter_type_, typename input_size_type_>
struct iterator_transformer<diagonal, pack<base_iter_type_>, input_size_type_>
{
public:
    typedef pack<base_iter_type_> input_iterator_type;

    typedef input_size_type_ input_size_type;

    typedef pack<base_iter_type_> iterator_type;

    static LITE_INLINE void transform(
        const input_iterator_type& org, 
        iterator_type& res)
    {
        res.i0 = org.i0;
    }

    static LITE_INLINE void transform(
        const diagonal&, 
        const input_iterator_type& org, 
        iterator_type& res)
    {
        res.i0 = org.i0;
    }

    static LITE_INLINE void transform(
        const diagonal&, 
        const input_iterator_type& org, 
        const input_size_type&,
        iterator_type& res)
    {
        res.i0 = org.i0;
    }
};

/***********************************************************************************************************/

template<
    typename base_iter_type_,
    typename type0_,
    typename input_size_type_>
struct iterator_transformer<
    diagonal, 
    pack<
        base_iter_type_,
        type0_
    >,
    input_size_type_>
{
private:
    static const int n0_ = 
        detail::type_if<detail::same_type<type0_, int>::result, constant<int, 0>, type0_>::type::value;

    static const int stride_ = n0_;

    static const bool has_var_stride_ =
        detail::same_type<type0_, int>::result
        ;

public:
    typedef diagonal transform_type;
    typedef pack<
        base_iter_type_,
        type0_
        > input_iterator_type;

    typedef input_size_type_ input_size_type;

    typedef pack<
        base_iter_type_, 
        typename detail::type_if<has_var_stride_, int, constant<int, stride_> >::type> 
        iterator_type;

    static LITE_INLINE void transform(
        const input_iterator_type& org, 
        iterator_type& res)
    {
        res.set(org.i0, org.i1);
    }

        static LITE_INLINE void transform(
        const transform_type&, 
        const input_iterator_type& org, 
        iterator_type& res)
    {
        res.set(org.i0, org.i1);
    }

    static LITE_INLINE void transform(
        const transform_type&, 
        const input_iterator_type& org, 
        const input_size_type&,
        iterator_type& res)
    {
        res.set(org.i0, org.i1);
    }
};

/***********************************************************************************************************/
template<
    typename base_iter_type_,
    typename type0_,
    typename type1_,
    typename input_size_type_>
struct iterator_transformer<
    diagonal, 
    pack<
        base_iter_type_,
        type0_,
        type1_
    >,
    input_size_type_>
{
private:
    static const int n0_ = 
        detail::type_if<detail::same_type<type0_, int>::result, constant<int, 0>, type0_>::type::value;
    static const int n1_ = 
        detail::type_if<detail::same_type<type1_, int>::result, constant<int, 0>, type1_>::type::value;

    static const int stride_ = n0_ + n1_;

    static const bool has_var_stride_ =
        detail::same_type<type0_, int>::result||
        detail::same_type<type1_, int>::result
        ;

public:
    typedef diagonal transform_type;
    typedef pack<
        base_iter_type_,
        type0_,
        type1_
        > input_iterator_type;

    typedef input_size_type_ input_size_type;

    typedef pack<
        base_iter_type_, 
        typename detail::type_if<has_var_stride_, int, constant<int, stride_> >::type> 
        iterator_type;

    static LITE_INLINE void transform(
        const input_iterator_type& org, 
        iterator_type& res)
    {
        res.set(org.i0, org.i1org.i2);
    }

        static LITE_INLINE void transform(
        const transform_type&, 
        const input_iterator_type& org, 
        iterator_type& res)
    {
        res.set(org.i0, org.i1org.i2);
    }

    static LITE_INLINE void transform(
        const transform_type&, 
        const input_iterator_type& org, 
        const input_size_type&,
        iterator_type& res)
    {
        res.set(org.i0, org.i1 + org.i2);
    }
};

/***********************************************************************************************************/
template<
    typename base_iter_type_,
    typename type0_,
    typename type1_,
    typename type2_,
    typename input_size_type_>
struct iterator_transformer<
    diagonal, 
    pack<
        base_iter_type_,
        type0_,
        type1_,
        type2_
    >,
    input_size_type_>
{
private:
    static const int n0_ = 
        detail::type_if<detail::same_type<type0_, int>::result, constant<int, 0>, type0_>::type::value;
    static const int n1_ = 
        detail::type_if<detail::same_type<type1_, int>::result, constant<int, 0>, type1_>::type::value;
    static const int n2_ = 
        detail::type_if<detail::same_type<type2_, int>::result, constant<int, 0>, type2_>::type::value;

    static const int stride_ = n0_ + n1_ + n2_;

    static const bool has_var_stride_ =
        detail::same_type<type0_, int>::result||
        detail::same_type<type1_, int>::result||
        detail::same_type<type2_, int>::result
        ;

public:
    typedef diagonal transform_type;
    typedef pack<
        base_iter_type_,
        type0_,
        type1_,
        type2_
        > input_iterator_type;

    typedef input_size_type_ input_size_type;

    typedef pack<
        base_iter_type_, 
        typename detail::type_if<has_var_stride_, int, constant<int, stride_> >::type> 
        iterator_type;

    static LITE_INLINE void transform(
        const input_iterator_type& org, 
        iterator_type& res)
    {
        res.set(org.i0, org.i1org.i2org.i3);
    }

        static LITE_INLINE void transform(
        const transform_type&, 
        const input_iterator_type& org, 
        iterator_type& res)
    {
        res.set(org.i0, org.i1org.i2org.i3);
    }

    static LITE_INLINE void transform(
        const transform_type&, 
        const input_iterator_type& org, 
        const input_size_type&,
        iterator_type& res)
    {
        res.set(org.i0, org.i1 + org.i2 + org.i3);
    }
};

/***********************************************************************************************************/

/***********************************************************************************************************/
/* transpose ***********************************************************************************************/
/***********************************************************************************************************/

/*!
    \brief 
    This transform returns a reference array that references the original array but its dimensions 
    in revere order.

    \ingroup array_transforms

    \remark
    When applied to a matrix (2-D array), it returns the transpose of the matrix.

    \par Example:

    \code
        array<float[4][5][6]> a;        // a 4x5x6 array

        a[transpose()](1, 2, 3) = -1;  // left hand side is a float[6][5][4] reference array 
        // the above line is equivalent to:
        a(3, 2, 1) = -1;
    \endcode
*/
class transpose
{
public:
    LITE_INLINE transpose() {}

    LITE_INLINE transpose(const transpose&) {}

    LITE_INLINE transpose& operator=(const transpose&) { return *this; }
};

/***********************************************************************************************************/
/* size_transformer, transpose *****************************************************************************/
/***********************************************************************************************************/

template<>
struct size_transformer<transpose, pack<> >
{
public:
    typedef transpose transform_type;

    typedef pack<> input_size_type;

    typedef pack<> size_type;

    static LITE_INLINE void transform(const input_size_type&, size_type&)
    {}

    static LITE_INLINE void transform(const transform_type&, const input_size_type&, size_type&)
    {}
};

/***********************************************************************************************************/

template<
    typename type0_
    >
struct size_transformer<
    transpose, 
    pack<
        type0_
    > >
{
public:
    typedef transpose transform_type;

    typedef pack<
        type0_
        > input_size_type;

    typedef pack<
        type0_
        > size_type;

    static LITE_INLINE void transform(const input_size_type& org, size_type& res)
    {
        set<0>(res, org.i0);
        LITE_ARRAY_USE(org);
    }

    static LITE_INLINE void transform(const transform_type&, const input_size_type& org, size_type& res)
    {
        set<0>(res, org.i0);
        LITE_ARRAY_USE(org);
    }
};

/***********************************************************************************************************/
template<
    typename type0_,
    typename type1_
    >
struct size_transformer<
    transpose, 
    pack<
        type0_,
        type1_
    > >
{
public:
    typedef transpose transform_type;

    typedef pack<
        type0_,
        type1_
        > input_size_type;

    typedef pack<
        type1_,
        type0_
        > size_type;

    static LITE_INLINE void transform(const input_size_type& org, size_type& res)
    {
        set<0>(res, org.i1);
        set<1>(res, org.i0);
        LITE_ARRAY_USE(org);
    }

    static LITE_INLINE void transform(const transform_type&, const input_size_type& org, size_type& res)
    {
        set<0>(res, org.i1);
        set<1>(res, org.i0);
        LITE_ARRAY_USE(org);
    }
};

/***********************************************************************************************************/
template<
    typename type0_,
    typename type1_,
    typename type2_
    >
struct size_transformer<
    transpose, 
    pack<
        type0_,
        type1_,
        type2_
    > >
{
public:
    typedef transpose transform_type;

    typedef pack<
        type0_,
        type1_,
        type2_
        > input_size_type;

    typedef pack<
        type2_,
        type1_,
        type0_
        > size_type;

    static LITE_INLINE void transform(const input_size_type& org, size_type& res)
    {
        set<0>(res, org.i2);
        set<1>(res, org.i1);
        set<2>(res, org.i0);
        LITE_ARRAY_USE(org);
    }

    static LITE_INLINE void transform(const transform_type&, const input_size_type& org, size_type& res)
    {
        set<0>(res, org.i2);
        set<1>(res, org.i1);
        set<2>(res, org.i0);
        LITE_ARRAY_USE(org);
    }
};

/***********************************************************************************************************/

/***********************************************************************************************************/
/* iterator_transformer, transpose *************************************************************************/
/***********************************************************************************************************/

template<typename base_iter_type_, typename input_size_type_>
struct iterator_transformer<transpose, pack<base_iter_type_>, input_size_type_>
{
public:
    typedef transpose transform_type;
    typedef pack<base_iter_type_> input_iterator_type;
    typedef input_size_type_ input_size_type;
    typedef pack<base_iter_type_> iterator_type;

    static LITE_INLINE void transform(
        const input_iterator_type& org, 
        iterator_type& res)
    {
        res.i0 = org.i0;
    }

    static LITE_INLINE void transform(
        const transform_type&, 
        const input_iterator_type& org, 
        iterator_type& res)
    {
        res.i0 = org.i0;
    }

    static LITE_INLINE void transform(
        const transform_type&, 
        const input_iterator_type& org, 
        const input_size_type&,
        iterator_type& res)
    {
        res.i0 = org.i0;
    }
};

/***********************************************************************************************************/


template<
    typename base_iter_type_,
    typename type0_,
    typename input_size_type_>
struct iterator_transformer<
    transpose, 
    pack<
        base_iter_type_,
        type0_
    >,
    input_size_type_>
{
public:
    typedef transpose transform_type;
    typedef pack<
        base_iter_type_,
        type0_
        > input_iterator_type;

    typedef input_size_type_ input_size_type;
    typedef pack<
        base_iter_type_,
        type0_
        > iterator_type;

    static LITE_INLINE void transform(
        const input_iterator_type& org, 
        iterator_type& res)
    {
        res.i0 = org.i0;
        set<1>(res, org.i1);
    }

    static LITE_INLINE void transform(
        const transform_type&, 
        const input_iterator_type& org, 
        iterator_type& res)
    {
        res.i0 = org.i0;
        set<1>(res, org.i1);
    }

    static LITE_INLINE void transform(
        const transform_type&, 
        const input_iterator_type& org, 
        const input_size_type&,
        iterator_type& res)
    {
        res.i0 = org.i0;
        set<1>(res, org.i1);
    }
};

/***********************************************************************************************************/

template<
    typename base_iter_type_,
    typename type0_,
    typename type1_,
    typename input_size_type_>
struct iterator_transformer<
    transpose, 
    pack<
        base_iter_type_,
        type0_,
        type1_
    >,
    input_size_type_>
{
public:
    typedef transpose transform_type;
    typedef pack<
        base_iter_type_,
        type0_,
        type1_
        > input_iterator_type;

    typedef input_size_type_ input_size_type;
    typedef pack<
        base_iter_type_,
        type1_,
        type0_
        > iterator_type;

    static LITE_INLINE void transform(
        const input_iterator_type& org, 
        iterator_type& res)
    {
        res.i0 = org.i0;
        set<1>(res, org.i2);
        set<2>(res, org.i1);
    }

    static LITE_INLINE void transform(
        const transform_type&, 
        const input_iterator_type& org, 
        iterator_type& res)
    {
        res.i0 = org.i0;
        set<1>(res, org.i2);
        set<2>(res, org.i1);
    }

    static LITE_INLINE void transform(
        const transform_type&, 
        const input_iterator_type& org, 
        const input_size_type&,
        iterator_type& res)
    {
        res.i0 = org.i0;
        set<1>(res, org.i2);
        set<2>(res, org.i1);
    }
};

/***********************************************************************************************************/

template<
    typename base_iter_type_,
    typename type0_,
    typename type1_,
    typename type2_,
    typename input_size_type_>
struct iterator_transformer<
    transpose, 
    pack<
        base_iter_type_,
        type0_,
        type1_,
        type2_
    >,
    input_size_type_>
{
public:
    typedef transpose transform_type;
    typedef pack<
        base_iter_type_,
        type0_,
        type1_,
        type2_
        > input_iterator_type;

    typedef input_size_type_ input_size_type;
    typedef pack<
        base_iter_type_,
        type2_,
        type1_,
        type0_
        > iterator_type;

    static LITE_INLINE void transform(
        const input_iterator_type& org, 
        iterator_type& res)
    {
        res.i0 = org.i0;
        set<1>(res, org.i3);
        set<2>(res, org.i2);
        set<3>(res, org.i1);
    }

    static LITE_INLINE void transform(
        const transform_type&, 
        const input_iterator_type& org, 
        iterator_type& res)
    {
        res.i0 = org.i0;
        set<1>(res, org.i3);
        set<2>(res, org.i2);
        set<3>(res, org.i1);
    }

    static LITE_INLINE void transform(
        const transform_type&, 
        const input_iterator_type& org, 
        const input_size_type&,
        iterator_type& res)
    {
        res.i0 = org.i0;
        set<1>(res, org.i3);
        set<2>(res, org.i2);
        set<3>(res, org.i1);
    }
};

/***********************************************************************************************************/

/***********************************************************************************************************/
/* block ***************************************************************************************************/
/***********************************************************************************************************/

#ifdef DOCUMENTATION_ONLY
/*!
    \brief 
    This transform can be used to create a reference array that corresponds to a block of the original array.
    The resulting array will have equal or less dimensions.

    \ingroup array_transforms

    \remark
    When applied to a 0-D or 1-D array, it returns a reference to the array itself. 

    The following is a pseudo definition of the class:

    \code
template<int n0_ ..., int nN_>
class block
{
public:
    typedef pack<...> size_type;    // the size type of the block

    block() {}

    block(const block& other);

    block(int n0, ..., int nN);

    block(const size_type& block_size, int n0 ..., int nN);

    block& operator=(const block& other);

    block operator()(int i0 ..., int iN) const;

    size_type block_size; // the size object of the block

    int i0; // starting offset at dimension 0
        .
        .
        .
    int iN; // starting offset at dimension N
};
    \endcode

    A block transform with template parameters \a n0_ ... \a nN_ can be applied to an array of N+1 dimensions. 
    For each dimension X in [0,N]:
    - If \a nX_ is at least 2 then the resulting array will have a constant dimension size \a nX_ 
        at the corresponding dimension.
    - If \a nX_ is 1 then the resulting array will have a variable size dimension at the corresponding 
        dimension. The actual size can be specified later as a constructor argument for \a nX.
    - If \a nX_ is -1 then the size of the dimension X of the original array will be retained 
        in the corresponding dimension of the resulting array.
    - If \a nX_ is 0 then the dimension X will be dropped, thus the number of dimensions 
        in the resulting array will be reduced by 1. 
        Conceptually, the block will have a constant size of 1 at dimension X and thus there is only one 
        valid index at that dimension which will become implicit.
        Therefore, the number of explicit dimensions are reduced by 1.

    \par Example:

    \code
        array<float[4][6][7]> a;    // a 4x6x7 array

        block<0, -1, -1> b0;        

        a[b0(2,0,0)] = 555;                 // the second and third indices are ignored
        // the above line is equivalent to:
        a[row(2)] = 555;

        block<-1, 0, -1> b1;        

        a[b1(0,2,0)] = 555;                 // the left hand size is a float[4][7] array
        // the above line is equivalent to:
        a[column(2)] = 555;

        block<-1, 2, 2> b2;        

        a[b2(0,3,3)] = 555;                 // the left hand size is a float[4][2][2] array
        // the above line is equivalent to:
        for (int i=0; i<a.size().i0; i++)
            for (int j=0; j<2; j++)
                for (int k=0; k<2; k++)
                    a(i,3+j,3+k) = 555;

        typedef block<0, 1, 1> B3;
        B3 b3(2, 2);                        // the resulting array will have a non-constant size of 2x2 

        a[b3(3,3,3)] = 555;                 // returns a 2x2 reference array with signature float[1][1]
                                            // starting at index (3,3,3)
        // the above line is equivalent to:
        for (int j=0; j<b3.block_size.i0; j++)
            for (int k=0; k<b3.block_size.i1; k++)
                a(3,3+j,3+k) = 555;

        std::cin >> b3.block_size;          // read the size of the two dimensions of the resulting array

        transform_traits<Array, B3>::array block_ref = a[b3(3,3,3)];
        
        b_ref = 555;                 
    \endcode
*/

template<int n0_ ..., int nN_>
class block
{
public:
    //! Size type of the reference array
    typedef pack<...> size_type;

    block() {}

    block(const block& other);

    /*! 
        \brief Constructs a block transform with the given dimension sizes.

        Note that all arguments that correspond to non-variable sized dimensions are ignored. 
        In other words, for any X in [0,N], if the template argument for \a nX_ is not 1 
        then \a nX will be ignored.
    */
    block(int n0, ..., int nN);

    /*! 
        \brief Constructs a block transform using the size object \a block_size 
        starting at indices (\a i0, ..., \a iN). 

        Note that for any X in [0,N], if the template argument for \a nX_ is -1 
        (i.e. the original dimension size is retained) then \a iX will be ignored (i.e. 0 will be assumed).
    */
    block(const size_type& block_size, int i0 ..., int iN);

    block& operator=(const block& other);

    /*! 
        \brief 
        Creates a block transform with the same dimension sizes as the current one but starting
        at indices (\a i0, ..., \a iN) instead. 

        Note that for any X in [0,N], if the template argument for \a nX_ is -1 
        (i.e. the original dimension size is retained) then \a iX will be ignored (i.e. 0 will be assumed).
    */
    block operator()(int i0 ..., int iN) const;

    //! The size object that specifies the size of the resulting array.
    size_type block_size;

    //! For each X in [0,N], \a iX is the starting index of the block at dimension X
    int iX;
};

#else // DOCUMENTATION_ONLY


template<
    >
class block<
    >
{
public:

    typedef pack<
        > size_type;

    LITE_INLINE block() 
        : block_size()
    {}

    LITE_INLINE block(const block& other) 
        : block_size(other.block_size)
    {}


    LITE_INLINE block(const size_type& bs )
        : block_size(bs)
    {}

    LITE_INLINE block& operator=(const block& other) 
    {
        block_size = other.block_size;
        return *this;
    }

    LITE_INLINE block
    operator()() const
    {
        return block(block_size );
    }

    size_type block_size;
};

/***********************************************************************************************************/

template<
    int n0_
    >
class block<
    n0_
    >
{
public:

    typedef pack<
        typename detail::type_if<n0_==1, int, constant<int, n0_> >::type
        > size_type;

    LITE_INLINE block() 
        : block_size(),
        i0()
    {}

    LITE_INLINE block(const block& other) 
        : block_size(other.block_size),
        i0(other.i0)
    {}

    LITE_INLINE block(int n0)
        : block_size(n0),
        i0()
    {}

    LITE_INLINE block(const size_type& bs, int i0)
        : block_size(bs),
        i0(i0)
    {}

    LITE_INLINE block& operator=(const block& other) 
    {
        block_size = other.block_size;
        i0 = other.i0;
        return *this;
    }

    LITE_INLINE block
    operator()(int i0) const
    {
        return block(block_size, i0);
    }

    size_type block_size;
    int i0;
};

/***********************************************************************************************************/

template<
    int n0_,
    int n1_
    >
class block<
    n0_,
    n1_
    >
{
public:

    typedef pack<
        typename detail::type_if<n0_==1, int, constant<int, n0_> >::type,
        typename detail::type_if<n1_==1, int, constant<int, n1_> >::type
        > size_type;

    LITE_INLINE block() 
        : block_size(),
        i0(), 
        i1()
    {}

    LITE_INLINE block(const block& other) 
        : block_size(other.block_size),
        i0(other.i0), 
        i1(other.i1)
    {}

    LITE_INLINE block(int n0, int n1)
        : block_size(n0, n1),
        i0(), 
        i1()
    {}

    LITE_INLINE block(const size_type& bs, int i0, int i1)
        : block_size(bs),
        i0(i0), 
        i1(i1)
    {}

    LITE_INLINE block& operator=(const block& other) 
    {
        block_size = other.block_size;
        i0 = other.i0;
        i1 = other.i1;
        return *this;
    }

    LITE_INLINE block
    operator()(int i0, int i1) const
    {
        return block(block_size, i0, i1);
    }

    size_type block_size;
    int i0;
    int i1;
};

/***********************************************************************************************************/

template<
    int n0_,
    int n1_,
    int n2_
    >
class block
{
public:

    typedef pack<
        typename detail::type_if<n0_==1, int, constant<int, n0_> >::type,
        typename detail::type_if<n1_==1, int, constant<int, n1_> >::type,
        typename detail::type_if<n2_==1, int, constant<int, n2_> >::type
        > size_type;

    LITE_INLINE block() 
        : block_size(),
        i0(), 
        i1(), 
        i2()
    {}

    LITE_INLINE block(const block& other) 
        : block_size(other.block_size),
        i0(other.i0), 
        i1(other.i1), 
        i2(other.i2)
    {}

    LITE_INLINE block(int n0, int n1, int n2)
        : block_size(n0, n1, n2),
        i0(), 
        i1(), 
        i2()
    {}

    LITE_INLINE block(const size_type& bs, int i0, int i1, int i2)
        : block_size(bs),
        i0(i0), 
        i1(i1), 
        i2(i2)
    {}

    LITE_INLINE block& operator=(const block& other) 
    {
        block_size = other.block_size;
        i0 = other.i0;
        i1 = other.i1;
        i2 = other.i2;
        return *this;
    }

    LITE_INLINE block
    operator()(int i0, int i1, int i2) const
    {
        return block(block_size, i0, i1, i2);
    }

    size_type block_size;
    int i0;
    int i1;
    int i2;
};

/***********************************************************************************************************/
 
#endif // DOCUMENTATION_ONLY

/***********************************************************************************************************/
/* size_transformer, block *********************************************************************************/
/***********************************************************************************************************/


template<
    >
struct size_transformer<
    block<
    >, 
    pack<
    > >
{
    typedef block<
        > transfrom_type;

    typedef pack<
        > input_size_type;

    typedef pack<
        > ex_size_type;

    typedef sub_pack<
        ex_size_type
        > sub_pack_type;


    typedef sub_pack_type::type size_type;

    static LITE_INLINE void transform(const transfrom_type&, const input_size_type&, size_type&)
    {}

private:
    typedef detail::compile_time_assert<transfrom_type::size_type::n == input_size_type::n>
        ::verified verified;
};

/***********************************************************************************************************/

template<
    int n0_,
    typename type0_
    >
struct size_transformer<
    block<
        n0_
    >, 
    pack<
        type0_
    > >
{
    typedef block<
        n0_
        > transfrom_type;

    typedef pack<
        type0_
        > input_size_type;

    typedef pack<
         typename detail::type_if<
            n0_ == -1, 
            type0_, 
            typename detail::type_if<n0_ == 1, int, constant<int, n0_> >::type
            >::type
        > ex_size_type;

    typedef sub_pack<
        ex_size_type,
        n0_!=0
        > sub_pack_type;


    typedef typename sub_pack_type::type size_type;

    static LITE_INLINE void 
    transform(const transfrom_type& trans, const input_size_type& org, size_type& res)
    {
        sub_pack_type::set(
            res,
            n0_==-1 ? org.i0 : trans.block_size.i0
            ); 
        LITE_ARRAY_USE(trans);
        LITE_ARRAY_USE(org);
    }

private:
    typedef typename detail::compile_time_assert<transfrom_type::size_type::n == input_size_type::n>
        ::verified verified;
};

/***********************************************************************************************************/

template<
    int n0_,
    int n1_,
    typename type0_,
    typename type1_
    >
struct size_transformer<
    block<
        n0_,
        n1_
    >, 
    pack<
        type0_,
        type1_
    > >
{
    typedef block<
        n0_,
        n1_
        > transfrom_type;

    typedef pack<
        type0_,
        type1_
        > input_size_type;

    typedef pack<
         typename detail::type_if<
            n0_ == -1, 
            type0_, 
            typename detail::type_if<n0_ == 1, int, constant<int, n0_> >::type
            >::type,
         typename detail::type_if<
            n1_ == -1, 
            type1_, 
            typename detail::type_if<n1_ == 1, int, constant<int, n1_> >::type
            >::type
        > ex_size_type;

    typedef sub_pack<
        ex_size_type,
        n0_!=0,
        n1_!=0
        > sub_pack_type;


    typedef typename sub_pack_type::type size_type;

    static LITE_INLINE void 
    transform(const transfrom_type& trans, const input_size_type& org, size_type& res)
    {
        sub_pack_type::set(
            res,
            n0_==-1 ? org.i0 : trans.block_size.i0, 
            n1_==-1 ? org.i1 : trans.block_size.i1
            ); 
        LITE_ARRAY_USE(trans);
        LITE_ARRAY_USE(org);
    }

private:
    typedef typename detail::compile_time_assert<transfrom_type::size_type::n == input_size_type::n>
        ::verified verified;
};

/***********************************************************************************************************/

template<
    int n0_,
    int n1_,
    int n2_,
    typename type0_,
    typename type1_,
    typename type2_
    >
struct size_transformer<
    block<
        n0_,
        n1_,
        n2_
    >, 
    pack<
        type0_,
        type1_,
        type2_
    > >
{
    typedef block<
        n0_,
        n1_,
        n2_
        > transfrom_type;

    typedef pack<
        type0_,
        type1_,
        type2_
        > input_size_type;

    typedef pack<
         typename detail::type_if<
            n0_ == -1, 
            type0_, 
            typename detail::type_if<n0_ == 1, int, constant<int, n0_> >::type
            >::type,
         typename detail::type_if<
            n1_ == -1, 
            type1_, 
            typename detail::type_if<n1_ == 1, int, constant<int, n1_> >::type
            >::type,
         typename detail::type_if<
            n2_ == -1, 
            type2_, 
            typename detail::type_if<n2_ == 1, int, constant<int, n2_> >::type
            >::type
        > ex_size_type;

    typedef sub_pack<
        ex_size_type,
        n0_!=0,
        n1_!=0,
        n2_!=0
        > sub_pack_type;


    typedef typename sub_pack_type::type size_type;

    static LITE_INLINE void 
    transform(const transfrom_type& trans, const input_size_type& org, size_type& res)
    {
        sub_pack_type::set(
            res,
            n0_==-1 ? org.i0 : trans.block_size.i0, 
            n1_==-1 ? org.i1 : trans.block_size.i1, 
            n2_==-1 ? org.i2 : trans.block_size.i2
            ); 
        LITE_ARRAY_USE(trans);
        LITE_ARRAY_USE(org);
    }

private:
    typedef typename detail::compile_time_assert<transfrom_type::size_type::n == input_size_type::n>
        ::verified verified;
};

/***********************************************************************************************************/


/***********************************************************************************************************/
/* iterator_transformer, block *****************************************************************************/
/***********************************************************************************************************/


template<
    typename base_iterator_type_,
    typename input_size_type_
    >
struct iterator_transformer<
    block<
    >,
    pack<
        base_iterator_type_
    >,
    input_size_type_
    >
{
    typedef block<
        > transfrom_type;

    typedef pack<
        base_iterator_type_
        > input_iterator_type;

    typedef sub_pack<
        input_iterator_type,
        true
        > sub_pack_type;

    typedef typename sub_pack_type::type iterator_type;

    static LITE_INLINE void
    transform(
        const transfrom_type& trans, 
        const input_iterator_type& org,
        iterator_type& res)
    {
        sub_pack_type::set(res, org.i0
            
        );
        
        LITE_ARRAY_USE(trans);
    }

    static LITE_INLINE void
    transform(
        const transfrom_type& trans, 
        const input_iterator_type& org,
        const input_size_type_&, 
        iterator_type& res)
    {
        sub_pack_type::set(res, org.i0
            
        );
        
        LITE_ARRAY_USE(trans);
    }

private:
    typedef typename detail::compile_time_assert<transfrom_type::size_type::n == input_size_type_::n>
        ::verified verified;
};

/***********************************************************************************************************/

template<
    int n0_,
    typename base_iterator_type_,
    typename type0_,
    typename input_size_type_
    >
struct iterator_transformer<
    block<
        n0_
    >,
    pack<
        base_iterator_type_,
        type0_
    >,
    input_size_type_
    >
{
    typedef block<
        n0_
        > transfrom_type;

    typedef pack<
        base_iterator_type_,
        type0_
        > input_iterator_type;

    typedef sub_pack<
        input_iterator_type,
        true,
        n0_!=0
        > sub_pack_type;

    typedef typename sub_pack_type::type iterator_type;

    static LITE_INLINE void
    transform(
        const transfrom_type& trans, 
        const input_iterator_type& org,
        iterator_type& res)
    {
        sub_pack_type::set(res, org.i0
            +(n0_ != -1 ? trans.i0*org.i1 : 0)
            ,
            org.i1
        );
        
    }

    static LITE_INLINE void
    transform(
        const transfrom_type& trans, 
        const input_iterator_type& org,
        const input_size_type_&, 
        iterator_type& res)
    {
        sub_pack_type::set(res, org.i0
            +(n0_ != -1 ? trans.i0*org.i1 : 0)
            ,
            org.i1
        );
        
    }

private:
    typedef typename detail::compile_time_assert<transfrom_type::size_type::n == input_size_type_::n>
        ::verified verified;
};

/***********************************************************************************************************/

template<
    int n0_,
    int n1_,
    typename base_iterator_type_,
    typename type0_,
    typename type1_,
    typename input_size_type_
    >
struct iterator_transformer<
    block<
        n0_,
        n1_
    >,
    pack<
        base_iterator_type_,
        type0_,
        type1_
    >,
    input_size_type_
    >
{
    typedef block<
        n0_,
        n1_
        > transfrom_type;

    typedef pack<
        base_iterator_type_,
        type0_,
        type1_
        > input_iterator_type;

    typedef sub_pack<
        input_iterator_type,
        true,
        n0_!=0,
        n1_!=0
        > sub_pack_type;

    typedef typename sub_pack_type::type iterator_type;

    static LITE_INLINE void
    transform(
        const transfrom_type& trans, 
        const input_iterator_type& org,
        iterator_type& res)
    {
        sub_pack_type::set(res, org.i0
            +(n0_ != -1 ? trans.i0*org.i1 : 0)
            +(n1_ != -1 ? trans.i1*org.i2 : 0)
            ,
            org.i1,
            org.i2
        );
        
    }

    static LITE_INLINE void
    transform(
        const transfrom_type& trans, 
        const input_iterator_type& org,
        const input_size_type_&, 
        iterator_type& res)
    {
        sub_pack_type::set(res, org.i0
            +(n0_ != -1 ? trans.i0*org.i1 : 0)
            +(n1_ != -1 ? trans.i1*org.i2 : 0)
            ,
            org.i1,
            org.i2
        );
        
    }

private:
    typedef typename detail::compile_time_assert<transfrom_type::size_type::n == input_size_type_::n>
        ::verified verified;
};

/***********************************************************************************************************/

template<
    int n0_,
    int n1_,
    int n2_,
    typename base_iterator_type_,
    typename type0_,
    typename type1_,
    typename type2_,
    typename input_size_type_
    >
struct iterator_transformer<
    block<
        n0_,
        n1_,
        n2_
    >,
    pack<
        base_iterator_type_,
        type0_,
        type1_,
        type2_
    >,
    input_size_type_
    >
{
    typedef block<
        n0_,
        n1_,
        n2_
        > transfrom_type;

    typedef pack<
        base_iterator_type_,
        type0_,
        type1_,
        type2_
        > input_iterator_type;

    typedef sub_pack<
        input_iterator_type,
        true,
        n0_!=0,
        n1_!=0,
        n2_!=0
        > sub_pack_type;

    typedef typename sub_pack_type::type iterator_type;

    static LITE_INLINE void
    transform(
        const transfrom_type& trans, 
        const input_iterator_type& org,
        iterator_type& res)
    {
        sub_pack_type::set(res, org.i0
            +(n0_ != -1 ? trans.i0*org.i1 : 0)
            +(n1_ != -1 ? trans.i1*org.i2 : 0)
            +(n2_ != -1 ? trans.i2*org.i3 : 0)
            ,
            org.i1,
            org.i2,
            org.i3
        );
        
    }

    static LITE_INLINE void
    transform(
        const transfrom_type& trans, 
        const input_iterator_type& org,
        const input_size_type_&, 
        iterator_type& res)
    {
        sub_pack_type::set(res, org.i0
            +(n0_ != -1 ? trans.i0*org.i1 : 0)
            +(n1_ != -1 ? trans.i1*org.i2 : 0)
            +(n2_ != -1 ? trans.i2*org.i3 : 0)
            ,
            org.i1,
            org.i2,
            org.i3
        );
        
    }

private:
    typedef typename detail::compile_time_assert<transfrom_type::size_type::n == input_size_type_::n>
        ::verified verified;
};

/***********************************************************************************************************/

/***********************************************************************************************************/
/* array_signature_traits **********************************************************************************/
/***********************************************************************************************************/

#ifdef DOCUMENTATION_ONLY
/*!
    \brief 
    This can be used to extract information from array signatures and get the appropriate iterator type 
    and size type for a signature.

    \ingroup array_advanced
*/
template<typename signature_, typename base_iterator_type_>
struct array_signature_traits
{
    //! The element type of the array (this may include CV qualifiers).
    typedef ??? element_type;

    //! The value type of an array
    typedef ??? value_type;

    typedef signature_ signature;

    /*!
        \brief 
        <c>element_type*</c> if \a base_iterator_type_ is not provided otherwise the same as \a base_iterator_type_
    */
    typedef ??? base_iterator_type;

    /*!
        \brief 
        The appropriate lite::s_iterator type matching the signature \a signature_ assuming forward storage
        and using base iterator of type \a base_iterator_type.
    */
    typedef ??? default_iterator;

    /*!
        \brief 
        The appropriate lite::s_iterator type matching the signature \a signature_ assuming reverse storage
        and using base iterator of type \a base_iterator_type.
    */
    typedef ??? default_rev_iterator;

    //! The appropriate size type for the signature \a signature_.
    typedef ??? size_type;

    //! The number of dimensions in the array signature \a signature_
    static const int dimensions = ???;

    //! The total number of elements in an array with the signature \a signature_
    static const int volume = ???;

    //! True if the signature has no variable size dimension (i.e. dimension of size 1)
    static const bool is_fixed_size = ???;
};

#else // DOCUMENTATION_ONLY

template<typename element_type_, typename base_iterator_type_>
struct array_signature_traits
{
    typedef element_type_ element_type;
    typedef typename detail::remove<element_type_, volatile const int>::type value_type;
    typedef value_type signature;

    typedef typename detail::type_if<
        detail::same_type<base_iterator_type_, void>::result,
        element_type_*,
        base_iterator_type_
        >::type base_iterator_type;

    typedef pack<base_iterator_type> default_iterator;
    typedef pack<base_iterator_type> default_rev_iterator;
    typedef pack<> size_type;

    static const int dimensions = 0;
    static const int volume = 1;
    static const bool is_fixed_size = true;
};

template<
    typename element_type_,
    int n0_, 
    typename base_iterator_type_>
struct array_signature_traits<
    element_type_[n0_],
    base_iterator_type_>
{
    typedef element_type_ element_type;
    typedef typename detail::remove<element_type_, volatile const int>::type value_type;
    typedef value_type signature[n0_];

    typedef typename detail::type_if<
        detail::same_type<base_iterator_type_, void>::result,
        element_type_*,
        base_iterator_type_
        >::type base_iterator_type;

    typedef pack<
        base_iterator_type,
        constant<int, 1>
        > default_iterator;

    typedef pack<
        base_iterator_type,
        constant<int, 1>
        > default_rev_iterator;

    typedef pack<
        typename detail::type_if<n0_ == 1, int, constant<int, n0_> >::type
        > size_type;

    static const int dimensions = 1;
    static const int volume = n0_;
    static const bool is_fixed_size = n0_!=1;
};

template<
    typename element_type_,
    int n0_, 
    int n1_, 
    typename base_iterator_type_>
struct array_signature_traits<
    element_type_[n0_][n1_],
    base_iterator_type_>
{
    typedef element_type_ element_type;
    typedef typename detail::remove<element_type_, volatile const int>::type value_type;
    typedef value_type signature[n0_][n1_];

    typedef typename detail::type_if<
        detail::same_type<base_iterator_type_, void>::result,
        element_type_*,
        base_iterator_type_
        >::type base_iterator_type;

    typedef pack<
        base_iterator_type,
        typename detail::type_if<(n1_==1), int, constant<int, n1_> >::type,
        constant<int, 1>
        > default_iterator;

    typedef pack<
        base_iterator_type,
        constant<int, 1>,
        typename detail::type_if<(n0_==1), int, constant<int, n0_> >::type
        > default_rev_iterator;

    typedef pack<
        typename detail::type_if<n0_ == 1, int, constant<int, n0_> >::type,
        typename detail::type_if<n1_ == 1, int, constant<int, n1_> >::type
        > size_type;

    static const int dimensions = 2;
    static const int volume = n0_ * n1_;
    static const bool is_fixed_size = n0_!=1 && n1_!=1;
};

template<
    typename element_type_,
    int n0_, 
    int n1_, 
    int n2_, 
    typename base_iterator_type_>
struct array_signature_traits<
    element_type_[n0_][n1_][n2_],
    base_iterator_type_>
{
    typedef element_type_ element_type;
    typedef typename detail::remove<element_type_, volatile const int>::type value_type;
    typedef value_type signature[n0_][n1_][n2_];

    typedef typename detail::type_if<
        detail::same_type<base_iterator_type_, void>::result,
        element_type_*,
        base_iterator_type_
        >::type base_iterator_type;

    typedef pack<
        base_iterator_type,
        typename detail::type_if<(n1_==1||n2_==1), int, constant<int, n1_*n2_> >::type,
        typename detail::type_if<(n2_==1), int, constant<int, n2_> >::type,
        constant<int, 1>
        > default_iterator;

    typedef pack<
        base_iterator_type,
        constant<int, 1>,
        typename detail::type_if<(n0_==1), int, constant<int, n0_> >::type,
        typename detail::type_if<(n1_==1||n0_==1), int, constant<int, n1_*n0_> >::type
        > default_rev_iterator;

    typedef pack<
        typename detail::type_if<n0_ == 1, int, constant<int, n0_> >::type,
        typename detail::type_if<n1_ == 1, int, constant<int, n1_> >::type,
        typename detail::type_if<n2_ == 1, int, constant<int, n2_> >::type
        > size_type;

    static const int dimensions = 3;
    static const int volume = n0_ * n1_ * n2_;
    static const bool is_fixed_size = n0_!=1 && n1_!=1 && n2_!=1;
};



template<
    typename element_type_,
    int n0_, 
    int n1_, 
    int n2_, 
    int n3_, 
    typename base_iterator_type_>
struct array_signature_traits<
    element_type_[n0_][n1_][n2_][n3_],
    base_iterator_type_>
{
    typedef element_type_ element_type;
    typedef typename detail::remove<element_type_, volatile const int>::type value_type;
    typedef value_type signature[n0_][n1_][n2_][n3_];

    // too many dimensions!
    //typedef ??? default_iterator;
    //typedef ??? default_rev_iterator;
    //typedef ??? size_type;

    static const int dimensions = 3+1;
    static const int volume = n0_ * n1_ * n2_ * n3_;
    static const bool is_fixed_size = n0_!=1 && n1_!=1 && n2_!=1 && n3_!=1;
};

#endif // !DOCUMENTATION_ONLY

/***********************************************************************************************************/
/* array_helper ********************************************************************************************/
/***********************************************************************************************************/

template<typename signature_, typename traits_type_>
struct array_helper
{
    typedef array<signature_, traits_type_, 
        typename traits_type_::template representation_type<signature_>::temporary_type> 
        temporary_array;

    typedef array<signature_, traits_type_, 
        typename traits_type_::template representation_type<signature_>::fwd_temporary_type> 
        fwd_temporary_array;

    typedef array<signature_, traits_type_, 
        typename traits_type_::template representation_type<signature_>::rev_temporary_type> 
        rev_temporary_array;
};

/***********************************************************************************************************/
/* for_each, helpers ***************************************************************************************/
/***********************************************************************************************************/

namespace detail
{

template<typename iterator_type_, int dim_=0>
struct g_iterator_traits;

/***********************************************************************************************************/
/* g_iterator_traits, s_iterator ***************************************************************************/
/***********************************************************************************************************/

template<typename base_iterator_type_>
struct g_iterator_traits<pack<base_iterator_type_>, 0>
{
    typedef pack<base_iterator_type_> iterator_type;

    static const int complexity = 1;
    static const int non_unit_strides_count = 0;
    static const int constant_strides_count = 0;
    static const int variable_strides_count = 0;
};

template<
    typename base_iterator_type_,
    typename type0_,
    typename type1_,
    typename type2_
    >
struct g_iterator_traits<
    pack<
        base_iterator_type_,
        type0_,
        type1_,
        type2_
    >,
    0
    >   
{
    typedef pack<
        base_iterator_type_,
        type0_,
        type1_,
        type2_
        > iterator_type;

    static const int complexity = 2;
    static const int non_unit_strides_count = 
        detail::same_type<type0_, constant<int, 1> >::result ? 0 : 1;
    static const int constant_strides_count = iterator_type::is_const1 ? 1 : 0;
    static const int variable_strides_count = iterator_type::is_const1 ? 0 : 1;
};
template<
    typename base_iterator_type_,
    typename type0_,
    typename type1_,
    typename type2_
    >
struct g_iterator_traits<
    pack<
        base_iterator_type_,
        type0_,
        type1_,
        type2_
    >,
    1
    >   
{
    typedef pack<
        base_iterator_type_,
        type0_,
        type1_,
        type2_
        > iterator_type;

    static const int complexity = 2;
    static const int non_unit_strides_count = 
        detail::same_type<type1_, constant<int, 1> >::result ? 0 : 1;
    static const int constant_strides_count = iterator_type::is_const2 ? 1 : 0;
    static const int variable_strides_count = iterator_type::is_const2 ? 0 : 1;
};
template<
    typename base_iterator_type_,
    typename type0_,
    typename type1_,
    typename type2_
    >
struct g_iterator_traits<
    pack<
        base_iterator_type_,
        type0_,
        type1_,
        type2_
    >,
    2
    >   
{
    typedef pack<
        base_iterator_type_,
        type0_,
        type1_,
        type2_
        > iterator_type;

    static const int complexity = 2;
    static const int non_unit_strides_count = 
        detail::same_type<type2_, constant<int, 1> >::result ? 0 : 1;
    static const int constant_strides_count = iterator_type::is_const3 ? 1 : 0;
    static const int variable_strides_count = iterator_type::is_const3 ? 0 : 1;
};

/***********************************************************************************************************/
/* g_iterator_traits, c_iterator ***************************************************************************/
/***********************************************************************************************************/

template<typename value_type_, int dim_>
struct g_iterator_traits<c_iterator<value_type_>, dim_>
{
    typedef c_iterator<value_type_> iterator_type;

    static const int complexity = 1;
    static const int non_unit_strides_count = 0;
    static const int constant_strides_count = 0;
    static const int variable_strides_count = 0;
};

/***********************************************************************************************************/
/* g_iterator_traits, u_iterator ***************************************************************************/
/***********************************************************************************************************/

template<typename base_iter_type_, typename func_type_, bool is_static_, int dim_>
struct g_iterator_traits<u_iterator<base_iter_type_, func_type_, is_static_>, dim_>
{
    typedef u_iterator<base_iter_type_, func_type_, is_static_> iterator_type;

    static const int complexity = 
        g_iterator_traits<base_iter_type_, dim_>::complexity+1;

    static const int non_unit_strides_count =
        g_iterator_traits<base_iter_type_, dim_>::non_unit_strides_count;

    static const int constant_strides_count = 
        g_iterator_traits<base_iter_type_, dim_>::constant_strides_count;

    static const int variable_strides_count = 
        g_iterator_traits<base_iter_type_, dim_>::variable_strides_count;
};

/***********************************************************************************************************/
/* g_iterator_traits, b_iterator ***************************************************************************/
/***********************************************************************************************************/

template<
    typename left_base_iter_type_, 
    typename right_base_iter_type_, 
    typename func_type_, 
    bool is_static_, 
    int dim_>
struct g_iterator_traits<
    b_iterator<left_base_iter_type_, right_base_iter_type_, func_type_, is_static_>, dim_>
{
    typedef b_iterator<left_base_iter_type_, right_base_iter_type_, func_type_, is_static_> iterator_type;

    static const int complexity = 
        g_iterator_traits<left_base_iter_type_, dim_>::complexity
        +g_iterator_traits<right_base_iter_type_, dim_>::complexity+1;

    static const int non_unit_strides_count =
        g_iterator_traits<left_base_iter_type_, dim_>::non_unit_strides_count
        +g_iterator_traits<right_base_iter_type_, dim_>::non_unit_strides_count;

    static const int constant_strides_count = 
        g_iterator_traits<left_base_iter_type_, dim_>::constant_strides_count
        +g_iterator_traits<right_base_iter_type_, dim_>::constant_strides_count;

    static const int variable_strides_count = 
        g_iterator_traits<left_base_iter_type_, dim_>::variable_strides_count
        +g_iterator_traits<right_base_iter_type_, dim_>::variable_strides_count;
};

/***********************************************************************************************************/
/* g_iterator_policy ***************************************************************************************/
/***********************************************************************************************************/

template<typename iterator_type_, int dim_=0>
struct g_iterator_policy
{
    typedef g_iterator_traits<iterator_type_, dim_> traits_type;

    static const bool use_index = traits_type::constant_strides_count >= traits_type::variable_strides_count;
    //?? add other policy
};

/***********************************************************************************************************/
/* matrix_policy *******************************************************************************************/
/***********************************************************************************************************/

template<typename array_type_, int freq_>
struct matrix_policy
{};

/***********************************************************************************************************/

template<typename value_type_, int n0_, typename traits_type_, typename _rep, int freq_>
struct matrix_policy<array<value_type_[n0_], traits_type_, _rep>, freq_>
{
    typedef array<value_type_[n0_], traits_type_, _rep> original_array_type;

    typedef g_iterator_traits<typename original_array_type::iterator, 0> g_iterator_traits0;

    static const bool should_cache_dim0 = 
        freq_ <= 1 ? g_iterator_traits0::complexity > 8 :
        freq_ <= 2 ? g_iterator_traits0::complexity > 2 || g_iterator_traits0::variable_strides_count > 2 :
        g_iterator_traits0::complexity > 2 
        || g_iterator_traits0::variable_strides_count > 0 
        || g_iterator_traits0::non_unit_strides_count > 0;

    typedef typename type_if<
        should_cache_dim0, 
        typename array_helper<value_type_[n0_], traits_type_>::temporary_array,
        const original_array_type&
        >::type cached_array;
};

/***********************************************************************************************************/

template<typename value_type_, int n0_, int n1_, typename traits_type_, typename _rep, int freq_>
struct matrix_policy<array<value_type_[n0_][n1_], traits_type_, _rep>,  freq_>
{
    typedef array<value_type_[n0_][n1_], traits_type_, _rep> original_array_type;

    typedef g_iterator_traits<typename original_array_type::iterator, 0> g_iterator_traits0;
    typedef g_iterator_traits<typename original_array_type::iterator, 1> g_iterator_traits1;

    static const bool should_cache_dim0 = 
        freq_ <= 1 ? g_iterator_traits0::complexity > 8 :
        freq_ <= 2 ? g_iterator_traits0::complexity > 2 || g_iterator_traits0::variable_strides_count > 2 :
        g_iterator_traits0::complexity > 2 
        || g_iterator_traits0::variable_strides_count > 0
        || g_iterator_traits0::non_unit_strides_count > 0;


    static const bool should_cache_dim1 = 
        freq_ <= 1 ? g_iterator_traits1::complexity > 8 :
        freq_ <= 2 ? g_iterator_traits1::complexity > 2 || g_iterator_traits1::variable_strides_count > 2 :
        g_iterator_traits1::complexity > 2 
        || g_iterator_traits1::variable_strides_count > 0
        || g_iterator_traits0::non_unit_strides_count > 0;

    typedef typename type_if<
        should_cache_dim0, 
        typename array_helper<value_type_[n0_][n1_], traits_type_>::fwd_temporary_array,
        const original_array_type&
        >::type cached_fwd_array;

    typedef typename type_if<
        should_cache_dim1, 
        typename array_helper<value_type_[n0_][n1_], traits_type_>::rev_temporary_array,
        const original_array_type&
        >::type cached_rev_array;
};

/***********************************************************************************************************/

template<typename value_type_, int n0_, int n1_, int n2_, typename traits_type_, typename _rep, int freq_>
struct matrix_policy<array<value_type_[n0_][n1_][n2_], traits_type_, _rep>, freq_>
{};

} // namespace detail

/***********************************************************************************************************/
/* for_each ************************************************************************************************/
/***********************************************************************************************************/

#ifdef DOCUMENTATION_ONLY

/*!
    \brief Evaluates every element of the array pointed by \a iter and of size \a size.

    \ingroup array_advanced
*/
template<typename iterator_type_, typename size_type_>
LITE_INLINE void for_each(const iterator_type_& iter, const size_type_& size);

/*!
    \brief 
    Applies the function object \a func to every element of the array pointed by \a iter and of size \a size.

    \ingroup array_advanced
*/
template<typename iterator_type_, typename function_type_, typename size_type_>
LITE_INLINE void for_each(const iterator_type_& iter, function_type_& func, const size_type_& size);

/*!
    \brief 
    Evaluates every element of the array pointed by \a iter and of size \a size 
    while the elements evaluate to true. Returns true if all the elements evaluated to true.

    \ingroup array_advanced
*/
template<typename iterator_type_, typename size_type_>
LITE_INLINE bool for_each_c(const iterator_type_& iter, const size_type_& size);

/*!
    \brief 
    Applies the function object \a func to every element of the array pointed by \a iter and of size \a size,
    while the function object evaluates to true. Returns true if the function object evaluates to true for
    all the elements.
    
    \ingroup array_advanced
*/
template<typename iterator_type_, typename function_type_, typename size_type_>
LITE_INLINE bool for_each_c(const iterator_type_& iter, function_type_& func, const size_type_& size);

#else // DOCUMENTATION_ONLY

/***********************************************************************************************************/
/* for_each, 0D arrays *************************************************************************************/
/***********************************************************************************************************/

template<typename iterator_type_>
LITE_INLINE void
for_each(const iterator_type_& iter, const pack<>&)
{
    at(iter);
}

template<typename iterator_type_, typename function_type_>
LITE_INLINE void
for_each(const iterator_type_& iter, function_type_& func, const pack<>&)
{
    func(at(iter));
}

template<typename iterator_type_>
LITE_INLINE bool
for_each_c(const iterator_type_& iter, const pack<>&)
{
    return at(iter);
}

template<typename iterator_type_, typename function_type_>
LITE_INLINE bool
for_each_c(const iterator_type_& iter, function_type_& func, const pack<>&)
{
    return func(at(iter));
}

/***********************************************************************************************************/
/* for_each, 1D small arrays, use_index ********************************************************************/
/***********************************************************************************************************/


template<typename iterator_type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    )>::type 
for_each(const iterator_type_& iter, const pack<constant<int, 1> >&)
{
    at(iter, 0);
}

template<typename iterator_type_, typename function_type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    )>::type 
for_each(const iterator_type_& iter, function_type_& func, const pack<constant<int, 1> >&)
{
    func(at(iter, 0));
}

template<typename iterator_type_, typename function_type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    ), bool>::type 
for_each_c(const iterator_type_& iter, function_type_& func, const pack<constant<int, 1> >&)
{
    if (!func(at(iter, 0))) return false;
    return true;
}

template<typename iterator_type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    ), bool>::type 
for_each_c(const iterator_type_& iter, const pack<constant<int, 1> >&)
{
    if (!at(iter, 0)) return false;
    return true;
}

template<typename iterator_type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    )>::type 
for_each(const iterator_type_& iter, const pack<constant<int, 2> >&)
{
    at(iter, 0);
    at(iter, 1);
}

template<typename iterator_type_, typename function_type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    )>::type 
for_each(const iterator_type_& iter, function_type_& func, const pack<constant<int, 2> >&)
{
    func(at(iter, 0));
    func(at(iter, 1));
}

template<typename iterator_type_, typename function_type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    ), bool>::type 
for_each_c(const iterator_type_& iter, function_type_& func, const pack<constant<int, 2> >&)
{
    if (!func(at(iter, 0))) return false;
    if (!func(at(iter, 1))) return false;
    return true;
}

template<typename iterator_type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    ), bool>::type 
for_each_c(const iterator_type_& iter, const pack<constant<int, 2> >&)
{
    if (!at(iter, 0)) return false;
    if (!at(iter, 1)) return false;
    return true;
}

template<typename iterator_type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    )>::type 
for_each(const iterator_type_& iter, const pack<constant<int, 3> >&)
{
    at(iter, 0);
    at(iter, 1);
    at(iter, 2);
}

template<typename iterator_type_, typename function_type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    )>::type 
for_each(const iterator_type_& iter, function_type_& func, const pack<constant<int, 3> >&)
{
    func(at(iter, 0));
    func(at(iter, 1));
    func(at(iter, 2));
}

template<typename iterator_type_, typename function_type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    ), bool>::type 
for_each_c(const iterator_type_& iter, function_type_& func, const pack<constant<int, 3> >&)
{
    if (!func(at(iter, 0))) return false;
    if (!func(at(iter, 1))) return false;
    if (!func(at(iter, 2))) return false;
    return true;
}

template<typename iterator_type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    ), bool>::type 
for_each_c(const iterator_type_& iter, const pack<constant<int, 3> >&)
{
    if (!at(iter, 0)) return false;
    if (!at(iter, 1)) return false;
    if (!at(iter, 2)) return false;
    return true;
}

template<typename iterator_type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    )>::type 
for_each(const iterator_type_& iter, const pack<constant<int, 4> >&)
{
    at(iter, 0);
    at(iter, 1);
    at(iter, 2);
    at(iter, 3);
}

template<typename iterator_type_, typename function_type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    )>::type 
for_each(const iterator_type_& iter, function_type_& func, const pack<constant<int, 4> >&)
{
    func(at(iter, 0));
    func(at(iter, 1));
    func(at(iter, 2));
    func(at(iter, 3));
}

template<typename iterator_type_, typename function_type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    ), bool>::type 
for_each_c(const iterator_type_& iter, function_type_& func, const pack<constant<int, 4> >&)
{
    if (!func(at(iter, 0))) return false;
    if (!func(at(iter, 1))) return false;
    if (!func(at(iter, 2))) return false;
    if (!func(at(iter, 3))) return false;
    return true;
}

template<typename iterator_type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    ), bool>::type 
for_each_c(const iterator_type_& iter, const pack<constant<int, 4> >&)
{
    if (!at(iter, 0)) return false;
    if (!at(iter, 1)) return false;
    if (!at(iter, 2)) return false;
    if (!at(iter, 3)) return false;
    return true;
}

template<typename iterator_type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    )>::type 
for_each(const iterator_type_& iter, const pack<constant<int, 5> >&)
{
    at(iter, 0);
    at(iter, 1);
    at(iter, 2);
    at(iter, 3);
    at(iter, 4);
}

template<typename iterator_type_, typename function_type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    )>::type 
for_each(const iterator_type_& iter, function_type_& func, const pack<constant<int, 5> >&)
{
    func(at(iter, 0));
    func(at(iter, 1));
    func(at(iter, 2));
    func(at(iter, 3));
    func(at(iter, 4));
}

template<typename iterator_type_, typename function_type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    ), bool>::type 
for_each_c(const iterator_type_& iter, function_type_& func, const pack<constant<int, 5> >&)
{
    if (!func(at(iter, 0))) return false;
    if (!func(at(iter, 1))) return false;
    if (!func(at(iter, 2))) return false;
    if (!func(at(iter, 3))) return false;
    if (!func(at(iter, 4))) return false;
    return true;
}

template<typename iterator_type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    ), bool>::type 
for_each_c(const iterator_type_& iter, const pack<constant<int, 5> >&)
{
    if (!at(iter, 0)) return false;
    if (!at(iter, 1)) return false;
    if (!at(iter, 2)) return false;
    if (!at(iter, 3)) return false;
    if (!at(iter, 4)) return false;
    return true;
}

/***********************************************************************************************************/
/* for_each, 1D small arrays, !use_index =*******************************************************************/
/***********************************************************************************************************/

template<typename iterator_type_>
LITE_INLINE 
typename detail::enable_if<(
    !detail::g_iterator_policy<iterator_type_>::use_index
    )>::type 
for_each(const iterator_type_& iter, const pack<constant<int, 6> >&)
{
    iterator_type_ it = iter;

    at(it, 0); inc<0>(it); 
    at(it, 1); inc<0>(it); 
    at(it, 2); inc<0>(it); 
    at(it, 3); inc<0>(it); 
    at(it, 4); inc<0>(it); 
    at(it, 5);
}

template<typename iterator_type_, typename function_type_>
LITE_INLINE 
typename detail::enable_if<(
    !detail::g_iterator_policy<iterator_type_>::use_index
    )>::type 
for_each(const iterator_type_& iter, function_type_& func, const pack<constant<int, 6> >&)
{
    iterator_type_ it = iter;

    func(at(it, 0)); inc<0>(it); 
    func(at(it, 1)); inc<0>(it); 
    func(at(it, 2)); inc<0>(it); 
    func(at(it, 3)); inc<0>(it); 
    func(at(it, 4)); inc<0>(it); 
    func(at(it, 5));
}

template<typename iterator_type_>
LITE_INLINE 
typename detail::enable_if<(
    !detail::g_iterator_policy<iterator_type_>::use_index
    ), bool>::type 
for_each_c(const iterator_type_& iter, const pack<constant<int, 6> >&)
{
    iterator_type_ it = iter;

    if (!at(iter, 0)) return false; inc<0>(it); 
    if (!at(iter, 1)) return false; inc<0>(it); 
    if (!at(iter, 2)) return false; inc<0>(it); 
    if (!at(iter, 3)) return false; inc<0>(it); 
    if (!at(iter, 4)) return false; inc<0>(it); 
    if (!at(iter, 5)) return false;

    return true;
}

template<typename iterator_type_, typename function_type_>
LITE_INLINE 
typename detail::enable_if<(
    !detail::g_iterator_policy<iterator_type_>::use_index
    ), bool>::type 
for_each_c(const iterator_type_& iter, function_type_& func, const pack<constant<int, 6> >&)
{
    iterator_type_ it = iter;

    if (!func(at(iter, 0))) return false; inc<0>(it); 
    if (!func(at(iter, 1))) return false; inc<0>(it); 
    if (!func(at(iter, 2))) return false; inc<0>(it); 
    if (!func(at(iter, 3))) return false; inc<0>(it); 
    if (!func(at(iter, 4))) return false; inc<0>(it); 
    if (!func(at(iter, 5))) return false;

    return true;
}

/***********************************************************************************************************/
/* for_each, 1D arrays, use_index **************************************************************************/
/***********************************************************************************************************/

template<typename iterator_type_, typename type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    )>::type 
for_each(const iterator_type_& iter, const pack<type_>& size)
{
    const int n = size.i0;
    int j=16;
    iterator_type_ it = iter;

    for (; j<=n; j+=16) {
        at(it, 0); 
        at(it, 1); 
        at(it, 2); 
        at(it, 3); 
        at(it, 4); 
        at(it, 5); 
        at(it, 6); 
        at(it, 7); 
        at(it, 8); 
        at(it, 9); 
        at(it, 10); 
        at(it, 11); 
        at(it, 12); 
        at(it, 13); 
        at(it, 14); 
        at(it, 15); 
        shift<0>(it, 16);
    }

    if (n & 8) {
        at(it, 0);
        at(it, 1);
        at(it, 2);
        at(it, 3);
        at(it, 4);
        at(it, 5);
        at(it, 6);
        at(it, 7);
        shift<0>(it, 8);
    }
    if (n & 4) {
        at(it, 0);
        at(it, 1);
        at(it, 2);
        at(it, 3);
        shift<0>(it, 4);
    }
    if (n & 2) {
        at(it, 0);
        at(it, 1);
        shift<0>(it, 2);
    }

    if (n & 1)
        at(it, 0);

    LITE_ARRAY_USE(size);
}

template<typename iterator_type_, typename function_type_, typename type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    )>::type 
for_each(const iterator_type_& iter, function_type_& func, const pack<type_>& size)
{
    const int n = size.i0;
    int j=16;
    iterator_type_ it = iter;

    for (; j<=n; j+=16) {
        func(at(it, 0)); 
        func(at(it, 1)); 
        func(at(it, 2)); 
        func(at(it, 3)); 
        func(at(it, 4)); 
        func(at(it, 5)); 
        func(at(it, 6)); 
        func(at(it, 7)); 
        func(at(it, 8)); 
        func(at(it, 9)); 
        func(at(it, 10)); 
        func(at(it, 11)); 
        func(at(it, 12)); 
        func(at(it, 13)); 
        func(at(it, 14)); 
        func(at(it, 15)); 
        shift<0>(it, 16);
    }

    if (n & 8) {
        func(at(it, 0));
        func(at(it, 1));
        func(at(it, 2));
        func(at(it, 3));
        func(at(it, 4));
        func(at(it, 5));
        func(at(it, 6));
        func(at(it, 7));
        shift<0>(it, 8);
    }
    if (n & 4) {
        func(at(it, 0));
        func(at(it, 1));
        func(at(it, 2));
        func(at(it, 3));
        shift<0>(it, 4);
    }
    if (n & 2) {
        func(at(it, 0));
        func(at(it, 1));
        shift<0>(it, 2);
    }

    if (n & 1)
        func(at(it, 0));

    LITE_ARRAY_USE(size);
}

template<typename iterator_type_, typename type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    ), bool>::type 
for_each_c(const iterator_type_& iter, const pack<type_>& size)
{
    const int n = size.i0;
    int j=16;
    iterator_type_ it = iter;

    for (; j<=n; j+=16) {
        if (!at(it, 0)) return false; 
        if (!at(it, 1)) return false; 
        if (!at(it, 2)) return false; 
        if (!at(it, 3)) return false; 
        if (!at(it, 4)) return false; 
        if (!at(it, 5)) return false; 
        if (!at(it, 6)) return false; 
        if (!at(it, 7)) return false; 
        if (!at(it, 8)) return false; 
        if (!at(it, 9)) return false; 
        if (!at(it, 10)) return false; 
        if (!at(it, 11)) return false; 
        if (!at(it, 12)) return false; 
        if (!at(it, 13)) return false; 
        if (!at(it, 14)) return false; 
        if (!at(it, 15)) return false; 
        shift<0>(it, 16);
    }

    if (n & 8) {
        if (!at(it, 0)) return false; 
        if (!at(it, 1)) return false; 
        if (!at(it, 2)) return false; 
        if (!at(it, 3)) return false; 
        if (!at(it, 4)) return false; 
        if (!at(it, 5)) return false; 
        if (!at(it, 6)) return false; 
        if (!at(it, 7)) return false; 
        shift<0>(it, 8);
    }
    if (n & 4) {
        if (!at(it, 0)) return false; 
        if (!at(it, 1)) return false; 
        if (!at(it, 2)) return false; 
        if (!at(it, 3)) return false; 
        shift<0>(it, 4);
    }
    if (n & 2) {
        if (!at(it, 0)) return false; 
        if (!at(it, 1)) return false; 
        shift<0>(it, 2);
    }

    if (n & 1)
        if (!at(it, 0)) return false; 

    return true;
    LITE_ARRAY_USE(size);
}

template<typename iterator_type_, typename function_type_, typename type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    ), bool>::type 
for_each_c(const iterator_type_& iter, function_type_& func, const pack<type_>& size)
{
    const int n = size.i0;
    int j=16;
    iterator_type_ it = iter;

    for (; j<=n; j+=16) {
        if (!func(at(it, 0))) return false; 
        if (!func(at(it, 1))) return false; 
        if (!func(at(it, 2))) return false; 
        if (!func(at(it, 3))) return false; 
        if (!func(at(it, 4))) return false; 
        if (!func(at(it, 5))) return false; 
        if (!func(at(it, 6))) return false; 
        if (!func(at(it, 7))) return false; 
        if (!func(at(it, 8))) return false; 
        if (!func(at(it, 9))) return false; 
        if (!func(at(it, 10))) return false; 
        if (!func(at(it, 11))) return false; 
        if (!func(at(it, 12))) return false; 
        if (!func(at(it, 13))) return false; 
        if (!func(at(it, 14))) return false; 
        if (!func(at(it, 15))) return false; 
        shift<0>(it, 16);
    }

    if (n & 8) {
        if (!func(at(it, 0))) return false; 
        if (!func(at(it, 1))) return false; 
        if (!func(at(it, 2))) return false; 
        if (!func(at(it, 3))) return false; 
        if (!func(at(it, 4))) return false; 
        if (!func(at(it, 5))) return false; 
        if (!func(at(it, 6))) return false; 
        if (!func(at(it, 7))) return false; 
        shift<0>(it, 8);
    }
    if (n & 4) {
        if (!func(at(it, 0))) return false; 
        if (!func(at(it, 1))) return false; 
        if (!func(at(it, 2))) return false; 
        if (!func(at(it, 3))) return false; 
        shift<0>(it, 4);
    }
    if (n & 2) {
        if (!func(at(it, 0))) return false; 
        if (!func(at(it, 1))) return false; 
        shift<0>(it, 2);
    }

    if (n & 1)
        if (!func(at(it, 0))) return false; 

    return true;
    LITE_ARRAY_USE(size);
}

/***********************************************************************************************************/
/* for_each, 1D arrays, !use_index *************************************************************************/
/***********************************************************************************************************/

template<typename iterator_type_, typename type_>
LITE_INLINE 
typename detail::enable_if<(
    !detail::g_iterator_policy<iterator_type_>::use_index
    )>::type 
for_each(const iterator_type_& iter, const pack<type_>& size)
{
    const int n = size.i0;
    int j=16;
    iterator_type_ it = iter;

    for (; j<=n; j+=16) {
        at(it); inc<0>(it);
        at(it); inc<0>(it);
        at(it); inc<0>(it);
        at(it); inc<0>(it);
        at(it); inc<0>(it);
        at(it); inc<0>(it);
        at(it); inc<0>(it);
        at(it); inc<0>(it);
        at(it); inc<0>(it);
        at(it); inc<0>(it);
        at(it); inc<0>(it);
        at(it); inc<0>(it);
        at(it); inc<0>(it);
        at(it); inc<0>(it);
        at(it); inc<0>(it);
        at(it); inc<0>(it);
    }

    if (n & 8) {
        at(it); inc<0>(it);
        at(it); inc<0>(it);
        at(it); inc<0>(it);
        at(it); inc<0>(it);
        at(it); inc<0>(it);
        at(it); inc<0>(it);
        at(it); inc<0>(it);
        at(it); inc<0>(it);
    }
    if (n & 4) {
        at(it); inc<0>(it);
        at(it); inc<0>(it);
        at(it); inc<0>(it);
        at(it); inc<0>(it);
    }
    if (n & 2) {
        at(it); inc<0>(it);
        at(it); inc<0>(it);
    }

    if (n & 1)
        at(it);
    LITE_ARRAY_USE(size);
}

template<typename iterator_type_, typename function_type_, typename type_>
LITE_INLINE 
typename detail::enable_if<(
    !detail::g_iterator_policy<iterator_type_>::use_index
    )>::type 
for_each(const iterator_type_& iter, function_type_& func, const pack<type_>& size)
{
    const int n = size.i0;
    int j=16;
    iterator_type_ it = iter;

    for (; j<=n; j+=16) {
        func(at(it)); inc<0>(it);
        func(at(it)); inc<0>(it);
        func(at(it)); inc<0>(it);
        func(at(it)); inc<0>(it);
        func(at(it)); inc<0>(it);
        func(at(it)); inc<0>(it);
        func(at(it)); inc<0>(it);
        func(at(it)); inc<0>(it);
        func(at(it)); inc<0>(it);
        func(at(it)); inc<0>(it);
        func(at(it)); inc<0>(it);
        func(at(it)); inc<0>(it);
        func(at(it)); inc<0>(it);
        func(at(it)); inc<0>(it);
        func(at(it)); inc<0>(it);
        func(at(it)); inc<0>(it);
    }

    if (n & 8) {
        func(at(it)); inc<0>(it);
        func(at(it)); inc<0>(it);
        func(at(it)); inc<0>(it);
        func(at(it)); inc<0>(it);
        func(at(it)); inc<0>(it);
        func(at(it)); inc<0>(it);
        func(at(it)); inc<0>(it);
        func(at(it)); inc<0>(it);
    }
    if (n & 4) {
        func(at(it)); inc<0>(it);
        func(at(it)); inc<0>(it);
        func(at(it)); inc<0>(it);
        func(at(it)); inc<0>(it);
    }
    if (n & 2) {
        func(at(it)); inc<0>(it);
        func(at(it)); inc<0>(it);
    }

    if (n & 1)
        func(at(it));
    LITE_ARRAY_USE(size);
}

template<typename iterator_type_, typename type_>
LITE_INLINE 
typename detail::enable_if<(
    !detail::g_iterator_policy<iterator_type_>::use_index
    ), bool>::type 
for_each_c(const iterator_type_& iter, const pack<type_>& size)
{
    const int n = size.i0;
    int j=16;
    iterator_type_ it = iter;

    for (; j<=n; j+=16) {
        if(!at(it)) return false; inc<0>(it);
        if(!at(it)) return false; inc<0>(it);
        if(!at(it)) return false; inc<0>(it);
        if(!at(it)) return false; inc<0>(it);
        if(!at(it)) return false; inc<0>(it);
        if(!at(it)) return false; inc<0>(it);
        if(!at(it)) return false; inc<0>(it);
        if(!at(it)) return false; inc<0>(it);
        if(!at(it)) return false; inc<0>(it);
        if(!at(it)) return false; inc<0>(it);
        if(!at(it)) return false; inc<0>(it);
        if(!at(it)) return false; inc<0>(it);
        if(!at(it)) return false; inc<0>(it);
        if(!at(it)) return false; inc<0>(it);
        if(!at(it)) return false; inc<0>(it);
        if(!at(it)) return false; inc<0>(it);
    }

    if (n & 8) {
        if(!at(it)) return false; inc<0>(it);
        if(!at(it)) return false; inc<0>(it);
        if(!at(it)) return false; inc<0>(it);
        if(!at(it)) return false; inc<0>(it);
        if(!at(it)) return false; inc<0>(it);
        if(!at(it)) return false; inc<0>(it);
        if(!at(it)) return false; inc<0>(it);
        if(!at(it)) return false; inc<0>(it);
    }
    if (n & 4) {
        if(!at(it)) return false; inc<0>(it);
        if(!at(it)) return false; inc<0>(it);
        if(!at(it)) return false; inc<0>(it);
        if(!at(it)) return false; inc<0>(it);
    }
    if (n & 2) {
        if(!at(it)) return false; inc<0>(it);
        if(!at(it)) return false; inc<0>(it);
    }

    if (n & 1)
        if(!at(it)) return false;

    return true;
    LITE_ARRAY_USE(size);
}


template<typename iterator_type_, typename function_type_, typename type_>
LITE_INLINE 
typename detail::enable_if<(
    !detail::g_iterator_policy<iterator_type_>::use_index
    ), bool>::type 
for_each_c(const iterator_type_& iter, function_type_& func, const pack<type_>& size)
{
    const int n = size.i0;
    int j=16;
    iterator_type_ it = iter;

    for (; j<=n; j+=16) {
        if(!func(at(it))) return false; inc<0>(it);
        if(!func(at(it))) return false; inc<0>(it);
        if(!func(at(it))) return false; inc<0>(it);
        if(!func(at(it))) return false; inc<0>(it);
        if(!func(at(it))) return false; inc<0>(it);
        if(!func(at(it))) return false; inc<0>(it);
        if(!func(at(it))) return false; inc<0>(it);
        if(!func(at(it))) return false; inc<0>(it);
        if(!func(at(it))) return false; inc<0>(it);
        if(!func(at(it))) return false; inc<0>(it);
        if(!func(at(it))) return false; inc<0>(it);
        if(!func(at(it))) return false; inc<0>(it);
        if(!func(at(it))) return false; inc<0>(it);
        if(!func(at(it))) return false; inc<0>(it);
        if(!func(at(it))) return false; inc<0>(it);
        if(!func(at(it))) return false; inc<0>(it);
    }

    if (n & 8) {
        if(!func(at(it))) return false; inc<0>(it);
        if(!func(at(it))) return false; inc<0>(it);
        if(!func(at(it))) return false; inc<0>(it);
        if(!func(at(it))) return false; inc<0>(it);
        if(!func(at(it))) return false; inc<0>(it);
        if(!func(at(it))) return false; inc<0>(it);
        if(!func(at(it))) return false; inc<0>(it);
        if(!func(at(it))) return false; inc<0>(it);
    }
    if (n & 4) {
        if(!func(at(it))) return false; inc<0>(it);
        if(!func(at(it))) return false; inc<0>(it);
        if(!func(at(it))) return false; inc<0>(it);
        if(!func(at(it))) return false; inc<0>(it);
    }
    if (n & 2) {
        if(!func(at(it))) return false; inc<0>(it);
        if(!func(at(it))) return false; inc<0>(it);
    }

    if (n & 1)
        if(!func(at(it))) return false; inc<0>(it);

    return true;
    LITE_ARRAY_USE(size);
}

/***********************************************************************************************************/
/* for_each, small square 2D arrays, use_index *************************************************************/
/***********************************************************************************************************/


template<typename iterator_type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    )>::type 
for_each(const iterator_type_& iter, const pack<constant<int, 1>, constant<int, 1> >&)
{
    at(iter, 0, 0);
}

template<typename iterator_type_, typename function_type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    )>::type 
for_each(
    const iterator_type_& iter, 
    function_type_& func, 
    const pack<constant<int, 1>, constant<int, 1> >&)
{
    func(at(iter, 0, 0));
}

template<typename iterator_type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    ), bool>::type 
for_each_c(
    const iterator_type_& iter, 
    const pack<constant<int, 1>, constant<int, 1> >&)
{
    if (!at(iter, 0, 0)) return false;
    return true;
}

template<typename iterator_type_, typename function_type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    ), bool>::type 
for_each_c(
    const iterator_type_& iter, 
    function_type_& func, 
    const pack<constant<int, 1>, constant<int, 1> >&)
{
    if (!func(at(iter, 0, 0))) return false;
    return true;
}

template<typename iterator_type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    )>::type 
for_each(const iterator_type_& iter, const pack<constant<int, 2>, constant<int, 2> >&)
{
    at(iter, 0, 0);
    at(iter, 0, 1);
    at(iter, 1, 0);
    at(iter, 1, 1);
}

template<typename iterator_type_, typename function_type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    )>::type 
for_each(
    const iterator_type_& iter, 
    function_type_& func, 
    const pack<constant<int, 2>, constant<int, 2> >&)
{
    func(at(iter, 0, 0));
    func(at(iter, 0, 1));
    func(at(iter, 1, 0));
    func(at(iter, 1, 1));
}

template<typename iterator_type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    ), bool>::type 
for_each_c(
    const iterator_type_& iter, 
    const pack<constant<int, 2>, constant<int, 2> >&)
{
    if (!at(iter, 0, 0)) return false;
    if (!at(iter, 0, 1)) return false;
    if (!at(iter, 1, 0)) return false;
    if (!at(iter, 1, 1)) return false;
    return true;
}

template<typename iterator_type_, typename function_type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    ), bool>::type 
for_each_c(
    const iterator_type_& iter, 
    function_type_& func, 
    const pack<constant<int, 2>, constant<int, 2> >&)
{
    if (!func(at(iter, 0, 0))) return false;
    if (!func(at(iter, 0, 1))) return false;
    if (!func(at(iter, 1, 0))) return false;
    if (!func(at(iter, 1, 1))) return false;
    return true;
}

template<typename iterator_type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    )>::type 
for_each(const iterator_type_& iter, const pack<constant<int, 3>, constant<int, 3> >&)
{
    at(iter, 0, 0);
    at(iter, 0, 1);
    at(iter, 0, 2);
    at(iter, 1, 0);
    at(iter, 1, 1);
    at(iter, 1, 2);
    at(iter, 2, 0);
    at(iter, 2, 1);
    at(iter, 2, 2);
}

template<typename iterator_type_, typename function_type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    )>::type 
for_each(
    const iterator_type_& iter, 
    function_type_& func, 
    const pack<constant<int, 3>, constant<int, 3> >&)
{
    func(at(iter, 0, 0));
    func(at(iter, 0, 1));
    func(at(iter, 0, 2));
    func(at(iter, 1, 0));
    func(at(iter, 1, 1));
    func(at(iter, 1, 2));
    func(at(iter, 2, 0));
    func(at(iter, 2, 1));
    func(at(iter, 2, 2));
}

template<typename iterator_type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    ), bool>::type 
for_each_c(
    const iterator_type_& iter, 
    const pack<constant<int, 3>, constant<int, 3> >&)
{
    if (!at(iter, 0, 0)) return false;
    if (!at(iter, 0, 1)) return false;
    if (!at(iter, 0, 2)) return false;
    if (!at(iter, 1, 0)) return false;
    if (!at(iter, 1, 1)) return false;
    if (!at(iter, 1, 2)) return false;
    if (!at(iter, 2, 0)) return false;
    if (!at(iter, 2, 1)) return false;
    if (!at(iter, 2, 2)) return false;
    return true;
}

template<typename iterator_type_, typename function_type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    ), bool>::type 
for_each_c(
    const iterator_type_& iter, 
    function_type_& func, 
    const pack<constant<int, 3>, constant<int, 3> >&)
{
    if (!func(at(iter, 0, 0))) return false;
    if (!func(at(iter, 0, 1))) return false;
    if (!func(at(iter, 0, 2))) return false;
    if (!func(at(iter, 1, 0))) return false;
    if (!func(at(iter, 1, 1))) return false;
    if (!func(at(iter, 1, 2))) return false;
    if (!func(at(iter, 2, 0))) return false;
    if (!func(at(iter, 2, 1))) return false;
    if (!func(at(iter, 2, 2))) return false;
    return true;
}

template<typename iterator_type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    )>::type 
for_each(const iterator_type_& iter, const pack<constant<int, 4>, constant<int, 4> >&)
{
    at(iter, 0, 0);
    at(iter, 0, 1);
    at(iter, 0, 2);
    at(iter, 0, 3);
    at(iter, 1, 0);
    at(iter, 1, 1);
    at(iter, 1, 2);
    at(iter, 1, 3);
    at(iter, 2, 0);
    at(iter, 2, 1);
    at(iter, 2, 2);
    at(iter, 2, 3);
    at(iter, 3, 0);
    at(iter, 3, 1);
    at(iter, 3, 2);
    at(iter, 3, 3);
}

template<typename iterator_type_, typename function_type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    )>::type 
for_each(
    const iterator_type_& iter, 
    function_type_& func, 
    const pack<constant<int, 4>, constant<int, 4> >&)
{
    func(at(iter, 0, 0));
    func(at(iter, 0, 1));
    func(at(iter, 0, 2));
    func(at(iter, 0, 3));
    func(at(iter, 1, 0));
    func(at(iter, 1, 1));
    func(at(iter, 1, 2));
    func(at(iter, 1, 3));
    func(at(iter, 2, 0));
    func(at(iter, 2, 1));
    func(at(iter, 2, 2));
    func(at(iter, 2, 3));
    func(at(iter, 3, 0));
    func(at(iter, 3, 1));
    func(at(iter, 3, 2));
    func(at(iter, 3, 3));
}

template<typename iterator_type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    ), bool>::type 
for_each_c(
    const iterator_type_& iter, 
    const pack<constant<int, 4>, constant<int, 4> >&)
{
    if (!at(iter, 0, 0)) return false;
    if (!at(iter, 0, 1)) return false;
    if (!at(iter, 0, 2)) return false;
    if (!at(iter, 0, 3)) return false;
    if (!at(iter, 1, 0)) return false;
    if (!at(iter, 1, 1)) return false;
    if (!at(iter, 1, 2)) return false;
    if (!at(iter, 1, 3)) return false;
    if (!at(iter, 2, 0)) return false;
    if (!at(iter, 2, 1)) return false;
    if (!at(iter, 2, 2)) return false;
    if (!at(iter, 2, 3)) return false;
    if (!at(iter, 3, 0)) return false;
    if (!at(iter, 3, 1)) return false;
    if (!at(iter, 3, 2)) return false;
    if (!at(iter, 3, 3)) return false;
    return true;
}

template<typename iterator_type_, typename function_type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    ), bool>::type 
for_each_c(
    const iterator_type_& iter, 
    function_type_& func, 
    const pack<constant<int, 4>, constant<int, 4> >&)
{
    if (!func(at(iter, 0, 0))) return false;
    if (!func(at(iter, 0, 1))) return false;
    if (!func(at(iter, 0, 2))) return false;
    if (!func(at(iter, 0, 3))) return false;
    if (!func(at(iter, 1, 0))) return false;
    if (!func(at(iter, 1, 1))) return false;
    if (!func(at(iter, 1, 2))) return false;
    if (!func(at(iter, 1, 3))) return false;
    if (!func(at(iter, 2, 0))) return false;
    if (!func(at(iter, 2, 1))) return false;
    if (!func(at(iter, 2, 2))) return false;
    if (!func(at(iter, 2, 3))) return false;
    if (!func(at(iter, 3, 0))) return false;
    if (!func(at(iter, 3, 1))) return false;
    if (!func(at(iter, 3, 2))) return false;
    if (!func(at(iter, 3, 3))) return false;
    return true;
}

template<typename iterator_type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    )>::type 
for_each(const iterator_type_& iter, const pack<constant<int, 5>, constant<int, 5> >&)
{
    at(iter, 0, 0);
    at(iter, 0, 1);
    at(iter, 0, 2);
    at(iter, 0, 3);
    at(iter, 0, 4);
    at(iter, 1, 0);
    at(iter, 1, 1);
    at(iter, 1, 2);
    at(iter, 1, 3);
    at(iter, 1, 4);
    at(iter, 2, 0);
    at(iter, 2, 1);
    at(iter, 2, 2);
    at(iter, 2, 3);
    at(iter, 2, 4);
    at(iter, 3, 0);
    at(iter, 3, 1);
    at(iter, 3, 2);
    at(iter, 3, 3);
    at(iter, 3, 4);
    at(iter, 4, 0);
    at(iter, 4, 1);
    at(iter, 4, 2);
    at(iter, 4, 3);
    at(iter, 4, 4);
}

template<typename iterator_type_, typename function_type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    )>::type 
for_each(
    const iterator_type_& iter, 
    function_type_& func, 
    const pack<constant<int, 5>, constant<int, 5> >&)
{
    func(at(iter, 0, 0));
    func(at(iter, 0, 1));
    func(at(iter, 0, 2));
    func(at(iter, 0, 3));
    func(at(iter, 0, 4));
    func(at(iter, 1, 0));
    func(at(iter, 1, 1));
    func(at(iter, 1, 2));
    func(at(iter, 1, 3));
    func(at(iter, 1, 4));
    func(at(iter, 2, 0));
    func(at(iter, 2, 1));
    func(at(iter, 2, 2));
    func(at(iter, 2, 3));
    func(at(iter, 2, 4));
    func(at(iter, 3, 0));
    func(at(iter, 3, 1));
    func(at(iter, 3, 2));
    func(at(iter, 3, 3));
    func(at(iter, 3, 4));
    func(at(iter, 4, 0));
    func(at(iter, 4, 1));
    func(at(iter, 4, 2));
    func(at(iter, 4, 3));
    func(at(iter, 4, 4));
}

template<typename iterator_type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    ), bool>::type 
for_each_c(
    const iterator_type_& iter, 
    const pack<constant<int, 5>, constant<int, 5> >&)
{
    if (!at(iter, 0, 0)) return false;
    if (!at(iter, 0, 1)) return false;
    if (!at(iter, 0, 2)) return false;
    if (!at(iter, 0, 3)) return false;
    if (!at(iter, 0, 4)) return false;
    if (!at(iter, 1, 0)) return false;
    if (!at(iter, 1, 1)) return false;
    if (!at(iter, 1, 2)) return false;
    if (!at(iter, 1, 3)) return false;
    if (!at(iter, 1, 4)) return false;
    if (!at(iter, 2, 0)) return false;
    if (!at(iter, 2, 1)) return false;
    if (!at(iter, 2, 2)) return false;
    if (!at(iter, 2, 3)) return false;
    if (!at(iter, 2, 4)) return false;
    if (!at(iter, 3, 0)) return false;
    if (!at(iter, 3, 1)) return false;
    if (!at(iter, 3, 2)) return false;
    if (!at(iter, 3, 3)) return false;
    if (!at(iter, 3, 4)) return false;
    if (!at(iter, 4, 0)) return false;
    if (!at(iter, 4, 1)) return false;
    if (!at(iter, 4, 2)) return false;
    if (!at(iter, 4, 3)) return false;
    if (!at(iter, 4, 4)) return false;
    return true;
}

template<typename iterator_type_, typename function_type_>
LITE_INLINE 
typename detail::enable_if<(
    detail::g_iterator_policy<iterator_type_>::use_index
    ), bool>::type 
for_each_c(
    const iterator_type_& iter, 
    function_type_& func, 
    const pack<constant<int, 5>, constant<int, 5> >&)
{
    if (!func(at(iter, 0, 0))) return false;
    if (!func(at(iter, 0, 1))) return false;
    if (!func(at(iter, 0, 2))) return false;
    if (!func(at(iter, 0, 3))) return false;
    if (!func(at(iter, 0, 4))) return false;
    if (!func(at(iter, 1, 0))) return false;
    if (!func(at(iter, 1, 1))) return false;
    if (!func(at(iter, 1, 2))) return false;
    if (!func(at(iter, 1, 3))) return false;
    if (!func(at(iter, 1, 4))) return false;
    if (!func(at(iter, 2, 0))) return false;
    if (!func(at(iter, 2, 1))) return false;
    if (!func(at(iter, 2, 2))) return false;
    if (!func(at(iter, 2, 3))) return false;
    if (!func(at(iter, 2, 4))) return false;
    if (!func(at(iter, 3, 0))) return false;
    if (!func(at(iter, 3, 1))) return false;
    if (!func(at(iter, 3, 2))) return false;
    if (!func(at(iter, 3, 3))) return false;
    if (!func(at(iter, 3, 4))) return false;
    if (!func(at(iter, 4, 0))) return false;
    if (!func(at(iter, 4, 1))) return false;
    if (!func(at(iter, 4, 2))) return false;
    if (!func(at(iter, 4, 3))) return false;
    if (!func(at(iter, 4, 4))) return false;
    return true;
}

/***********************************************************************************************************/
/* for_each, nD arrays *************************************************************************************/
/***********************************************************************************************************/

template<typename iterator_type_, typename size_type_>
LITE_INLINE 
typename detail::enable_if<(
    size_type_::n > 1
    )>::type 
for_each(const iterator_type_& iter, const size_type_& size)
{
    typedef size_transformer<plane<0>, size_type_> s_transformer;
    typedef iterator_transformer<plane<0>, iterator_type_, size_type_> i_transformer;

    iterator_type_ it = iter;
    typename s_transformer::size_type new_size;
    typename i_transformer::iterator_type new_it;
    const int n = size.i0;

    s_transformer::transform(size, new_size);

    for (int i=0; i<n; i++) {
        i_transformer::transform(it, new_it);
        for_each(new_it, new_size);
        inc<0>(it);
    }
}

template<typename iterator_type_, typename function_type_, typename size_type_>
LITE_INLINE 
typename detail::enable_if<(
    size_type_::n > 1
    )>::type 
for_each(const iterator_type_& iter, function_type_& func, const size_type_& size)
{
    typedef size_transformer<plane<0>, size_type_> s_transformer;
    typedef iterator_transformer<plane<0>, iterator_type_, size_type_> i_transformer;

    iterator_type_ it = iter;
    typename s_transformer::size_type new_size;
    typename i_transformer::iterator_type new_it;
    const int n = size.i0;

    s_transformer::transform(size, new_size);

    for (int i=0; i<n; i++) {
        i_transformer::transform(it, new_it);
        for_each(new_it, func, new_size);
        inc<0>(it);
    }
}

template<typename iterator_type_, typename size_type_>
LITE_INLINE 
typename detail::enable_if<(
    size_type_::n > 1
    ), bool>::type 
for_each_c(const iterator_type_& iter, const size_type_& size)
{
    typedef size_transformer<plane<0>, size_type_> s_transformer;
    typedef iterator_transformer<plane<0>, iterator_type_, size_type_> i_transformer;

    iterator_type_ it = iter;
    typename s_transformer::size_type new_size;
    typename i_transformer::iterator_type new_it;
    const int n = size.i0;

    s_transformer::transform(size, new_size);

    for (int i=0; i<n; i++) {
        i_transformer::transform(it, new_it);
        if (!for_each_c(new_it, new_size))
            return false;
        inc<0>(it);
    }
    return true;
}


template<typename iterator_type_, typename function_type_, typename size_type_>
LITE_INLINE 
typename detail::enable_if<(
    size_type_::n > 1
    ), bool>::type 
for_each_c(const iterator_type_& iter, function_type_& func, const size_type_& size)
{
    typedef size_transformer<plane<0>, size_type_> s_transformer;
    typedef iterator_transformer<plane<0>, iterator_type_, size_type_> i_transformer;

    iterator_type_ it = iter;
    typename s_transformer::size_type new_size;
    typename i_transformer::iterator_type new_it;
    const int n = size.i0;

    s_transformer::transform(size, new_size);

    for (int i=0; i<n; i++) {
        i_transformer::transform(it, new_it);
        if (!for_each_c(new_it, func, new_size))
            return false;
        inc<0>(it);
    }
    return true;
}

#endif // !DOCUMENTATION_ONLY

/***********************************************************************************************************/
/* for_each ************************************************************************************************/
/***********************************************************************************************************/

/*!
    \brief Evaluates every element of the array \a a.

    \ingroup array_advanced
*/
template<typename signature_, typename traits_type_, typename rep_>
LITE_INLINE void for_each(const array<signature_, traits_type_, rep_>& a)
{
    for_each(a.begin(), a.size());
}

/*!
    \brief Evaluates every element of the array \a a.

    \ingroup array_advanced
*/
template<typename signature_, typename traits_type_, typename rep_>
LITE_INLINE void for_each(array<signature_, traits_type_, rep_>& a)
{
    for_each(a.begin(), a.size());
}

/*!
    \brief 
    Applies the function object \a func to every element of the array \a a.

    \ingroup array_advanced
*/
template<typename signature_, typename traits_type_, typename rep_, typename function_type_>
LITE_INLINE void for_each(const array<signature_, traits_type_, rep_>& a, function_type_& func)
{
    for_each(a.begin(), func, a.size());
}

/*!
    \brief 
    Applies the function object \a func to every element of the array \a a.

    \ingroup array_advanced
*/
template<typename signature_, typename traits_type_, typename rep_, typename function_type_>
LITE_INLINE void for_each(array<signature_, traits_type_, rep_>& a, function_type_& func)
{
    for_each(a.begin(), func, a.size());
}

/*!
    \brief 
    Evaluates every element of the array \a a while the elements evaluate to true. 
    Returns true if all the elements evaluated to true.

    \ingroup array_advanced
*/
template<typename signature_, typename traits_type_, typename rep_>
LITE_INLINE bool for_each_c(const array<signature_, traits_type_, rep_>& a)
{
    return for_each_c(a.begin(), a.size());
}

/*!
    \brief 
    Evaluates every element of the array \a a while the elements evaluate to true. 
    Returns true if all the elements evaluated to true.

    \ingroup array_advanced
*/
template<typename signature_, typename traits_type_, typename rep_>
LITE_INLINE bool for_each_c(array<signature_, traits_type_, rep_>& a)
{
    return for_each_c(a.begin(), a.size());
}

/*!
    \brief 
    Applies the function object \a func to every element of the array \a a while the function object 
    evaluates to true. Returns true if the function object evaluates to true for
    all the elements.
    
    \ingroup array_advanced
*/
template<typename signature_, typename traits_type_, typename rep_, typename function_type_>
LITE_INLINE bool for_each_c(const array<signature_, traits_type_, rep_>& a, function_type_& func)
{
    return for_each_c(a.begin(), func, a.size());
}

/*!
    \brief 
    Applies the function object \a func to every element of the array \a a while the function object 
    evaluates to true. Returns true if the function object evaluates to true for
    all the elements.
    
    \ingroup array_advanced
*/
template<typename signature_, typename traits_type_, typename rep_, typename function_type_>
LITE_INLINE bool for_each_c(array<signature_, traits_type_, rep_>& a, function_type_& func)
{
    return for_each_c(a.begin(), func, a.size());
}

/***********************************************************************************************************/
/* default_array_traits ************************************************************************************/
/***********************************************************************************************************/

/*!
    \brief This is the default array traits type used by the class lite::array.
    \ingroup array_advanced

    See \ref array_traits for more information.
*/
struct default_array_traits
{
    template<typename signature_>
    struct representation_type
    {
        typedef array_signature_traits<signature_> array_details;

        typedef typename detail::type_if<
            (array_details::volume <= 4096 && array_details::is_fixed_size), 
            internal_rep<false>,
            hybrid_rep<false, (array_details::volume <= 64 ? 64 : 1)>
            >::type type;

        typedef typename detail::type_if<
            (array_details::volume <= 4096 && array_details::is_fixed_size), 
            internal_rep<false>,
            hybrid_rep<false, (array_details::volume <= 4096 ? 4096 : 1)>
            >::type temporary_type;

        typedef typename detail::type_if<
            (array_details::volume <= 4096 && array_details::is_fixed_size), 
            internal_rep<false>,
            hybrid_rep<false, (array_details::volume <= 4096 ? 4096 : 1)>
            >::type fwd_temporary_type;

        typedef typename detail::type_if<
            (array_details::volume <= 4096 && array_details::is_fixed_size), 
            internal_rep<true>,
            hybrid_rep<true, (array_details::volume <= 4096 ? 4096 : 1)>
            >::type rev_temporary_type;
    };
};

/***********************************************************************************************************/
/* copy ****************************************************************************************************/
/***********************************************************************************************************/

template<typename signature_, typename traits_type_, typename src_rep_>
LITE_INLINE 
typename array<signature_, traits_type_, src_rep_>::temporary_array
copy(const array<signature_, traits_type_, src_rep_>& src)
{
    return src;
}

/***********************************************************************************************************/
/* volume **************************************************************************************************/
/***********************************************************************************************************/

#ifdef DOCUMENTATION_ONLY

/*!
    \brief Returns the total volume of an array of the size \a sz.
    
    \ingroup array_operations

    \par Example:

    \code
        array<float[1][1][5]> a(10, 10, 5);

        std::cout << volume(a.size()) << std::endl;
    \endcode
    The output would be:
    \verbatim
        500
    \endverbatim
*/
template<typename size_type_>
int volume(const size_type_& sz);

#else // DOCUMENTATION_ONLY

LITE_INLINE int volume(const pack<>&)
{
    return 1;
}

template<
    typename type0_
    >
LITE_INLINE int 
volume(
    const pack<
        type0_
    >& size)
{        
    return size.i0;
    LITE_ARRAY_USE(size);
}

template<
    typename type0_,
    typename type1_
    >
LITE_INLINE int 
volume(
    const pack<
        type0_,
        type1_
    >& size)
{        
    return size.i0*size.i1;
    LITE_ARRAY_USE(size);
}

template<
    typename type0_,
    typename type1_,
    typename type2_
    >
LITE_INLINE int 
volume(
    const pack<
        type0_,
        type1_,
        type2_
    >& size)
{        
    return size.i0*size.i1*size.i2;
    LITE_ARRAY_USE(size);
}



#endif // DOCUMENTATION_ONLY

/***********************************************************************************************************/
/* array ***************************************************************************************************/
/***********************************************************************************************************/

// forward declaration
template<typename type_>
class assign;

// forward declaration
template<typename type_>
class swapper;

#ifdef DOCUMENTATION_ONLY
/*!
    \brief 
    This class represents a general sinlge/multidimensional array with 
    constant/variable size dimensions.

    \ingroup array_class
    The set of specializations of this class provides a unified way of representing and working 
    with sinlge/multidimensional arrays with constant/variable size dimensions.

    For a detailed explanation see \ref array_class .
*/
template<
    typename signature_, 
    typename traits_type_ = default_array_traits, 
    typename rep_ = typename traits_type_::template representation_type<signature_>::type>
class array
{
public:
    typedef signature_ signature; //!< The signature of the array
    typedef traits_type_ traits_type; //!< The type traits
    typedef ... value_type; //!< Type of the elements of the array
    typedef ... iterator; //!< Array iterator type
    typedef ... const_iterator; //!< Array const iterator type
    typedef ... reference; //!< Type of the reference to the elements of the array
    typedef ... const_reference; //!< Type of the const reference to the elements of the array


    /*! 
        \brief 
        A compatible array type with the same signature and traits, suitable for defining temporary
        variables or return types.
    */
    typedef ... temporary_array; 

    /*! 
        \brief 
        A compatible array type with the same signature and traits and forward storage, 
        suitable for defining temporary variables or return types.
    */
    typedef ... fwd_temporary_array; 

    /*! 
        \brief 
        A compatible array type with the same signature and traits and reverse storage, 
        suitable for defining temporary variables or return types.
    */
    typedef ... rev_temporary_array;

    //! A type that is used to represent and store the size of the arrays with the current signature.
    typedef ... size_type;

    //! The number of dimensions of the array.
    static const int dimensions = ...; 

    /*! 
        \brief Indicates whether the array is using reverse storage.
        \remark Available only in primary arrays.
    */
    static const bool is_reverse = ...; 

    /*!
        \brief Default constructs the array. 
        
        All non-constant dimension sizes are set to 0. 
        The content of the array (in cases it has a fixed size and therefore not initially empty) 
        will be left uninitialized unless the elements of the array have a user-defined type that has its own
        default constructor. A reference array will be initialized to a null reference.
    */
    array();

    /*!
        \brief Initializes the array to a copy of the \a other array. 
        \remark In case of a reference array, only the reference is copied. 
    */
    array(const array& other);

    /*!
        \brief 
        Initializes the array to a copy of the \a other array. 
        The other array could have a different representation type.
    
        \remark 
        In case of a reference array, only the reference is copied. 
        The other array could have a different representation type with an iterator type that is 
        convertible to the current reference array's \a iterator_type.
    */
    template<typename other_rep_>
    array(const array<signature_, traits_type_, other_rep_>& other);

    /*!
        \brief Constructs an array with the given dimension sizes.

        All non-constant dimension sizes are set to their corresponding supplied value from \a a0 to \a aN. 
        The arguments corresponding to fixed-size dimensions are ignored. The array is then allocated. 
        The content of the array will be left uninitialized unless the elements of the array have 
        a user-defined type that has its own default constructor.
    */
    explicit array(int n0, ..., int nN);

    /*!
        \brief Constructs an array with the given dimension sizes.

        The array is then allocated. The content of the array will be left uninitialized 
        unless the elements of the array have a user-defined type that has its own default constructor.
    */
    explicit array(const size_type& size);

    /*!
        \brief Constructs an array using the supplied values.

        \remark 
        This constructor is only available for vectors (1D arrays) that use the 
        internal representation (\ref array_internal) 
        and have a fixed size of at most #LITE_ARRAY_MAX_VECTOR_ARGS .

        \par Example 

        \code
            array<double[2]> a(2.3, 4.5);
            array<double[3]> a(2.3, 4.5, 4.6);
            array<double[9]> a(1, 2, ..., 9); // error: more than LITE_ARRAY_MAX_VECTOR_ARGS number of args.
        \endcode
    */
    array(const value_type& a0, ..., const value_type& aT);

    /*!
        \brief 
        Constructs a reference array by passing the \a arg0 to \a argK to the constructor of 
        the iterator which is maintained internally and using the size \a sz .

        \remark 
        This constructor is only available in reference arrays (see \ref array_reference). 
        Also, K should be less than #LITE_ARRAY_MAX_ITERATOR_ARGS. In other words, this constructor can 
        take at most #LITE_ARRAY_MAX_ITERATOR_ARGS arguments to be passed to the 
        constructor of the iterator.
        This constructor is used internally by almost all array operations that return a reference array.
    */
    template<typename arg_type0_, ..., typename arg_typeK_>
    array(const arg_type0_& arg0, ..., const arg_typeK_& argK, const size_type& sz);

    /*!
        \brief 
        Constructs a reference array by applying the transform \a trans to the iterator \a it 
        and size object \a sz.

        \remark 
        This constructor is only available in reference arrays (see \ref array_reference) and 
        is used internally by \c operator[] of array classes to construct  
        a reference array to be returned as the result of applying a transform.
    */
    template<typename other_iterator_type_, typename other_size_type_, typename transform_type_>
    array(
        const other_iterator_type_& it, 
        const other_size_type_& sz, 
        const transform_type_& trans);


    /*!
        \brief Copies the \a other array to the current array, possibly resizing the current array.
        
        \remark 
        Reference arrays will not be resized therefore their size should exactly match the size 
        of the \a other array.
    */
    array& operator=(const array& other);

    /*!
        \brief 
        Copies the \a other array to the current array, possibly resizing the current array.
        The other array could have a different representation type.

        \remark 
        Reference arrays will not be resized therefore their size should exactly match the size 
        of the \a other array.
    */
    template<typename other_rep_>
    array& operator=(const array<signature_, traits_type_, other_rep_>& other);

    //! Returns a const iterator pointing to the start of the array.
    const_iterator begin() const;

    //! Returns a const iterator pointing to the start of the array.
    iterator begin();

    //! Returns a size object containing the dimension sizes of the array.
    size_type size() const;

    //! Returns a const reference to the element of the array at the specified position.
    const_reference operator()(int i0, ..., int iN) const;

    //! Returns a reference to the element of the array at the specified position.
    reference operator()(int i0, ..., int iN);

    /*! 
        \brief Returns a const reference to the element of the 1D array at the specified index.

        \remark This operator is only available in vectors (1D arrays).
    */
    const_reference operator[](int i0) const;

    /*! 
        \brief Returns a reference to the element of the 1D array at the specified index.

        \remark This operator is only available in vectors (1D arrays).
    */
    reference operator[](int i0);

    /*! 
        \brief Applies the transform \a trans to the current array and returns the resulting array.

        \remark 
        All the standard pre-defined transforms return a reference array as their result however this is
        not required for user-defined transforms.
    */
    template<typename transform_type_>
    const typename transform_traits<array, transform_type_>::const_array
    operator[](const transform_type_& trans) const;

    /*! 
        \brief Applies the transform \a trans to the current array and returns the resulting array.

        \remark 
        All the standard pre-defined transforms return a reference array as their result however this is
        not required for user-defined transforms.
    */
    template<typename transform_type_>
    const typename transform_traits<array, transform_type_>::array
    operator[](const transform_type_& trans);

    /*! 
        \brief Returns a const pointer to the beginning of the array storage.

        \remark 
        This function is available in arrays with internal (see \ref array_internal) and 
        hybrid (see \ref array_hybrid) representation and is not required for user-defined 
        array representations.
        It is not available in reference arrays (see \ref array_reference).
    */
    const value_type* data() const;

    /*! 
        \brief Returns a pointer to the beginning of the array storage.

        \remark 
        This function is available in arrays with internal (see \ref array_internal) and 
        hybrid (see \ref array_hybrid) representation and is not required for user-defined array 
        representations.
        It is not available in reference arrays (see \ref array_reference).
    */
    value_type* data();

    /*!
        \brief Resizes the array dimensions to the specified sizes. 
        
        The arguments corresponding to fixed-size dimensions are ignored. 

        \remark 
        When you resize an array, the old content of the array will be lost and the new array elements 
        might be uninitialized.

        \remark 
        This function is available only in primary arrays. 
        It is not available in reference arrays (see \ref array_reference). 
        This function does nothing for arrays with internal representations (see \ref array_internal).
        See \ref array_hybrid for more details about what this function does for hybrid representations.
    */
    void resize(int n0, ..., int nN);

    /*!
        \brief Resizes the array dimensions to the specified sizes. 
        
        \remark 
        When you resize an array, the old content of the array will be lost and the new array elements 
        might be uninitialized.

        \remark 
        This function is available only in primary arrays. 
        It is not available in reference arrays (see \ref array_reference). 
        This function does nothing for arrays with internal representations (see \ref array_internal).
        See \ref array_hybrid for more details about what this function does for hybrid representations.
    */
    void resize(const size_type& sz);

    /*!
        \brief Releases the memory allocated for the array and set the size to 0. 
        
        \remark 
        This function is available only in primary arrays. Furthermore, this function 
        does nothing for arrays with internal representations (see \ref array_internal).
        See \ref array_hybrid for more details about what this function does for hybrid representations.
    */
    void release();
};

#endif // DOCUMENTATION_ONLY

/***********************************************************************************************************/
/* array, reference_rep ************************************************************************************/
/***********************************************************************************************************/

/*!
    \brief This is a tag type that can be used to specify reference representation for an array.
    
    \ingroup array_advanced

    See \ref array_reference.
*/
template<typename iterator_type_>
class reference_rep {};


template<
    typename value_type_,
    typename traits_type_,
    typename iterator_
    >
class array<
    value_type_,
    traits_type_,
    reference_rep<iterator_>
    >
{
public:
    typedef value_type_ signature;
    typedef traits_type_ traits_type;
    typedef value_type_ value_type;
    typedef iterator_ iterator;
    typedef iterator_ const_iterator;
    typedef typename std::iterator_traits<iterator>::reference reference;
    typedef reference const_reference;

    typedef typename array_helper<signature, traits_type_>::temporary_array temporary_array;
    typedef typename array_helper<signature, traits_type_>::fwd_temporary_array fwd_temporary_array;
    typedef typename array_helper<signature, traits_type_>::rev_temporary_array rev_temporary_array;

    typedef typename array_signature_traits<signature>::size_type size_type;

    static const int dimensions = 0;

    LITE_INLINE array(const array& other) 
        : m_iterator(other.m_iterator), m_size(other.m_size)
    {}

    template<typename other_rep_>
    LITE_INLINE array(const array<signature, traits_type_, other_rep_>& other) 
        : m_iterator(other.begin()), m_size(other.size())
    {}

    template<typename other_rep_>
    LITE_INLINE array(array<signature, traits_type_, other_rep_>& other) 
        : m_iterator(other.begin()), m_size(other.size())
    {}

    template<
        typename arg_type0_    
        >
    LITE_INLINE array(
        const arg_type0_& arg0,
        const size_type& sz)
        : m_iterator(arg0),
          m_size(sz)
    {}

    template<
        typename arg_type0_,    
        typename arg_type1_    
        >
    LITE_INLINE array(
        const arg_type0_& arg0,
        const arg_type1_& arg1,
        const size_type& sz)
        : m_iterator(arg0, arg1),
          m_size(sz)
    {}

    template<
        typename arg_type0_,    
        typename arg_type1_,    
        typename arg_type2_    
        >
    LITE_INLINE array(
        const arg_type0_& arg0,
        const arg_type1_& arg1,
        const arg_type2_& arg2,
        const size_type& sz)
        : m_iterator(arg0, arg1, arg2),
          m_size(sz)
    {}


    template<typename other_iterator_type_, typename other_size_type_, typename transform_type_>
    LITE_INLINE array(
        const other_iterator_type_& it, 
        const other_size_type_& sz, 
        const transform_type_& trans)
    {
        iterator_transformer<transform_type_, other_iterator_type_, other_size_type_>
            ::transform(trans, it, sz, m_iterator);

        size_transformer<transform_type_, other_size_type_>
            ::transform(trans, sz, m_size);
    }

    LITE_INLINE const array& operator=(const array& other) const
    {
        typedef b_iterator<iterator, iterator, assign<value_type> > iterator_type;

        LITE_ARRAY_SIZE_CHECK(m_size, other.m_size, "operator=(): array sizes do not match");

        for_each(iterator_type(m_iterator, other.m_iterator), m_size);
        return *this;
    }

    template<typename other_rep_>
    LITE_INLINE const array& operator=(const array<signature, traits_type_, other_rep_>& other) const
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            assign<value_type> > 
            iterator_type;

        LITE_ARRAY_SIZE_CHECK(m_size, other.size(), "operator=(): array sizes do not match");

        for_each(iterator_type(m_iterator, other.begin()), m_size);
        return *this;
    }

    LITE_INLINE const array& operator=(const value_type& value) const
    {
        typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;

        for_each(iterator_type(m_iterator, value), m_size);
        return *this;
    }

    LITE_INLINE const iterator& begin() const
    {
        return m_iterator;
    }

    LITE_INLINE const size_type& size() const
    {
        return m_size;
    }

    LITE_INLINE reference 
    operator()() const
    {
        return at(m_iterator);
    }

    template<typename transform_type_>
    LITE_INLINE const typename transform_traits<array, transform_type_>::array
    operator[](const transform_type_& trans) const
    {
        typedef typename transform_traits<array, transform_type_>::array result_type;

        return result_type(m_iterator, m_size, trans);
    }

    template<typename other_rep_>
    LITE_INLINE void swap(const array<signature, traits_type_, other_rep_>& other) const
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            swapper<value_type> > 
            iterator_type;

        LITE_ARRAY_SIZE_CHECK(m_size, other.size(), "swap(): array sizes do not match");

        for_each(iterator_type(m_iterator, other.begin()), m_size);
    }

    template<typename other_rep_>
    LITE_INLINE void swap(array<signature, traits_type_, other_rep_>& other) const
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::iterator, 
            swapper<value_type> > 
            iterator_type;

        LITE_ARRAY_SIZE_CHECK(m_size, other.size(), "swap(): array sizes do not match");

        for_each(iterator_type(m_iterator, other.begin()), m_size);
    }

private:
    iterator m_iterator;
    size_type m_size;
};

/***********************************************************************************************************/

template<
    typename value_type_,
    int n0_, 
    typename traits_type_,
    typename iterator_
    >
class array<
    value_type_[n0_],
    traits_type_,
    reference_rep<iterator_>
    >
{
public:
    typedef value_type_ signature[n0_];
    typedef traits_type_ traits_type;
    typedef value_type_ value_type;
    typedef iterator_ iterator;
    typedef iterator_ const_iterator;
    typedef typename std::iterator_traits<iterator>::reference reference;
    typedef reference const_reference;

    typedef typename array_helper<signature, traits_type_>::temporary_array temporary_array;
    typedef typename array_helper<signature, traits_type_>::fwd_temporary_array fwd_temporary_array;
    typedef typename array_helper<signature, traits_type_>::rev_temporary_array rev_temporary_array;

    typedef typename array_signature_traits<signature>::size_type size_type;

    static const int dimensions = 1;

    LITE_INLINE array(const array& other) 
        : m_iterator(other.m_iterator), m_size(other.m_size)
    {}

    template<typename other_rep_>
    LITE_INLINE array(const array<signature, traits_type_, other_rep_>& other) 
        : m_iterator(other.begin()), m_size(other.size())
    {}

    template<typename other_rep_>
    LITE_INLINE array(array<signature, traits_type_, other_rep_>& other) 
        : m_iterator(other.begin()), m_size(other.size())
    {}

    template<
        typename arg_type0_    
        >
    LITE_INLINE array(
        const arg_type0_& arg0,
        const size_type& sz)
        : m_iterator(arg0),
          m_size(sz)
    {}

    template<
        typename arg_type0_,    
        typename arg_type1_    
        >
    LITE_INLINE array(
        const arg_type0_& arg0,
        const arg_type1_& arg1,
        const size_type& sz)
        : m_iterator(arg0, arg1),
          m_size(sz)
    {}

    template<
        typename arg_type0_,    
        typename arg_type1_,    
        typename arg_type2_    
        >
    LITE_INLINE array(
        const arg_type0_& arg0,
        const arg_type1_& arg1,
        const arg_type2_& arg2,
        const size_type& sz)
        : m_iterator(arg0, arg1, arg2),
          m_size(sz)
    {}


    template<typename other_iterator_type_, typename other_size_type_, typename transform_type_>
    LITE_INLINE array(
        const other_iterator_type_& it, 
        const other_size_type_& sz, 
        const transform_type_& trans)
    {
        iterator_transformer<transform_type_, other_iterator_type_, other_size_type_>
            ::transform(trans, it, sz, m_iterator);

        size_transformer<transform_type_, other_size_type_>
            ::transform(trans, sz, m_size);
    }

    LITE_INLINE const array& operator=(const array& other) const
    {
        typedef b_iterator<iterator, iterator, assign<value_type> > iterator_type;

        LITE_ARRAY_SIZE_CHECK(m_size, other.m_size, "operator=(): array sizes do not match");

        for_each(iterator_type(m_iterator, other.m_iterator), m_size);
        return *this;
    }

    template<typename other_rep_>
    LITE_INLINE const array& operator=(const array<signature, traits_type_, other_rep_>& other) const
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            assign<value_type> > 
            iterator_type;

        LITE_ARRAY_SIZE_CHECK(m_size, other.size(), "operator=(): array sizes do not match");

        for_each(iterator_type(m_iterator, other.begin()), m_size);
        return *this;
    }

    LITE_INLINE const array& operator=(const value_type& value) const
    {
        typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;

        for_each(iterator_type(m_iterator, value), m_size);
        return *this;
    }

    LITE_INLINE const iterator& begin() const
    {
        return m_iterator;
    }

    LITE_INLINE const size_type& size() const
    {
        return m_size;
    }

    LITE_INLINE reference 
    operator()(int i0) const
    {
        return at(m_iterator, i0);
    }

    LITE_INLINE reference 
    operator[](int i0) const
    {
        return at(m_iterator, i0);
    }

    template<typename transform_type_>
    LITE_INLINE const typename transform_traits<array, transform_type_>::array
    operator[](const transform_type_& trans) const
    {
        typedef typename transform_traits<array, transform_type_>::array result_type;

        return result_type(m_iterator, m_size, trans);
    }

    template<typename other_rep_>
    LITE_INLINE void swap(const array<signature, traits_type_, other_rep_>& other) const
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            swapper<value_type> > 
            iterator_type;

        LITE_ARRAY_SIZE_CHECK(m_size, other.size(), "swap(): array sizes do not match");

        for_each(iterator_type(m_iterator, other.begin()), m_size);
    }

    template<typename other_rep_>
    LITE_INLINE void swap(array<signature, traits_type_, other_rep_>& other) const
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::iterator, 
            swapper<value_type> > 
            iterator_type;

        LITE_ARRAY_SIZE_CHECK(m_size, other.size(), "swap(): array sizes do not match");

        for_each(iterator_type(m_iterator, other.begin()), m_size);
    }

private:
    iterator m_iterator;
    size_type m_size;
};

/***********************************************************************************************************/

template<
    typename value_type_,
    int n0_, 
    int n1_, 
    typename traits_type_,
    typename iterator_
    >
class array<
    value_type_[n0_][n1_],
    traits_type_,
    reference_rep<iterator_>
    >
{
public:
    typedef value_type_ signature[n0_][n1_];
    typedef traits_type_ traits_type;
    typedef value_type_ value_type;
    typedef iterator_ iterator;
    typedef iterator_ const_iterator;
    typedef typename std::iterator_traits<iterator>::reference reference;
    typedef reference const_reference;

    typedef typename array_helper<signature, traits_type_>::temporary_array temporary_array;
    typedef typename array_helper<signature, traits_type_>::fwd_temporary_array fwd_temporary_array;
    typedef typename array_helper<signature, traits_type_>::rev_temporary_array rev_temporary_array;

    typedef typename array_signature_traits<signature>::size_type size_type;

    static const int dimensions = 2;

    LITE_INLINE array(const array& other) 
        : m_iterator(other.m_iterator), m_size(other.m_size)
    {}

    template<typename other_rep_>
    LITE_INLINE array(const array<signature, traits_type_, other_rep_>& other) 
        : m_iterator(other.begin()), m_size(other.size())
    {}

    template<typename other_rep_>
    LITE_INLINE array(array<signature, traits_type_, other_rep_>& other) 
        : m_iterator(other.begin()), m_size(other.size())
    {}

    template<
        typename arg_type0_    
        >
    LITE_INLINE array(
        const arg_type0_& arg0,
        const size_type& sz)
        : m_iterator(arg0),
          m_size(sz)
    {}

    template<
        typename arg_type0_,    
        typename arg_type1_    
        >
    LITE_INLINE array(
        const arg_type0_& arg0,
        const arg_type1_& arg1,
        const size_type& sz)
        : m_iterator(arg0, arg1),
          m_size(sz)
    {}

    template<
        typename arg_type0_,    
        typename arg_type1_,    
        typename arg_type2_    
        >
    LITE_INLINE array(
        const arg_type0_& arg0,
        const arg_type1_& arg1,
        const arg_type2_& arg2,
        const size_type& sz)
        : m_iterator(arg0, arg1, arg2),
          m_size(sz)
    {}


    template<typename other_iterator_type_, typename other_size_type_, typename transform_type_>
    LITE_INLINE array(
        const other_iterator_type_& it, 
        const other_size_type_& sz, 
        const transform_type_& trans)
    {
        iterator_transformer<transform_type_, other_iterator_type_, other_size_type_>
            ::transform(trans, it, sz, m_iterator);

        size_transformer<transform_type_, other_size_type_>
            ::transform(trans, sz, m_size);
    }

    LITE_INLINE const array& operator=(const array& other) const
    {
        typedef b_iterator<iterator, iterator, assign<value_type> > iterator_type;

        LITE_ARRAY_SIZE_CHECK(m_size, other.m_size, "operator=(): array sizes do not match");

        for_each(iterator_type(m_iterator, other.m_iterator), m_size);
        return *this;
    }

    template<typename other_rep_>
    LITE_INLINE const array& operator=(const array<signature, traits_type_, other_rep_>& other) const
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            assign<value_type> > 
            iterator_type;

        LITE_ARRAY_SIZE_CHECK(m_size, other.size(), "operator=(): array sizes do not match");

        for_each(iterator_type(m_iterator, other.begin()), m_size);
        return *this;
    }

    LITE_INLINE const array& operator=(const value_type& value) const
    {
        typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;

        for_each(iterator_type(m_iterator, value), m_size);
        return *this;
    }

    LITE_INLINE const iterator& begin() const
    {
        return m_iterator;
    }

    LITE_INLINE const size_type& size() const
    {
        return m_size;
    }

    LITE_INLINE reference 
    operator()(int i0, int i1) const
    {
        return at(m_iterator, i0, i1);
    }

    template<typename transform_type_>
    LITE_INLINE const typename transform_traits<array, transform_type_>::array
    operator[](const transform_type_& trans) const
    {
        typedef typename transform_traits<array, transform_type_>::array result_type;

        return result_type(m_iterator, m_size, trans);
    }

    template<typename other_rep_>
    LITE_INLINE void swap(const array<signature, traits_type_, other_rep_>& other) const
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            swapper<value_type> > 
            iterator_type;

        LITE_ARRAY_SIZE_CHECK(m_size, other.size(), "swap(): array sizes do not match");

        for_each(iterator_type(m_iterator, other.begin()), m_size);
    }

    template<typename other_rep_>
    LITE_INLINE void swap(array<signature, traits_type_, other_rep_>& other) const
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::iterator, 
            swapper<value_type> > 
            iterator_type;

        LITE_ARRAY_SIZE_CHECK(m_size, other.size(), "swap(): array sizes do not match");

        for_each(iterator_type(m_iterator, other.begin()), m_size);
    }

private:
    iterator m_iterator;
    size_type m_size;
};

/***********************************************************************************************************/

template<
    typename value_type_,
    int n0_, 
    int n1_, 
    int n2_, 
    typename traits_type_,
    typename iterator_
    >
class array<
    value_type_[n0_][n1_][n2_],
    traits_type_,
    reference_rep<iterator_>
    >
{
public:
    typedef value_type_ signature[n0_][n1_][n2_];
    typedef traits_type_ traits_type;
    typedef value_type_ value_type;
    typedef iterator_ iterator;
    typedef iterator_ const_iterator;
    typedef typename std::iterator_traits<iterator>::reference reference;
    typedef reference const_reference;

    typedef typename array_helper<signature, traits_type_>::temporary_array temporary_array;
    typedef typename array_helper<signature, traits_type_>::fwd_temporary_array fwd_temporary_array;
    typedef typename array_helper<signature, traits_type_>::rev_temporary_array rev_temporary_array;

    typedef typename array_signature_traits<signature>::size_type size_type;

    static const int dimensions = 3;

    LITE_INLINE array(const array& other) 
        : m_iterator(other.m_iterator), m_size(other.m_size)
    {}

    template<typename other_rep_>
    LITE_INLINE array(const array<signature, traits_type_, other_rep_>& other) 
        : m_iterator(other.begin()), m_size(other.size())
    {}

    template<typename other_rep_>
    LITE_INLINE array(array<signature, traits_type_, other_rep_>& other) 
        : m_iterator(other.begin()), m_size(other.size())
    {}

    template<
        typename arg_type0_    
        >
    LITE_INLINE array(
        const arg_type0_& arg0,
        const size_type& sz)
        : m_iterator(arg0),
          m_size(sz)
    {}

    template<
        typename arg_type0_,    
        typename arg_type1_    
        >
    LITE_INLINE array(
        const arg_type0_& arg0,
        const arg_type1_& arg1,
        const size_type& sz)
        : m_iterator(arg0, arg1),
          m_size(sz)
    {}

    template<
        typename arg_type0_,    
        typename arg_type1_,    
        typename arg_type2_    
        >
    LITE_INLINE array(
        const arg_type0_& arg0,
        const arg_type1_& arg1,
        const arg_type2_& arg2,
        const size_type& sz)
        : m_iterator(arg0, arg1, arg2),
          m_size(sz)
    {}


    template<typename other_iterator_type_, typename other_size_type_, typename transform_type_>
    LITE_INLINE array(
        const other_iterator_type_& it, 
        const other_size_type_& sz, 
        const transform_type_& trans)
    {
        iterator_transformer<transform_type_, other_iterator_type_, other_size_type_>
            ::transform(trans, it, sz, m_iterator);

        size_transformer<transform_type_, other_size_type_>
            ::transform(trans, sz, m_size);
    }

    LITE_INLINE const array& operator=(const array& other) const
    {
        typedef b_iterator<iterator, iterator, assign<value_type> > iterator_type;

        LITE_ARRAY_SIZE_CHECK(m_size, other.m_size, "operator=(): array sizes do not match");

        for_each(iterator_type(m_iterator, other.m_iterator), m_size);
        return *this;
    }

    template<typename other_rep_>
    LITE_INLINE const array& operator=(const array<signature, traits_type_, other_rep_>& other) const
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            assign<value_type> > 
            iterator_type;

        LITE_ARRAY_SIZE_CHECK(m_size, other.size(), "operator=(): array sizes do not match");

        for_each(iterator_type(m_iterator, other.begin()), m_size);
        return *this;
    }

    LITE_INLINE const array& operator=(const value_type& value) const
    {
        typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;

        for_each(iterator_type(m_iterator, value), m_size);
        return *this;
    }

    LITE_INLINE const iterator& begin() const
    {
        return m_iterator;
    }

    LITE_INLINE const size_type& size() const
    {
        return m_size;
    }

    LITE_INLINE reference 
    operator()(int i0, int i1, int i2) const
    {
        return at(m_iterator, i0, i1, i2);
    }

    template<typename transform_type_>
    LITE_INLINE const typename transform_traits<array, transform_type_>::array
    operator[](const transform_type_& trans) const
    {
        typedef typename transform_traits<array, transform_type_>::array result_type;

        return result_type(m_iterator, m_size, trans);
    }

    template<typename other_rep_>
    LITE_INLINE void swap(const array<signature, traits_type_, other_rep_>& other) const
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            swapper<value_type> > 
            iterator_type;

        LITE_ARRAY_SIZE_CHECK(m_size, other.size(), "swap(): array sizes do not match");

        for_each(iterator_type(m_iterator, other.begin()), m_size);
    }

    template<typename other_rep_>
    LITE_INLINE void swap(array<signature, traits_type_, other_rep_>& other) const
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::iterator, 
            swapper<value_type> > 
            iterator_type;

        LITE_ARRAY_SIZE_CHECK(m_size, other.size(), "swap(): array sizes do not match");

        for_each(iterator_type(m_iterator, other.begin()), m_size);
    }

private:
    iterator m_iterator;
    size_type m_size;
};

/***********************************************************************************************************/


/***********************************************************************************************************/
/* array, internal_rep *************************************************************************************/
/***********************************************************************************************************/

/*!
    \brief This is a tag type that can be used to specify internal representation for an array.
    
    \ingroup array_advanced

    See \ref array_internal.
*/
template<bool reversed_>
class internal_rep {};

// forward declaration
template<typename type_>
class swapper;

template<
    typename value_type_,
    typename traits_type_
    >
class array<
    value_type_,
    traits_type_,
    internal_rep<false>
    >
{
public:
    typedef value_type_ signature;
    typedef traits_type_ traits_type;
    typedef value_type_ value_type;
    typedef const value_type_& const_reference;
    typedef value_type_& reference;

    typedef typename array_signature_traits<const signature>::default_iterator const_iterator;
    typedef typename array_signature_traits<signature>::default_iterator iterator;
    typedef typename array_signature_traits<signature>::size_type size_type;

    typedef typename array_helper<signature, traits_type_>::temporary_array temporary_array;
    typedef typename array_helper<signature, traits_type_>::fwd_temporary_array fwd_temporary_array;
    typedef typename array_helper<signature, traits_type_>::rev_temporary_array rev_temporary_array;

    static const bool is_reverse = false;
    static const int dimensions = 0;

    LITE_INLINE array() 
    {}


    explicit LITE_INLINE array(const size_type&)
    {}

    LITE_INLINE array(const array& other) 
    {
        typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;

        for_each(iterator_type(
            &m_data, 
            &other.m_data), 
            size_type());
    }

    template<typename other_rep_>
    LITE_INLINE array(const array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            assign<value_type> > 
            iterator_type;

        LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), "array(): array sizes do not match");

        for_each(iterator_type(&m_data, other.begin()), size_type());
    }

    LITE_INLINE array(const value_type& value) 
    {
        typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;

        for_each(iterator_type(&m_data, value), size_type());
    }


    LITE_INLINE array& operator=(const array& other) 
    {
        typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;

        for_each(iterator_type(
            &m_data, 
            &other.m_data), 
            size_type());
        return *this;
    }

    template<typename other_rep_>
    LITE_INLINE array& operator=(const array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            assign<value_type> > 
            iterator_type;

        LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), "array(): array sizes do not match");

        for_each(iterator_type(&m_data, other.begin()), size_type());
        return *this;
    }

    LITE_INLINE array& operator=(const value_type& value)
    {
        typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;

        for_each(iterator_type(&m_data, value), size_type());
        return *this;
    }

    LITE_INLINE const_iterator begin() const
    {
        return const_iterator(&m_data);
    }

    LITE_INLINE iterator begin()
    {
        return iterator(&m_data);
    }

    LITE_INLINE size_type size() const
    {
        return size_type();
    }

    LITE_INLINE const_reference 
    operator()() const
    {
        return m_data;
    }

    LITE_INLINE reference 
    operator()() 
    {
        return m_data;
    }


    template<typename transform_type_>
    LITE_INLINE const typename transform_traits<array, transform_type_>::const_array
    operator[](const transform_type_& trans) const
    {
        typedef typename transform_traits<array, transform_type_>::const_array result_type;

        return result_type(begin(), size(), trans);
    }

    template<typename transform_type_>
    LITE_INLINE const typename transform_traits<array, transform_type_>::array
    operator[](const transform_type_& trans)
    {
        typedef typename transform_traits<array, transform_type_>::array result_type;

        return result_type(begin(), size(), trans);
    }

    LITE_INLINE const value_type* data() const
    {
        return &m_data;
    }

    LITE_INLINE value_type* data()
    {
        return &m_data;
    }

    LITE_INLINE void release() 
    {}

    LITE_INLINE void resize()
    {}

    LITE_INLINE void resize(const size_type&)
    {}

    template<typename other_rep_>
    LITE_INLINE void swap(const array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            swapper<value_type> > 
            iterator_type;

        for_each(iterator_type(&m_data, other.begin()), size_type());
    }

    template<typename other_rep_>
    LITE_INLINE void swap(array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::iterator, 
            swapper<value_type> > 
            iterator_type;

        for_each(iterator_type(&m_data, other.begin()), size_type());
    }

private:
    value_type m_data;
};

/***********************************************************************************************************/

template<
    typename value_type_,
    int n0_, 
    typename traits_type_
    >
class array<
    value_type_[n0_],
    traits_type_,
    internal_rep<false>
    >
{
public:
    typedef value_type_ signature[n0_];
    typedef traits_type_ traits_type;
    typedef value_type_ value_type;
    typedef const value_type_& const_reference;
    typedef value_type_& reference;

    typedef typename array_signature_traits<const signature>::default_iterator const_iterator;
    typedef typename array_signature_traits<signature>::default_iterator iterator;
    typedef typename array_signature_traits<signature>::size_type size_type;

    typedef typename array_helper<signature, traits_type_>::temporary_array temporary_array;
    typedef typename array_helper<signature, traits_type_>::fwd_temporary_array fwd_temporary_array;
    typedef typename array_helper<signature, traits_type_>::rev_temporary_array rev_temporary_array;

    static const bool is_reverse = false;
    static const int dimensions = 1;

    LITE_INLINE array() 
    {}

    explicit LITE_INLINE array(int)
    {}

    explicit LITE_INLINE array(const size_type&)
    {}

    LITE_INLINE array(const array& other) 
    {
        typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;

        for_each(iterator_type(
            &m_data[0], 
            &other.m_data[0]), 
            size_type());
    }

    template<typename other_rep_>
    LITE_INLINE array(const array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            assign<value_type> > 
            iterator_type;

        LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), "array(): array sizes do not match");

        for_each(iterator_type(&m_data[0], other.begin()), size_type());
    }

    LITE_INLINE array(const value_type& value) 
    {
        typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;

        for_each(iterator_type(&m_data[0], value), size_type());
    }


    LITE_INLINE array(
        typename detail::type_if<n0_==2, const value_type&, detail::invalid_argument>::type a0,
        const value_type& a1 
        )
    {
        m_data[0] = a0;
        m_data[1] = a1;
    }

    LITE_INLINE array(
        typename detail::type_if<n0_==3, const value_type&, detail::invalid_argument>::type a0,
        const value_type& a1, 
        const value_type& a2 
        )
    {
        m_data[0] = a0;
        m_data[1] = a1;
        m_data[2] = a2;
    }

    LITE_INLINE array(
        typename detail::type_if<n0_==4, const value_type&, detail::invalid_argument>::type a0,
        const value_type& a1, 
        const value_type& a2, 
        const value_type& a3 
        )
    {
        m_data[0] = a0;
        m_data[1] = a1;
        m_data[2] = a2;
        m_data[3] = a3;
    }

    LITE_INLINE array(
        typename detail::type_if<n0_==5, const value_type&, detail::invalid_argument>::type a0,
        const value_type& a1, 
        const value_type& a2, 
        const value_type& a3, 
        const value_type& a4 
        )
    {
        m_data[0] = a0;
        m_data[1] = a1;
        m_data[2] = a2;
        m_data[3] = a3;
        m_data[4] = a4;
    }

    LITE_INLINE array& operator=(const array& other) 
    {
        typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;

        for_each(iterator_type(
            &m_data[0], 
            &other.m_data[0]), 
            size_type());
        return *this;
    }

    template<typename other_rep_>
    LITE_INLINE array& operator=(const array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            assign<value_type> > 
            iterator_type;

        LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), "array(): array sizes do not match");

        for_each(iterator_type(&m_data[0], other.begin()), size_type());
        return *this;
    }

    LITE_INLINE array& operator=(const value_type& value)
    {
        typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;

        for_each(iterator_type(&m_data[0], value), size_type());
        return *this;
    }

    LITE_INLINE const_iterator begin() const
    {
        return const_iterator(&m_data[0]);
    }

    LITE_INLINE iterator begin()
    {
        return iterator(&m_data[0]);
    }

    LITE_INLINE size_type size() const
    {
        return size_type();
    }

    LITE_INLINE const_reference 
    operator()(int i0) const
    {
        return m_data[i0];
    }

    LITE_INLINE reference 
    operator()(int i0) 
    {
        return m_data[i0];
    }

    LITE_INLINE const_reference 
    operator[](int i0) const
    {
        return m_data[i0];
    }

    LITE_INLINE reference 
    operator[](int i0)
    {
        return m_data[i0];
    }


    template<typename transform_type_>
    LITE_INLINE const typename transform_traits<array, transform_type_>::const_array
    operator[](const transform_type_& trans) const
    {
        typedef typename transform_traits<array, transform_type_>::const_array result_type;

        return result_type(begin(), size(), trans);
    }

    template<typename transform_type_>
    LITE_INLINE const typename transform_traits<array, transform_type_>::array
    operator[](const transform_type_& trans)
    {
        typedef typename transform_traits<array, transform_type_>::array result_type;

        return result_type(begin(), size(), trans);
    }

    LITE_INLINE const value_type* data() const
    {
        return &m_data[0];
    }

    LITE_INLINE value_type* data()
    {
        return &m_data[0];
    }

    LITE_INLINE void release() 
    {}

    LITE_INLINE void resize(int)
    {}

    LITE_INLINE void resize(const size_type&)
    {}

    template<typename other_rep_>
    LITE_INLINE void swap(const array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            swapper<value_type> > 
            iterator_type;

        for_each(iterator_type(&m_data[0], other.begin()), size_type());
    }

    template<typename other_rep_>
    LITE_INLINE void swap(array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::iterator, 
            swapper<value_type> > 
            iterator_type;

        for_each(iterator_type(&m_data[0], other.begin()), size_type());
    }

private:
    value_type m_data[n0_];
};

/***********************************************************************************************************/

template<
    typename value_type_,
    int n0_, 
    int n1_, 
    typename traits_type_
    >
class array<
    value_type_[n0_][n1_],
    traits_type_,
    internal_rep<false>
    >
{
public:
    typedef value_type_ signature[n0_][n1_];
    typedef traits_type_ traits_type;
    typedef value_type_ value_type;
    typedef const value_type_& const_reference;
    typedef value_type_& reference;

    typedef typename array_signature_traits<const signature>::default_iterator const_iterator;
    typedef typename array_signature_traits<signature>::default_iterator iterator;
    typedef typename array_signature_traits<signature>::size_type size_type;

    typedef typename array_helper<signature, traits_type_>::temporary_array temporary_array;
    typedef typename array_helper<signature, traits_type_>::fwd_temporary_array fwd_temporary_array;
    typedef typename array_helper<signature, traits_type_>::rev_temporary_array rev_temporary_array;

    static const bool is_reverse = false;
    static const int dimensions = 2;

    LITE_INLINE array() 
    {}

    explicit LITE_INLINE array(int, int)
    {}

    explicit LITE_INLINE array(const size_type&)
    {}

    LITE_INLINE array(const array& other) 
    {
        typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;

        for_each(iterator_type(
            &m_data[0][0], 
            &other.m_data[0][0]), 
            size_type());
    }

    template<typename other_rep_>
    LITE_INLINE array(const array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            assign<value_type> > 
            iterator_type;

        LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), "array(): array sizes do not match");

        for_each(iterator_type(&m_data[0][0], other.begin()), size_type());
    }

    LITE_INLINE array(const value_type& value) 
    {
        typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;

        for_each(iterator_type(&m_data[0][0], value), size_type());
    }


    LITE_INLINE array& operator=(const array& other) 
    {
        typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;

        for_each(iterator_type(
            &m_data[0][0], 
            &other.m_data[0][0]), 
            size_type());
        return *this;
    }

    template<typename other_rep_>
    LITE_INLINE array& operator=(const array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            assign<value_type> > 
            iterator_type;

        LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), "array(): array sizes do not match");

        for_each(iterator_type(&m_data[0][0], other.begin()), size_type());
        return *this;
    }

    LITE_INLINE array& operator=(const value_type& value)
    {
        typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;

        for_each(iterator_type(&m_data[0][0], value), size_type());
        return *this;
    }

    LITE_INLINE const_iterator begin() const
    {
        return const_iterator(&m_data[0][0]);
    }

    LITE_INLINE iterator begin()
    {
        return iterator(&m_data[0][0]);
    }

    LITE_INLINE size_type size() const
    {
        return size_type();
    }

    LITE_INLINE const_reference 
    operator()(int i0, int i1) const
    {
        return m_data[i0][i1];
    }

    LITE_INLINE reference 
    operator()(int i0, int i1) 
    {
        return m_data[i0][i1];
    }


    template<typename transform_type_>
    LITE_INLINE const typename transform_traits<array, transform_type_>::const_array
    operator[](const transform_type_& trans) const
    {
        typedef typename transform_traits<array, transform_type_>::const_array result_type;

        return result_type(begin(), size(), trans);
    }

    template<typename transform_type_>
    LITE_INLINE const typename transform_traits<array, transform_type_>::array
    operator[](const transform_type_& trans)
    {
        typedef typename transform_traits<array, transform_type_>::array result_type;

        return result_type(begin(), size(), trans);
    }

    LITE_INLINE const value_type* data() const
    {
        return &m_data[0][0];
    }

    LITE_INLINE value_type* data()
    {
        return &m_data[0][0];
    }

    LITE_INLINE void release() 
    {}

    LITE_INLINE void resize(int, int)
    {}

    LITE_INLINE void resize(const size_type&)
    {}

    template<typename other_rep_>
    LITE_INLINE void swap(const array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            swapper<value_type> > 
            iterator_type;

        for_each(iterator_type(&m_data[0][0], other.begin()), size_type());
    }

    template<typename other_rep_>
    LITE_INLINE void swap(array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::iterator, 
            swapper<value_type> > 
            iterator_type;

        for_each(iterator_type(&m_data[0][0], other.begin()), size_type());
    }

private:
    value_type m_data[n0_][n1_];
};

/***********************************************************************************************************/

template<
    typename value_type_,
    int n0_, 
    int n1_, 
    int n2_, 
    typename traits_type_
    >
class array<
    value_type_[n0_][n1_][n2_],
    traits_type_,
    internal_rep<false>
    >
{
public:
    typedef value_type_ signature[n0_][n1_][n2_];
    typedef traits_type_ traits_type;
    typedef value_type_ value_type;
    typedef const value_type_& const_reference;
    typedef value_type_& reference;

    typedef typename array_signature_traits<const signature>::default_iterator const_iterator;
    typedef typename array_signature_traits<signature>::default_iterator iterator;
    typedef typename array_signature_traits<signature>::size_type size_type;

    typedef typename array_helper<signature, traits_type_>::temporary_array temporary_array;
    typedef typename array_helper<signature, traits_type_>::fwd_temporary_array fwd_temporary_array;
    typedef typename array_helper<signature, traits_type_>::rev_temporary_array rev_temporary_array;

    static const bool is_reverse = false;
    static const int dimensions = 3;

    LITE_INLINE array() 
    {}

    explicit LITE_INLINE array(int, int, int)
    {}

    explicit LITE_INLINE array(const size_type&)
    {}

    LITE_INLINE array(const array& other) 
    {
        typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;

        for_each(iterator_type(
            &m_data[0][0][0], 
            &other.m_data[0][0][0]), 
            size_type());
    }

    template<typename other_rep_>
    LITE_INLINE array(const array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            assign<value_type> > 
            iterator_type;

        LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), "array(): array sizes do not match");

        for_each(iterator_type(&m_data[0][0][0], other.begin()), size_type());
    }

    LITE_INLINE array(const value_type& value) 
    {
        typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;

        for_each(iterator_type(&m_data[0][0][0], value), size_type());
    }


    LITE_INLINE array& operator=(const array& other) 
    {
        typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;

        for_each(iterator_type(
            &m_data[0][0][0], 
            &other.m_data[0][0][0]), 
            size_type());
        return *this;
    }

    template<typename other_rep_>
    LITE_INLINE array& operator=(const array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            assign<value_type> > 
            iterator_type;

        LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), "array(): array sizes do not match");

        for_each(iterator_type(&m_data[0][0][0], other.begin()), size_type());
        return *this;
    }

    LITE_INLINE array& operator=(const value_type& value)
    {
        typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;

        for_each(iterator_type(&m_data[0][0][0], value), size_type());
        return *this;
    }

    LITE_INLINE const_iterator begin() const
    {
        return const_iterator(&m_data[0][0][0]);
    }

    LITE_INLINE iterator begin()
    {
        return iterator(&m_data[0][0][0]);
    }

    LITE_INLINE size_type size() const
    {
        return size_type();
    }

    LITE_INLINE const_reference 
    operator()(int i0, int i1, int i2) const
    {
        return m_data[i0][i1][i2];
    }

    LITE_INLINE reference 
    operator()(int i0, int i1, int i2) 
    {
        return m_data[i0][i1][i2];
    }


    template<typename transform_type_>
    LITE_INLINE const typename transform_traits<array, transform_type_>::const_array
    operator[](const transform_type_& trans) const
    {
        typedef typename transform_traits<array, transform_type_>::const_array result_type;

        return result_type(begin(), size(), trans);
    }

    template<typename transform_type_>
    LITE_INLINE const typename transform_traits<array, transform_type_>::array
    operator[](const transform_type_& trans)
    {
        typedef typename transform_traits<array, transform_type_>::array result_type;

        return result_type(begin(), size(), trans);
    }

    LITE_INLINE const value_type* data() const
    {
        return &m_data[0][0][0];
    }

    LITE_INLINE value_type* data()
    {
        return &m_data[0][0][0];
    }

    LITE_INLINE void release() 
    {}

    LITE_INLINE void resize(int, int, int)
    {}

    LITE_INLINE void resize(const size_type&)
    {}

    template<typename other_rep_>
    LITE_INLINE void swap(const array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            swapper<value_type> > 
            iterator_type;

        for_each(iterator_type(&m_data[0][0][0], other.begin()), size_type());
    }

    template<typename other_rep_>
    LITE_INLINE void swap(array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::iterator, 
            swapper<value_type> > 
            iterator_type;

        for_each(iterator_type(&m_data[0][0][0], other.begin()), size_type());
    }

private:
    value_type m_data[n0_][n1_][n2_];
};

/***********************************************************************************************************/

template<
    typename value_type_,
    typename traits_type_
    >
class array<
    value_type_,
    traits_type_,
    internal_rep<true>
    >
{
public:
    typedef value_type_ signature;
    typedef traits_type_ traits_type;
    typedef value_type_ value_type;
    typedef const value_type_& const_reference;
    typedef value_type_& reference;

    typedef typename array_signature_traits<const signature>::default_rev_iterator const_iterator;
    typedef typename array_signature_traits<signature>::default_rev_iterator iterator;
    typedef typename array_signature_traits<signature>::size_type size_type;

    typedef typename array_helper<signature, traits_type_>::temporary_array temporary_array;
    typedef typename array_helper<signature, traits_type_>::fwd_temporary_array fwd_temporary_array;
    typedef typename array_helper<signature, traits_type_>::rev_temporary_array rev_temporary_array;

    static const bool is_reverse = true;
    static const int dimensions = 0;

    LITE_INLINE array() 
    {}


    explicit LITE_INLINE array(const size_type&)
    {}

    LITE_INLINE array(const array& other) 
    {
        typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;

        for_each(iterator_type(
            &m_data, 
            &other.m_data), 
            size_type());
    }

    template<typename other_rep_>
    LITE_INLINE array(const array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            assign<value_type> > 
            iterator_type;

        LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), "array(): array sizes do not match");

        for_each(iterator_type(&m_data, other.begin()), size_type());
    }

    LITE_INLINE array(const value_type& value) 
    {
        typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;

        for_each(iterator_type(&m_data, value), size_type());
    }


    LITE_INLINE array& operator=(const array& other) 
    {
        typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;

        for_each(iterator_type(
            &m_data, 
            &other.m_data), 
            size_type());
        return *this;
    }

    template<typename other_rep_>
    LITE_INLINE array& operator=(const array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            assign<value_type> > 
            iterator_type;

        LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), "array(): array sizes do not match");

        for_each(iterator_type(&m_data, other.begin()), size_type());
        return *this;
    }

    LITE_INLINE array& operator=(const value_type& value)
    {
        typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;

        for_each(iterator_type(&m_data, value), size_type());
        return *this;
    }

    LITE_INLINE const_iterator begin() const
    {
        return const_iterator(&m_data);
    }

    LITE_INLINE iterator begin()
    {
        return iterator(&m_data);
    }

    LITE_INLINE size_type size() const
    {
        return size_type();
    }

    LITE_INLINE const_reference 
    operator()() const
    {
        return m_data; 
    }

    LITE_INLINE reference 
    operator()() 
    {
        return m_data;
    }


    template<typename transform_type_>
    LITE_INLINE const typename transform_traits<array, transform_type_>::const_array
    operator[](const transform_type_& trans) const
    {
        typedef typename transform_traits<array, transform_type_>::const_array result_type;

        return result_type(begin(), size(), trans);
    }

    template<typename transform_type_>
    LITE_INLINE const typename transform_traits<array, transform_type_>::array
    operator[](const transform_type_& trans)
    {
        typedef typename transform_traits<array, transform_type_>::array result_type;

        return result_type(begin(), size(), trans);
    }

    LITE_INLINE const value_type* data() const
    {
        return &m_data;
    }

    LITE_INLINE value_type* data()
    {
        return &m_data;
    }

    LITE_INLINE void release() 
    {}

    LITE_INLINE void resize()
    {}

    LITE_INLINE void resize(const size_type&)
    {}

    template<typename other_rep_>
    LITE_INLINE void swap(const array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            swapper<value_type> > 
            iterator_type;

        for_each(iterator_type(&m_data, other.begin()), size_type());
    }

    template<typename other_rep_>
    LITE_INLINE void swap(array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::iterator, 
            swapper<value_type> > 
            iterator_type;

        for_each(iterator_type(&m_data, other.begin()), size_type());
    }

private:
    value_type m_data;
};

/***********************************************************************************************************/

template<
    typename value_type_,
    int n0_, 
    typename traits_type_
    >
class array<
    value_type_[n0_],
    traits_type_,
    internal_rep<true>
    >
{
public:
    typedef value_type_ signature[n0_];
    typedef traits_type_ traits_type;
    typedef value_type_ value_type;
    typedef const value_type_& const_reference;
    typedef value_type_& reference;

    typedef typename array_signature_traits<const signature>::default_rev_iterator const_iterator;
    typedef typename array_signature_traits<signature>::default_rev_iterator iterator;
    typedef typename array_signature_traits<signature>::size_type size_type;

    typedef typename array_helper<signature, traits_type_>::temporary_array temporary_array;
    typedef typename array_helper<signature, traits_type_>::fwd_temporary_array fwd_temporary_array;
    typedef typename array_helper<signature, traits_type_>::rev_temporary_array rev_temporary_array;

    static const bool is_reverse = true;
    static const int dimensions = 1;

    LITE_INLINE array() 
    {}

    explicit LITE_INLINE array(int)
    {}

    explicit LITE_INLINE array(const size_type&)
    {}

    LITE_INLINE array(const array& other) 
    {
        typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;

        for_each(iterator_type(
            &m_data[0], 
            &other.m_data[0]), 
            size_type());
    }

    template<typename other_rep_>
    LITE_INLINE array(const array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            assign<value_type> > 
            iterator_type;

        LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), "array(): array sizes do not match");

        for_each(iterator_type(&m_data[0], other.begin()), size_type());
    }

    LITE_INLINE array(const value_type& value) 
    {
        typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;

        for_each(iterator_type(&m_data[0], value), size_type());
    }


    LITE_INLINE array(
        typename detail::type_if<n0_==2, const value_type&, detail::invalid_argument>::type a0,
        const value_type& a1 
        )
    {
        m_data[0] = a0;
        m_data[1] = a1;
    }

    LITE_INLINE array(
        typename detail::type_if<n0_==3, const value_type&, detail::invalid_argument>::type a0,
        const value_type& a1, 
        const value_type& a2 
        )
    {
        m_data[0] = a0;
        m_data[1] = a1;
        m_data[2] = a2;
    }

    LITE_INLINE array(
        typename detail::type_if<n0_==4, const value_type&, detail::invalid_argument>::type a0,
        const value_type& a1, 
        const value_type& a2, 
        const value_type& a3 
        )
    {
        m_data[0] = a0;
        m_data[1] = a1;
        m_data[2] = a2;
        m_data[3] = a3;
    }

    LITE_INLINE array(
        typename detail::type_if<n0_==5, const value_type&, detail::invalid_argument>::type a0,
        const value_type& a1, 
        const value_type& a2, 
        const value_type& a3, 
        const value_type& a4 
        )
    {
        m_data[0] = a0;
        m_data[1] = a1;
        m_data[2] = a2;
        m_data[3] = a3;
        m_data[4] = a4;
    }

    LITE_INLINE array& operator=(const array& other) 
    {
        typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;

        for_each(iterator_type(
            &m_data[0], 
            &other.m_data[0]), 
            size_type());
        return *this;
    }

    template<typename other_rep_>
    LITE_INLINE array& operator=(const array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            assign<value_type> > 
            iterator_type;

        LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), "array(): array sizes do not match");

        for_each(iterator_type(&m_data[0], other.begin()), size_type());
        return *this;
    }

    LITE_INLINE array& operator=(const value_type& value)
    {
        typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;

        for_each(iterator_type(&m_data[0], value), size_type());
        return *this;
    }

    LITE_INLINE const_iterator begin() const
    {
        return const_iterator(&m_data[0]);
    }

    LITE_INLINE iterator begin()
    {
        return iterator(&m_data[0]);
    }

    LITE_INLINE size_type size() const
    {
        return size_type();
    }

    LITE_INLINE const_reference 
    operator()(int i0) const
    {
        return m_data[i0]; 
    }

    LITE_INLINE reference 
    operator()(int i0) 
    {
        return m_data[i0];
    }

    LITE_INLINE const_reference 
    operator[](int i0) const
    {
        return m_data[i0];
    }

    LITE_INLINE reference 
    operator[](int i0)
    {
        return m_data[i0];
    }


    template<typename transform_type_>
    LITE_INLINE const typename transform_traits<array, transform_type_>::const_array
    operator[](const transform_type_& trans) const
    {
        typedef typename transform_traits<array, transform_type_>::const_array result_type;

        return result_type(begin(), size(), trans);
    }

    template<typename transform_type_>
    LITE_INLINE const typename transform_traits<array, transform_type_>::array
    operator[](const transform_type_& trans)
    {
        typedef typename transform_traits<array, transform_type_>::array result_type;

        return result_type(begin(), size(), trans);
    }

    LITE_INLINE const value_type* data() const
    {
        return &m_data[0];
    }

    LITE_INLINE value_type* data()
    {
        return &m_data[0];
    }

    LITE_INLINE void release() 
    {}

    LITE_INLINE void resize(int)
    {}

    LITE_INLINE void resize(const size_type&)
    {}

    template<typename other_rep_>
    LITE_INLINE void swap(const array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            swapper<value_type> > 
            iterator_type;

        for_each(iterator_type(&m_data[0], other.begin()), size_type());
    }

    template<typename other_rep_>
    LITE_INLINE void swap(array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::iterator, 
            swapper<value_type> > 
            iterator_type;

        for_each(iterator_type(&m_data[0], other.begin()), size_type());
    }

private:
    value_type m_data[n0_];
};

/***********************************************************************************************************/

template<
    typename value_type_,
    int n0_, 
    int n1_, 
    typename traits_type_
    >
class array<
    value_type_[n0_][n1_],
    traits_type_,
    internal_rep<true>
    >
{
public:
    typedef value_type_ signature[n0_][n1_];
    typedef traits_type_ traits_type;
    typedef value_type_ value_type;
    typedef const value_type_& const_reference;
    typedef value_type_& reference;

    typedef typename array_signature_traits<const signature>::default_rev_iterator const_iterator;
    typedef typename array_signature_traits<signature>::default_rev_iterator iterator;
    typedef typename array_signature_traits<signature>::size_type size_type;

    typedef typename array_helper<signature, traits_type_>::temporary_array temporary_array;
    typedef typename array_helper<signature, traits_type_>::fwd_temporary_array fwd_temporary_array;
    typedef typename array_helper<signature, traits_type_>::rev_temporary_array rev_temporary_array;

    static const bool is_reverse = true;
    static const int dimensions = 2;

    LITE_INLINE array() 
    {}

    explicit LITE_INLINE array(int, int)
    {}

    explicit LITE_INLINE array(const size_type&)
    {}

    LITE_INLINE array(const array& other) 
    {
        typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;

        for_each(iterator_type(
            &m_data[0][0], 
            &other.m_data[0][0]), 
            size_type());
    }

    template<typename other_rep_>
    LITE_INLINE array(const array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            assign<value_type> > 
            iterator_type;

        LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), "array(): array sizes do not match");

        for_each(iterator_type(&m_data[0][0], other.begin()), size_type());
    }

    LITE_INLINE array(const value_type& value) 
    {
        typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;

        for_each(iterator_type(&m_data[0][0], value), size_type());
    }


    LITE_INLINE array& operator=(const array& other) 
    {
        typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;

        for_each(iterator_type(
            &m_data[0][0], 
            &other.m_data[0][0]), 
            size_type());
        return *this;
    }

    template<typename other_rep_>
    LITE_INLINE array& operator=(const array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            assign<value_type> > 
            iterator_type;

        LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), "array(): array sizes do not match");

        for_each(iterator_type(&m_data[0][0], other.begin()), size_type());
        return *this;
    }

    LITE_INLINE array& operator=(const value_type& value)
    {
        typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;

        for_each(iterator_type(&m_data[0][0], value), size_type());
        return *this;
    }

    LITE_INLINE const_iterator begin() const
    {
        return const_iterator(&m_data[0][0]);
    }

    LITE_INLINE iterator begin()
    {
        return iterator(&m_data[0][0]);
    }

    LITE_INLINE size_type size() const
    {
        return size_type();
    }

    LITE_INLINE const_reference 
    operator()(int i0, int i1) const
    {
        return m_data[i1][i0]; 
    }

    LITE_INLINE reference 
    operator()(int i0, int i1) 
    {
        return m_data[i1][i0];
    }


    template<typename transform_type_>
    LITE_INLINE const typename transform_traits<array, transform_type_>::const_array
    operator[](const transform_type_& trans) const
    {
        typedef typename transform_traits<array, transform_type_>::const_array result_type;

        return result_type(begin(), size(), trans);
    }

    template<typename transform_type_>
    LITE_INLINE const typename transform_traits<array, transform_type_>::array
    operator[](const transform_type_& trans)
    {
        typedef typename transform_traits<array, transform_type_>::array result_type;

        return result_type(begin(), size(), trans);
    }

    LITE_INLINE const value_type* data() const
    {
        return &m_data[0][0];
    }

    LITE_INLINE value_type* data()
    {
        return &m_data[0][0];
    }

    LITE_INLINE void release() 
    {}

    LITE_INLINE void resize(int, int)
    {}

    LITE_INLINE void resize(const size_type&)
    {}

    template<typename other_rep_>
    LITE_INLINE void swap(const array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            swapper<value_type> > 
            iterator_type;

        for_each(iterator_type(&m_data[0][0], other.begin()), size_type());
    }

    template<typename other_rep_>
    LITE_INLINE void swap(array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::iterator, 
            swapper<value_type> > 
            iterator_type;

        for_each(iterator_type(&m_data[0][0], other.begin()), size_type());
    }

private:
    value_type m_data[n1_][n0_];
};

/***********************************************************************************************************/

template<
    typename value_type_,
    int n0_, 
    int n1_, 
    int n2_, 
    typename traits_type_
    >
class array<
    value_type_[n0_][n1_][n2_],
    traits_type_,
    internal_rep<true>
    >
{
public:
    typedef value_type_ signature[n0_][n1_][n2_];
    typedef traits_type_ traits_type;
    typedef value_type_ value_type;
    typedef const value_type_& const_reference;
    typedef value_type_& reference;

    typedef typename array_signature_traits<const signature>::default_rev_iterator const_iterator;
    typedef typename array_signature_traits<signature>::default_rev_iterator iterator;
    typedef typename array_signature_traits<signature>::size_type size_type;

    typedef typename array_helper<signature, traits_type_>::temporary_array temporary_array;
    typedef typename array_helper<signature, traits_type_>::fwd_temporary_array fwd_temporary_array;
    typedef typename array_helper<signature, traits_type_>::rev_temporary_array rev_temporary_array;

    static const bool is_reverse = true;
    static const int dimensions = 3;

    LITE_INLINE array() 
    {}

    explicit LITE_INLINE array(int, int, int)
    {}

    explicit LITE_INLINE array(const size_type&)
    {}

    LITE_INLINE array(const array& other) 
    {
        typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;

        for_each(iterator_type(
            &m_data[0][0][0], 
            &other.m_data[0][0][0]), 
            size_type());
    }

    template<typename other_rep_>
    LITE_INLINE array(const array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            assign<value_type> > 
            iterator_type;

        LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), "array(): array sizes do not match");

        for_each(iterator_type(&m_data[0][0][0], other.begin()), size_type());
    }

    LITE_INLINE array(const value_type& value) 
    {
        typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;

        for_each(iterator_type(&m_data[0][0][0], value), size_type());
    }


    LITE_INLINE array& operator=(const array& other) 
    {
        typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;

        for_each(iterator_type(
            &m_data[0][0][0], 
            &other.m_data[0][0][0]), 
            size_type());
        return *this;
    }

    template<typename other_rep_>
    LITE_INLINE array& operator=(const array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            assign<value_type> > 
            iterator_type;

        LITE_ARRAY_SIZE_CHECK(size_type(), other.size(), "array(): array sizes do not match");

        for_each(iterator_type(&m_data[0][0][0], other.begin()), size_type());
        return *this;
    }

    LITE_INLINE array& operator=(const value_type& value)
    {
        typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;

        for_each(iterator_type(&m_data[0][0][0], value), size_type());
        return *this;
    }

    LITE_INLINE const_iterator begin() const
    {
        return const_iterator(&m_data[0][0][0]);
    }

    LITE_INLINE iterator begin()
    {
        return iterator(&m_data[0][0][0]);
    }

    LITE_INLINE size_type size() const
    {
        return size_type();
    }

    LITE_INLINE const_reference 
    operator()(int i0, int i1, int i2) const
    {
        return m_data[i2][i1][i0]; 
    }

    LITE_INLINE reference 
    operator()(int i0, int i1, int i2) 
    {
        return m_data[i2][i1][i0];
    }


    template<typename transform_type_>
    LITE_INLINE const typename transform_traits<array, transform_type_>::const_array
    operator[](const transform_type_& trans) const
    {
        typedef typename transform_traits<array, transform_type_>::const_array result_type;

        return result_type(begin(), size(), trans);
    }

    template<typename transform_type_>
    LITE_INLINE const typename transform_traits<array, transform_type_>::array
    operator[](const transform_type_& trans)
    {
        typedef typename transform_traits<array, transform_type_>::array result_type;

        return result_type(begin(), size(), trans);
    }

    LITE_INLINE const value_type* data() const
    {
        return &m_data[0][0][0];
    }

    LITE_INLINE value_type* data()
    {
        return &m_data[0][0][0];
    }

    LITE_INLINE void release() 
    {}

    LITE_INLINE void resize(int, int, int)
    {}

    LITE_INLINE void resize(const size_type&)
    {}

    template<typename other_rep_>
    LITE_INLINE void swap(const array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            swapper<value_type> > 
            iterator_type;

        for_each(iterator_type(&m_data[0][0][0], other.begin()), size_type());
    }

    template<typename other_rep_>
    LITE_INLINE void swap(array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::iterator, 
            swapper<value_type> > 
            iterator_type;

        for_each(iterator_type(&m_data[0][0][0], other.begin()), size_type());
    }

private:
    value_type m_data[n2_][n1_][n0_];
};

/***********************************************************************************************************/


/***********************************************************************************************************/
/* array, hybrid_rep ***************************************************************************************/
/***********************************************************************************************************/

/*!
    \brief This is a tag type that can be used to specify hybrid representation for an array.
    
    \ingroup array_advanced

    See \ref array_hybrid.
*/
template<bool reversed_, int internal_buf_size_>
class hybrid_rep 
{};


template<
    typename value_type_,
    typename traits_type_,
    int internal_buf_size_
    >
class array<
    value_type_,
    traits_type_,
    hybrid_rep<false, internal_buf_size_>
    >
{
public:
    typedef value_type_ signature;
    typedef traits_type_ traits_type;
    typedef value_type_ value_type;
    typedef const value_type_& const_reference;
    typedef value_type_& reference;

    typedef typename array_signature_traits<const signature>::default_iterator const_iterator;
    typedef typename array_signature_traits<signature>::default_iterator iterator;
    typedef typename array_signature_traits<signature>::size_type size_type;

    typedef typename array_helper<signature, traits_type_>::temporary_array temporary_array;
    typedef typename array_helper<signature, traits_type_>::fwd_temporary_array fwd_temporary_array;
    typedef typename array_helper<signature, traits_type_>::rev_temporary_array rev_temporary_array;

    static const int dimensions = 0;
    static const bool is_reverse = false;
    static const int internal_buffer_size = internal_buf_size_;



    explicit LITE_INLINE array(const size_type& sz)
    {
        init();
        resize(sz);
    }

    LITE_INLINE array(const array& other) 
    {
        typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;

        init();
        resize(other.size());
        for_each(iterator_type(m_iterator, other.m_iterator), m_size);
    }

    template<typename other_rep_>
    LITE_INLINE array(const array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            assign<value_type> > 
            iterator_type;

        init();
        resize(other.size());
        for_each(iterator_type(m_iterator, other.begin()), m_size);
    }

    LITE_INLINE array(const value_type& value) 
    {
        typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;

        init();
        for_each(iterator_type(m_iterator, value), m_size);
    }

    LITE_INLINE array& operator=(const array& other) 
    {
        typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;

        resize(other.size());
        for_each(iterator_type(m_iterator, other.m_iterator), m_size);
        return *this;
    }

    template<typename other_rep_>
    LITE_INLINE array& operator=(const array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            assign<value_type> > 
            iterator_type;

        resize(other.size());
        for_each(iterator_type(m_iterator, other.begin()), m_size);
        return *this;
    }

    LITE_INLINE array& operator=(const value_type& value)
    {
        typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;

        for_each(iterator_type(m_iterator, value), m_size);
        return *this;
    }

    LITE_INLINE const_iterator begin() const
    {
        return m_iterator;
    }

    LITE_INLINE iterator begin()
    {
        return m_iterator;
    }

    LITE_INLINE size_type size() const
    {
        return m_size;
    }

    LITE_INLINE const_reference 
    operator()() const
    {
        return *(m_iterator.i0);
    }

    LITE_INLINE reference 
    operator()() 
    {
        return *(m_iterator.i0);
    }


    template<typename transform_type_>
    LITE_INLINE const typename transform_traits<array, transform_type_>::const_array
    operator[](const transform_type_& trans) const
    {
        typedef typename transform_traits<array, transform_type_>::const_array result_type;

        return result_type(begin(), size(), trans);
    }

    template<typename transform_type_>
    LITE_INLINE const typename transform_traits<array, transform_type_>::array
    operator[](const transform_type_& trans)
    {
        typedef typename transform_traits<array, transform_type_>::array result_type;

        return result_type(begin(), size(), trans);
    }

    LITE_INLINE const value_type* data() const
    {
        return m_iterator.i0;
    }

    LITE_INLINE value_type* data()
    {
        return m_iterator.i0;
    }

    LITE_INLINE void release() 
    {
        if (m_iterator.i0 && m_iterator.i0 != m_buffer)
            delete[] m_iterator.i0;

        m_iterator.i0 = 0;
        m_size.set();
    }

    LITE_INLINE void resize()
    {
        resize(size_type());
    }

    LITE_INLINE void resize(const size_type& new_size)
    {
        int old_volumne = volume(m_size);
        int new_volume = volume(new_size);

        if (old_volumne != new_volume || m_iterator.i0==0) {
            if (m_iterator.i0 && m_iterator.i0 != m_buffer)
                delete[] m_iterator.i0;
            m_iterator.i0 = 0;
            m_size.set();

            if (new_volume == 0)
                return;

            m_iterator.i0 = new_volume <= internal_buffer_size ? m_buffer : new value_type[new_volume];
        }
        m_size = new_size;
        m_iterator.set(
            m_iterator.i0
        );
    }

    template<typename other_rep_>
    LITE_INLINE void swap(const array<signature, traits_type_, other_rep_>& other) 
    {
        regular_swap(other);
    }

    template<typename other_rep_>
    LITE_INLINE void swap(array<signature, traits_type_, other_rep_>& other) 
    {
        regular_swap(other);
    }

    LITE_INLINE void swap(array& other)
    {
        // fast swap
        if (m_iterator.i0 != m_buffer && other.m_iterator.i0 != other.m_buffer) {
            iterator tmp_iter = other.m_iterator;
            size_type tmp_size = other.m_size;

            other.m_iterator = m_iterator;
            other.m_size = m_size;

            m_iterator = tmp_iter;
            m_size = tmp_size;
        }
        else
            regular_swap(other);
    }


    LITE_INLINE ~array() 
    {
        if (m_iterator.i0 && m_iterator.i0 != m_buffer)
            delete[] m_iterator.i0;
    }

private:

    template<typename other_array_>
    LITE_INLINE void regular_swap(other_array_& other)
    {
        typedef b_iterator<iterator, typename other_array_::iterator, swapper<value_type> > iterator_type;

        if (m_size == other.size()) 
            for_each(iterator_type(m_iterator, other.begin()), m_size);
        else {
            typename other_array_::temporary_array tmp = other;

            other = *this;
            *this = tmp;
        }
    }

    //template<typename other_signature_, typename other_traits_type_, typename other_rep_>
    //friend class array;

    LITE_INLINE void init()
    {
        m_iterator.i0 = 0;
        m_size.set();
        resize(m_size);
    }

    iterator m_iterator;
    size_type m_size;
    value_type m_buffer[internal_buffer_size >= 1 ? internal_buffer_size : 1];
};

/***********************************************************************************************************/

template<
    typename value_type_,
    int n0_, 
    typename traits_type_,
    int internal_buf_size_
    >
class array<
    value_type_[n0_],
    traits_type_,
    hybrid_rep<false, internal_buf_size_>
    >
{
public:
    typedef value_type_ signature[n0_];
    typedef traits_type_ traits_type;
    typedef value_type_ value_type;
    typedef const value_type_& const_reference;
    typedef value_type_& reference;

    typedef typename array_signature_traits<const signature>::default_iterator const_iterator;
    typedef typename array_signature_traits<signature>::default_iterator iterator;
    typedef typename array_signature_traits<signature>::size_type size_type;

    typedef typename array_helper<signature, traits_type_>::temporary_array temporary_array;
    typedef typename array_helper<signature, traits_type_>::fwd_temporary_array fwd_temporary_array;
    typedef typename array_helper<signature, traits_type_>::rev_temporary_array rev_temporary_array;

    static const int dimensions = 1;
    static const bool is_reverse = false;
    static const int internal_buffer_size = internal_buf_size_;

    LITE_INLINE array() 
    {
        init();
        resize(size_type());
    }

    explicit LITE_INLINE array(int n0)
    {
        init();
        resize(size_type(n0));
    }

    explicit LITE_INLINE array(const size_type& sz)
    {
        init();
        resize(sz);
    }

    LITE_INLINE array(const array& other) 
    {
        typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;

        init();
        resize(other.size());
        for_each(iterator_type(m_iterator, other.m_iterator), m_size);
    }

    template<typename other_rep_>
    LITE_INLINE array(const array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            assign<value_type> > 
            iterator_type;

        init();
        resize(other.size());
        for_each(iterator_type(m_iterator, other.begin()), m_size);
    }

    LITE_INLINE array(const value_type& value) 
    {
        typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;

        init();
        for_each(iterator_type(m_iterator, value), m_size);
    }

    LITE_INLINE array& operator=(const array& other) 
    {
        typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;

        resize(other.size());
        for_each(iterator_type(m_iterator, other.m_iterator), m_size);
        return *this;
    }

    template<typename other_rep_>
    LITE_INLINE array& operator=(const array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            assign<value_type> > 
            iterator_type;

        resize(other.size());
        for_each(iterator_type(m_iterator, other.begin()), m_size);
        return *this;
    }

    LITE_INLINE array& operator=(const value_type& value)
    {
        typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;

        for_each(iterator_type(m_iterator, value), m_size);
        return *this;
    }

    LITE_INLINE const_iterator begin() const
    {
        return m_iterator;
    }

    LITE_INLINE iterator begin()
    {
        return m_iterator;
    }

    LITE_INLINE size_type size() const
    {
        return m_size;
    }

    LITE_INLINE const_reference 
    operator()(int i0) const
    {
        return *(m_iterator.i0+i0*m_iterator.i1);
    }

    LITE_INLINE reference 
    operator()(int i0) 
    {
        return *(m_iterator.i0+i0*m_iterator.i1);
    }

    LITE_INLINE const_reference 
    operator[](int i0) const
    {
        return *(m_iterator.i0+i0*m_iterator.i1);
    }

    LITE_INLINE reference 
    operator[](int i0)
    {
        return *(m_iterator.i0+i0*m_iterator.i1);
    }


    template<typename transform_type_>
    LITE_INLINE const typename transform_traits<array, transform_type_>::const_array
    operator[](const transform_type_& trans) const
    {
        typedef typename transform_traits<array, transform_type_>::const_array result_type;

        return result_type(begin(), size(), trans);
    }

    template<typename transform_type_>
    LITE_INLINE const typename transform_traits<array, transform_type_>::array
    operator[](const transform_type_& trans)
    {
        typedef typename transform_traits<array, transform_type_>::array result_type;

        return result_type(begin(), size(), trans);
    }

    LITE_INLINE const value_type* data() const
    {
        return m_iterator.i0;
    }

    LITE_INLINE value_type* data()
    {
        return m_iterator.i0;
    }

    LITE_INLINE void release() 
    {
        if (m_iterator.i0 && m_iterator.i0 != m_buffer)
            delete[] m_iterator.i0;

        m_iterator.i0 = 0;
        m_size.set(0);
    }

    LITE_INLINE void resize(int n0)
    {
        resize(size_type(n0));
    }

    LITE_INLINE void resize(const size_type& new_size)
    {
        int old_volumne = volume(m_size);
        int new_volume = volume(new_size);

        if (old_volumne != new_volume || m_iterator.i0==0) {
            if (m_iterator.i0 && m_iterator.i0 != m_buffer)
                delete[] m_iterator.i0;
            m_iterator.i0 = 0;
            m_size.set(0);

            if (new_volume == 0)
                return;

            m_iterator.i0 = new_volume <= internal_buffer_size ? m_buffer : new value_type[new_volume];
        }
        m_size = new_size;
        m_iterator.set(
            m_iterator.i0,
            1
        );
    }

    template<typename other_rep_>
    LITE_INLINE void swap(const array<signature, traits_type_, other_rep_>& other) 
    {
        regular_swap(other);
    }

    template<typename other_rep_>
    LITE_INLINE void swap(array<signature, traits_type_, other_rep_>& other) 
    {
        regular_swap(other);
    }

    LITE_INLINE void swap(array& other)
    {
        // fast swap
        if (m_iterator.i0 != m_buffer && other.m_iterator.i0 != other.m_buffer) {
            iterator tmp_iter = other.m_iterator;
            size_type tmp_size = other.m_size;

            other.m_iterator = m_iterator;
            other.m_size = m_size;

            m_iterator = tmp_iter;
            m_size = tmp_size;
        }
        else
            regular_swap(other);
    }


    LITE_INLINE ~array() 
    {
        if (m_iterator.i0 && m_iterator.i0 != m_buffer)
            delete[] m_iterator.i0;
    }

private:

    template<typename other_array_>
    LITE_INLINE void regular_swap(other_array_& other)
    {
        typedef b_iterator<iterator, typename other_array_::iterator, swapper<value_type> > iterator_type;

        if (m_size == other.size()) 
            for_each(iterator_type(m_iterator, other.begin()), m_size);
        else {
            typename other_array_::temporary_array tmp = other;

            other = *this;
            *this = tmp;
        }
    }

    //template<typename other_signature_, typename other_traits_type_, typename other_rep_>
    //friend class array;

    LITE_INLINE void init()
    {
        m_iterator.i0 = 0;
        m_size.set(0);
        resize(m_size);
    }

    iterator m_iterator;
    size_type m_size;
    value_type m_buffer[internal_buffer_size >= 1 ? internal_buffer_size : 1];
};

/***********************************************************************************************************/

template<
    typename value_type_,
    int n0_, 
    int n1_, 
    typename traits_type_,
    int internal_buf_size_
    >
class array<
    value_type_[n0_][n1_],
    traits_type_,
    hybrid_rep<false, internal_buf_size_>
    >
{
public:
    typedef value_type_ signature[n0_][n1_];
    typedef traits_type_ traits_type;
    typedef value_type_ value_type;
    typedef const value_type_& const_reference;
    typedef value_type_& reference;

    typedef typename array_signature_traits<const signature>::default_iterator const_iterator;
    typedef typename array_signature_traits<signature>::default_iterator iterator;
    typedef typename array_signature_traits<signature>::size_type size_type;

    typedef typename array_helper<signature, traits_type_>::temporary_array temporary_array;
    typedef typename array_helper<signature, traits_type_>::fwd_temporary_array fwd_temporary_array;
    typedef typename array_helper<signature, traits_type_>::rev_temporary_array rev_temporary_array;

    static const int dimensions = 2;
    static const bool is_reverse = false;
    static const int internal_buffer_size = internal_buf_size_;

    LITE_INLINE array() 
    {
        init();
        resize(size_type());
    }

    explicit LITE_INLINE array(int n0, int n1)
    {
        init();
        resize(size_type(n0, n1));
    }

    explicit LITE_INLINE array(const size_type& sz)
    {
        init();
        resize(sz);
    }

    LITE_INLINE array(const array& other) 
    {
        typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;

        init();
        resize(other.size());
        for_each(iterator_type(m_iterator, other.m_iterator), m_size);
    }

    template<typename other_rep_>
    LITE_INLINE array(const array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            assign<value_type> > 
            iterator_type;

        init();
        resize(other.size());
        for_each(iterator_type(m_iterator, other.begin()), m_size);
    }

    LITE_INLINE array(const value_type& value) 
    {
        typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;

        init();
        for_each(iterator_type(m_iterator, value), m_size);
    }

    LITE_INLINE array& operator=(const array& other) 
    {
        typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;

        resize(other.size());
        for_each(iterator_type(m_iterator, other.m_iterator), m_size);
        return *this;
    }

    template<typename other_rep_>
    LITE_INLINE array& operator=(const array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            assign<value_type> > 
            iterator_type;

        resize(other.size());
        for_each(iterator_type(m_iterator, other.begin()), m_size);
        return *this;
    }

    LITE_INLINE array& operator=(const value_type& value)
    {
        typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;

        for_each(iterator_type(m_iterator, value), m_size);
        return *this;
    }

    LITE_INLINE const_iterator begin() const
    {
        return m_iterator;
    }

    LITE_INLINE iterator begin()
    {
        return m_iterator;
    }

    LITE_INLINE size_type size() const
    {
        return m_size;
    }

    LITE_INLINE const_reference 
    operator()(int i0, int i1) const
    {
        return *(m_iterator.i0+i0*m_iterator.i1+i1*m_iterator.i2);
    }

    LITE_INLINE reference 
    operator()(int i0, int i1) 
    {
        return *(m_iterator.i0+i0*m_iterator.i1+i1*m_iterator.i2);
    }


    template<typename transform_type_>
    LITE_INLINE const typename transform_traits<array, transform_type_>::const_array
    operator[](const transform_type_& trans) const
    {
        typedef typename transform_traits<array, transform_type_>::const_array result_type;

        return result_type(begin(), size(), trans);
    }

    template<typename transform_type_>
    LITE_INLINE const typename transform_traits<array, transform_type_>::array
    operator[](const transform_type_& trans)
    {
        typedef typename transform_traits<array, transform_type_>::array result_type;

        return result_type(begin(), size(), trans);
    }

    LITE_INLINE const value_type* data() const
    {
        return m_iterator.i0;
    }

    LITE_INLINE value_type* data()
    {
        return m_iterator.i0;
    }

    LITE_INLINE void release() 
    {
        if (m_iterator.i0 && m_iterator.i0 != m_buffer)
            delete[] m_iterator.i0;

        m_iterator.i0 = 0;
        m_size.set(0, 0);
    }

    LITE_INLINE void resize(int n0, int n1)
    {
        resize(size_type(n0, n1));
    }

    LITE_INLINE void resize(const size_type& new_size)
    {
        int old_volumne = volume(m_size);
        int new_volume = volume(new_size);

        if (old_volumne != new_volume || m_iterator.i0==0) {
            if (m_iterator.i0 && m_iterator.i0 != m_buffer)
                delete[] m_iterator.i0;
            m_iterator.i0 = 0;
            m_size.set(0, 0);

            if (new_volume == 0)
                return;

            m_iterator.i0 = new_volume <= internal_buffer_size ? m_buffer : new value_type[new_volume];
        }
        m_size = new_size;
        m_iterator.set(
            m_iterator.i0,
            m_size.i1,
            1
        );
    }

    template<typename other_rep_>
    LITE_INLINE void swap(const array<signature, traits_type_, other_rep_>& other) 
    {
        regular_swap(other);
    }

    template<typename other_rep_>
    LITE_INLINE void swap(array<signature, traits_type_, other_rep_>& other) 
    {
        regular_swap(other);
    }

    LITE_INLINE void swap(array& other)
    {
        // fast swap
        if (m_iterator.i0 != m_buffer && other.m_iterator.i0 != other.m_buffer) {
            iterator tmp_iter = other.m_iterator;
            size_type tmp_size = other.m_size;

            other.m_iterator = m_iterator;
            other.m_size = m_size;

            m_iterator = tmp_iter;
            m_size = tmp_size;
        }
        else
            regular_swap(other);
    }


    LITE_INLINE ~array() 
    {
        if (m_iterator.i0 && m_iterator.i0 != m_buffer)
            delete[] m_iterator.i0;
    }

private:

    template<typename other_array_>
    LITE_INLINE void regular_swap(other_array_& other)
    {
        typedef b_iterator<iterator, typename other_array_::iterator, swapper<value_type> > iterator_type;

        if (m_size == other.size()) 
            for_each(iterator_type(m_iterator, other.begin()), m_size);
        else {
            typename other_array_::temporary_array tmp = other;

            other = *this;
            *this = tmp;
        }
    }

    //template<typename other_signature_, typename other_traits_type_, typename other_rep_>
    //friend class array;

    LITE_INLINE void init()
    {
        m_iterator.i0 = 0;
        m_size.set(0, 0);
        resize(m_size);
    }

    iterator m_iterator;
    size_type m_size;
    value_type m_buffer[internal_buffer_size >= 1 ? internal_buffer_size : 1];
};

/***********************************************************************************************************/

template<
    typename value_type_,
    int n0_, 
    int n1_, 
    int n2_, 
    typename traits_type_,
    int internal_buf_size_
    >
class array<
    value_type_[n0_][n1_][n2_],
    traits_type_,
    hybrid_rep<false, internal_buf_size_>
    >
{
public:
    typedef value_type_ signature[n0_][n1_][n2_];
    typedef traits_type_ traits_type;
    typedef value_type_ value_type;
    typedef const value_type_& const_reference;
    typedef value_type_& reference;

    typedef typename array_signature_traits<const signature>::default_iterator const_iterator;
    typedef typename array_signature_traits<signature>::default_iterator iterator;
    typedef typename array_signature_traits<signature>::size_type size_type;

    typedef typename array_helper<signature, traits_type_>::temporary_array temporary_array;
    typedef typename array_helper<signature, traits_type_>::fwd_temporary_array fwd_temporary_array;
    typedef typename array_helper<signature, traits_type_>::rev_temporary_array rev_temporary_array;

    static const int dimensions = 3;
    static const bool is_reverse = false;
    static const int internal_buffer_size = internal_buf_size_;

    LITE_INLINE array() 
    {
        init();
        resize(size_type());
    }

    explicit LITE_INLINE array(int n0, int n1, int n2)
    {
        init();
        resize(size_type(n0, n1, n2));
    }

    explicit LITE_INLINE array(const size_type& sz)
    {
        init();
        resize(sz);
    }

    LITE_INLINE array(const array& other) 
    {
        typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;

        init();
        resize(other.size());
        for_each(iterator_type(m_iterator, other.m_iterator), m_size);
    }

    template<typename other_rep_>
    LITE_INLINE array(const array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            assign<value_type> > 
            iterator_type;

        init();
        resize(other.size());
        for_each(iterator_type(m_iterator, other.begin()), m_size);
    }

    LITE_INLINE array(const value_type& value) 
    {
        typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;

        init();
        for_each(iterator_type(m_iterator, value), m_size);
    }

    LITE_INLINE array& operator=(const array& other) 
    {
        typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;

        resize(other.size());
        for_each(iterator_type(m_iterator, other.m_iterator), m_size);
        return *this;
    }

    template<typename other_rep_>
    LITE_INLINE array& operator=(const array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            assign<value_type> > 
            iterator_type;

        resize(other.size());
        for_each(iterator_type(m_iterator, other.begin()), m_size);
        return *this;
    }

    LITE_INLINE array& operator=(const value_type& value)
    {
        typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;

        for_each(iterator_type(m_iterator, value), m_size);
        return *this;
    }

    LITE_INLINE const_iterator begin() const
    {
        return m_iterator;
    }

    LITE_INLINE iterator begin()
    {
        return m_iterator;
    }

    LITE_INLINE size_type size() const
    {
        return m_size;
    }

    LITE_INLINE const_reference 
    operator()(int i0, int i1, int i2) const
    {
        return *(m_iterator.i0+i0*m_iterator.i1+i1*m_iterator.i2+i2*m_iterator.i3);
    }

    LITE_INLINE reference 
    operator()(int i0, int i1, int i2) 
    {
        return *(m_iterator.i0+i0*m_iterator.i1+i1*m_iterator.i2+i2*m_iterator.i3);
    }


    template<typename transform_type_>
    LITE_INLINE const typename transform_traits<array, transform_type_>::const_array
    operator[](const transform_type_& trans) const
    {
        typedef typename transform_traits<array, transform_type_>::const_array result_type;

        return result_type(begin(), size(), trans);
    }

    template<typename transform_type_>
    LITE_INLINE const typename transform_traits<array, transform_type_>::array
    operator[](const transform_type_& trans)
    {
        typedef typename transform_traits<array, transform_type_>::array result_type;

        return result_type(begin(), size(), trans);
    }

    LITE_INLINE const value_type* data() const
    {
        return m_iterator.i0;
    }

    LITE_INLINE value_type* data()
    {
        return m_iterator.i0;
    }

    LITE_INLINE void release() 
    {
        if (m_iterator.i0 && m_iterator.i0 != m_buffer)
            delete[] m_iterator.i0;

        m_iterator.i0 = 0;
        m_size.set(0, 0, 0);
    }

    LITE_INLINE void resize(int n0, int n1, int n2)
    {
        resize(size_type(n0, n1, n2));
    }

    LITE_INLINE void resize(const size_type& new_size)
    {
        int old_volumne = volume(m_size);
        int new_volume = volume(new_size);

        if (old_volumne != new_volume || m_iterator.i0==0) {
            if (m_iterator.i0 && m_iterator.i0 != m_buffer)
                delete[] m_iterator.i0;
            m_iterator.i0 = 0;
            m_size.set(0, 0, 0);

            if (new_volume == 0)
                return;

            m_iterator.i0 = new_volume <= internal_buffer_size ? m_buffer : new value_type[new_volume];
        }
        m_size = new_size;
        m_iterator.set(
            m_iterator.i0,
            m_size.i1*m_size.i2,
            m_size.i2,
            1
        );
    }

    template<typename other_rep_>
    LITE_INLINE void swap(const array<signature, traits_type_, other_rep_>& other) 
    {
        regular_swap(other);
    }

    template<typename other_rep_>
    LITE_INLINE void swap(array<signature, traits_type_, other_rep_>& other) 
    {
        regular_swap(other);
    }

    LITE_INLINE void swap(array& other)
    {
        // fast swap
        if (m_iterator.i0 != m_buffer && other.m_iterator.i0 != other.m_buffer) {
            iterator tmp_iter = other.m_iterator;
            size_type tmp_size = other.m_size;

            other.m_iterator = m_iterator;
            other.m_size = m_size;

            m_iterator = tmp_iter;
            m_size = tmp_size;
        }
        else
            regular_swap(other);
    }


    LITE_INLINE ~array() 
    {
        if (m_iterator.i0 && m_iterator.i0 != m_buffer)
            delete[] m_iterator.i0;
    }

private:

    template<typename other_array_>
    LITE_INLINE void regular_swap(other_array_& other)
    {
        typedef b_iterator<iterator, typename other_array_::iterator, swapper<value_type> > iterator_type;

        if (m_size == other.size()) 
            for_each(iterator_type(m_iterator, other.begin()), m_size);
        else {
            typename other_array_::temporary_array tmp = other;

            other = *this;
            *this = tmp;
        }
    }

    //template<typename other_signature_, typename other_traits_type_, typename other_rep_>
    //friend class array;

    LITE_INLINE void init()
    {
        m_iterator.i0 = 0;
        m_size.set(0, 0, 0);
        resize(m_size);
    }

    iterator m_iterator;
    size_type m_size;
    value_type m_buffer[internal_buffer_size >= 1 ? internal_buffer_size : 1];
};

/***********************************************************************************************************/

template<
    typename value_type_,
    typename traits_type_,
    int internal_buf_size_
    >
class array<
    value_type_,
    traits_type_,
    hybrid_rep<true, internal_buf_size_>
    >
{
public:
    typedef value_type_ signature;
    typedef traits_type_ traits_type;
    typedef value_type_ value_type;
    typedef const value_type_& const_reference;
    typedef value_type_& reference;

    typedef typename array_signature_traits<const signature>::default_rev_iterator const_iterator;
    typedef typename array_signature_traits<signature>::default_rev_iterator iterator;
    typedef typename array_signature_traits<signature>::size_type size_type;

    typedef typename array_helper<signature, traits_type_>::temporary_array temporary_array;
    typedef typename array_helper<signature, traits_type_>::fwd_temporary_array fwd_temporary_array;
    typedef typename array_helper<signature, traits_type_>::rev_temporary_array rev_temporary_array;

    static const int dimensions = 0;
    static const bool is_reverse = true;
    static const int internal_buffer_size = internal_buf_size_;



    explicit LITE_INLINE array(const size_type& sz)
    {
        init();
        resize(sz);
    }

    LITE_INLINE array(const array& other) 
    {
        typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;

        init();
        resize(other.size());
        for_each(iterator_type(m_iterator, other.m_iterator), m_size);
    }

    template<typename other_rep_>
    LITE_INLINE array(const array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            assign<value_type> > 
            iterator_type;

        init();
        resize(other.size());
        for_each(iterator_type(m_iterator, other.begin()), m_size);
    }

    LITE_INLINE array(const value_type& value) 
    {
        typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;

        init();
        for_each(iterator_type(m_iterator, value), m_size);
    }

    LITE_INLINE array& operator=(const array& other) 
    {
        typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;

        resize(other.size());
        for_each(iterator_type(m_iterator, other.m_iterator), m_size);
        return *this;
    }

    template<typename other_rep_>
    LITE_INLINE array& operator=(const array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            assign<value_type> > 
            iterator_type;

        resize(other.size());
        for_each(iterator_type(m_iterator, other.begin()), m_size);
        return *this;
    }

    LITE_INLINE array& operator=(const value_type& value)
    {
        typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;

        for_each(iterator_type(m_iterator, value), m_size);
        return *this;
    }

    LITE_INLINE const_iterator begin() const
    {
        return m_iterator;
    }

    LITE_INLINE iterator begin()
    {
        return m_iterator;
    }

    LITE_INLINE size_type size() const
    {
        return m_size;
    }

    LITE_INLINE const_reference 
    operator()() const
    {
        return *(m_iterator.i0);
    }

    LITE_INLINE reference 
    operator()() 
    {
        return *(m_iterator.i0);
    }


    template<typename transform_type_>
    LITE_INLINE const typename transform_traits<array, transform_type_>::const_array
    operator[](const transform_type_& trans) const
    {
        typedef typename transform_traits<array, transform_type_>::const_array result_type;

        return result_type(begin(), size(), trans);
    }

    template<typename transform_type_>
    LITE_INLINE const typename transform_traits<array, transform_type_>::array
    operator[](const transform_type_& trans)
    {
        typedef typename transform_traits<array, transform_type_>::array result_type;

        return result_type(begin(), size(), trans);
    }

    LITE_INLINE const value_type* data() const
    {
        return m_iterator.i0;
    }

    LITE_INLINE value_type* data()
    {
        return m_iterator.i0;
    }

    LITE_INLINE void release() 
    {
        if (m_iterator.i0 && m_iterator.i0 != m_buffer)
            delete[] m_iterator.i0;

        m_iterator.i0 = 0;
        m_size.set();
    }

    LITE_INLINE void resize()
    {
        resize(size_type());
    }

    LITE_INLINE void resize(const size_type& new_size)
    {
        int old_volumne = volume(m_size);
        int new_volume = volume(new_size);

        if (old_volumne != new_volume || m_iterator.i0==0) {
            if (m_iterator.i0 && m_iterator.i0 != m_buffer)
                delete[] m_iterator.i0;
            m_iterator.i0 = 0;
            m_size.set();

            if (new_volume == 0)
                return;

            m_iterator.i0 = new_volume <= internal_buffer_size ? m_buffer : new value_type[new_volume];
        }
        m_size = new_size;
        m_iterator.set(
            m_iterator.i0
        );
    }

    template<typename other_rep_>
    LITE_INLINE void swap(const array<signature, traits_type_, other_rep_>& other) 
    {
        regular_swap(other);
    }

    template<typename other_rep_>
    LITE_INLINE void swap(array<signature, traits_type_, other_rep_>& other) 
    {
        regular_swap(other);
    }

    LITE_INLINE void swap(array& other)
    {
        // fast swap
        if (m_iterator.i0 != m_buffer && other.m_iterator.i0 != other.m_buffer) {
            iterator tmp_iter = other.m_iterator;
            size_type tmp_size = other.m_size;

            other.m_iterator = m_iterator;
            other.m_size = m_size;

            m_iterator = tmp_iter;
            m_size = tmp_size;
        }
        else
            regular_swap(other);
    }


    LITE_INLINE ~array() 
    {
        if (m_iterator.i0 && m_iterator.i0 != m_buffer)
            delete[] m_iterator.i0;
    }

private:

    template<typename other_array_>
    LITE_INLINE void regular_swap(other_array_& other)
    {
        typedef b_iterator<iterator, typename other_array_::iterator, swapper<value_type> > iterator_type;

        if (m_size == other.size()) 
            for_each(iterator_type(m_iterator, other.begin()), m_size);
        else {
            typename other_array_::temporary_array tmp = other;

            other = *this;
            *this = tmp;
        }
    }

    //template<typename other_signature_, typename other_traits_type_, typename other_rep_>
    //friend class array;

    LITE_INLINE void init()
    {
        m_iterator.i0 = 0;
        m_size.set();
        resize(m_size);
    }

    iterator m_iterator;
    size_type m_size;
    value_type m_buffer[internal_buffer_size >= 1 ? internal_buffer_size : 1];
};

/***********************************************************************************************************/

template<
    typename value_type_,
    int n0_, 
    typename traits_type_,
    int internal_buf_size_
    >
class array<
    value_type_[n0_],
    traits_type_,
    hybrid_rep<true, internal_buf_size_>
    >
{
public:
    typedef value_type_ signature[n0_];
    typedef traits_type_ traits_type;
    typedef value_type_ value_type;
    typedef const value_type_& const_reference;
    typedef value_type_& reference;

    typedef typename array_signature_traits<const signature>::default_rev_iterator const_iterator;
    typedef typename array_signature_traits<signature>::default_rev_iterator iterator;
    typedef typename array_signature_traits<signature>::size_type size_type;

    typedef typename array_helper<signature, traits_type_>::temporary_array temporary_array;
    typedef typename array_helper<signature, traits_type_>::fwd_temporary_array fwd_temporary_array;
    typedef typename array_helper<signature, traits_type_>::rev_temporary_array rev_temporary_array;

    static const int dimensions = 1;
    static const bool is_reverse = true;
    static const int internal_buffer_size = internal_buf_size_;

    LITE_INLINE array() 
    {
        init();
        resize(size_type());
    }

    explicit LITE_INLINE array(int n0)
    {
        init();
        resize(size_type(n0));
    }

    explicit LITE_INLINE array(const size_type& sz)
    {
        init();
        resize(sz);
    }

    LITE_INLINE array(const array& other) 
    {
        typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;

        init();
        resize(other.size());
        for_each(iterator_type(m_iterator, other.m_iterator), m_size);
    }

    template<typename other_rep_>
    LITE_INLINE array(const array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            assign<value_type> > 
            iterator_type;

        init();
        resize(other.size());
        for_each(iterator_type(m_iterator, other.begin()), m_size);
    }

    LITE_INLINE array(const value_type& value) 
    {
        typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;

        init();
        for_each(iterator_type(m_iterator, value), m_size);
    }

    LITE_INLINE array& operator=(const array& other) 
    {
        typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;

        resize(other.size());
        for_each(iterator_type(m_iterator, other.m_iterator), m_size);
        return *this;
    }

    template<typename other_rep_>
    LITE_INLINE array& operator=(const array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            assign<value_type> > 
            iterator_type;

        resize(other.size());
        for_each(iterator_type(m_iterator, other.begin()), m_size);
        return *this;
    }

    LITE_INLINE array& operator=(const value_type& value)
    {
        typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;

        for_each(iterator_type(m_iterator, value), m_size);
        return *this;
    }

    LITE_INLINE const_iterator begin() const
    {
        return m_iterator;
    }

    LITE_INLINE iterator begin()
    {
        return m_iterator;
    }

    LITE_INLINE size_type size() const
    {
        return m_size;
    }

    LITE_INLINE const_reference 
    operator()(int i0) const
    {
        return *(m_iterator.i0+i0*m_iterator.i1);
    }

    LITE_INLINE reference 
    operator()(int i0) 
    {
        return *(m_iterator.i0+i0*m_iterator.i1);
    }

    LITE_INLINE const_reference 
    operator[](int i0) const
    {
        return *(m_iterator.i0+i0*m_iterator.i1);
    }

    LITE_INLINE reference 
    operator[](int i0)
    {
        return *(m_iterator.i0+i0*m_iterator.i1);
    }


    template<typename transform_type_>
    LITE_INLINE const typename transform_traits<array, transform_type_>::const_array
    operator[](const transform_type_& trans) const
    {
        typedef typename transform_traits<array, transform_type_>::const_array result_type;

        return result_type(begin(), size(), trans);
    }

    template<typename transform_type_>
    LITE_INLINE const typename transform_traits<array, transform_type_>::array
    operator[](const transform_type_& trans)
    {
        typedef typename transform_traits<array, transform_type_>::array result_type;

        return result_type(begin(), size(), trans);
    }

    LITE_INLINE const value_type* data() const
    {
        return m_iterator.i0;
    }

    LITE_INLINE value_type* data()
    {
        return m_iterator.i0;
    }

    LITE_INLINE void release() 
    {
        if (m_iterator.i0 && m_iterator.i0 != m_buffer)
            delete[] m_iterator.i0;

        m_iterator.i0 = 0;
        m_size.set(0);
    }

    LITE_INLINE void resize(int n0)
    {
        resize(size_type(n0));
    }

    LITE_INLINE void resize(const size_type& new_size)
    {
        int old_volumne = volume(m_size);
        int new_volume = volume(new_size);

        if (old_volumne != new_volume || m_iterator.i0==0) {
            if (m_iterator.i0 && m_iterator.i0 != m_buffer)
                delete[] m_iterator.i0;
            m_iterator.i0 = 0;
            m_size.set(0);

            if (new_volume == 0)
                return;

            m_iterator.i0 = new_volume <= internal_buffer_size ? m_buffer : new value_type[new_volume];
        }
        m_size = new_size;
        m_iterator.set(
            m_iterator.i0,
            1
        );
    }

    template<typename other_rep_>
    LITE_INLINE void swap(const array<signature, traits_type_, other_rep_>& other) 
    {
        regular_swap(other);
    }

    template<typename other_rep_>
    LITE_INLINE void swap(array<signature, traits_type_, other_rep_>& other) 
    {
        regular_swap(other);
    }

    LITE_INLINE void swap(array& other)
    {
        // fast swap
        if (m_iterator.i0 != m_buffer && other.m_iterator.i0 != other.m_buffer) {
            iterator tmp_iter = other.m_iterator;
            size_type tmp_size = other.m_size;

            other.m_iterator = m_iterator;
            other.m_size = m_size;

            m_iterator = tmp_iter;
            m_size = tmp_size;
        }
        else
            regular_swap(other);
    }


    LITE_INLINE ~array() 
    {
        if (m_iterator.i0 && m_iterator.i0 != m_buffer)
            delete[] m_iterator.i0;
    }

private:

    template<typename other_array_>
    LITE_INLINE void regular_swap(other_array_& other)
    {
        typedef b_iterator<iterator, typename other_array_::iterator, swapper<value_type> > iterator_type;

        if (m_size == other.size()) 
            for_each(iterator_type(m_iterator, other.begin()), m_size);
        else {
            typename other_array_::temporary_array tmp = other;

            other = *this;
            *this = tmp;
        }
    }

    //template<typename other_signature_, typename other_traits_type_, typename other_rep_>
    //friend class array;

    LITE_INLINE void init()
    {
        m_iterator.i0 = 0;
        m_size.set(0);
        resize(m_size);
    }

    iterator m_iterator;
    size_type m_size;
    value_type m_buffer[internal_buffer_size >= 1 ? internal_buffer_size : 1];
};

/***********************************************************************************************************/

template<
    typename value_type_,
    int n0_, 
    int n1_, 
    typename traits_type_,
    int internal_buf_size_
    >
class array<
    value_type_[n0_][n1_],
    traits_type_,
    hybrid_rep<true, internal_buf_size_>
    >
{
public:
    typedef value_type_ signature[n0_][n1_];
    typedef traits_type_ traits_type;
    typedef value_type_ value_type;
    typedef const value_type_& const_reference;
    typedef value_type_& reference;

    typedef typename array_signature_traits<const signature>::default_rev_iterator const_iterator;
    typedef typename array_signature_traits<signature>::default_rev_iterator iterator;
    typedef typename array_signature_traits<signature>::size_type size_type;

    typedef typename array_helper<signature, traits_type_>::temporary_array temporary_array;
    typedef typename array_helper<signature, traits_type_>::fwd_temporary_array fwd_temporary_array;
    typedef typename array_helper<signature, traits_type_>::rev_temporary_array rev_temporary_array;

    static const int dimensions = 2;
    static const bool is_reverse = true;
    static const int internal_buffer_size = internal_buf_size_;

    LITE_INLINE array() 
    {
        init();
        resize(size_type());
    }

    explicit LITE_INLINE array(int n0, int n1)
    {
        init();
        resize(size_type(n0, n1));
    }

    explicit LITE_INLINE array(const size_type& sz)
    {
        init();
        resize(sz);
    }

    LITE_INLINE array(const array& other) 
    {
        typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;

        init();
        resize(other.size());
        for_each(iterator_type(m_iterator, other.m_iterator), m_size);
    }

    template<typename other_rep_>
    LITE_INLINE array(const array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            assign<value_type> > 
            iterator_type;

        init();
        resize(other.size());
        for_each(iterator_type(m_iterator, other.begin()), m_size);
    }

    LITE_INLINE array(const value_type& value) 
    {
        typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;

        init();
        for_each(iterator_type(m_iterator, value), m_size);
    }

    LITE_INLINE array& operator=(const array& other) 
    {
        typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;

        resize(other.size());
        for_each(iterator_type(m_iterator, other.m_iterator), m_size);
        return *this;
    }

    template<typename other_rep_>
    LITE_INLINE array& operator=(const array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            assign<value_type> > 
            iterator_type;

        resize(other.size());
        for_each(iterator_type(m_iterator, other.begin()), m_size);
        return *this;
    }

    LITE_INLINE array& operator=(const value_type& value)
    {
        typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;

        for_each(iterator_type(m_iterator, value), m_size);
        return *this;
    }

    LITE_INLINE const_iterator begin() const
    {
        return m_iterator;
    }

    LITE_INLINE iterator begin()
    {
        return m_iterator;
    }

    LITE_INLINE size_type size() const
    {
        return m_size;
    }

    LITE_INLINE const_reference 
    operator()(int i0, int i1) const
    {
        return *(m_iterator.i0+i0*m_iterator.i1+i1*m_iterator.i2);
    }

    LITE_INLINE reference 
    operator()(int i0, int i1) 
    {
        return *(m_iterator.i0+i0*m_iterator.i1+i1*m_iterator.i2);
    }


    template<typename transform_type_>
    LITE_INLINE const typename transform_traits<array, transform_type_>::const_array
    operator[](const transform_type_& trans) const
    {
        typedef typename transform_traits<array, transform_type_>::const_array result_type;

        return result_type(begin(), size(), trans);
    }

    template<typename transform_type_>
    LITE_INLINE const typename transform_traits<array, transform_type_>::array
    operator[](const transform_type_& trans)
    {
        typedef typename transform_traits<array, transform_type_>::array result_type;

        return result_type(begin(), size(), trans);
    }

    LITE_INLINE const value_type* data() const
    {
        return m_iterator.i0;
    }

    LITE_INLINE value_type* data()
    {
        return m_iterator.i0;
    }

    LITE_INLINE void release() 
    {
        if (m_iterator.i0 && m_iterator.i0 != m_buffer)
            delete[] m_iterator.i0;

        m_iterator.i0 = 0;
        m_size.set(0, 0);
    }

    LITE_INLINE void resize(int n0, int n1)
    {
        resize(size_type(n0, n1));
    }

    LITE_INLINE void resize(const size_type& new_size)
    {
        int old_volumne = volume(m_size);
        int new_volume = volume(new_size);

        if (old_volumne != new_volume || m_iterator.i0==0) {
            if (m_iterator.i0 && m_iterator.i0 != m_buffer)
                delete[] m_iterator.i0;
            m_iterator.i0 = 0;
            m_size.set(0, 0);

            if (new_volume == 0)
                return;

            m_iterator.i0 = new_volume <= internal_buffer_size ? m_buffer : new value_type[new_volume];
        }
        m_size = new_size;
        m_iterator.set(
            m_iterator.i0,
            1,
            m_size.i0
        );
    }

    template<typename other_rep_>
    LITE_INLINE void swap(const array<signature, traits_type_, other_rep_>& other) 
    {
        regular_swap(other);
    }

    template<typename other_rep_>
    LITE_INLINE void swap(array<signature, traits_type_, other_rep_>& other) 
    {
        regular_swap(other);
    }

    LITE_INLINE void swap(array& other)
    {
        // fast swap
        if (m_iterator.i0 != m_buffer && other.m_iterator.i0 != other.m_buffer) {
            iterator tmp_iter = other.m_iterator;
            size_type tmp_size = other.m_size;

            other.m_iterator = m_iterator;
            other.m_size = m_size;

            m_iterator = tmp_iter;
            m_size = tmp_size;
        }
        else
            regular_swap(other);
    }


    LITE_INLINE ~array() 
    {
        if (m_iterator.i0 && m_iterator.i0 != m_buffer)
            delete[] m_iterator.i0;
    }

private:

    template<typename other_array_>
    LITE_INLINE void regular_swap(other_array_& other)
    {
        typedef b_iterator<iterator, typename other_array_::iterator, swapper<value_type> > iterator_type;

        if (m_size == other.size()) 
            for_each(iterator_type(m_iterator, other.begin()), m_size);
        else {
            typename other_array_::temporary_array tmp = other;

            other = *this;
            *this = tmp;
        }
    }

    //template<typename other_signature_, typename other_traits_type_, typename other_rep_>
    //friend class array;

    LITE_INLINE void init()
    {
        m_iterator.i0 = 0;
        m_size.set(0, 0);
        resize(m_size);
    }

    iterator m_iterator;
    size_type m_size;
    value_type m_buffer[internal_buffer_size >= 1 ? internal_buffer_size : 1];
};

/***********************************************************************************************************/

template<
    typename value_type_,
    int n0_, 
    int n1_, 
    int n2_, 
    typename traits_type_,
    int internal_buf_size_
    >
class array<
    value_type_[n0_][n1_][n2_],
    traits_type_,
    hybrid_rep<true, internal_buf_size_>
    >
{
public:
    typedef value_type_ signature[n0_][n1_][n2_];
    typedef traits_type_ traits_type;
    typedef value_type_ value_type;
    typedef const value_type_& const_reference;
    typedef value_type_& reference;

    typedef typename array_signature_traits<const signature>::default_rev_iterator const_iterator;
    typedef typename array_signature_traits<signature>::default_rev_iterator iterator;
    typedef typename array_signature_traits<signature>::size_type size_type;

    typedef typename array_helper<signature, traits_type_>::temporary_array temporary_array;
    typedef typename array_helper<signature, traits_type_>::fwd_temporary_array fwd_temporary_array;
    typedef typename array_helper<signature, traits_type_>::rev_temporary_array rev_temporary_array;

    static const int dimensions = 3;
    static const bool is_reverse = true;
    static const int internal_buffer_size = internal_buf_size_;

    LITE_INLINE array() 
    {
        init();
        resize(size_type());
    }

    explicit LITE_INLINE array(int n0, int n1, int n2)
    {
        init();
        resize(size_type(n0, n1, n2));
    }

    explicit LITE_INLINE array(const size_type& sz)
    {
        init();
        resize(sz);
    }

    LITE_INLINE array(const array& other) 
    {
        typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;

        init();
        resize(other.size());
        for_each(iterator_type(m_iterator, other.m_iterator), m_size);
    }

    template<typename other_rep_>
    LITE_INLINE array(const array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            assign<value_type> > 
            iterator_type;

        init();
        resize(other.size());
        for_each(iterator_type(m_iterator, other.begin()), m_size);
    }

    LITE_INLINE array(const value_type& value) 
    {
        typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;

        init();
        for_each(iterator_type(m_iterator, value), m_size);
    }

    LITE_INLINE array& operator=(const array& other) 
    {
        typedef b_iterator<iterator, const_iterator, assign<value_type> > iterator_type;

        resize(other.size());
        for_each(iterator_type(m_iterator, other.m_iterator), m_size);
        return *this;
    }

    template<typename other_rep_>
    LITE_INLINE array& operator=(const array<signature, traits_type_, other_rep_>& other) 
    {
        typedef b_iterator<
            iterator, 
            typename array<signature, traits_type_, other_rep_>::const_iterator, 
            assign<value_type> > 
            iterator_type;

        resize(other.size());
        for_each(iterator_type(m_iterator, other.begin()), m_size);
        return *this;
    }

    LITE_INLINE array& operator=(const value_type& value)
    {
        typedef b_iterator<iterator, c_iterator<value_type>, assign<value_type> > iterator_type;

        for_each(iterator_type(m_iterator, value), m_size);
        return *this;
    }

    LITE_INLINE const_iterator begin() const
    {
        return m_iterator;
    }

    LITE_INLINE iterator begin()
    {
        return m_iterator;
    }

    LITE_INLINE size_type size() const
    {
        return m_size;
    }

    LITE_INLINE const_reference 
    operator()(int i0, int i1, int i2) const
    {
        return *(m_iterator.i0+i0*m_iterator.i1+i1*m_iterator.i2+i2*m_iterator.i3);
    }

    LITE_INLINE reference 
    operator()(int i0, int i1, int i2) 
    {
        return *(m_iterator.i0+i0*m_iterator.i1+i1*m_iterator.i2+i2*m_iterator.i3);
    }


    template<typename transform_type_>
    LITE_INLINE const typename transform_traits<array, transform_type_>::const_array
    operator[](const transform_type_& trans) const
    {
        typedef typename transform_traits<array, transform_type_>::const_array result_type;

        return result_type(begin(), size(), trans);
    }

    template<typename transform_type_>
    LITE_INLINE const typename transform_traits<array, transform_type_>::array
    operator[](const transform_type_& trans)
    {
        typedef typename transform_traits<array, transform_type_>::array result_type;

        return result_type(begin(), size(), trans);
    }

    LITE_INLINE const value_type* data() const
    {
        return m_iterator.i0;
    }

    LITE_INLINE value_type* data()
    {
        return m_iterator.i0;
    }

    LITE_INLINE void release() 
    {
        if (m_iterator.i0 && m_iterator.i0 != m_buffer)
            delete[] m_iterator.i0;

        m_iterator.i0 = 0;
        m_size.set(0, 0, 0);
    }

    LITE_INLINE void resize(int n0, int n1, int n2)
    {
        resize(size_type(n0, n1, n2));
    }

    LITE_INLINE void resize(const size_type& new_size)
    {
        int old_volumne = volume(m_size);
        int new_volume = volume(new_size);

        if (old_volumne != new_volume || m_iterator.i0==0) {
            if (m_iterator.i0 && m_iterator.i0 != m_buffer)
                delete[] m_iterator.i0;
            m_iterator.i0 = 0;
            m_size.set(0, 0, 0);

            if (new_volume == 0)
                return;

            m_iterator.i0 = new_volume <= internal_buffer_size ? m_buffer : new value_type[new_volume];
        }
        m_size = new_size;
        m_iterator.set(
            m_iterator.i0,
            1,
            m_size.i0,
            m_size.i0*m_size.i1
        );
    }

    template<typename other_rep_>
    LITE_INLINE void swap(const array<signature, traits_type_, other_rep_>& other) 
    {
        regular_swap(other);
    }

    template<typename other_rep_>
    LITE_INLINE void swap(array<signature, traits_type_, other_rep_>& other) 
    {
        regular_swap(other);
    }

    LITE_INLINE void swap(array& other)
    {
        // fast swap
        if (m_iterator.i0 != m_buffer && other.m_iterator.i0 != other.m_buffer) {
            iterator tmp_iter = other.m_iterator;
            size_type tmp_size = other.m_size;

            other.m_iterator = m_iterator;
            other.m_size = m_size;

            m_iterator = tmp_iter;
            m_size = tmp_size;
        }
        else
            regular_swap(other);
    }


    LITE_INLINE ~array() 
    {
        if (m_iterator.i0 && m_iterator.i0 != m_buffer)
            delete[] m_iterator.i0;
    }

private:

    template<typename other_array_>
    LITE_INLINE void regular_swap(other_array_& other)
    {
        typedef b_iterator<iterator, typename other_array_::iterator, swapper<value_type> > iterator_type;

        if (m_size == other.size()) 
            for_each(iterator_type(m_iterator, other.begin()), m_size);
        else {
            typename other_array_::temporary_array tmp = other;

            other = *this;
            *this = tmp;
        }
    }

    //template<typename other_signature_, typename other_traits_type_, typename other_rep_>
    //friend class array;

    LITE_INLINE void init()
    {
        m_iterator.i0 = 0;
        m_size.set(0, 0, 0);
        resize(m_size);
    }

    iterator m_iterator;
    size_type m_size;
    value_type m_buffer[internal_buffer_size >= 1 ? internal_buffer_size : 1];
};

/***********************************************************************************************************/


/***********************************************************************************************************/
/* transform_traits ****************************************************************************************/
/***********************************************************************************************************/

#ifdef DOCUMENTATION_ONLY
/*!
    \brief 
    This class provides information about applying a transform object to an array object.
    It can be used for example to get the exact type of the array that is returned as the result of applying
    a transform.

    \ingroup array_transforms

    \par Example
    
    \code
        typedef array<float[5][5]> A;
    
        A a;

        transform_traits<A, row>::array a_r1 = a[row(1)];

        a_r1 = -1;
        // the previous line is equivalent to:
        a[row(1)] = -1;

        transform_traits<A, row>::temporary_array a_rt = a[row(1)];
        a[row(1)] = a[row(2)];
        a[row(2)] = a_rt;
        // the previous 3 lines is equivalent to:
        swap(a[row(1)], a[row(2)]);
    \endcode
*/

template<typename array_type_, typename trans_type_>
struct transform_traits
{
    //! The size type of the resulting array
    typedef typename size_transformer<trans_type_, typename array_type_::size_type>::size_type size_type;

    //! The signature of the resulting array
    typedef typename detail::size_to_signature<size_type, typename array_type_::value_type>::type signature;

    //! The traits type of the resulting array which is the same as the traits type of the original array
    typedef typename array_type_::traits_type traits_type;

    //! The iterator type of the resulting array.
    typedef typename iterator_transformer<
        trans_type_, 
        typename array_type_::iterator, 
        typename array_type_::size_type>::iterator_type iterator;

    //! The const iterator type of the resulting array.
    typedef typename iterator_transformer<
        trans_type_, 
        typename array_type_::const_iterator, 
        typename array_type_::size_type>::iterator_type const_iterator;

    //! The exact type of the resulting array when the transform is applied to a non-const array object
    typedef ::lite::array<signature, traits_type, reference_rep<iterator> > array;
    
    //! The exact type of the resulting array when the transform is applied to a const array object
    typedef ::lite::array<signature, traits_type, reference_rep<const_iterator> > const_array;

    /*! 
        \brief 
        An array type compatible with the resulting array (i.e. with the same signature and traits).
        Suitable for defining temporary variables or return types.
    */
    typedef typename array_helper<signature, traits_type>::temporary_array temporary_array;

    /*! 
        \brief 
        An array type compatible with the resulting array (i.e. with the same signature and traits)
        and with forward storage. Suitable for defining temporary variables or return types.
    */
    typedef typename array_helper<signature, traits_type>::fwd_temporary_array fwd_temporary_array;

    /*! 
        \brief 
        An array type compatible with the resulting array (i.e. with the same signature and traits)
        and with reverse storage. Suitable for defining temporary variables or return types.
    */
    typedef typename array_helper<signature, traits_type>::rev_temporary_array rev_temporary_array;
};

#else // DOCUMENTATION_ONLY

template<typename array_type_, typename trans_type_>
struct transform_traits<
    array_type_, 
    trans_type_, 
    typename detail::enable_if<
        detail::defined<typename size_transformer<trans_type_, 
            typename array_type_::size_type>::size_type>::value
        >::type
    >
{
    typedef typename size_transformer<trans_type_, typename array_type_::size_type>::size_type size_type;
    typedef typename detail::size_to_signature<size_type, typename array_type_::value_type>::type signature;
    typedef typename array_type_::traits_type traits_type;

    typedef typename iterator_transformer<
        trans_type_, 
        typename array_type_::iterator, 
        typename array_type_::size_type>::iterator_type iterator;

    typedef typename iterator_transformer<
        trans_type_, 
        typename array_type_::const_iterator, 
        typename array_type_::size_type>::iterator_type const_iterator;

    typedef ::lite::array<signature, traits_type, reference_rep<iterator> > array;
    typedef ::lite::array<signature, traits_type, reference_rep<const_iterator> > const_array;

    typedef typename array_helper<signature, traits_type>::temporary_array temporary_array;
    typedef typename array_helper<signature, traits_type>::fwd_temporary_array fwd_temporary_array;
    typedef typename array_helper<signature, traits_type>::rev_temporary_array rev_temporary_array;
};

#endif // DOCUMENTATION_ONLY

/***********************************************************************************************************/
/* function objects ****************************************************************************************/
/***********************************************************************************************************/

template<typename type_>
class uplus
{ 
public: 
    typedef type_ argument_type;
    typedef type_ result_type;

    LITE_INLINE result_type operator()(const argument_type& a) const 
    { return +a; } 
};

template<typename type_>
class negate
{ 
public: 
    typedef type_ argument_type;
    typedef type_ result_type;

    LITE_INLINE result_type operator()(const argument_type& a) const 
    { return -a; } 
};

template<typename type_>
class plus
{ 
public: 
    typedef type_ first_argument_type;
    typedef type_ second_argument_type;
    typedef type_ result_type;

    LITE_INLINE result_type operator()(const first_argument_type& a, const second_argument_type& b) const 
    { return a + b; } 
};

template<typename type_>
class minus
{ 
public: 
    typedef type_ first_argument_type;
    typedef type_ second_argument_type;
    typedef type_ result_type;

    LITE_INLINE result_type operator()(const first_argument_type& a, const second_argument_type& b) const 
    { return a - b; } 
};

template<typename type_>
class multiplies
{ 
public: 
    typedef type_ first_argument_type;
    typedef type_ second_argument_type;
    typedef type_ result_type;

    LITE_INLINE result_type operator()(const first_argument_type& a, const second_argument_type& b) const 
    { return a*b; } 
};

template<typename type_>
class divides
{ 
public: 
    typedef type_ first_argument_type;
    typedef type_ second_argument_type;
    typedef type_ result_type;

    LITE_INLINE result_type operator()(const first_argument_type& a, const second_argument_type& b) const 
    { return a/b; } 
};

template<typename type_>
class assign
{ 
public: 
    typedef type_ first_argument_type;
    typedef type_ second_argument_type;
    typedef type_& result_type;

    LITE_INLINE result_type operator()(first_argument_type& a, const second_argument_type& b) const 
    { return a = b; } 
};

template<typename type_>
class plus_assign
{ 
public: 
    typedef type_ first_argument_type;
    typedef type_ second_argument_type;
    typedef type_& result_type;

    LITE_INLINE result_type operator()(first_argument_type& a, const second_argument_type& b) const 
    { return a += b; } 
};

template<typename type_>
class minus_assign
{ 
public: 
    typedef type_ first_argument_type;
    typedef type_ second_argument_type;
    typedef type_& result_type;

    LITE_INLINE result_type operator()(first_argument_type& a, const second_argument_type& b) const 
    { return a -= b; } 
};

template<typename type_>
class multiplies_assign
{ 
public: 
    typedef type_ first_argument_type;
    typedef type_ second_argument_type;
    typedef type_& result_type;

    LITE_INLINE result_type operator()(first_argument_type& a, const second_argument_type& b) const 
    { return a *= b; } 
};

template<typename type_>
class divides_assign
{ 
public: 
    typedef type_ first_argument_type;
    typedef type_ second_argument_type;
    typedef type_& result_type;

    LITE_INLINE result_type operator()(first_argument_type& a, const second_argument_type& b) const 
    { return a /= b; } 
};

template<typename type_>
class minimum
{ 
public: 
    typedef type_ first_argument_type;
    typedef type_ second_argument_type;
    typedef const type_& result_type;

    LITE_INLINE result_type operator()(const first_argument_type& a, const second_argument_type& b) const 
    { return a < b ? a : b; } 
};

template<typename type_>
class maximum
{ 
public: 
    typedef type_ first_argument_type;
    typedef type_ second_argument_type;
    typedef const type_& result_type;

    LITE_INLINE result_type operator()(const first_argument_type& a, const second_argument_type& b) const 
    { return a > b ? a : b; } 
};

template<typename type_>
class square
{ 
public: 
    typedef type_ argument_type;
    typedef type_ result_type;

    LITE_INLINE result_type operator()(const argument_type& a) const 
    { return a*a; } 
};

template<typename type_>
class less
{ 
public: 
    typedef type_ first_argument_type;
    typedef type_ second_argument_type;
    typedef bool result_type;

    LITE_INLINE result_type operator()(const first_argument_type& a, const second_argument_type& b) const 
    { return a < b; } 
};

template<typename type_>
class less_equal
{ 
public: 
    typedef type_ first_argument_type;
    typedef type_ second_argument_type;
    typedef bool result_type;

    LITE_INLINE result_type operator()(const first_argument_type& a, const second_argument_type& b) const 
    { return a <= b; } 
};

template<typename type_>
class equal_to
{ 
public: 
    typedef type_ first_argument_type;
    typedef type_ second_argument_type;
    typedef bool result_type;

    LITE_INLINE result_type operator()(const first_argument_type& a, const second_argument_type& b) const 
    { return a == b; } 
};

template<typename type_>
class greater_equal
{ 
public: 
    typedef type_ first_argument_type;
    typedef type_ second_argument_type;
    typedef bool result_type;

    LITE_INLINE result_type operator()(const first_argument_type& a, const second_argument_type& b) const 
    { return a >= b; } 
};

template<typename type_>
class greater
{ 
public: 
    typedef type_ first_argument_type;
    typedef type_ second_argument_type;
    typedef bool result_type;

    LITE_INLINE result_type operator()(const first_argument_type& a, const second_argument_type& b) const 
    { return a > b; } 
};

template<typename type_>
class compare3
{ 
public: 
    typedef type_ first_argument_type;
    typedef type_ second_argument_type;
    typedef int result_type;

    LITE_INLINE result_type operator()(const first_argument_type& a, const second_argument_type& b) const 
    { return a < b ? -1 : b < a ? 1 : 0; } 
};

template<typename type_>
class round
{ 
public: 
    typedef type_ argument_type;
    typedef type_ result_type;

    round(const type_& normal = type_(1)) : m_normal(normal) {}

    LITE_INLINE result_type operator()(const argument_type& a) const 
    { return (a+m_normal)-m_normal; } 

private:
    type_ m_normal;
};

template<typename type_>
class accumulator
{ 
public: 
    typedef type_ argument_type;
    typedef void result_type;

    LITE_INLINE accumulator(const type_& value = type_()) 
        : m_value(value) 
    {}

    LITE_INLINE accumulator(const accumulator& other) 
        : m_value(other.m_value) 
    {}

    LITE_INLINE accumulator& operator=(const accumulator& other)
    {
        m_value = other.m_value;
        return *this;
    }

    LITE_INLINE void operator()(const argument_type& a) 
    { 
        m_value += a;
    }

    LITE_INLINE type_ operator()() const
    { 
        return m_value;
    }

private:
    type_ m_value;
};

template<typename type_>
class while_equal
{ 
public: 
    typedef type_ argument_type;
    typedef bool result_type;

    LITE_INLINE while_equal(): m_result() {}

    LITE_INLINE while_equal(const while_equal& other) : m_result(other.m_result) {}

    LITE_INLINE while_equal& operator=(const while_equal& other) 
    { 
        m_result = other.m_result;
        return *this; 
    }

    LITE_INLINE result_type operator()(const argument_type& a) 
    { 
        if (a == 0)
            return true;

        m_result = a;
        return false;
    }
    
    LITE_INLINE argument_type operator()() const
    {
        return m_result;
    }

private:
    argument_type m_result;
};


template<typename type_>
class swapper
{ 
public: 
    typedef type_ first_argument_type;
    typedef type_ second_argument_type;
    typedef bool result_type;

    LITE_INLINE result_type operator()(first_argument_type& a, second_argument_type& b) const 
    { 
        std::swap(a, b);
        return true; 
    } 
};

/***********************************************************************************************************/
/* apply<F>(A) *********************************************************************************************/
/***********************************************************************************************************/

template<typename func_type_, typename signature_, typename traits_type_, typename rep_>
LITE_INLINE array<signature_, traits_type_, reference_rep<u_iterator<
    typename array<signature_,traits_type_, rep_>::const_iterator,
    func_type_>
    > >
apply(const array<signature_, traits_type_, rep_>& a)
{
    typedef array<signature_, traits_type_, reference_rep<u_iterator<
        typename array<signature_,traits_type_, rep_>::const_iterator,
        func_type_> > 
    > result_type;

    return result_type(a.begin(), a.size());
}

template<typename func_type_, typename signature_, typename traits_type_, typename rep_>
LITE_INLINE array<signature_, traits_type_, reference_rep<u_iterator<
    typename array<signature_,traits_type_, rep_>::iterator,
    func_type_>
    > >
apply(array<signature_, traits_type_, rep_>& a)
{
    typedef array<signature_, traits_type_, reference_rep<u_iterator<
        typename array<signature_,traits_type_, rep_>::iterator,
        func_type_> > 
    > result_type;

    return result_type(a.begin(), a.size());
}

/***********************************************************************************************************/
/* apply(A,f) **********************************************************************************************/
/***********************************************************************************************************/

template<typename func_type_, typename signature_, typename traits_type_, typename rep_>
LITE_INLINE array<signature_, traits_type_, reference_rep<u_iterator<
    typename array<signature_,traits_type_, rep_>::const_iterator,
    func_type_,
    false>
    > >
apply(const array<signature_, traits_type_, rep_>& a, const func_type_& func)
{
    typedef array<signature_, traits_type_, reference_rep<u_iterator<
        typename array<signature_,traits_type_, rep_>::const_iterator,
        func_type_,
        false> > 
    > result_type;

    return result_type(a.begin(), func, a.size());
}

template<typename func_type_, typename signature_, typename traits_type_, typename rep_>
LITE_INLINE array<signature_, traits_type_, reference_rep<u_iterator<
    typename array<signature_,traits_type_, rep_>::iterator,
    func_type_,
    false>
    > >
apply(array<signature_, traits_type_, rep_>& a, const func_type_& func)
{
    typedef array<signature_, traits_type_, reference_rep<u_iterator<
        typename array<signature_,traits_type_, rep_>::iterator,
        func_type_,
        false> > 
    > result_type;

    return result_type(a.begin(), func, a.size());
}


/***********************************************************************************************************/
/* apply<F>(A,A) *******************************************************************************************/
/***********************************************************************************************************/

template<typename func_type_, typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
LITE_INLINE 
array<signature_, traits_type_, reference_rep<b_iterator<
    typename array<signature_,traits_type_, l_rep_>::const_iterator,
    typename array<signature_,traits_type_, r_rep_>::const_iterator,
    func_type_>
    > >
apply(const array<signature_, traits_type_, l_rep_>& a, const array<signature_, traits_type_, r_rep_>& b)
{
    typedef array<signature_, traits_type_, reference_rep<b_iterator<
        typename array<signature_,traits_type_, l_rep_>::const_iterator,
        typename array<signature_,traits_type_, r_rep_>::const_iterator,
        func_type_
        > > > result_type;

    LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "apply<F>(A,A): array sizes do not match");
    return result_type(a.begin(), b.begin(), a.size());
}

template<typename func_type_, typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
LITE_INLINE 
array<signature_, traits_type_, reference_rep<b_iterator<
    typename array<signature_,traits_type_, l_rep_>::iterator,
    typename array<signature_,traits_type_, r_rep_>::const_iterator,
    func_type_>
    > >
apply(array<signature_, traits_type_, l_rep_>& a, const array<signature_, traits_type_, r_rep_>& b)
{
    typedef array<signature_, traits_type_, reference_rep<b_iterator<
        typename array<signature_,traits_type_, l_rep_>::iterator,
        typename array<signature_,traits_type_, r_rep_>::const_iterator,
        func_type_
        > > > result_type;

    LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "apply<F>(A,A): array sizes do not match");
    return result_type(a.begin(), b.begin(), a.size());
}

template<typename func_type_, typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
LITE_INLINE 
array<signature_, traits_type_, reference_rep<b_iterator<
    typename array<signature_,traits_type_, l_rep_>::const_iterator,
    typename array<signature_,traits_type_, r_rep_>::iterator,
    func_type_>
    > >
apply(const array<signature_, traits_type_, l_rep_>& a, array<signature_, traits_type_, r_rep_>& b)
{
    typedef array<signature_, traits_type_, reference_rep<b_iterator<
        typename array<signature_,traits_type_, l_rep_>::const_iterator,
        typename array<signature_,traits_type_, r_rep_>::iterator,
        func_type_
        > > > result_type;

    LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "apply<F>(A,A): array sizes do not match");
    return result_type(a.begin(), b.begin(), a.size());
}

template<typename func_type_, typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
LITE_INLINE 
array<signature_, traits_type_, reference_rep<b_iterator<
    typename array<signature_,traits_type_, l_rep_>::iterator,
    typename array<signature_,traits_type_, r_rep_>::iterator,
    func_type_>
    > >
apply(array<signature_, traits_type_, l_rep_>& a, array<signature_, traits_type_, r_rep_>& b)
{
    typedef array<signature_, traits_type_, reference_rep<b_iterator<
        typename array<signature_,traits_type_, l_rep_>::iterator,
        typename array<signature_,traits_type_, r_rep_>::iterator,
        func_type_
        > > > result_type;

    LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "apply<F>(A,A): array sizes do not match");
    return result_type(a.begin(), b.begin(), a.size());
}

/***********************************************************************************************************/
/* apply(A,A,f) ********************************************************************************************/
/***********************************************************************************************************/

template<typename func_type_, typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
LITE_INLINE 
array<signature_, traits_type_, reference_rep<b_iterator<
    typename array<signature_,traits_type_, l_rep_>::const_iterator,
    typename array<signature_,traits_type_, r_rep_>::const_iterator,
    func_type_>
    > >
apply(
    const array<signature_, traits_type_, l_rep_>& a, 
    const array<signature_, traits_type_, r_rep_>& b,
    const func_type_& func)
{
    typedef array<signature_, traits_type_, reference_rep<b_iterator<
        typename array<signature_,traits_type_, l_rep_>::const_iterator,
        typename array<signature_,traits_type_, r_rep_>::const_iterator,
        func_type_,
        false
        > > > result_type;

    LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "apply(A,A,f): array sizes do not match");
    return result_type(a.begin(), b.begin(), func, a.size());
}

template<typename func_type_, typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
LITE_INLINE 
array<signature_, traits_type_, reference_rep<b_iterator<
    typename array<signature_,traits_type_, l_rep_>::iterator,
    typename array<signature_,traits_type_, r_rep_>::const_iterator,
    func_type_>
    > >
apply(
    array<signature_, traits_type_, l_rep_>& a, 
    const array<signature_, traits_type_, r_rep_>& b,
    const func_type_& func)
{
    typedef array<signature_, traits_type_, reference_rep<b_iterator<
        typename array<signature_,traits_type_, l_rep_>::iterator,
        typename array<signature_,traits_type_, r_rep_>::const_iterator,
        func_type_,
        false
        > > > result_type;

    LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "apply(A,A,f): array sizes do not match");
    return result_type(a.begin(), b.begin(), func, a.size());
}

template<typename func_type_, typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
LITE_INLINE 
array<signature_, traits_type_, reference_rep<b_iterator<
    typename array<signature_,traits_type_, l_rep_>::const_iterator,
    typename array<signature_,traits_type_, r_rep_>::iterator,
    func_type_>
    > >
apply(
    const array<signature_, traits_type_, l_rep_>& a, 
    array<signature_, traits_type_, r_rep_>& b,
    const func_type_& func)
{
    typedef array<signature_, traits_type_, reference_rep<b_iterator<
        typename array<signature_,traits_type_, l_rep_>::const_iterator,
        typename array<signature_,traits_type_, r_rep_>::iterator,
        func_type_,
        false
        > > > result_type;

    LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "apply(A,A,f): array sizes do not match");
    return result_type(a.begin(), b.begin(), func, a.size());
}

template<typename func_type_, typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
LITE_INLINE 
array<signature_, traits_type_, reference_rep<b_iterator<
    typename array<signature_,traits_type_, l_rep_>::iterator,
    typename array<signature_,traits_type_, r_rep_>::iterator,
    func_type_>
    > >
apply(
    array<signature_, traits_type_, l_rep_>& a, 
    array<signature_, traits_type_, r_rep_>& b,
    const func_type_& func)
{
    typedef array<signature_, traits_type_, reference_rep<b_iterator<
        typename array<signature_,traits_type_, l_rep_>::iterator,
        typename array<signature_,traits_type_, r_rep_>::iterator,
        func_type_,
        false
        > > > result_type;

    LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "apply(A,A,f): array sizes do not match");
    return result_type(a.begin(), b.begin(), func, a.size());
}

/***********************************************************************************************************/
/* +A ******************************************************************************************************/
/***********************************************************************************************************/

template<typename signature_, typename traits_type_, typename rep_>
LITE_INLINE 
array<signature_, traits_type_, reference_rep<u_iterator<
    typename array<signature_,traits_type_, rep_>::const_iterator,
    uplus<typename array_signature_traits<signature_>::element_type>
    > > >
operator+(const array<signature_, traits_type_, rep_>& a)
{
    typedef array<signature_, traits_type_, reference_rep<u_iterator<
        typename array<signature_,traits_type_, rep_>::const_iterator,
        uplus<typename array_signature_traits<signature_>::element_type>
        > > > result_type;

    return result_type(a.begin(), a.size());
}

/***********************************************************************************************************/
/* -A ******************************************************************************************************/
/***********************************************************************************************************/

template<typename signature_, typename traits_type_, typename rep_>
LITE_INLINE array<signature_, traits_type_, reference_rep<u_iterator<
    typename array<signature_,traits_type_, rep_>::const_iterator,
    negate<typename array_signature_traits<signature_>::element_type>
    > > >
operator-(const array<signature_, traits_type_, rep_>& a)
{
    typedef array<signature_, traits_type_, reference_rep<u_iterator<
        typename array<signature_,traits_type_, rep_>::const_iterator,
        negate<typename array_signature_traits<signature_>::element_type>
        > > > result_type;

    return result_type(a.begin(), a.size());
}

/***********************************************************************************************************/
/* A+c *****************************************************************************************************/
/***********************************************************************************************************/

template<typename signature_, typename traits_type_, typename l_rep_>
LITE_INLINE 
array<signature_, traits_type_, reference_rep<b_iterator<
    typename array<signature_,traits_type_, l_rep_>::const_iterator,
    c_iterator<typename array_signature_traits<signature_>::element_type>,
    plus<typename array_signature_traits<signature_>::element_type>
    > > >
operator+(
    const array<signature_, traits_type_, l_rep_>& a, 
    const typename array_signature_traits<signature_>::element_type& b)
{
    typedef array<signature_, traits_type_, reference_rep<b_iterator<
        typename array<signature_,traits_type_, l_rep_>::const_iterator,
        c_iterator<typename array_signature_traits<signature_>::element_type>,
        plus<typename array_signature_traits<signature_>::element_type>
        > > > result_type;

    return result_type(a.begin(), b, a.size());
}

/***********************************************************************************************************/
/* c+A *****************************************************************************************************/
/***********************************************************************************************************/

template<typename signature_, typename traits_type_, typename r_rep_>
LITE_INLINE 
array<signature_, traits_type_, reference_rep<b_iterator<
    c_iterator<typename array_signature_traits<signature_>::element_type>,
    typename array<signature_,traits_type_, r_rep_>::const_iterator,
    plus<typename array_signature_traits<signature_>::element_type>
    > > >
operator+(
    const typename array_signature_traits<signature_>::element_type& a, 
    const array<signature_, traits_type_, r_rep_>& b)
{
    typedef array<signature_, traits_type_, reference_rep<b_iterator<
        c_iterator<typename array_signature_traits<signature_>::element_type>,
        typename array<signature_,traits_type_, r_rep_>::const_iterator,
        plus<typename array_signature_traits<signature_>::element_type>
        > > > result_type;

    return result_type(a, b.begin(), b.size());
}

/***********************************************************************************************************/
/* A-c *****************************************************************************************************/
/***********************************************************************************************************/

template<typename signature_, typename traits_type_, typename l_rep_>
LITE_INLINE 
array<signature_, traits_type_, reference_rep<b_iterator<
    typename array<signature_,traits_type_, l_rep_>::const_iterator,
    c_iterator<typename array_signature_traits<signature_>::element_type>,
    minus<typename array_signature_traits<signature_>::element_type>
    > > >
operator-(
    const array<signature_, traits_type_, l_rep_>& a, 
    const typename array_signature_traits<signature_>::element_type& b)
{
    typedef array<signature_, traits_type_, reference_rep<b_iterator<
        typename array<signature_,traits_type_, l_rep_>::const_iterator,
        c_iterator<typename array_signature_traits<signature_>::element_type>,
        minus<typename array_signature_traits<signature_>::element_type>
        > > > result_type;

    return result_type(a.begin(), b, a.size());
}

/***********************************************************************************************************/
/* c-A *****************************************************************************************************/
/***********************************************************************************************************/

template<typename signature_, typename traits_type_, typename r_rep_>
LITE_INLINE 
array<signature_, traits_type_, reference_rep<b_iterator<
    c_iterator<typename array_signature_traits<signature_>::element_type>,
    typename array<signature_,traits_type_, r_rep_>::const_iterator,
    minus<typename array_signature_traits<signature_>::element_type>
    > > >
operator-(
    const typename array_signature_traits<signature_>::element_type& a, 
    const array<signature_, traits_type_, r_rep_>& b)
{
    typedef array<signature_, traits_type_, reference_rep<b_iterator<
        c_iterator<typename array_signature_traits<signature_>::element_type>,
        typename array<signature_,traits_type_, r_rep_>::const_iterator,
        minus<typename array_signature_traits<signature_>::element_type>
        > > > result_type;

    return result_type(a, b.begin(), b.size());
}


/***********************************************************************************************************/
/* A*c *****************************************************************************************************/
/***********************************************************************************************************/

template<typename signature_, typename traits_type_, typename l_rep_>
LITE_INLINE 
array<signature_, traits_type_, reference_rep<b_iterator<
    typename array<signature_,traits_type_, l_rep_>::const_iterator,
    c_iterator<typename array_signature_traits<signature_>::element_type>,
    multiplies<typename array_signature_traits<signature_>::element_type>
    > > >
operator*(
    const array<signature_, traits_type_, l_rep_>& a, 
    const typename array_signature_traits<signature_>::element_type& b)
{
    typedef array<signature_, traits_type_, reference_rep<b_iterator<
        typename array<signature_,traits_type_, l_rep_>::const_iterator,
        c_iterator<typename array_signature_traits<signature_>::element_type>,
        multiplies<typename array_signature_traits<signature_>::element_type>
        > > > result_type;

    return result_type(a.begin(), b, a.size());
}

/***********************************************************************************************************/
/* c*A *****************************************************************************************************/
/***********************************************************************************************************/

template<typename signature_, typename traits_type_, typename r_rep_>
LITE_INLINE 
array<signature_, traits_type_, reference_rep<b_iterator<
    c_iterator<typename array_signature_traits<signature_>::element_type>,
    typename array<signature_,traits_type_, r_rep_>::const_iterator,
    multiplies<typename array_signature_traits<signature_>::element_type>
    > > >
operator*(
    const typename array_signature_traits<signature_>::element_type& a, 
    const array<signature_, traits_type_, r_rep_>& b)
{
    typedef array<signature_, traits_type_, reference_rep<b_iterator<
        c_iterator<typename array_signature_traits<signature_>::element_type>,
        typename array<signature_,traits_type_, r_rep_>::const_iterator,
        multiplies<typename array_signature_traits<signature_>::element_type>
        > > > result_type;

    return result_type(a, b.begin(), b.size());
}

/***********************************************************************************************************/
/* A/c *****************************************************************************************************/
/***********************************************************************************************************/

template<typename signature_, typename traits_type_, typename l_rep_>
LITE_INLINE 
array<signature_, traits_type_, reference_rep<b_iterator<
    typename array<signature_,traits_type_, l_rep_>::const_iterator,
    c_iterator<typename array_signature_traits<signature_>::element_type>,
    divides<typename array_signature_traits<signature_>::element_type>
    > > >
operator/(
    const array<signature_, traits_type_, l_rep_>& a, 
    const typename array_signature_traits<signature_>::element_type& b)
{
    typedef array<signature_, traits_type_, reference_rep<b_iterator<
        typename array<signature_,traits_type_, l_rep_>::const_iterator,
        c_iterator<typename array_signature_traits<signature_>::element_type>,
        divides<typename array_signature_traits<signature_>::element_type>
        > > > result_type;

    return result_type(a.begin(), b, a.size());
}


/***********************************************************************************************************/
/* A+A *****************************************************************************************************/
/***********************************************************************************************************/

template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
LITE_INLINE 
array<signature_, traits_type_, reference_rep<b_iterator<
    typename array<signature_,traits_type_, l_rep_>::const_iterator,
    typename array<signature_,traits_type_, r_rep_>::const_iterator,
    plus<typename array_signature_traits<signature_>::element_type>
    > > >
operator+(const array<signature_, traits_type_, l_rep_>& a, const array<signature_, traits_type_, r_rep_>& b)
{
    typedef array<signature_, traits_type_, reference_rep<b_iterator<
        typename array<signature_,traits_type_, l_rep_>::const_iterator,
        typename array<signature_,traits_type_, r_rep_>::const_iterator,
        plus<typename array_signature_traits<signature_>::element_type>
        > > > result_type;

    LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "operator+(A,A): array sizes do not match");
    return result_type(a.begin(), b.begin(), a.size());
}

/***********************************************************************************************************/
/* A-A *****************************************************************************************************/
/***********************************************************************************************************/

template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
LITE_INLINE 
array<signature_, traits_type_, reference_rep<b_iterator<
    typename array<signature_,traits_type_, l_rep_>::const_iterator,
    typename array<signature_,traits_type_, r_rep_>::const_iterator,
    minus<typename array_signature_traits<signature_>::element_type>
    > > >
operator-(const array<signature_, traits_type_, l_rep_>& a, const array<signature_, traits_type_, r_rep_>& b)
{
    typedef array<signature_, traits_type_, reference_rep<b_iterator<
        typename array<signature_,traits_type_, l_rep_>::const_iterator,
        typename array<signature_,traits_type_, r_rep_>::const_iterator,
        minus<typename array_signature_traits<signature_>::element_type>
        > > > result_type;

    LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "operator-(A,A): array sizes do not match");
    return result_type(a.begin(), b.begin(), a.size());
}

/***********************************************************************************************************/
/* A|A *****************************************************************************************************/
/***********************************************************************************************************/

template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
LITE_INLINE 
array<signature_, traits_type_, reference_rep<b_iterator<
    typename array<signature_,traits_type_, l_rep_>::const_iterator,
    typename array<signature_,traits_type_, r_rep_>::const_iterator,
    multiplies<typename array_signature_traits<signature_>::element_type>
    > > >
operator|(const array<signature_, traits_type_, l_rep_>& a, const array<signature_, traits_type_, r_rep_>& b)
{
    typedef array<signature_, traits_type_, reference_rep<b_iterator<
        typename array<signature_,traits_type_, l_rep_>::const_iterator,
        typename array<signature_,traits_type_, r_rep_>::const_iterator,
        multiplies<typename array_signature_traits<signature_>::element_type>
        > > > result_type;

    LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "operator|(A,A): array sizes do not match");
    return result_type(a.begin(), b.begin(), a.size());
}

/***********************************************************************************************************/
/* A+=c ****************************************************************************************************/
/***********************************************************************************************************/

template<typename signature_, typename traits_type_, typename l_rep_>
LITE_INLINE 
const array<signature_, traits_type_, l_rep_>&
operator+=(
    const array<signature_, traits_type_, l_rep_>& a, 
    const typename array_signature_traits<signature_>::element_type& b)
{
    typedef b_iterator<
        typename array<signature_,traits_type_, l_rep_>::iterator,
        c_iterator<typename array_signature_traits<signature_>::element_type>,
        plus_assign<typename array_signature_traits<signature_>::element_type>
        > iterator_type;

    for_each(iterator_type(a.begin(), b), a.size());
    return a;
}

template<typename signature_, typename traits_type_, typename l_rep_>
LITE_INLINE 
array<signature_, traits_type_, l_rep_>&
operator+=(
    array<signature_, traits_type_, l_rep_>& a, 
    const typename array_signature_traits<signature_>::element_type& b)
{
    typedef b_iterator<
        typename array<signature_,traits_type_, l_rep_>::iterator,
        c_iterator<typename array_signature_traits<signature_>::element_type>,
        plus_assign<typename array_signature_traits<signature_>::element_type>
        > iterator_type;

    for_each(iterator_type(a.begin(), b), a.size());
    return a;
}

/***********************************************************************************************************/
/* A-=c ****************************************************************************************************/
/***********************************************************************************************************/

template<typename signature_, typename traits_type_, typename l_rep_>
LITE_INLINE 
const array<signature_, traits_type_, l_rep_>&
operator-=(
    const array<signature_, traits_type_, l_rep_>& a, 
    const typename array_signature_traits<signature_>::element_type& b)
{
    typedef b_iterator<
        typename array<signature_,traits_type_, l_rep_>::iterator,
        c_iterator<typename array_signature_traits<signature_>::element_type>,
        minus_assign<typename array_signature_traits<signature_>::element_type>
        > iterator_type;

    for_each(iterator_type(a.begin(), b), a.size());
    return a;
}

template<typename signature_, typename traits_type_, typename l_rep_>
LITE_INLINE 
array<signature_, traits_type_, l_rep_>&
operator-=(
    array<signature_, traits_type_, l_rep_>& a, 
    const typename array_signature_traits<signature_>::element_type& b)
{
    typedef b_iterator<
        typename array<signature_,traits_type_, l_rep_>::iterator,
        c_iterator<typename array_signature_traits<signature_>::element_type>,
        minus_assign<typename array_signature_traits<signature_>::element_type>
        > iterator_type;

    for_each(iterator_type(a.begin(), b), a.size());
    return a;
}

/***********************************************************************************************************/
/* A*=c ****************************************************************************************************/
/***********************************************************************************************************/

template<typename signature_, typename traits_type_, typename l_rep_>
LITE_INLINE 
const array<signature_, traits_type_, l_rep_>&
operator*=(
    const array<signature_, traits_type_, l_rep_>& a, 
    const typename array_signature_traits<signature_>::element_type& b)
{
    typedef b_iterator<
        typename array<signature_,traits_type_, l_rep_>::iterator,
        c_iterator<typename array_signature_traits<signature_>::element_type>,
        multiplies_assign<typename array_signature_traits<signature_>::element_type>
        > iterator_type;

    for_each(iterator_type(a.begin(), b), a.size());
    return a;
}

template<typename signature_, typename traits_type_, typename l_rep_>
LITE_INLINE 
array<signature_, traits_type_, l_rep_>&
operator*=(
    array<signature_, traits_type_, l_rep_>& a, 
    const typename array_signature_traits<signature_>::element_type& b)
{
    typedef b_iterator<
        typename array<signature_,traits_type_, l_rep_>::iterator,
        c_iterator<typename array_signature_traits<signature_>::element_type>,
        multiplies_assign<typename array_signature_traits<signature_>::element_type>
        > iterator_type;

    for_each(iterator_type(a.begin(), b), a.size());
    return a;
}

/***********************************************************************************************************/
/* A/=c ****************************************************************************************************/
/***********************************************************************************************************/

template<typename signature_, typename traits_type_, typename l_rep_>
LITE_INLINE 
const array<signature_, traits_type_, l_rep_>&
operator/=(
    const array<signature_, traits_type_, l_rep_>& a, 
    const typename array_signature_traits<signature_>::element_type& b)
{
    typedef b_iterator<
        typename array<signature_,traits_type_, l_rep_>::iterator,
        c_iterator<typename array_signature_traits<signature_>::element_type>,
        divides_assign<typename array_signature_traits<signature_>::element_type>
        > iterator_type;

    for_each(iterator_type(a.begin(), b), a.size());
    return a;
}

template<typename signature_, typename traits_type_, typename l_rep_>
LITE_INLINE 
array<signature_, traits_type_, l_rep_>&
operator/=(
    array<signature_, traits_type_, l_rep_>& a, 
    const typename array_signature_traits<signature_>::element_type& b)
{
    typedef b_iterator<
        typename array<signature_,traits_type_, l_rep_>::iterator,
        c_iterator<typename array_signature_traits<signature_>::element_type>,
        divides_assign<typename array_signature_traits<signature_>::element_type>
        > iterator_type;

    for_each(iterator_type(a.begin(), b), a.size());
    return a;
}

/***********************************************************************************************************/
/* A+=A ****************************************************************************************************/
/***********************************************************************************************************/

template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
LITE_INLINE 
array<signature_, traits_type_, l_rep_>&
operator+=(array<signature_, traits_type_, l_rep_>& a, const array<signature_, traits_type_, r_rep_>& b)
{
    typedef b_iterator<
        typename array<signature_,traits_type_, l_rep_>::iterator,
        typename array<signature_,traits_type_, r_rep_>::const_iterator,
        plus_assign<typename array_signature_traits<signature_>::element_type>
        > iterator_type;

    LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "operator+=(A,A): array sizes do not match");
    for_each(iterator_type(a.begin(), b.begin()), a.size());
    return a;
}

template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
LITE_INLINE 
const array<signature_, traits_type_, l_rep_>&
operator+=(const array<signature_, traits_type_, l_rep_>& a, const array<signature_, traits_type_, r_rep_>& b)
{
    typedef b_iterator<
        typename array<signature_,traits_type_, l_rep_>::iterator,
        typename array<signature_,traits_type_, r_rep_>::const_iterator,
        plus_assign<typename array_signature_traits<signature_>::element_type>
        > iterator_type;

    LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "operator+=(A,A): array sizes do not match");
    for_each(iterator_type(a.begin(), b.begin()), a.size());
    return a;
}

/***********************************************************************************************************/
/* A-=A ****************************************************************************************************/
/***********************************************************************************************************/

template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
LITE_INLINE 
array<signature_, traits_type_, l_rep_>&
operator-=(array<signature_, traits_type_, l_rep_>& a, const array<signature_, traits_type_, r_rep_>& b)
{
    typedef b_iterator<
        typename array<signature_,traits_type_, l_rep_>::iterator,
        typename array<signature_,traits_type_, r_rep_>::const_iterator,
        minus_assign<typename array_signature_traits<signature_>::element_type>
        > iterator_type;

    LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "operator-=(A,A): array sizes do not match");
    for_each(iterator_type(a.begin(), b.begin()), a.size());
    return a;
}

template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
LITE_INLINE 
const array<signature_, traits_type_, l_rep_>&
operator-=(const array<signature_, traits_type_, l_rep_>& a, const array<signature_, traits_type_, r_rep_>& b)
{
    typedef b_iterator<
        typename array<signature_,traits_type_, l_rep_>::iterator,
        typename array<signature_,traits_type_, r_rep_>::const_iterator,
        minus_assign<typename array_signature_traits<signature_>::element_type>
        > iterator_type;

    LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "operator-=(A,A): array sizes do not match");
    for_each(iterator_type(a.begin(), b.begin()), a.size());
    return a;
}

/***********************************************************************************************************/
/* A|=A ****************************************************************************************************/
/***********************************************************************************************************/

template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
LITE_INLINE 
array<signature_, traits_type_, l_rep_>&
operator|=(array<signature_, traits_type_, l_rep_>& a, const array<signature_, traits_type_, r_rep_>& b)
{
    typedef b_iterator<
        typename array<signature_,traits_type_, l_rep_>::iterator,
        typename array<signature_,traits_type_, r_rep_>::const_iterator,
        multiplies_assign<typename array_signature_traits<signature_>::element_type>
    > iterator_type;

    LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "operator|=(A,A): array sizes do not match");
    for_each(iterator_type(a.begin(), b.begin()), a.size());
    return a;
}

template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
LITE_INLINE 
const array<signature_, traits_type_, l_rep_>&
operator|=(const array<signature_, traits_type_, l_rep_>& a, const array<signature_, traits_type_, r_rep_>& b)
{
    typedef b_iterator<
        typename array<signature_,traits_type_, l_rep_>::iterator,
        typename array<signature_,traits_type_, r_rep_>::const_iterator,
        multiplies_assign<typename array_signature_traits<signature_>::element_type>
    > iterator_type;

    LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "operator|=(A,A): array sizes do not match");
    for_each(iterator_type(a.begin(), b.begin()), a.size());
    return a;
}

/***********************************************************************************************************/
/* A<A *****************************************************************************************************/
/***********************************************************************************************************/

template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
LITE_INLINE bool 
operator<(const array<signature_, traits_type_, l_rep_>& a, const array<signature_, traits_type_, r_rep_>& b)
{
    typedef b_iterator<
        typename array<signature_,traits_type_, l_rep_>::const_iterator,
        typename array<signature_,traits_type_, r_rep_>::const_iterator,
        less<typename array_signature_traits<signature_>::element_type>
    > iterator_type;

    LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "operator<(A,A): array sizes do not match");
    return for_each_c(iterator_type(a.begin(), b.begin()), a.size());
}

/***********************************************************************************************************/
/* A<=A ****************************************************************************************************/
/***********************************************************************************************************/

template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
LITE_INLINE bool 
operator<=(const array<signature_, traits_type_, l_rep_>& a, const array<signature_, traits_type_, r_rep_>& b)
{
    typedef b_iterator<
        typename array<signature_,traits_type_, l_rep_>::const_iterator,
        typename array<signature_,traits_type_, r_rep_>::const_iterator,
        less_equal<typename array_signature_traits<signature_>::element_type>
    > iterator_type;

    LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "operator<=(A,A): array sizes do not match");
    return for_each_c(iterator_type(a.begin(), b.begin()), a.size());
}

/***********************************************************************************************************/
/* A==A ****************************************************************************************************/
/***********************************************************************************************************/

template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
LITE_INLINE bool 
operator==(const array<signature_, traits_type_, l_rep_>& a, const array<signature_, traits_type_, r_rep_>& b)
{
    typedef b_iterator<
        typename array<signature_,traits_type_, l_rep_>::const_iterator,
        typename array<signature_,traits_type_, r_rep_>::const_iterator,
        equal_to<typename array_signature_traits<signature_>::element_type>
    > iterator_type;

    LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "operator==(A,A): array sizes do not match");
    return for_each_c(iterator_type(a.begin(), b.begin()), a.size());
}

/***********************************************************************************************************/
/* A!=A ****************************************************************************************************/
/***********************************************************************************************************/

template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
LITE_INLINE bool 
operator!=(const array<signature_, traits_type_, l_rep_>& a, const array<signature_, traits_type_, r_rep_>& b)
{
    return !(a==b);
}

/***********************************************************************************************************/
/* A>=A ****************************************************************************************************/
/***********************************************************************************************************/

template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
LITE_INLINE bool 
operator>=(const array<signature_, traits_type_, l_rep_>& a, const array<signature_, traits_type_, r_rep_>& b)
{
    typedef b_iterator<
        typename array<signature_,traits_type_, l_rep_>::const_iterator,
        typename array<signature_,traits_type_, r_rep_>::const_iterator,
        greater_equal<typename array_signature_traits<signature_>::element_type>
    > iterator_type;

    LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "operator>=(A,A): array sizes do not match");
    return for_each_c(iterator_type(a.begin(), b.begin()), a.size());
}

/***********************************************************************************************************/
/* A>A *****************************************************************************************************/
/***********************************************************************************************************/

template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
LITE_INLINE bool 
operator>(const array<signature_, traits_type_, l_rep_>& a, const array<signature_, traits_type_, r_rep_>& b)
{
    typedef b_iterator<
        typename array<signature_,traits_type_, l_rep_>::const_iterator,
        typename array<signature_,traits_type_, r_rep_>::const_iterator,
        greater<typename array_signature_traits<signature_>::element_type>
    > iterator_type;

    LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "operator>(A,A): array sizes do not match");
    return for_each_c(iterator_type(a.begin(), b.begin()), a.size());
}

/***********************************************************************************************************/
/* compare(A,A) ********************************************************************************************/
/***********************************************************************************************************/

template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
LITE_INLINE int
compare(const array<signature_, traits_type_, l_rep_>& a, const array<signature_, traits_type_, r_rep_>& b)
{
    typedef b_iterator<
        typename array<signature_,traits_type_, l_rep_>::const_iterator,
        typename array<signature_,traits_type_, r_rep_>::const_iterator,
        compare3<typename array_signature_traits<signature_>::element_type>
        > iterator_type;

    while_equal<typename compare3<
        typename array_signature_traits<signature_>::element_type>::result_type> func;

    LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "compare(A,A): array sizes do not match");
    for_each_c(iterator_type(a.begin(), b.begin()), func, a.size());
    return func();
}

/***********************************************************************************************************/
/* norm(A) *************************************************************************************************/
/***********************************************************************************************************/

template<typename signature_, typename traits_type_, typename rep_>
LITE_INLINE typename array_signature_traits<signature_>::element_type 
norm(const array<signature_, traits_type_, rep_>& a)
{
    typedef u_iterator<
        typename array<signature_,traits_type_, rep_>::const_iterator,
        square<typename array_signature_traits<signature_>::element_type>
    > iterator_type;

    accumulator<typename array_signature_traits<signature_>::element_type> acc;

    for_each(iterator_type(a.begin()), acc, a.size());
    return acc();
}

/***********************************************************************************************************/
/* normalized(A) *******************************************************************************************/
/***********************************************************************************************************/

template<typename signature_, typename traits_type_, typename rep_>
LITE_INLINE const typename array_helper<signature_, traits_type_>::temporary_array
normalized(const array<signature_, traits_type_, rep_>& a)
{
    typedef array<signature_, traits_type_, rep_> a_type;
    typedef typename array_helper<signature_, traits_type_>::temporary_array result_type;
    typedef typename array_signature_traits<signature_>::element_type value_type;
    typedef u_iterator<typename result_type::iterator, square<value_type> > iterator_type;

    result_type result = a;
    accumulator<value_type> acc;

    for_each(iterator_type(result.begin()), acc, result.size());
    result *= value_type(1)/sqrt(acc());
    return result;
}

/***********************************************************************************************************/
/* abs(A) **************************************************************************************************/
/***********************************************************************************************************/

template<typename signature_, typename traits_type_, typename rep_>
LITE_INLINE typename array_signature_traits<signature_>::element_type 
abs(const array<signature_, traits_type_, rep_>& a)
{
    return sqrt(norm(a));
}

/***********************************************************************************************************/
/* min(A,A) ************************************************************************************************/
/***********************************************************************************************************/

template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
LITE_INLINE 
array<signature_, traits_type_, reference_rep<b_iterator<
    typename array<signature_,traits_type_, l_rep_>::const_iterator,
    typename array<signature_,traits_type_, r_rep_>::const_iterator,
    minimum<typename array_signature_traits<signature_>::element_type>
    > > >
min(const array<signature_, traits_type_, l_rep_>& a, const array<signature_, traits_type_, r_rep_>& b)
{
    typedef array<signature_, traits_type_, reference_rep<b_iterator<
        typename array<signature_,traits_type_, l_rep_>::const_iterator,
        typename array<signature_,traits_type_, r_rep_>::const_iterator,
        minimum<typename array_signature_traits<signature_>::element_type>
        > > > result_type;

    LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "min(A,A): array sizes do not match");

    return result_type(a.begin(), b.begin(), a.size());
}

template<typename signature_, typename traits_type_, typename rep_>
LITE_INLINE 
array<signature_, traits_type_, reference_rep<b_iterator<
    typename array<signature_,traits_type_, rep_>::const_iterator,
    typename array<signature_,traits_type_, rep_>::const_iterator,
    minimum<typename array_signature_traits<signature_>::element_type>
    > > >
min(const array<signature_, traits_type_, rep_>& a, const array<signature_, traits_type_, rep_>& b)
{
    typedef array<signature_, traits_type_, reference_rep<b_iterator<
        typename array<signature_,traits_type_, rep_>::const_iterator,
        typename array<signature_,traits_type_, rep_>::const_iterator,
        minimum<typename array_signature_traits<signature_>::element_type>
        > > > result_type;

    LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "min(A,A): array sizes do not match");

    return result_type(a.begin(), b.begin(), a.size());
}

/***********************************************************************************************************/
/* max(A,A) ************************************************************************************************/
/***********************************************************************************************************/

template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
LITE_INLINE 
array<signature_, traits_type_, reference_rep<b_iterator<
    typename array<signature_,traits_type_, l_rep_>::const_iterator,
    typename array<signature_,traits_type_, r_rep_>::const_iterator,
    maximum<typename array_signature_traits<signature_>::element_type>
    > > >
max(const array<signature_, traits_type_, l_rep_>& a, const array<signature_, traits_type_, r_rep_>& b)
{
    typedef array<signature_, traits_type_, reference_rep<b_iterator<
        typename array<signature_,traits_type_, l_rep_>::const_iterator,
        typename array<signature_,traits_type_, r_rep_>::const_iterator,
        maximum<typename array_signature_traits<signature_>::element_type>
        > > > result_type;

    LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "max(A,A): array sizes do not match");

    return result_type(a.begin(), b.begin(), a.size());
}

template<typename signature_, typename traits_type_, typename rep_>
LITE_INLINE 
array<signature_, traits_type_, reference_rep<b_iterator<
    typename array<signature_,traits_type_, rep_>::const_iterator,
    typename array<signature_,traits_type_, rep_>::const_iterator,
    maximum<typename array_signature_traits<signature_>::element_type>
    > > >
max(const array<signature_, traits_type_, rep_>& a, const array<signature_, traits_type_, rep_>& b)
{
    typedef array<signature_, traits_type_, reference_rep<b_iterator<
        typename array<signature_,traits_type_, rep_>::const_iterator,
        typename array<signature_,traits_type_, rep_>::const_iterator,
        maximum<typename array_signature_traits<signature_>::element_type>
        > > > result_type;

    LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "max(A,A): array sizes do not match");

    return result_type(a.begin(), b.begin(), a.size());
}

/***********************************************************************************************************/
/* V*V *****************************************************************************************************/
/***********************************************************************************************************/

template<typename value_type_, int n_, typename traits_type_, typename l_rep_, typename r_rep_>
LITE_INLINE 
typename detail::enable_if<(array_signature_traits<value_type_>::dimensions == 0), value_type_>::type
operator*(
    const array<value_type_[n_], traits_type_, l_rep_>& a, 
    const array<value_type_[n_], traits_type_, r_rep_>& b)
{
    typedef b_iterator<
        typename array<value_type_[n_],traits_type_, l_rep_>::const_iterator,
        typename array<value_type_[n_],traits_type_, r_rep_>::const_iterator,
        multiplies<value_type_>
        > iterator_type;

    accumulator<value_type_> acc;

    LITE_ARRAY_SIZE_CHECK(a.size(), b.size(), "operator*(V,V): vector sizes do not match");
    for_each(iterator_type(a.begin(), b.begin()), acc, a.size());
    return acc();
}

/***********************************************************************************************************/
/* M*V *****************************************************************************************************/
/***********************************************************************************************************/

template<typename value_type_, int m_, int n_, typename traits_type_, typename l_rep_, typename r_rep_>
LITE_INLINE 
typename detail::enable_if<
    (array_signature_traits<value_type_>::dimensions == 0), 
    const typename array_helper<value_type_[m_], traits_type_>::temporary_array
    >::type
operator*(
    const array<value_type_[m_][n_], traits_type_, l_rep_>& a, 
    const array<value_type_[n_], traits_type_, r_rep_>& b)
{
    typedef array<value_type_[m_][n_], traits_type_, l_rep_> a_type;
    typedef array<value_type_[n_], traits_type_, r_rep_> b_type;
    typedef typename array_helper<value_type_[m_], traits_type_>::temporary_array result_type;
    typedef typename result_type::size_type size_type;

    typename detail::matrix_policy<a_type, 1> ::cached_fwd_array aa = a;
    typename detail::matrix_policy<b_type, 9> ::cached_array bb = b;

    const int m = aa.size().i0;

    const size_type size(m);
    result_type result(size);

    LITE_ARRAY_SIZE_CHECK(aa.size().i1, b.size().i0, "operator*(M,V): matrix/vector sizes do not match");

    for (int i=0; i<m; i++)
        result[i] = aa[row(i)]*bb;

    return result;
}

/***********************************************************************************************************/
/* V*M *****************************************************************************************************/
/***********************************************************************************************************/

template<typename value_type_, int m_, int n_, typename traits_type_, typename l_rep_, typename r_rep_>
LITE_INLINE 
typename detail::enable_if<
    (array_signature_traits<value_type_>::dimensions == 0), 
    const typename array_helper<value_type_[n_], traits_type_>::temporary_array
    >::type
operator*(
    const array<value_type_[m_], traits_type_, l_rep_>& a,
    const array<value_type_[m_][n_], traits_type_, r_rep_>& b)
{
    typedef array<value_type_[m_], traits_type_, l_rep_> a_type;
    typedef array<value_type_[m_][n_], traits_type_, r_rep_> b_type;
    typedef typename array_helper<value_type_[n_], traits_type_>::temporary_array result_type;
    typedef typename result_type::size_type size_type;

    typename detail::matrix_policy<a_type, 9>::cached_array aa = a;
    typename detail::matrix_policy<b_type, 1>::cached_rev_array bb = b;

    const int n = bb.size().i1;

    const size_type size(n);
    result_type result(size);

    LITE_ARRAY_SIZE_CHECK(aa.size().i0, bb.size().i0, "operator*(V,M): matrix/vector sizes do not match");

    for (int j=0; j<n; j++)
        result[j] = aa*bb[column(j)];

    return result;
}

/***********************************************************************************************************/
/* M*M *****************************************************************************************************/
/***********************************************************************************************************/

template<
    typename value_type_, 
    int m_, 
    int n_, 
    int p_, 
    typename traits_type_, 
    typename l_rep_, 
    typename r_rep_>
LITE_INLINE 
typename detail::enable_if<
    (array_signature_traits<value_type_>::dimensions == 0), 
    const typename array_helper<value_type_[m_][p_], traits_type_>::temporary_array
    >::type
operator*(
    const array<value_type_[m_][n_], traits_type_, l_rep_>& a,
    const array<value_type_[n_][p_], traits_type_, r_rep_>& b)
{
    typedef array<value_type_[m_][n_], traits_type_, l_rep_> a_type;
    typedef array<value_type_[n_][p_], traits_type_, r_rep_> b_type;
    typedef typename array_helper<value_type_[m_][p_], traits_type_>::temporary_array result_type;
    typedef typename result_type::size_type size_type;

    typename detail::matrix_policy<a_type, 9>::cached_fwd_array aa = a;
    typename detail::matrix_policy<b_type, 9>::cached_rev_array bb = b;

    const int m = aa.size().i0;
    const int p = bb.size().i1;

    const size_type size(m, p);
    result_type result(size);

    LITE_ARRAY_SIZE_CHECK(aa.size().i1, bb.size().i0, "operator*(M,M): matrix sizes do not match");

    for (int i=0; i<m; i++)
        for (int j=0; j<p; j++)
            result(i,j) = aa[row(i)]*bb[column(j)];

    return result;
}

/***********************************************************************************************************/
/* V%V, 2D (cross product) *********************************************************************************/
/***********************************************************************************************************/

template<typename value_type_, typename traits_type_, typename l_rep_, typename r_rep_>
LITE_INLINE 
typename detail::enable_if<(
    array_signature_traits<value_type_>::dimensions == 0),
    value_type_
    >::type
operator%(
    const array<value_type_[2], traits_type_, l_rep_>& a, 
    const array<value_type_[2], traits_type_, r_rep_>& b)
{
    return a[0]*b[1]-a[1]*b[0];
}

/***********************************************************************************************************/
/* V%V, 3D (cross product) *********************************************************************************/
/***********************************************************************************************************/

template<typename value_type_, typename traits_type_, typename l_rep_, typename r_rep_>
LITE_INLINE 
typename detail::enable_if<(
    array_signature_traits<value_type_>::dimensions == 0),
    const typename array_helper<value_type_[3], traits_type_>::temporary_array
    >::type
operator%(
    const array<value_type_[3], traits_type_, l_rep_>& a, 
    const array<value_type_[3], traits_type_, r_rep_>& b)
{
    typedef array<value_type_[3], traits_type_, l_rep_> a_type;
    typedef array<value_type_[3], traits_type_, r_rep_> b_type;
    typedef typename array_helper<value_type_[3], traits_type_>::temporary_array result_type;

    typename detail::matrix_policy<a_type, 9>::cached_array aa = a;
    typename detail::matrix_policy<b_type, 9>::cached_array bb = b;

    return result_type(aa[1]*bb[2]-aa[2]*bb[1], aa[2]*bb[0]-aa[0]*bb[2], aa[0]*bb[1]-aa[1]*bb[0]);
}

/***********************************************************************************************************/
/* determinant, 2D *****************************************************************************************/
/***********************************************************************************************************/

template<typename value_type_, typename traits_type_, typename rep_>
LITE_INLINE 
typename detail::enable_if<(
    array_signature_traits<value_type_>::dimensions == 0),
    value_type_
    >::type
det(const array<value_type_[2][2], traits_type_, rep_>& a)
{
    return a(0, 0)*a(1, 1) - a(0, 1)*a(1, 0);
}

/***********************************************************************************************************/
/* determinant, 3D *****************************************************************************************/
/***********************************************************************************************************/

template<typename value_type_, typename traits_type_, typename rep_>
LITE_INLINE 
typename detail::enable_if<(
    array_signature_traits<value_type_>::dimensions == 0),
    value_type_
    >::type
det(const array<value_type_[3][3], traits_type_, rep_>& a)
{
    typedef array<value_type_[3][3], traits_type_, rep_> a_type;
    typename detail::matrix_policy<a_type, 9>::cached_fwd_array aa = a;

    value_type_ det00 = aa(2, 2)*aa(1, 1)-aa(2, 1)*aa(1, 2);
    value_type_ det10 = aa(2, 2)*aa(0, 1)-aa(2, 1)*aa(0, 2);
    value_type_ det20 = aa(1, 2)*aa(0, 1)-aa(1, 1)*aa(0, 2);
    return aa(0, 0)*det00-aa(1, 0)*det10+aa(2, 0)*det20;
}

/***********************************************************************************************************/
/* determinant, nD *****************************************************************************************/
/***********************************************************************************************************/

// uses Gaussian upper triangulation
template<typename value_type_, int n_, typename traits_type_, typename rep_>
LITE_INLINE 
typename detail::enable_if<(
    array_signature_traits<value_type_>::dimensions == 0),
    value_type_
    >::type
det(const array<value_type_[n_][n_], traits_type_, rep_>& a)
{
    using std::abs;

    typedef typename array_helper<value_type_[n_][n_], traits_type_>::fwd_temporary_array temporary_type;
    typedef array<value_type_[n_][n_], traits_type_, rep_> a_type;

    LITE_ARRAY_SIZE_CHECK(a.size().i0, a.size().i1, "det(M): not a square matrix");

    temporary_type aa = a;
    const int n = aa.size().i0;
    int swaps = 0;

    for (int i=0; i<n; i++) {
        const block<0,1> blk(0, n-i);
        int i_max = i;
        value_type_ val_max = abs(aa(i, i));

        // find the strongest row
        for (int i2 = i+1; i2<n; i2++)
            if (abs(aa(i2, i)) > val_max) {
                i_max = i2;
                val_max = abs(aa(i2, i));
            }

        // swap row i_max with row i
        if (i_max != i) {
            typename transform_traits<temporary_type, block<0,1> >::temporary_array tmp_row;

            tmp_row = aa[blk(i, i)];
            aa[blk(i, i)] = aa[blk(i_max, i)];
            aa[blk(i_max, i)] = tmp_row;
            swaps++;
        }

        // if a singular matrix return a zero matrix
        if (aa(i, i) == value_type_())
            return value_type_();

        value_type_ epsilon = std::numeric_limits<value_type_>::epsilon()*aa(i, i)*n;
        value_type_ factor = value_type_(1)/aa(i, i);

        // simplify the column in the lower triangle
        for (int i2 = i+1; i2<n; i2++) 
            if (abs(aa(i2, i)) > epsilon)
                aa[blk(i2, i)] -= (aa(i2, i)*factor)*aa[blk(i, i)];
    }

    value_type_ result = value_type_(1);

    for (int i=0; i<n; i++)
        result *= aa(i, i);

    return (swaps & 1) != 0 ? -result : result;
}

/***********************************************************************************************************/
/* inverse, 2D *********************************************************************************************/
/***********************************************************************************************************/

template<typename value_type_, typename traits_type_, typename rep_>
LITE_INLINE 
typename detail::enable_if<(
    array_signature_traits<value_type_>::dimensions == 0),
    const typename array_helper<value_type_[2][2], traits_type_>::temporary_array
    >::type
inverse(const array<value_type_[2][2], traits_type_, rep_>& a)
{
    typedef array<value_type_[2][2], traits_type_, rep_> a_type;
    typename detail::matrix_policy<a_type, 9>::cached_fwd_array aa = a;

    typename array_helper<value_type_[2][2], traits_type_>::temporary_array result;

    value_type_ inv_det = value_type_(1)/(aa(0, 0)*aa(1, 1) - aa(0, 1)*a(1, 0));

    result(0, 0) = aa(1, 1) * inv_det;
    result(0, 1) = -aa(0, 1) * inv_det;
    result(0, 2) = -aa(1, 0) * inv_det;
    result(0, 3) = aa(0, 0) * inv_det;

    return result;
}

/***********************************************************************************************************/
/* inverse, 3D *********************************************************************************************/
/***********************************************************************************************************/

template<typename value_type_, typename traits_type_, typename rep_>
LITE_INLINE 
typename detail::enable_if<(
    array_signature_traits<value_type_>::dimensions == 0),
    const typename array_helper<value_type_[3][3], traits_type_>::temporary_array
    >::type
inverse(const array<value_type_[3][3], traits_type_, rep_>& a)
{
    typedef array<value_type_[3][3], traits_type_, rep_> a_type;
    typename detail::matrix_policy<a_type, 9>::cached_fwd_array aa = a;

    typename array_helper<value_type_[3][3], traits_type_>::temporary_array result;
    
    value_type_ det00 = aa(2, 2)*aa(1, 1)-aa(2, 1)*aa(1, 2);
    value_type_ det10 = aa(2, 2)*aa(0, 1)-aa(2, 1)*aa(0, 2);
    value_type_ det20 = aa(1, 2)*aa(0, 1)-aa(1, 1)*aa(0, 2);
    value_type_ inv_det = value_type_(1)/(aa(0, 0)*det00-aa(1, 0)*det10+aa(2, 0)*det20);

    result(0, 0) = det00*inv_det; 
    result(0, 1) = -det10*inv_det; 
    result(0, 2) = det20*inv_det;
    result(1, 0) = (aa(2, 0)*aa(1, 2)-aa(2, 2)*aa(1, 0))*inv_det; 
    result(1, 1) = (aa(2, 2)*aa(0, 0)-aa(2, 0)*aa(0, 2))*inv_det;
    result(1, 2) = (aa(1, 0)*aa(0, 2)-aa(1, 2)*aa(0, 0))*inv_det;
    result(2, 0) = (aa(2, 1)*aa(1, 0)-aa(2, 0)*aa(1, 1))*inv_det;
    result(2, 1) = (aa(2, 0)*aa(0, 1)-aa(2, 1)*aa(0, 0))*inv_det;
    result(2, 2) = (aa(1, 1)*aa(0, 0)-aa(1, 0)*aa(0, 1))*inv_det;

    return result;
}

/***********************************************************************************************************/
/* inverse, nD *********************************************************************************************/
/***********************************************************************************************************/

// uses Gauss-Jordan elimination
template<typename value_type_, int n_, typename traits_type_, typename rep_>
LITE_INLINE 
typename detail::enable_if<(
    array_signature_traits<value_type_>::dimensions == 0),
    const typename array_helper<value_type_[n_][n_], traits_type_>::temporary_array
    >::type
inverse(const array<value_type_[n_][n_], traits_type_, rep_>& a)
{
    using std::abs;

    typedef array<value_type_[n_][n_], traits_type_, rep_> a_type;
    typedef typename array_helper<value_type_[n_][n_], traits_type_>::temporary_array temporary_type;

    LITE_ARRAY_SIZE_CHECK(a.size().i0, a.size().i1, "inverse(M): not a square matrix");

    const int n = a.size().i0;
    temporary_type aa=a, result(n, n);

    result = value_type_();

    result[diagonal()] = value_type_(1);

    for (int i=0; i<n; i++) {
        const block<0,1> blk(0, n-i);
        int i_max = i;
        value_type_ val_max = abs(aa(i, i));

        // find the strongest row
        for (int i2 = i+1; i2<n; i2++)
            if (abs(aa(i2, i)) > val_max) {
                i_max = i2;
                val_max = abs(aa(i2, i));
            }

        // swap row i_max with row i
        if (i_max != i) {
            typename transform_traits<temporary_type, row>::temporary_array res_tmp;

            res_tmp = result[row(i)];
            result[row(i)] = result[row(i_max)];
            result[row(i_max)] = res_tmp; 

            typename transform_traits<temporary_type, block<0,1> >::temporary_array org_tmp;
                
            org_tmp = aa[blk(i,i)];
            aa[blk(i,i)] = aa[blk(i_max, i)];
            aa[blk(i_max,i)] = org_tmp; 
        }

        // if a singular matrix return a zero matrix
        if (aa(i, i) == value_type_()) {
            result = value_type_();
            break;
        }

        // normalize the row
        value_type_ factor = value_type_(1)/aa(i, i);

        result[row(i)] *= factor;
        aa[blk(i, i)] *= factor;

        value_type_ epsilon = std::numeric_limits<value_type_>::epsilon()*aa(i, i)*n;

        // simplify the column in the lower triangle
        for (int i2 = i+1; i2<n; i2++) 
            if (abs(aa(i2, i)) > epsilon) {
                result[row(i2)] -= aa(i2, i)*result[row(i)];
                aa[blk(i2,i)] -= aa(i2, i)*aa[blk(i,i)];
            }
    }

    // simplify the upper triangle
    for (int i = n-1; i>=0; i--) {
        value_type_ epsilon = std::numeric_limits<value_type_>::epsilon()*aa(i, i)*n;

        for (int i2 = 0; i2<i; i2++) 
            if (abs(aa(i2, i)) > epsilon) 
                // we don't need to update the original here as it won't be used any more!
                result[row(i2)] -= aa(i2, i)*result[row(i)];
    }

    return result;
}

/***********************************************************************************************************/
/* rotation, 2D ********************************************************************************************/
/***********************************************************************************************************/

template<typename value_type_, typename traits_type_, typename rep_>
LITE_INLINE 
typename detail::enable_if<(
    array_signature_traits<value_type_>::dimensions == 0),
    const typename array_helper<value_type_[2][2], traits_type_>::temporary_array
    >::type
rotation_n(
    const array<value_type_[2], traits_type_, rep_>&, 
    const typename array_signature_traits<value_type_>::element_type& angle)
{
    using namespace std;
    typename array_helper<value_type_[2][2], traits_type_>::temporary_array result;

    value_type_ tmp_cos = cos(angle);
    value_type_ tmp_sin = sin(angle);

    result(0, 0) = tmp_cos;
    result(1, 1) = tmp_cos;
    result(0, 1) = -tmp_sin;
    result(1, 0) = tmp_sin;

    return result;
}

template<typename value_type_, typename traits_type_, typename rep_>
LITE_INLINE 
typename detail::enable_if<(
    array_signature_traits<value_type_>::dimensions == 0),
    const typename array_helper<value_type_[2][2], traits_type_>::temporary_array
    >::type
rotation(
    const array<value_type_[2], traits_type_, rep_>& dummy, 
    const typename array_signature_traits<value_type_>::element_type& angle)
{
    return rotation_n(dummy, angle);
}

/***********************************************************************************************************/
/* rotation, 3D ********************************************************************************************/
/***********************************************************************************************************/

template<typename value_type_, typename traits_type_, typename rep_>
LITE_INLINE 
typename detail::enable_if<(
    array_signature_traits<value_type_>::dimensions == 0),
    const typename array_helper<value_type_[3][3], traits_type_>::temporary_array
    >::type
rotation_n(
    const array<value_type_[3], traits_type_, rep_>& axis, 
    const typename array_signature_traits<value_type_>::element_type& angle)
{
    using namespace std;

    typedef array<value_type_[3], traits_type_, rep_> axis_type;

    typename detail::matrix_policy<axis_type, 9> ::cached_array cached_axis = axis;
    typename array_helper<value_type_[3][3], traits_type_>::temporary_array result;

    value_type_ tmp_cos = cos(angle);
    value_type_ tmp_sin = sin(angle);
    value_type_ tmp_rcos = value_type_(1) - tmp_cos;

    result(0, 0) = tmp_cos + cached_axis[0]*cached_axis[0]*tmp_rcos;
    result(1, 1) = tmp_cos + cached_axis[1]*cached_axis[1]*tmp_rcos;
    result(2, 2) = tmp_cos + cached_axis[2]*cached_axis[2]*tmp_rcos;

    value_type_ tmp1 = cached_axis[0]*cached_axis[1]*tmp_rcos;
    value_type_ tmp2 = cached_axis[2]*tmp_sin;

    result(1, 0) = tmp1 + tmp2;
    result(0, 1) = tmp1 - tmp2;
    tmp1 = cached_axis[0]*cached_axis[2]*tmp_rcos;
    tmp2 = cached_axis[1]*tmp_sin;
    result(2, 0) = tmp1 - tmp2;
    result(0, 2) = tmp1 + tmp2;    
    tmp1 = cached_axis[1]*cached_axis[2]*tmp_rcos;
    tmp2 = cached_axis[0]*tmp_sin;
    result(2, 1) = tmp1 + tmp2;
    result(1, 2) = tmp1 - tmp2;

    return result;
}

template<typename value_type_, typename traits_type_, typename rep_>
LITE_INLINE 
typename detail::enable_if<(
    array_signature_traits<value_type_>::dimensions == 0),
    const typename array_helper<value_type_[3][3], traits_type_>::temporary_array
    >::type
rotation(
    const array<value_type_[3], traits_type_, rep_>& axis, 
    const typename array_signature_traits<value_type_>::element_type& angle)
{
    typename array_helper<value_type_[3], traits_type_>::temporary_array normalized_axis = axis;

    normalized_axis *= value_type_(1)/abs(normalized_axis);

    return rotation_n(normalized_axis, angle);
}

/***********************************************************************************************************/
/* scale ***************************************************************************************************/
/***********************************************************************************************************/

template<typename value_type_, int n_, typename traits_type_, typename rep_>
LITE_INLINE 
typename detail::enable_if<(
    array_signature_traits<value_type_>::dimensions == 0),
    const typename array_helper<value_type_[n_][n_], traits_type_>::temporary_array
    >::type
scale(const array<value_type_[n_], traits_type_, rep_>& factors)
{
    const int n = factors.size().i0;
    typename array_helper<value_type_[n_][n_], traits_type_>::temporary_array 
        result(n, n);

    result = value_type_();
    result[diagonal()] = factors;
    return result;
}

/***********************************************************************************************************/
/* array_comparator ****************************************************************************************/
/***********************************************************************************************************/

/*!
    \brief 
    This class defines a function object that can be used to compare two compatible arrays to 
    define an ordering. 

    \ingroup array_operations

    \par Example

    \code
        typedef array<float[2]> Point2D;

        std::map<Point2D, Shape*, array_comparator> space_map;

        space_map[Point2D(0f, 2.5f)] = new Circle();
    \endcode
*/
class array_comparator
{
public:
    LITE_INLINE array_comparator() {}

    LITE_INLINE array_comparator(const array_comparator&) {}

    LITE_INLINE array_comparator& operator= (array_comparator&) { return *this; }

    //! Returns true if \a a is lexicographically before \a b.
    template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
    LITE_INLINE bool 
    operator()(
        const array<signature_, traits_type_, l_rep_>& a, 
        const array<signature_, traits_type_, r_rep_>& b) const
    {
        return compare(a, b) < 0;
    }
};

/***********************************************************************************************************/
/* from, fixed size ****************************************************************************************/
/***********************************************************************************************************/

#ifdef DOCUMENTATION_ONLY

/*!
    \brief constructs a reference array to a C array.

    \ingroup array_operations

    \par Example:

    \code
    array<float[3][3]> a, c;
    float b[3][3];

    std::cin >> from(b) >> a;   // read a and b
    c = a*from(b);              // matrix multiplication
    \endcode
*/
template<typename value_type_, int n0_ ..., int nN_>
const array<...>
from(value_type_ (&a)[n0_]...[nN_]);

#else // DOCUMENTATION_ONLY

template<
    typename value_type_,
    int n0_
>
LITE_INLINE 
typename detail::enable_if<
    array_signature_traits<value_type_[n0_]>::is_fixed_size,
    const array<typename array_signature_traits<value_type_[n0_]>::signature, 
        default_array_traits, 
        reference_rep<typename array_signature_traits<value_type_[n0_]>::default_iterator> > 
    >::type
from(value_type_ (&a)[n0_])
{
    typedef array<typename array_signature_traits<value_type_[n0_]>::signature, 
        default_array_traits, 
        reference_rep<typename array_signature_traits<value_type_[n0_]>::default_iterator> 
        > result_type;

    return result_type(&a[0], typename result_type::size_type());
};

template<
    typename value_type_,
    int n0_,
    int n1_
>
LITE_INLINE 
typename detail::enable_if<
    array_signature_traits<value_type_[n0_][n1_]>::is_fixed_size,
    const array<typename array_signature_traits<value_type_[n0_][n1_]>::signature, 
        default_array_traits, 
        reference_rep<typename array_signature_traits<value_type_[n0_][n1_]>::default_iterator> > 
    >::type
from(value_type_ (&a)[n0_][n1_])
{
    typedef array<typename array_signature_traits<value_type_[n0_][n1_]>::signature, 
        default_array_traits, 
        reference_rep<typename array_signature_traits<value_type_[n0_][n1_]>::default_iterator> 
        > result_type;

    return result_type(&a[0][0], typename result_type::size_type());
};

template<
    typename value_type_,
    int n0_,
    int n1_,
    int n2_
>
LITE_INLINE 
typename detail::enable_if<
    array_signature_traits<value_type_[n0_][n1_][n2_]>::is_fixed_size,
    const array<typename array_signature_traits<value_type_[n0_][n1_][n2_]>::signature, 
        default_array_traits, 
        reference_rep<typename array_signature_traits<value_type_[n0_][n1_][n2_]>::default_iterator> > 
    >::type
from(value_type_ (&a)[n0_][n1_][n2_])
{
    typedef array<typename array_signature_traits<value_type_[n0_][n1_][n2_]>::signature, 
        default_array_traits, 
        reference_rep<typename array_signature_traits<value_type_[n0_][n1_][n2_]>::default_iterator> 
        > result_type;

    return result_type(&a[0][0][0], typename result_type::size_type());
};


#endif // DOCUMENTATION_ONLY

/***********************************************************************************************************/
/* from, variable size *************************************************************************************/
/***********************************************************************************************************/

#ifdef DOCUMENTATION_ONLY

/*!
    \brief 
    Constructs a reference array from a pointer (or any other appropriate random access iterator) with 
    the specified dimension sizes.

    \ingroup array_operations

    \par Example:

    \code
    array<float[3][3]> a, c;
    std::vector<float> v(9);

    std::cin >> from(v.begin(), 3, 3);  // read v
    std::cin >> a;                      // read a
    c = a*from(v.begin(), 3, 3);        // matrix multiplication
    \endcode
*/
template<typename iterator_type_>
const array<...>
from(iterator_type_ it, int n0 ..., int nN);

#else // DOCUMENTATION_ONLY

template<typename iterator_type_>
LITE_INLINE 
const array<
    typename std::iterator_traits<iterator_type_>::value_type[1],
    default_array_traits, 
    reference_rep<pack<iterator_type_, constant<int, 1> > > > 
from(iterator_type_ it, int n0)
{
    typedef array<
        typename std::iterator_traits<iterator_type_>::value_type[1],
        default_array_traits, 
        reference_rep<pack<iterator_type_, constant<int, 1> > > 
        > result_type;

    typedef typename result_type::iterator iterator_type;

    return result_type(
        iterator_type(it, 1), 
        typename result_type::size_type(n0));
}

template<typename iterator_type_>
LITE_INLINE 
const array<
    typename std::iterator_traits<iterator_type_>::value_type[1][1],
    default_array_traits, 
    reference_rep<pack<iterator_type_, int, constant<int, 1> > > > 
from(iterator_type_ it, int n0, int n1)
{
    typedef array<
        typename std::iterator_traits<iterator_type_>::value_type[1][1],
        default_array_traits, 
        reference_rep<pack<iterator_type_, int, constant<int, 1> > > 
        > result_type;

    typedef typename result_type::iterator iterator_type;

    return result_type(
        iterator_type(it, n1, 1), 
        typename result_type::size_type(n0,n1));
}

template<typename iterator_type_>
LITE_INLINE 
const array<
    typename std::iterator_traits<iterator_type_>::value_type[1][1][1],
    default_array_traits, 
    reference_rep<pack<iterator_type_, int, int, constant<int, 1> > > > 
from(iterator_type_ it, int n0, int n1, int n2)
{
    typedef array<
        typename std::iterator_traits<iterator_type_>::value_type[1][1][1],
        default_array_traits, 
        reference_rep<pack<iterator_type_, int, int, constant<int, 1> > > 
        > result_type;

    typedef typename result_type::iterator iterator_type;

    return result_type(
        iterator_type(it, n1*n2, n2, 1), 
        typename result_type::size_type(n0,n1,n2));
}


#endif // DOCUMENTATION_ONLY

/***********************************************************************************************************/
/* from, pack size *****************************************************************************************/
/***********************************************************************************************************/

#ifdef DOCUMENTATION_ONLY

/*!
    \brief 
    Constructs a reference array from a pointer (or any other appropriate random access iterator) with 
    the specified size.

    \ingroup array_operations

    \par Example:

    \code
    array<float[3][3]> a, c;
    std::vector<float> v(9);

    std::cin >> from(v.begin(), a.size());  // read v
    std::cin >> a;                          // read a
    c = a*from(v.begin(), a.size());        // matrix multiplication
    \endcode
*/
template<typename iterator_type_, typename type0_ ..., typename typeN_>
const array<...>
from(iterator_type_ it, const pack<type0_ ..., typeN_>& size);

#else // DOCUMENTATION_ONLY


template<
    typename iterator_type_,
    typename type0_
>
LITE_INLINE 
const array<
    typename detail::size_to_signature<
        pack<type0_>, 
        typename std::iterator_traits<iterator_type_>::value_type 
    >::type, 
    default_array_traits, 
    reference_rep<
        typename array_signature_traits<
            typename detail::size_to_signature<
                pack<type0_>, 
                typename std::iterator_traits<iterator_type_>::value_type 
            >::type,
            iterator_type_
        >::default_iterator>
    >
from(
    iterator_type_ it, 
    const pack<type0_>& size) 
{
    typedef array<
        typename detail::size_to_signature<
            pack<type0_>, 
            typename std::iterator_traits<iterator_type_>::value_type 
        >::type, 
        default_array_traits, 
        reference_rep<
            typename array_signature_traits<
                typename detail::size_to_signature<
                    pack<type0_>, 
                    typename std::iterator_traits<iterator_type_>::value_type 
                >::type,
                iterator_type_
            >::default_iterator>
        > result_type;

    typedef typename result_type::iterator iterator_type;

    return result_type(
        iterator_type(it, 1), 
        size);
}

template<
    typename iterator_type_,
    typename type0_,
    typename type1_
>
LITE_INLINE 
const array<
    typename detail::size_to_signature<
        pack<type0_,type1_>, 
        typename std::iterator_traits<iterator_type_>::value_type 
    >::type, 
    default_array_traits, 
    reference_rep<
        typename array_signature_traits<
            typename detail::size_to_signature<
                pack<type0_,type1_>, 
                typename std::iterator_traits<iterator_type_>::value_type 
            >::type,
            iterator_type_
        >::default_iterator>
    >
from(
    iterator_type_ it, 
    const pack<type0_, type1_>& size) 
{
    typedef array<
        typename detail::size_to_signature<
            pack<type0_,type1_>, 
            typename std::iterator_traits<iterator_type_>::value_type 
        >::type, 
        default_array_traits, 
        reference_rep<
            typename array_signature_traits<
                typename detail::size_to_signature<
                    pack<type0_,type1_>, 
                    typename std::iterator_traits<iterator_type_>::value_type 
                >::type,
                iterator_type_
            >::default_iterator>
        > result_type;

    typedef typename result_type::iterator iterator_type;

    return result_type(
        iterator_type(it, size.i1, 1), 
        size);
}

template<
    typename iterator_type_,
    typename type0_,
    typename type1_,
    typename type2_
>
LITE_INLINE 
const array<
    typename detail::size_to_signature<
        pack<type0_,type1_,type2_>, 
        typename std::iterator_traits<iterator_type_>::value_type 
    >::type, 
    default_array_traits, 
    reference_rep<
        typename array_signature_traits<
            typename detail::size_to_signature<
                pack<type0_,type1_,type2_>, 
                typename std::iterator_traits<iterator_type_>::value_type 
            >::type,
            iterator_type_
        >::default_iterator>
    >
from(
    iterator_type_ it, 
    const pack<type0_, type1_, type2_>& size) 
{
    typedef array<
        typename detail::size_to_signature<
            pack<type0_,type1_,type2_>, 
            typename std::iterator_traits<iterator_type_>::value_type 
        >::type, 
        default_array_traits, 
        reference_rep<
            typename array_signature_traits<
                typename detail::size_to_signature<
                    pack<type0_,type1_,type2_>, 
                    typename std::iterator_traits<iterator_type_>::value_type 
                >::type,
                iterator_type_
            >::default_iterator>
        > result_type;

    typedef typename result_type::iterator iterator_type;

    return result_type(
        iterator_type(it, size.i1*size.i2, size.i2, 1), 
        size);
}


#endif // !DOCUMENTATION_ONLY

/***********************************************************************************************************/
/* from, identity ******************************************************************************************/
/***********************************************************************************************************/

template<typename signature_, typename traits_type_, typename rep_>
LITE_INLINE 
array<signature_, traits_type_, rep_>&
from(array<signature_, traits_type_, rep_>& a)
{
    return a;
}

template<typename signature_, typename traits_type_, typename rep_>
LITE_INLINE 
const array<signature_, traits_type_, rep_>&
from(const array<signature_, traits_type_, rep_>& a)
{
    return a;
}

/***********************************************************************************************************/
/* array_cast **********************************************************************************************/
/***********************************************************************************************************/

#ifdef DOCUMENTATION_ONLY

/*!
    \brief Casts the array \a ar to a compatible array type that has the same signature and traits type
    as \a dst_array_type_.

    \ingroup array_operations

    The result of the cast is always a reference array that points to the original array. No copying
    is ever made. This function may throw a lite::size_mismatch_error exception if the actual 
    size of the array \a ar does not match the signature type of \a dst_array_type_.

    \par Example:
    
    \code
        array<float[10]> a;                     // 1D array of constant size 10
        array<float[1]> b(10);                  // 1D array of non-constant size 10

        a = b;                                  // error: array signatures do not match.
        a = array_cast<array<float[10]> >(b);   // works fine.
        array_cast<array<float[1]> >(a) = b;    // produces the same result as the previous line.
    \endcode

    \throws lite::size_mismatch_error
*/
template<
    typename dst_array_type_, 
    typename src_signature_, 
    typename src_traits_type_, 
    typename src_rep_>
const array<...>
array_cast(const array<src_signature_, src_traits_type_, src_rep_>& ar);

#else // DOCUMENTATION_ONLY

template<
    typename dst_array_type_, 
    typename src_signature_, 
    typename src_traits_type_, 
    typename src_rep_>
LITE_INLINE 
typename detail::enable_if<
    (array_signature_traits<src_signature_>::dimensions == dst_array_type_::dimensions),
    const array<
        typename dst_array_type_::signature,
        typename dst_array_type_::traits_type,
        reference_rep<typename array<src_signature_, src_traits_type_, src_rep_>::const_iterator> >
    >::type
array_cast(const array<src_signature_, src_traits_type_, src_rep_>& a)
{
    typedef array<
        typename dst_array_type_::signature,
        typename dst_array_type_::traits_type,
        reference_rep<typename array<src_signature_, src_traits_type_, src_rep_>::const_iterator> >
        result_type;

    typename result_type::size_type new_size(a.size());
   
    LITE_ARRAY_SIZE_CHECK(a.size(), new_size, "array_cast<A>(A): source/target sizes do not match");

    return result_type(a.begin(), new_size);
}

template<
    typename dst_array_type_, 
    typename src_signature_, 
    typename src_traits_type_, 
    typename src_rep_>
LITE_INLINE 
typename detail::enable_if<
    (array_signature_traits<src_signature_>::dimensions == dst_array_type_::dimensions),
    const array<
        typename dst_array_type_::signature,
        typename dst_array_type_::traits_type,
        reference_rep<typename array<src_signature_, src_traits_type_, src_rep_>::iterator> >
    >::type
array_cast(array<src_signature_, src_traits_type_, src_rep_>& a)
{
    typedef array<
        typename dst_array_type_::signature,
        typename dst_array_type_::traits_type,
        reference_rep<typename array<src_signature_, src_traits_type_, src_rep_>::iterator> >
        result_type;

    typename result_type::size_type new_size(a.size());
   
    LITE_ARRAY_SIZE_CHECK(a.size(), new_size, "array_cast<A>(A): source/target sizes do not match");

    return result_type(a.begin(), new_size);
}

#endif // !DOCUMENTATION_ONLY

/***********************************************************************************************************/
/* array io, operator<< ************************************************************************************/
/***********************************************************************************************************/

template<
    typename char_type_ , 
    typename char_traits_type_, 
    typename value_type_, 
    typename traits_type_, 
    typename rep_>
void print(
    std::basic_ostream<char_type_, char_traits_type_>& os, 
    const array<value_type_, traits_type_, rep_>& ar,
    int level
    )
{	
    std::streamsize width = os.width();
    bool punct = (os.flags() & std::ios_base::boolalpha) != 0;
    
    os.width(0);

    if (punct)
        os << '[';

    os.width(width);
    os << ar();

    if (punct)
        os << ']';
}

template<
    typename char_type_ , 
    typename char_traits_type_, 
    typename value_type_, 
    int n0_,
    typename traits_type_, 
    typename rep_>
void print(
    std::basic_ostream<char_type_, char_traits_type_>& os, 
    const array<value_type_[n0_], traits_type_, rep_>& ar,
    int
    )
{	
    std::streamsize width = os.width();
    bool punct = (os.flags() & std::ios_base::boolalpha) != 0;
    const int n =ar.size().i0;

    os.width(0);

    if (punct)
        os << '[';

    for (int i=0; i<n; i++) {
        if (i != 0)
            os << ' ';
        os.width(width);
        os << ar[i];
    }

    if (punct)
        os << ']';
}

template<
    typename char_type_ , 
    typename char_traits_type_, 
    typename tail_type_, 
    int n0_,
    int n1_,
    typename traits_type_, 
    typename rep_>
void print(
    std::basic_ostream<char_type_, char_traits_type_>& os, 
    const array<tail_type_[n0_][n1_], traits_type_, rep_>& ar,
    int level =0
    )
{	
    std::streamsize width = os.width();
    bool punct = (os.flags() & std::ios_base::boolalpha) != 0;
    const int n =ar.size().i0;

    os.width(0);

    if (punct) {
        os << '[' << '\n';
        for (int j=0; j<level; j++) { os.width(width); os << ' '; }
    }
    for (int i=0; i<n; i++) {
        os.width(width); 
        os << ' ';
        os.width(width);
        print(os, ar[row(i)], level+1);
        if (i < n-1) {
            os << "\n";
            for (int j=0; j<level; j++) { os.width(width); os << ' '; }
        }
    }
    if (punct) {
        os << '\n';
        for (int j=0; j<level; j++) { os.width(width); os << ' '; }
        os << ']';
    }
}

/*!
    \brief Prints the array \a ar to the output stream \a os.

    \ingroup array_operations
    \anchor array_output

    If the field width value for \a os is set, it will be 
    used to set the field width for each of the elements to be printed. 
    Also if the \a boolalpha flags is set then the values of each dimension will be surrounded 
    in a matching pair of square brackets.

    \par Example:

    \code 
        array<int[3][3]> m = 0;

        m[diagonal()] = 1;
        std::cout << std::boolalpha  << std::setw(2) << m << std::endl;
    \endcode 
    The output would be:
    \verbatim
        [ 
          [ 1  0  0]
          [ 0  1  0]
          [ 0  0  1]
        ]
    \endverbatim
*/
template<
    typename char_type_ , 
    typename char_traits_type_, 
    typename signature_, 
    typename traits_type_, 
    typename rep_>
std::basic_ostream<char_type_, char_traits_type_>& 
operator<<(
    std::basic_ostream<char_type_, char_traits_type_>& os, 
    const array<signature_, traits_type_, rep_>& ar)
{
    print(os, ar, 0);
    return os;
}

/***********************************************************************************************************/
/* array io, operator>> ************************************************************************************/
/***********************************************************************************************************/

template<
    typename char_type_ , 
    typename char_traits_type_, 
    typename value_type_, 
    typename traits_type_, 
    typename rep_>
void scan(
    std::basic_istream<char_type_, char_traits_type_>& is, 
    const array<value_type_, traits_type_, rep_>& ar,
    bool fancy
    )
{
    char_type_ ch;

    if (fancy && !(is >> ch && is.narrow(ch, '\0') == '[')) {
        is.setstate(std::ios_base::failbit);
        return;
    }

    is >> ar();

    ch = char_type_();

    if (fancy && !(is >> ch && is.narrow(ch, '\0') == ']')) {
        is.setstate(std::ios_base::failbit);
        return;
    }
}

template<
    typename char_type_ , 
    typename char_traits_type_, 
    typename value_type_, 
    typename traits_type_, 
    typename rep_>
void scan(
    std::basic_istream<char_type_, char_traits_type_>& is, 
    array<value_type_, traits_type_, rep_>& ar,
    bool fancy
    )
{
    char_type_ ch;

    if (fancy && !(is >> ch && is.narrow(ch, '\0') == '[')) {
        is.setstate(std::ios_base::failbit);
        return;
    }

    is >> ar();

    ch = char_type_();

    if (fancy && !(is >> ch && is.narrow(ch, '\0') == ']')) {
        is.setstate(std::ios_base::failbit);
        return;
    }
}

/***********************************************************************************************************/

template<
    typename char_type_ , 
    typename char_traits_type_, 
    typename value_type_, 
    int n0_,
    typename traits_type_, 
    typename rep_>
void scan(
    std::basic_istream<char_type_, char_traits_type_>& is, 
    const array<value_type_[n0_], traits_type_, rep_>& ar,
    bool fancy
    )
{
    const int n =ar.size().i0;
    char_type_ ch;

    if (fancy && !(is >> ch && is.narrow(ch, '\0') == '[')) {
        is.setstate(std::ios_base::failbit);
        return;
    }

    for (int i=0; i<n; i++)
        is >> ar[i];

    ch = char_type_();

    if (fancy && !(is >> ch && is.narrow(ch, '\0') == ']')) {
        is.setstate(std::ios_base::failbit);
        return;
    }
}

template<
    typename char_type_ , 
    typename char_traits_type_, 
    typename value_type_, 
    int n0_,
    typename traits_type_, 
    typename rep_>
void scan(
    std::basic_istream<char_type_, char_traits_type_>& is, 
    array<value_type_[n0_], traits_type_, rep_>& ar,
    bool fancy
    )
{
    const int n =ar.size().i0;
    char_type_ ch;

    if (fancy && !(is >> ch && is.narrow(ch, '\0') == '[')) {
        is.setstate(std::ios_base::failbit);
        return;
    }

    for (int i=0; i<n; i++)
        is >> ar[i];

    ch = char_type_();

    if (fancy && !(is >> ch && is.narrow(ch, '\0') == ']')) {
        is.setstate(std::ios_base::failbit);
        return;
    }
}

/***********************************************************************************************************/

template<
    typename char_type_ , 
    typename char_traits_type_, 
    typename tail_type_, 
    int n0_,
    int n1_,
    typename traits_type_, 
    typename rep_>
void scan(
    std::basic_istream<char_type_, char_traits_type_>& is, 
    const array<tail_type_[n0_][n1_], traits_type_, rep_>& ar,
    bool fancy
    )
{
    const int n =ar.size().i0;
    char_type_ ch;

    if (fancy && !(is >> ch && is.narrow(ch, '\0') == '[')) {
        is.setstate(std::ios_base::failbit);
        return;
    }

    for (int i=0; i<n; i++)
        scan(is, ar[row(i)], fancy);

    ch = char_type_();

    if (fancy && !(is >> ch && is.narrow(ch, '\0') == ']')) {
        is.setstate(std::ios_base::failbit);
        return;
    }
}


template<
    typename char_type_ , 
    typename char_traits_type_, 
    typename tail_type_, 
    int n0_,
    int n1_,
    typename traits_type_, 
    typename rep_>
void scan(
    std::basic_istream<char_type_, char_traits_type_>& is, 
    array<tail_type_[n0_][n1_], traits_type_, rep_>& ar,
    bool fancy
    )
{
    const int n =ar.size().i0;
    char_type_ ch;

    if (fancy && !(is >> ch && is.narrow(ch, '\0') == '[')) {
        is.setstate(std::ios_base::failbit);
        return;
    }

    for (int i=0; i<n; i++)
        scan(is, ar[row(i)], fancy);

    ch = char_type_();

    if (fancy && !(is >> ch && is.narrow(ch, '\0') == ']')) {
        is.setstate(std::ios_base::failbit);
        return;
    }
}

/***********************************************************************************************************/

/*!
    \brief Scans (reads) the array \a ar from the input stream \a is.

    \ingroup array_operations
     
    The values of each dimension could be surrounded in a matching pair of square brackets. 

    \remark 
        - All the consecutive line breaks and white space characters are treated as a single space.
        - \a ar is declared const to allow reading into reference arrays.

    \par Example:

    \code 
        array<int[3][3]> m=0;
        std::cin >> m[diagonal()];
        std::cout << m << std::endl;
    \endcode 
    If the input is:
    \verbatim
        [ 1 2 3 ]
    \endverbatim
    The output would be:
    \verbatim
        1 0 0
        0 2 0
        0 0 3
    \endverbatim
*/
template<
    typename char_type_ , 
    typename char_traits_type_, 
    typename signature_, 
    typename traits_type_, 
    typename rep_>
std::basic_istream<char_type_, char_traits_type_>& 
operator>>(
    std::basic_istream<char_type_, char_traits_type_>& is, 
    const array<signature_, traits_type_, rep_>& ar)
{
    char_type_ ch;

    if (!(is >> ch))
        return is;
        
    bool fancy = is.narrow(ch, '\0') == '[';

    is.putback(ch);
    scan(is, ar, fancy);
    return is;
}

/*!
    \brief Scans (reads) the array \a ar from the input stream \a is.

    \ingroup array_operations
    \anchor array_input
     
    The values of each dimension could be surrounded in a matching pair of square brackets. 

    \remark All the consecutive line breaks and white space characters are treated as a single space.

    \par Example:

    \code 
        array<int[3][3]> m;
        std::cin >> m;
        std::cout << m << std::endl;
    \endcode 
    If the input is:
    \verbatim
        [ 
          [ 1  0  0]
          [ 0  1  0]
          [ 0  0  1]
        ]
    \endverbatim
    The output would be:
    \verbatim
        1 0 0
        0 1 0
        0 0 1
    \endverbatim
*/
template<
    typename char_type_ , 
    typename char_traits_type_, 
    typename signature_, 
    typename traits_type_, 
    typename rep_>
std::basic_istream<char_type_, char_traits_type_>& 
operator>>(
    std::basic_istream<char_type_, char_traits_type_>& is, 
    array<signature_, traits_type_, rep_>& ar)
{
    char_type_ ch;

    if (!(is >> ch))
        return is;
        
    bool fancy = is.narrow(ch, '\0') == '[';

    is.putback(ch);
    scan(is, ar, fancy);
    return is;
}

} // namespace lite

/***********************************************************************************************************/
/* swap ****************************************************************************************************/
/***********************************************************************************************************/
namespace std {

template<typename signature_, typename traits_type_, typename rep_>
LITE_INLINE void 
swap(
    const lite::array<signature_, traits_type_, rep_>& a, 
    const lite::array<signature_, traits_type_, rep_>& b)
{
    a.swap(b);
}

template<typename signature_, typename traits_type_, typename rep_>
LITE_INLINE void 
swap(
    lite::array<signature_, traits_type_, rep_>& a, 
    lite::array<signature_, traits_type_, rep_>& b)
{
    a.swap(b);
}

template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
LITE_INLINE void 
swap(
    const lite::array<signature_, traits_type_, l_rep_>& a, 
    const lite::array<signature_, traits_type_, r_rep_>& b)
{
    a.swap(b);
}

template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
LITE_INLINE void 
swap(
    const lite::array<signature_, traits_type_, l_rep_>& a, 
    lite::array<signature_, traits_type_, r_rep_>& b)
{
    a.swap(b);
}

template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
LITE_INLINE void 
swap(
    lite::array<signature_, traits_type_, l_rep_>& a, 
    const lite::array<signature_, traits_type_, r_rep_>& b)
{
    a.swap(b);
}

template<typename signature_, typename traits_type_, typename l_rep_, typename r_rep_>
LITE_INLINE void 
swap(
    lite::array<signature_, traits_type_, l_rep_>& a, 
    lite::array<signature_, traits_type_, r_rep_>& b)
{
    a.swap(b);
}

} // namespace std

#ifdef _MSC_VER
#pragma warning(pop)
#endif // _MSC_VER

#endif // LITE_ARRAY_HPP



